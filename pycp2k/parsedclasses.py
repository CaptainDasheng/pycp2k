#! /usr/bin/env python
# -*- coding: utf-8 -*-

"""This module holds all the classes parsed from xml file created with command
cp2k --xml"""

from pycp2k.printable import printable


class _dipoles1(printable):
    """
    Specifies the dipoles of the particles.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        The dipole components for each atom.
        """
        self._name = "DIPOLES"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _load_balance1(printable):
    """
    Parameters influencing the load balancing of the HF
    """
    def __init__(self):
        self.Nbins = None
        """
        Number of bins per process used to group atom quartets.
        """
        self.Block_size = None
        """
        Determines the blocking used for the atomic quartet loops. A proper
        choice can speedup the calculation. The default (-1) is automatic.
        """
        self.Randomize = None
        """
        This flag controls the randomization of the bin assignment to
        processes. For highly ordered input structures with a bad load
        balance, setting this flag to TRUE might improve.
        """
        self.PRINT = _print21()
        self._name = "LOAD_BALANCE"
        self._keywords = [('Nbins', 'NBINS'), ('Block_size', 'BLOCK_SIZE'), ('Randomize', 'RANDOMIZE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _load_balance2(printable):
    """
    Parameters influencing the load balancing of the HF
    """
    def __init__(self):
        self.Nbins = None
        """
        Number of bins per process used to group atom quartets.
        """
        self.Block_size = None
        """
        Determines the blocking used for the atomic quartet loops. A proper
        choice can speedup the calculation. The default (-1) is automatic.
        """
        self.Randomize = None
        """
        This flag controls the randomization of the bin assignment to
        processes. For highly ordered input structures with a bad load
        balance, setting this flag to TRUE might improve.
        """
        self.PRINT = _print23()
        self._name = "LOAD_BALANCE"
        self._keywords = [('Nbins', 'NBINS'), ('Block_size', 'BLOCK_SIZE'), ('Randomize', 'RANDOMIZE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _load_balance3(printable):
    """
    Parameters influencing the load balancing of the HF
    """
    def __init__(self):
        self.Nbins = None
        """
        Number of bins per process used to group atom quartets.
        """
        self.Block_size = None
        """
        Determines the blocking used for the atomic quartet loops. A proper
        choice can speedup the calculation. The default (-1) is automatic.
        """
        self.Randomize = None
        """
        This flag controls the randomization of the bin assignment to
        processes. For highly ordered input structures with a bad load
        balance, setting this flag to TRUE might improve.
        """
        self.PRINT = _print25()
        self._name = "LOAD_BALANCE"
        self._keywords = [('Nbins', 'NBINS'), ('Block_size', 'BLOCK_SIZE'), ('Randomize', 'RANDOMIZE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _load_balance4(printable):
    """
    Parameters influencing the load balancing of the HF
    """
    def __init__(self):
        self.Nbins = None
        """
        Number of bins per process used to group atom quartets.
        """
        self.Block_size = None
        """
        Determines the blocking used for the atomic quartet loops. A proper
        choice can speedup the calculation. The default (-1) is automatic.
        """
        self.Randomize = None
        """
        This flag controls the randomization of the bin assignment to
        processes. For highly ordered input structures with a bad load
        balance, setting this flag to TRUE might improve.
        """
        self.PRINT = _print27()
        self._name = "LOAD_BALANCE"
        self._keywords = [('Nbins', 'NBINS'), ('Block_size', 'BLOCK_SIZE'), ('Randomize', 'RANDOMIZE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _load_balance5(printable):
    """
    Parameters influencing the load balancing of the HF
    """
    def __init__(self):
        self.Nbins = None
        """
        Number of bins per process used to group atom quartets.
        """
        self.Block_size = None
        """
        Determines the blocking used for the atomic quartet loops. A proper
        choice can speedup the calculation. The default (-1) is automatic.
        """
        self.Randomize = None
        """
        This flag controls the randomization of the bin assignment to
        processes. For highly ordered input structures with a bad load
        balance, setting this flag to TRUE might improve.
        """
        self.PRINT = _print52()
        self._name = "LOAD_BALANCE"
        self._keywords = [('Nbins', 'NBINS'), ('Block_size', 'BLOCK_SIZE'), ('Randomize', 'RANDOMIZE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _load_balance6(printable):
    """
    Parameters influencing the load balancing of the HF
    """
    def __init__(self):
        self.Nbins = None
        """
        Number of bins per process used to group atom quartets.
        """
        self.Block_size = None
        """
        Determines the blocking used for the atomic quartet loops. A proper
        choice can speedup the calculation. The default (-1) is automatic.
        """
        self.Randomize = None
        """
        This flag controls the randomization of the bin assignment to
        processes. For highly ordered input structures with a bad load
        balance, setting this flag to TRUE might improve.
        """
        self.PRINT = _print54()
        self._name = "LOAD_BALANCE"
        self._keywords = [('Nbins', 'NBINS'), ('Block_size', 'BLOCK_SIZE'), ('Randomize', 'RANDOMIZE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _load_balance7(printable):
    """
    Parameters influencing the load balancing of the HF
    """
    def __init__(self):
        self.Nbins = None
        """
        Number of bins per process used to group atom quartets.
        """
        self.Block_size = None
        """
        Determines the blocking used for the atomic quartet loops. A proper
        choice can speedup the calculation. The default (-1) is automatic.
        """
        self.Randomize = None
        """
        This flag controls the randomization of the bin assignment to
        processes. For highly ordered input structures with a bad load
        balance, setting this flag to TRUE might improve.
        """
        self.PRINT = _print64()
        self._name = "LOAD_BALANCE"
        self._keywords = [('Nbins', 'NBINS'), ('Block_size', 'BLOCK_SIZE'), ('Randomize', 'RANDOMIZE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _load_balance8(printable):
    """
    Parameters influencing the load balancing of the HF
    """
    def __init__(self):
        self.Nbins = None
        """
        Number of bins per process used to group atom quartets.
        """
        self.Block_size = None
        """
        Determines the blocking used for the atomic quartet loops. A proper
        choice can speedup the calculation. The default (-1) is automatic.
        """
        self.Randomize = None
        """
        This flag controls the randomization of the bin assignment to
        processes. For highly ordered input structures with a bad load
        balance, setting this flag to TRUE might improve.
        """
        self.PRINT = _print66()
        self._name = "LOAD_BALANCE"
        self._keywords = [('Nbins', 'NBINS'), ('Block_size', 'BLOCK_SIZE'), ('Randomize', 'RANDOMIZE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _thermostat_fast1(printable):
    """
    Specify thermostat type and parameters controlling the thermostat.
    """
    def __init__(self):
        self.Type = None
        """
        Specify the thermostat used for the constant temperature ensembles.

        Available values:
            NOSE
                Uses only the Nose-Hoover thermostat.
        """
        self.Region = None
        """
        Determines the defined region for fast thermostat

        Available values:
            GLOBAL
            MOLECULE
            MASSIVE
            DEFINED
            NONE
        """
        self.list_DEFINE_REGION = []
        self.NOSE = _nose4()
        self._name = "THERMOSTAT_FAST"
        self._keywords = [('Type', 'TYPE'), ('Region', 'REGION')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('NOSE', 'NOSE')]
        self._repeated_subsections = [('DEFINE_REGION', '_define_region3')]

    def add_DEFINE_REGION(self):
        new_section = _define_region3()
        self.list_DEFINE_REGION.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info52(printable):
    """
    Controls the printing of information on the HFX RI approximation
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each367()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info53(printable):
    """
    Controls the printing of information on the HFX RI approximation
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each373()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info50(printable):
    """
    controls the printing of FARMING specific output
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each343()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info51(printable):
    """
    Controls the printing basic info about the vibrational method
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each351()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _u3(printable):
    """
    Section to define the energy as a generalized collective variable.
    """
    def __init__(self):
        self.MIXED = _mixed4()
        self._name = "U"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('MIXED', 'MIXED')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _optx1(printable):
    """
    Uses the OPTX functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self._name = "OPTX"
        self._keywords = [('Scale_x', 'SCALE_X')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _optx2(printable):
    """
    Uses the OPTX functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self._name = "OPTX"
        self._keywords = [('Scale_x', 'SCALE_X')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each285(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _s2_restraint1(printable):
    """
    Use S2 in a re/constraint (OT only)
    """
    def __init__(self):
        self.Strength = None
        """
        force constant of the restraint
        """
        self.Target = None
        """
        target value of the restraint
        """
        self.Functional_form = None
        """
        Specifies the functional form of the term added

        Available values:
            RESTRAINT
                Harmonic potential: s*(q-t)**2
            CONSTRAINT
                Constraint form: s*(q-t)
        """
        self._name = "S2_RESTRAINT"
        self._keywords = [('Strength', 'STRENGTH'), ('Target', 'TARGET'), ('Functional_form', 'FUNCTIONAL_FORM')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _u4(printable):
    """
    Section to define the energy as a generalized collective variable.
    """
    def __init__(self):
        self.MIXED = _mixed5()
        self._name = "U"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('MIXED', 'MIXED')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _point29(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point28(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _hf_info1(printable):
    """
    Controls the printing basic info about hf method
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each113()
        self._name = "HF_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _point20(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _hf_info3(printable):
    """
    Controls the printing basic info about hf method
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each126()
        self._name = "HF_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _hf_info2(printable):
    """
    Controls the printing basic info about hf method
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each119()
        self._name = "HF_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _point25(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _hf_info4(printable):
    """
    Controls the printing basic info about hf method
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each132()
        self._name = "HF_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _point27(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point26(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _multiple_walkers1(printable):
    """
    Enables and configures the metadynamics using multiple walkers.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Controls the usage of the multiple walkers in a metadynamics run.
        """
        self.Walker_id = None
        """
        Sets the walker ID for the local metadynamics run.
        """
        self.Number_of_walkers = None
        """
        Sets the total number of walkers in the metadynamic run.
        """
        self.Walker_comm_frequency = None
        """
        Sets the frequency (in unit of spawned hills) for the communication
        between the several walkers, in order to update the local list of
        hills with the ones coming from the other walkers
        """
        self.Walkers_status = None
        """
        Stores the status of the several walkers in the local run.
        """
        self.WALKERS_FILE_NAME = _walkers_file_name1()
        self._name = "MULTIPLE_WALKERS"
        self._keywords = [('Walker_id', 'WALKER_ID'), ('Number_of_walkers', 'NUMBER_OF_WALKERS'), ('Walker_comm_frequency', 'WALKER_COMM_FREQUENCY'), ('Walkers_status', 'WALKERS_STATUS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('WALKERS_FILE_NAME', 'WALKERS_FILE_NAME')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _geminal_basis4(printable):
    """
    Controls the printing of the Geminal basis functions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each135()
        self._name = "GEMINAL_BASIS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _geminal_basis5(printable):
    """
    Controls the printing of the Geminal basis functions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each311()
        self._name = "GEMINAL_BASIS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _geminal_basis6(printable):
    """
    Controls the printing of the Geminal basis functions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each317()
        self._name = "GEMINAL_BASIS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _geminal_basis7(printable):
    """
    Controls the printing of the Geminal basis functions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each368()
        self._name = "GEMINAL_BASIS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _geminal_basis1(printable):
    """
    Controls the printing of the Geminal basis functions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each116()
        self._name = "GEMINAL_BASIS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _geminal_basis2(printable):
    """
    Controls the printing of the Geminal basis functions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each122()
        self._name = "GEMINAL_BASIS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _geminal_basis3(printable):
    """
    Controls the printing of the Geminal basis functions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each129()
        self._name = "GEMINAL_BASIS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _vdw_potential2(printable):
    """
    This section combines all possible additional dispersion corrections
    to the normal XC functionals. This can be more functionals or simple
    empirical pair potentials.
    """
    def __init__(self):
        self.Potential_type = None
        """
        Type of dispersion/vdW functional or potential to use

        Available values:
            NONE
            PAIR_POTENTIAL
            NON_LOCAL
        """
        self.list_PAIR_POTENTIAL = []
        self.list_NON_LOCAL = []
        self._name = "VDW_POTENTIAL"
        self._keywords = [('Potential_type', 'POTENTIAL_TYPE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('PAIR_POTENTIAL', '_pair_potential2'), ('NON_LOCAL', '_non_local2')]

    def add_PAIR_POTENTIAL(self):
        new_section = _pair_potential2()
        self.list_PAIR_POTENTIAL.append(new_section)
        return new_section

    def add_NON_LOCAL(self):
        new_section = _non_local2()
        self.list_NON_LOCAL.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Dispersion_functional(self):
        """
        See documentation for Potential_type
        """
        return self.Potential_type

    @Dispersion_functional.setter
    def Dispersion_functional(self, value):
        self.Potential_type = value



class _vdw_potential3(printable):
    """
    This section combines all possible additional dispersion corrections
    to the normal XC functionals. This can be more functionals or simple
    empirical pair potentials.
    """
    def __init__(self):
        self.Potential_type = None
        """
        Type of dispersion/vdW functional or potential to use

        Available values:
            NONE
            PAIR_POTENTIAL
            NON_LOCAL
        """
        self.list_PAIR_POTENTIAL = []
        self.list_NON_LOCAL = []
        self._name = "VDW_POTENTIAL"
        self._keywords = [('Potential_type', 'POTENTIAL_TYPE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('PAIR_POTENTIAL', '_pair_potential3'), ('NON_LOCAL', '_non_local3')]

    def add_PAIR_POTENTIAL(self):
        new_section = _pair_potential3()
        self.list_PAIR_POTENTIAL.append(new_section)
        return new_section

    def add_NON_LOCAL(self):
        new_section = _non_local3()
        self.list_NON_LOCAL.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Dispersion_functional(self):
        """
        See documentation for Potential_type
        """
        return self.Potential_type

    @Dispersion_functional.setter
    def Dispersion_functional(self, value):
        self.Potential_type = value



class _vdw_potential1(printable):
    """
    This section combines all possible additional dispersion corrections
    to the normal XC functionals. This can be more functionals or simple
    empirical pair potentials.
    """
    def __init__(self):
        self.Potential_type = None
        """
        Type of dispersion/vdW functional or potential to use

        Available values:
            NONE
            PAIR_POTENTIAL
            NON_LOCAL
        """
        self.list_PAIR_POTENTIAL = []
        self.list_NON_LOCAL = []
        self._name = "VDW_POTENTIAL"
        self._keywords = [('Potential_type', 'POTENTIAL_TYPE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('PAIR_POTENTIAL', '_pair_potential1'), ('NON_LOCAL', '_non_local1')]

    def add_PAIR_POTENTIAL(self):
        new_section = _pair_potential1()
        self.list_PAIR_POTENTIAL.append(new_section)
        return new_section

    def add_NON_LOCAL(self):
        new_section = _non_local1()
        self.list_NON_LOCAL.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Dispersion_functional(self):
        """
        See documentation for Potential_type
        """
        return self.Potential_type

    @Dispersion_functional.setter
    def Dispersion_functional(self, value):
        self.Potential_type = value



class _geminal_basis8(printable):
    """
    Controls the printing of the Geminal basis functions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each374()
        self._name = "GEMINAL_BASIS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _vdw_potential4(printable):
    """
    This section combines all possible additional dispersion corrections
    to the normal XC functionals. This can be more functionals or simple
    empirical pair potentials.
    """
    def __init__(self):
        self.Potential_type = None
        """
        Type of dispersion/vdW functional or potential to use

        Available values:
            NONE
            PAIR_POTENTIAL
            NON_LOCAL
        """
        self.list_PAIR_POTENTIAL = []
        self.list_NON_LOCAL = []
        self._name = "VDW_POTENTIAL"
        self._keywords = [('Potential_type', 'POTENTIAL_TYPE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('PAIR_POTENTIAL', '_pair_potential4'), ('NON_LOCAL', '_non_local4')]

    def add_PAIR_POTENTIAL(self):
        new_section = _pair_potential4()
        self.list_PAIR_POTENTIAL.append(new_section)
        return new_section

    def add_NON_LOCAL(self):
        new_section = _non_local4()
        self.list_NON_LOCAL.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Dispersion_functional(self):
        """
        See documentation for Potential_type
        """
        return self.Potential_type

    @Dispersion_functional.setter
    def Dispersion_functional(self, value):
        self.Potential_type = value



class _combine_colvar1(printable):
    """
    Allows the possibility to combine several COLVARs into one COLVAR with
    a generic function.
    """
    def __init__(self):
        self.Function = None
        """
        Specifies the function used to combine different COLVARs into one.
        """
        self.Variables = None
        """
        Specifies the name of the variable that parametrises the FUNCTION
        defining how COLVARS should be combined. The matching follows the same
        order of the COLVARS definition in the input file.
        """
        self.list_Parameters = []
        self.list_Values = []
        self.Dx = None
        """
        Parameter used for computing the derivative of the combination of
        COLVARs with the Ridders method.
        """
        self.Error_limit = None
        """
        Checks that the error in computing the derivative is not larger than
        the value set. In case prints a warning message.
        """
        self.list_COLVAR = []
        self._name = "COMBINE_COLVAR"
        self._keywords = [('Function', 'FUNCTION'), ('Variables', 'VARIABLES'), ('Dx', 'DX'), ('Error_limit', 'ERROR_LIMIT')]
        self._repeated_keywords = [('Parameters', 'PARAMETERS'), ('Values', 'VALUES')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('COLVAR', '_colvar4')]

    def add_COLVAR(self):
        new_section = _colvar4()
        self.list_COLVAR.append(new_section)
        return new_section

    def add_Parameters(self, value):
        self.list_Parameters.append(value)

    def add_Values(self, value):
        self.list_Values.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _block1(printable):
    """
    Specify the atom number belonging to this fragment.
    """
    def __init__(self):
        self.List = None
        """
        Specifies a list of atoms.
        """
        self._name = "BLOCK"
        self._keywords = [('List', 'LIST')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _CP2K_INPUT1(printable):
    """"""
    def __init__(self):
        self.GLOBAL = _global1()
        self.TEST = _test1()
        self.DEBUG = _debug1()
        self.MOTION = _motion1()
        self.MULTIPLE_FORCE_EVALS = _multiple_force_evals1()
        self.list_FORCE_EVAL = []
        self.FARMING = _farming1()
        self.OPTIMIZE_INPUT = _optimize_input1()
        self.OPTIMIZE_BASIS = _optimize_basis1()
        self.EXT_RESTART = _ext_restart1()
        self.VIBRATIONAL_ANALYSIS = _vibrational_analysis1()
        self.ATOM = _atom1()
        self._name = "CP2K_INPUT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('GLOBAL', 'GLOBAL'), ('TEST', 'TEST'), ('DEBUG', 'DEBUG'), ('MOTION', 'MOTION'), ('MULTIPLE_FORCE_EVALS', 'MULTIPLE_FORCE_EVALS'), ('FARMING', 'FARMING'), ('OPTIMIZE_INPUT', 'OPTIMIZE_INPUT'), ('OPTIMIZE_BASIS', 'OPTIMIZE_BASIS'), ('EXT_RESTART', 'EXT_RESTART'), ('VIBRATIONAL_ANALYSIS', 'VIBRATIONAL_ANALYSIS'), ('ATOM', 'ATOM')]
        self._repeated_subsections = [('FORCE_EVAL', '_force_eval2')]

    def add_FORCE_EVAL(self):
        new_section = _force_eval2()
        self.list_FORCE_EVAL.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _mode_selective1(printable):
    """
    All parameters needed for to run a mode selective vibrational analysis
    """
    def __init__(self):
        self.Frequency = None
        """
        value close to the expected value of the frequency for to look for. If
        the block Davidson algorithm is applied, the nrep closest frequencies
        are tracked.
        """
        self.Range = None
        """
        Track modes in a given range of frequencies. No warranty that the set
        of frequencies is complete.
        """
        self.Atoms = None
        """
        Specifies the list of atoms which should be displaced for the Initial
        guess
        """
        self.Eps_max_val = None
        """
        Convergence criterium for the davidson algorithm. Specifies the
        maximal value in the residuum vectors
        """
        self.Eps_norm = None
        """
        Convergence criterium for the davidson algorithm. Specifies the
        maximal value of the norm of the residuum vectors
        """
        self.Initial_guess = None
        """
        The type of initial guess for the normal modes

        Available values:
            BFGS_HESS
                get the first displacement vector out of the BFGS approximate Hessian
            ATOMIC
                use random displacements for a set of atoms specified
            RESTART
                use data from MS_RESTART as initial guess
            RESTART_VEC
                use a vector from MS_RESTART, useful if you want to increase accurcy
                by changing functionals or basis
            MOLDEN_RESTART
                use the .mol file of a former run, to restart a vector(similar to
                Restart_vec, but a different file FORMAT is used)
        """
        self.Restart_file_name = None
        """
        Specifies the name of the file used to create the restarted vectors
        """
        self.INVOLVED_ATOMS = _involved_atoms1()
        self.list_PRINT = []
        self._name = "MODE_SELECTIVE"
        self._keywords = [('Frequency', 'FREQUENCY'), ('Range', 'RANGE'), ('Atoms', 'ATOMS'), ('Eps_max_val', 'EPS_MAX_VAL'), ('Eps_norm', 'EPS_NORM'), ('Initial_guess', 'INITIAL_GUESS'), ('Restart_file_name', 'RESTART_FILE_NAME')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('INVOLVED_ATOMS', 'INVOLVED_ATOMS')]
        self._repeated_subsections = [('PRINT', '_print61')]

    def add_PRINT(self):
        new_section = _print61()
        self.list_PRINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _coord_fit_points1(printable):
    """
    Controls the printing of the coordinates of the grid points used for
    periodic RESP fitting. This section is intended to be only used for
    testing (you can get large files).
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each330()
        self._name = "COORD_FIT_POINTS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each246(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _coordination4(printable):
    """
    Section to define the coordination number as a collective variable.
    """
    def __init__(self):
        self.list_Atoms_from = []
        self.list_Points_from = self.list_Atoms_from
        self.list_Atoms_to = []
        self.list_Points_to = self.list_Atoms_to
        self.list_Atoms_to_b = []
        self.list_Points_to_b = self.list_Atoms_to_b
        self.list_Kinds_from = []
        self.list_Kinds_to = []
        self.list_Kinds_to_b = []
        self.R0 = None
        """
        Specify the R0 parameter in the coordination function.
        """
        self.Nn = None
        """
        Sets the value of the numerator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Nd = None
        """
        Sets the value of the denominator of the exponential factorin the
        coordination FUNCTION.
        """
        self.R0_b = None
        """
        For the CV given by the multiplication of two coorination numbers,
        specify the R0 parameter in the second coordination function.
        """
        self.Nn_b = None
        """
        For the CV given by the multiplication of two coorination numbers,Sets
        the value of the numerator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Nd_b = None
        """
        For the CV given by the multiplication of two coorination numbers,Sets
        the value of the denominator of the exponential factorin the
        coordination FUNCTION.
        """
        self.list_POINT = []
        self._name = "COORDINATION"
        self._keywords = [('R0', 'R0'), ('Nn', 'NN'), ('Nd', 'ND'), ('R0_b', 'R0_B'), ('Nn_b', 'NN_B'), ('Nd_b', 'ND_B')]
        self._repeated_keywords = [('Atoms_from', 'ATOMS_FROM'), ('Atoms_to', 'ATOMS_TO'), ('Atoms_to_b', 'ATOMS_TO_B'), ('Kinds_from', 'KINDS_FROM'), ('Kinds_to', 'KINDS_TO'), ('Kinds_to_b', 'KINDS_TO_B')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point58')]

    def add_POINT(self):
        new_section = _point58()
        self.list_POINT.append(new_section)
        return new_section

    def add_Atoms_from(self, value):
        self.list_Atoms_from.append(value)

    def add_Atoms_to(self, value):
        self.list_Atoms_to.append(value)

    def add_Atoms_to_b(self, value):
        self.list_Atoms_to_b.append(value)

    def add_Kinds_from(self, value):
        self.list_Kinds_from.append(value)

    def add_Kinds_to(self, value):
        self.list_Kinds_to.append(value)

    def add_Kinds_to_b(self, value):
        self.list_Kinds_to_b.append(value)

    def add_Points_from(self, value):
        self.list_KINDS_TO_B.append(value)

    def add_Points_to(self, value):
        self.list_KINDS_TO_B.append(value)

    def add_Points_to_b(self, value):
        self.list_KINDS_TO_B.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def R_0(self):
        """
        See documentation for R0
        """
        return self.R0

    @property
    def Expon_numerator(self):
        """
        See documentation for Nn
        """
        return self.Nn

    @property
    def Expon_denominator(self):
        """
        See documentation for Nd
        """
        return self.Nd

    @property
    def R_0_b(self):
        """
        See documentation for R0_b
        """
        return self.R0_b

    @property
    def Expon_numerator_b(self):
        """
        See documentation for Nn_b
        """
        return self.Nn_b

    @property
    def Expon_denominator_b(self):
        """
        See documentation for Nd_b
        """
        return self.Nd_b

    @R_0.setter
    def R_0(self, value):
        self.R0 = value

    @Expon_numerator.setter
    def Expon_numerator(self, value):
        self.Nn = value

    @Expon_denominator.setter
    def Expon_denominator(self, value):
        self.Nd = value

    @R_0_b.setter
    def R_0_b(self, value):
        self.R0_b = value

    @Expon_numerator_b.setter
    def Expon_numerator_b(self, value):
        self.Nn_b = value

    @Expon_denominator_b.setter
    def Expon_denominator_b(self, value):
        self.Nd_b = value



class _coordination1(printable):
    """
    Section to define the coordination number as a collective variable.
    """
    def __init__(self):
        self.list_Atoms_from = []
        self.list_Points_from = self.list_Atoms_from
        self.list_Atoms_to = []
        self.list_Points_to = self.list_Atoms_to
        self.list_Atoms_to_b = []
        self.list_Points_to_b = self.list_Atoms_to_b
        self.list_Kinds_from = []
        self.list_Kinds_to = []
        self.list_Kinds_to_b = []
        self.R0 = None
        """
        Specify the R0 parameter in the coordination function.
        """
        self.Nn = None
        """
        Sets the value of the numerator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Nd = None
        """
        Sets the value of the denominator of the exponential factorin the
        coordination FUNCTION.
        """
        self.R0_b = None
        """
        For the CV given by the multiplication of two coorination numbers,
        specify the R0 parameter in the second coordination function.
        """
        self.Nn_b = None
        """
        For the CV given by the multiplication of two coorination numbers,Sets
        the value of the numerator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Nd_b = None
        """
        For the CV given by the multiplication of two coorination numbers,Sets
        the value of the denominator of the exponential factorin the
        coordination FUNCTION.
        """
        self.list_POINT = []
        self._name = "COORDINATION"
        self._keywords = [('R0', 'R0'), ('Nn', 'NN'), ('Nd', 'ND'), ('R0_b', 'R0_B'), ('Nn_b', 'NN_B'), ('Nd_b', 'ND_B')]
        self._repeated_keywords = [('Atoms_from', 'ATOMS_FROM'), ('Atoms_to', 'ATOMS_TO'), ('Atoms_to_b', 'ATOMS_TO_B'), ('Kinds_from', 'KINDS_FROM'), ('Kinds_to', 'KINDS_TO'), ('Kinds_to_b', 'KINDS_TO_B')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point4')]

    def add_POINT(self):
        new_section = _point4()
        self.list_POINT.append(new_section)
        return new_section

    def add_Atoms_from(self, value):
        self.list_Atoms_from.append(value)

    def add_Atoms_to(self, value):
        self.list_Atoms_to.append(value)

    def add_Atoms_to_b(self, value):
        self.list_Atoms_to_b.append(value)

    def add_Kinds_from(self, value):
        self.list_Kinds_from.append(value)

    def add_Kinds_to(self, value):
        self.list_Kinds_to.append(value)

    def add_Kinds_to_b(self, value):
        self.list_Kinds_to_b.append(value)

    def add_Points_from(self, value):
        self.list_KINDS_TO_B.append(value)

    def add_Points_to(self, value):
        self.list_KINDS_TO_B.append(value)

    def add_Points_to_b(self, value):
        self.list_KINDS_TO_B.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def R_0(self):
        """
        See documentation for R0
        """
        return self.R0

    @property
    def Expon_numerator(self):
        """
        See documentation for Nn
        """
        return self.Nn

    @property
    def Expon_denominator(self):
        """
        See documentation for Nd
        """
        return self.Nd

    @property
    def R_0_b(self):
        """
        See documentation for R0_b
        """
        return self.R0_b

    @property
    def Expon_numerator_b(self):
        """
        See documentation for Nn_b
        """
        return self.Nn_b

    @property
    def Expon_denominator_b(self):
        """
        See documentation for Nd_b
        """
        return self.Nd_b

    @R_0.setter
    def R_0(self, value):
        self.R0 = value

    @Expon_numerator.setter
    def Expon_numerator(self, value):
        self.Nn = value

    @Expon_denominator.setter
    def Expon_denominator(self, value):
        self.Nd = value

    @R_0_b.setter
    def R_0_b(self, value):
        self.R0_b = value

    @Expon_numerator_b.setter
    def Expon_numerator_b(self, value):
        self.Nn_b = value

    @Expon_denominator_b.setter
    def Expon_denominator_b(self, value):
        self.Nd_b = value



class _coordination2(printable):
    """
    Section to define the coordination number as a collective variable.
    """
    def __init__(self):
        self.list_Atoms_from = []
        self.list_Points_from = self.list_Atoms_from
        self.list_Atoms_to = []
        self.list_Points_to = self.list_Atoms_to
        self.list_Atoms_to_b = []
        self.list_Points_to_b = self.list_Atoms_to_b
        self.list_Kinds_from = []
        self.list_Kinds_to = []
        self.list_Kinds_to_b = []
        self.R0 = None
        """
        Specify the R0 parameter in the coordination function.
        """
        self.Nn = None
        """
        Sets the value of the numerator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Nd = None
        """
        Sets the value of the denominator of the exponential factorin the
        coordination FUNCTION.
        """
        self.R0_b = None
        """
        For the CV given by the multiplication of two coorination numbers,
        specify the R0 parameter in the second coordination function.
        """
        self.Nn_b = None
        """
        For the CV given by the multiplication of two coorination numbers,Sets
        the value of the numerator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Nd_b = None
        """
        For the CV given by the multiplication of two coorination numbers,Sets
        the value of the denominator of the exponential factorin the
        coordination FUNCTION.
        """
        self.list_POINT = []
        self._name = "COORDINATION"
        self._keywords = [('R0', 'R0'), ('Nn', 'NN'), ('Nd', 'ND'), ('R0_b', 'R0_B'), ('Nn_b', 'NN_B'), ('Nd_b', 'ND_B')]
        self._repeated_keywords = [('Atoms_from', 'ATOMS_FROM'), ('Atoms_to', 'ATOMS_TO'), ('Atoms_to_b', 'ATOMS_TO_B'), ('Kinds_from', 'KINDS_FROM'), ('Kinds_to', 'KINDS_TO'), ('Kinds_to_b', 'KINDS_TO_B')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point22')]

    def add_POINT(self):
        new_section = _point22()
        self.list_POINT.append(new_section)
        return new_section

    def add_Atoms_from(self, value):
        self.list_Atoms_from.append(value)

    def add_Atoms_to(self, value):
        self.list_Atoms_to.append(value)

    def add_Atoms_to_b(self, value):
        self.list_Atoms_to_b.append(value)

    def add_Kinds_from(self, value):
        self.list_Kinds_from.append(value)

    def add_Kinds_to(self, value):
        self.list_Kinds_to.append(value)

    def add_Kinds_to_b(self, value):
        self.list_Kinds_to_b.append(value)

    def add_Points_from(self, value):
        self.list_KINDS_TO_B.append(value)

    def add_Points_to(self, value):
        self.list_KINDS_TO_B.append(value)

    def add_Points_to_b(self, value):
        self.list_KINDS_TO_B.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def R_0(self):
        """
        See documentation for R0
        """
        return self.R0

    @property
    def Expon_numerator(self):
        """
        See documentation for Nn
        """
        return self.Nn

    @property
    def Expon_denominator(self):
        """
        See documentation for Nd
        """
        return self.Nd

    @property
    def R_0_b(self):
        """
        See documentation for R0_b
        """
        return self.R0_b

    @property
    def Expon_numerator_b(self):
        """
        See documentation for Nn_b
        """
        return self.Nn_b

    @property
    def Expon_denominator_b(self):
        """
        See documentation for Nd_b
        """
        return self.Nd_b

    @R_0.setter
    def R_0(self, value):
        self.R0 = value

    @Expon_numerator.setter
    def Expon_numerator(self, value):
        self.Nn = value

    @Expon_denominator.setter
    def Expon_denominator(self, value):
        self.Nd = value

    @R_0_b.setter
    def R_0_b(self, value):
        self.R0_b = value

    @Expon_numerator_b.setter
    def Expon_numerator_b(self, value):
        self.Nn_b = value

    @Expon_denominator_b.setter
    def Expon_denominator_b(self, value):
        self.Nd_b = value



class _coordination3(printable):
    """
    Section to define the coordination number as a collective variable.
    """
    def __init__(self):
        self.list_Atoms_from = []
        self.list_Points_from = self.list_Atoms_from
        self.list_Atoms_to = []
        self.list_Points_to = self.list_Atoms_to
        self.list_Atoms_to_b = []
        self.list_Points_to_b = self.list_Atoms_to_b
        self.list_Kinds_from = []
        self.list_Kinds_to = []
        self.list_Kinds_to_b = []
        self.R0 = None
        """
        Specify the R0 parameter in the coordination function.
        """
        self.Nn = None
        """
        Sets the value of the numerator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Nd = None
        """
        Sets the value of the denominator of the exponential factorin the
        coordination FUNCTION.
        """
        self.R0_b = None
        """
        For the CV given by the multiplication of two coorination numbers,
        specify the R0 parameter in the second coordination function.
        """
        self.Nn_b = None
        """
        For the CV given by the multiplication of two coorination numbers,Sets
        the value of the numerator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Nd_b = None
        """
        For the CV given by the multiplication of two coorination numbers,Sets
        the value of the denominator of the exponential factorin the
        coordination FUNCTION.
        """
        self.list_POINT = []
        self._name = "COORDINATION"
        self._keywords = [('R0', 'R0'), ('Nn', 'NN'), ('Nd', 'ND'), ('R0_b', 'R0_B'), ('Nn_b', 'NN_B'), ('Nd_b', 'ND_B')]
        self._repeated_keywords = [('Atoms_from', 'ATOMS_FROM'), ('Atoms_to', 'ATOMS_TO'), ('Atoms_to_b', 'ATOMS_TO_B'), ('Kinds_from', 'KINDS_FROM'), ('Kinds_to', 'KINDS_TO'), ('Kinds_to_b', 'KINDS_TO_B')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point40')]

    def add_POINT(self):
        new_section = _point40()
        self.list_POINT.append(new_section)
        return new_section

    def add_Atoms_from(self, value):
        self.list_Atoms_from.append(value)

    def add_Atoms_to(self, value):
        self.list_Atoms_to.append(value)

    def add_Atoms_to_b(self, value):
        self.list_Atoms_to_b.append(value)

    def add_Kinds_from(self, value):
        self.list_Kinds_from.append(value)

    def add_Kinds_to(self, value):
        self.list_Kinds_to.append(value)

    def add_Kinds_to_b(self, value):
        self.list_Kinds_to_b.append(value)

    def add_Points_from(self, value):
        self.list_KINDS_TO_B.append(value)

    def add_Points_to(self, value):
        self.list_KINDS_TO_B.append(value)

    def add_Points_to_b(self, value):
        self.list_KINDS_TO_B.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def R_0(self):
        """
        See documentation for R0
        """
        return self.R0

    @property
    def Expon_numerator(self):
        """
        See documentation for Nn
        """
        return self.Nn

    @property
    def Expon_denominator(self):
        """
        See documentation for Nd
        """
        return self.Nd

    @property
    def R_0_b(self):
        """
        See documentation for R0_b
        """
        return self.R0_b

    @property
    def Expon_numerator_b(self):
        """
        See documentation for Nn_b
        """
        return self.Nn_b

    @property
    def Expon_denominator_b(self):
        """
        See documentation for Nd_b
        """
        return self.Nd_b

    @R_0.setter
    def R_0(self, value):
        self.R0 = value

    @Expon_numerator.setter
    def Expon_numerator(self, value):
        self.Nn = value

    @Expon_denominator.setter
    def Expon_denominator(self, value):
        self.Nd = value

    @R_0_b.setter
    def R_0_b(self, value):
        self.R0_b = value

    @Expon_numerator_b.setter
    def Expon_numerator_b(self, value):
        self.Nn_b = value

    @Expon_denominator_b.setter
    def Expon_denominator_b(self, value):
        self.Nd_b = value



class _lbfgs4(printable):
    """
    Provides parameters to tune the limited memory BFGS (LBFGS)
    optimization
    """
    def __init__(self):
        self.Max_h_rank = None
        """
        Maximum rank (and consequently size) of the approximate Hessian matrix
        used by the LBFGS optimizer. Larger values (e.g. 30) will accelerate
        the convergence behaviour at the cost of a larger memory consumption.
        """
        self.Max_f_per_iter = None
        """
        Maximum number of force evaluations per iteration(used for the line
        search)
        """
        self.Wanted_proj_gradient = None
        """
        Convergence criterium (overrides the general ones):Requested norm
        threshold of the gradient multiplied by the approximate Hessian.
        """
        self.Wanted_rel_f_error = None
        """
        Convergence criterium (overrides the general ones):Requested relative
        error on the objective functionof the optimizer (the energy)
        """
        self._name = "LBFGS"
        self._keywords = [('Max_h_rank', 'MAX_H_RANK'), ('Max_f_per_iter', 'MAX_F_PER_ITER'), ('Wanted_proj_gradient', 'WANTED_PROJ_GRADIENT'), ('Wanted_rel_f_error', 'WANTED_REL_F_ERROR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _lbfgs2(printable):
    """
    Provides parameters to tune the limited memory BFGS (LBFGS)
    optimization
    """
    def __init__(self):
        self.Max_h_rank = None
        """
        Maximum rank (and consequently size) of the approximate Hessian matrix
        used by the LBFGS optimizer. Larger values (e.g. 30) will accelerate
        the convergence behaviour at the cost of a larger memory consumption.
        """
        self.Max_f_per_iter = None
        """
        Maximum number of force evaluations per iteration(used for the line
        search)
        """
        self.Wanted_proj_gradient = None
        """
        Convergence criterium (overrides the general ones):Requested norm
        threshold of the gradient multiplied by the approximate Hessian.
        """
        self.Wanted_rel_f_error = None
        """
        Convergence criterium (overrides the general ones):Requested relative
        error on the objective functionof the optimizer (the energy)
        """
        self._name = "LBFGS"
        self._keywords = [('Max_h_rank', 'MAX_H_RANK'), ('Max_f_per_iter', 'MAX_F_PER_ITER'), ('Wanted_proj_gradient', 'WANTED_PROJ_GRADIENT'), ('Wanted_rel_f_error', 'WANTED_REL_F_ERROR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _lbfgs3(printable):
    """
    Provides parameters to tune the limited memory BFGS (LBFGS)
    optimization
    """
    def __init__(self):
        self.Max_h_rank = None
        """
        Maximum rank (and consequently size) of the approximate Hessian matrix
        used by the LBFGS optimizer. Larger values (e.g. 30) will accelerate
        the convergence behaviour at the cost of a larger memory consumption.
        """
        self.Max_f_per_iter = None
        """
        Maximum number of force evaluations per iteration(used for the line
        search)
        """
        self.Wanted_proj_gradient = None
        """
        Convergence criterium (overrides the general ones):Requested norm
        threshold of the gradient multiplied by the approximate Hessian.
        """
        self.Wanted_rel_f_error = None
        """
        Convergence criterium (overrides the general ones):Requested relative
        error on the objective functionof the optimizer (the energy)
        """
        self._name = "LBFGS"
        self._keywords = [('Max_h_rank', 'MAX_H_RANK'), ('Max_f_per_iter', 'MAX_F_PER_ITER'), ('Wanted_proj_gradient', 'WANTED_PROJ_GRADIENT'), ('Wanted_rel_f_error', 'WANTED_REL_F_ERROR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _lbfgs1(printable):
    """
    Provides parameters to tune the limited memory BFGS (LBFGS)
    optimization
    """
    def __init__(self):
        self.Max_h_rank = None
        """
        Maximum rank (and consequently size) of the approximate Hessian matrix
        used by the LBFGS optimizer. Larger values (e.g. 30) will accelerate
        the convergence behaviour at the cost of a larger memory consumption.
        """
        self.Max_f_per_iter = None
        """
        Maximum number of force evaluations per iteration(used for the line
        search)
        """
        self.Wanted_proj_gradient = None
        """
        Convergence criterium (overrides the general ones):Requested norm
        threshold of the gradient multiplied by the approximate Hessian.
        """
        self.Wanted_rel_f_error = None
        """
        Convergence criterium (overrides the general ones):Requested relative
        error on the objective functionof the optimizer (the energy)
        """
        self._name = "LBFGS"
        self._keywords = [('Max_h_rank', 'MAX_H_RANK'), ('Max_f_per_iter', 'MAX_F_PER_ITER'), ('Wanted_proj_gradient', 'WANTED_PROJ_GRADIENT'), ('Wanted_rel_f_error', 'WANTED_REL_F_ERROR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _force3(printable):
    """
    The forces for NOSE HOOVER used for restart
    """
    def __init__(self):
        self.Default_keyword = None
        """
        Specify masses of the system
        """
        self._name = "FORCE"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _force2(printable):
    """
    The forces for NOSE HOOVER used for restart
    """
    def __init__(self):
        self.Default_keyword = None
        """
        Specify masses of the system
        """
        self._name = "FORCE"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _force1(printable):
    """
    The forces for NOSE HOOVER used for restart
    """
    def __init__(self):
        self.Default_keyword = None
        """
        Specify masses of the system
        """
        self._name = "FORCE"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _force6(printable):
    """
    Forces exerted by the helium on the solute system (used for restarts)
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Number of real values should be 3 * <num_solute_atoms> *
        <num_solute_beads>
        """
        self._name = "FORCE"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _force5(printable):
    """
    The forces for NOSE HOOVER used for restart
    """
    def __init__(self):
        self.Default_keyword = None
        """
        Specify masses of the system
        """
        self._name = "FORCE"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _force4(printable):
    """
    The forces for NOSE HOOVER used for restart
    """
    def __init__(self):
        self.Default_keyword = None
        """
        Specify masses of the system
        """
        self._name = "FORCE"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _coupling1(printable):
    """
    Coupling between two force_eval: E=(E1+E2 -
    sqrt((E1-E2)**2+4*H12**2))/2
    """
    def __init__(self):
        self.Coupling_parameter = None
        """
        Coupling parameter H12 used in the coupling
        """
        self._name = "COUPLING"
        self._keywords = [('Coupling_parameter', 'COUPLING_PARAMETER')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _compare_forces1(printable):
    """
    A comparison of forces between fit and reference
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each346()
        self._name = "COMPARE_FORCES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _kinds1(printable):
    """
    controls the output of information on the kinds
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Potential = None
        """
        If the printkey is activated controls the printing of the
        fist_potential, gth_potential or all electron potential information
        """
        self.Basis_set = None
        """
        If the printkey is activated controls the printing of basis set
        information
        """
        self.Se_parameters = None
        """
        If the printkey is activated controls the printing of the semi-
        empirical parameters.
        """
        self.EACH = _each282()
        self._name = "KINDS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Potential', 'POTENTIAL'), ('Basis_set', 'BASIS_SET'), ('Se_parameters', 'SE_PARAMETERS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _vibrational_analysis1(printable):
    """
    Section to setup parameters to perform a Normal Modes analysis.
    """
    def __init__(self):
        self.Dx = None
        """
        Specify the increment to be used to construct the HESSIAN with finite
        difference method
        """
        self.Nproc_rep = None
        """
        Specify the number of processors to be used per replica environment
        (for parallel runs). In case of mode selective calculations more than
        one replica will start a block Davidson algorithm to track more than
        only one frequency
        """
        self.Proc_dist_type = None
        """
        Specify the topology of the mapping of processors into replicas.

        Available values:
            INTERLEAVED
                Interleaved distribution
            BLOCKED
                Blocked distribution
        """
        self.Fully_periodic = None
        """
        Avoids to clean rotations from the Hessian matrix.
        """
        self.Intensities = None
        """
        Calculation of the IR-Intensities. Calculation of dipols has to be
        specified explicitly
        """
        self.MODE_SELECTIVE = _mode_selective1()
        self.PRINT = _print62()
        self._name = "VIBRATIONAL_ANALYSIS"
        self._keywords = [('Dx', 'DX'), ('Nproc_rep', 'NPROC_REP'), ('Proc_dist_type', 'PROC_DIST_TYPE'), ('Fully_periodic', 'FULLY_PERIODIC'), ('Intensities', 'INTENSITIES')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('MODE_SELECTIVE', 'MODE_SELECTIVE'), ('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _line_search1(printable):
    """
    Provides parameters to tune the line search during the conjugate
    gradient optimization
    """
    def __init__(self):
        self.Type = None
        """
        1D line search algorithm to be used with the CG optimizer, in
        increasing order of robustness and cost.

        Available values:
            NONE
                take fixed lenght steps
            2PNT
                extrapolate based on 2 points
            3PNT
                extrapolate based on on 3 points
            GOLD
                perform 1D golden section search of the minimum (very expensive)
            FIT
                perform 1D fit of a parabola on several evaluation of energy (very
                expensive and more robust vs numerical noise)
        """
        self._2PNT = _num2pnt1()
        self.GOLD = _gold1()
        self._name = "LINE_SEARCH"
        self._keywords = [('Type', 'TYPE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('_2PNT', '2PNT'), ('GOLD', 'GOLD')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _line_search3(printable):
    """
    Provides parameters to tune the line search during the conjugate
    gradient optimization
    """
    def __init__(self):
        self.Type = None
        """
        1D line search algorithm to be used with the CG optimizer, in
        increasing order of robustness and cost.

        Available values:
            NONE
                take fixed lenght steps
            2PNT
                extrapolate based on 2 points
            3PNT
                extrapolate based on on 3 points
            GOLD
                perform 1D golden section search of the minimum (very expensive)
            FIT
                perform 1D fit of a parabola on several evaluation of energy (very
                expensive and more robust vs numerical noise)
        """
        self._2PNT = _num2pnt3()
        self.GOLD = _gold3()
        self._name = "LINE_SEARCH"
        self._keywords = [('Type', 'TYPE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('_2PNT', '2PNT'), ('GOLD', 'GOLD')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _line_search2(printable):
    """
    Provides parameters to tune the line search during the conjugate
    gradient optimization
    """
    def __init__(self):
        self.Type = None
        """
        1D line search algorithm to be used with the CG optimizer, in
        increasing order of robustness and cost.

        Available values:
            NONE
                take fixed lenght steps
            2PNT
                extrapolate based on 2 points
            3PNT
                extrapolate based on on 3 points
            GOLD
                perform 1D golden section search of the minimum (very expensive)
            FIT
                perform 1D fit of a parabola on several evaluation of energy (very
                expensive and more robust vs numerical noise)
        """
        self._2PNT = _num2pnt2()
        self.GOLD = _gold2()
        self._name = "LINE_SEARCH"
        self._keywords = [('Type', 'TYPE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('_2PNT', '2PNT'), ('GOLD', 'GOLD')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _line_search4(printable):
    """
    Provides parameters to tune the line search during the conjugate
    gradient optimization
    """
    def __init__(self):
        self.Type = None
        """
        1D line search algorithm to be used with the CG optimizer, in
        increasing order of robustness and cost.

        Available values:
            NONE
                take fixed lenght steps
            2PNT
                extrapolate based on 2 points
            3PNT
                extrapolate based on on 3 points
            GOLD
                perform 1D golden section search of the minimum (very expensive)
            FIT
                perform 1D fit of a parabola on several evaluation of energy (very
                expensive and more robust vs numerical noise)
        """
        self._2PNT = _num2pnt4()
        self.GOLD = _gold4()
        self._name = "LINE_SEARCH"
        self._keywords = [('Type', 'TYPE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('_2PNT', '2PNT'), ('GOLD', 'GOLD')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _mass3(printable):
    """
    Information to initialize the Ad-Langevin thermostat DOF MASS
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify an initial thermostat DOF MASS for Ad-Langevin thermostat.
        """
        self._name = "MASS"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _involved_atoms1(printable):
    """
    All parameters needed for the tracking of modes dominated by the
    motion of selected atoms
    """
    def __init__(self):
        self.Range = None
        """
         Specifies the range of wavenumbers in which the modes related to the
        ATOMS have to be tracked.  If not specified frequencies >400cm-1 will
        be used to avoid tracking of translational or rotational modes
        """
        self.Involved_atoms = None
        """
        Specifies the list of atoms on which the tracked eigenvector should
        have the highest value similar to looking for the vibration of a set
        of atoms
        """
        self._name = "INVOLVED_ATOMS"
        self._keywords = [('Range', 'RANGE'), ('Involved_atoms', 'INVOLVED_ATOMS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _mass2(printable):
    """
    The masses for NOSE HOOVER used for restart
    """
    def __init__(self):
        self.Default_keyword = None
        """
        Specify masses of the system
        """
        self._name = "MASS"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _mass1(printable):
    """
    The masses for BAROSTAT used for restart
    """
    def __init__(self):
        self.Default_keyword = None
        """
        Specify masses of the system
        """
        self._name = "MASS"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _cls_function_cubes1(printable):
    """
    Controls the printing of the relaxed orbitals
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Stride = None
        """
        The stride (X,Y,Z) used to write the cube file (larger values result
        in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1
        number valid for all components.
        """
        self.Cubes_lu_bounds = None
        """
        The lower and upper index of the states to be printed as cube
        """
        self.list_Cubes_list = []
        self.Append = None
        """
        append the cube files when they already exist
        """
        self.EACH = _each164()
        self._name = "CLS_FUNCTION_CUBES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Stride', 'STRIDE'), ('Cubes_lu_bounds', 'CUBES_LU_BOUNDS'), ('Append', 'APPEND')]
        self._repeated_keywords = [('Cubes_list', 'CUBES_LIST')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def add_Cubes_list(self, value):
        self.list_Cubes_list.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Cubes_lu(self):
        """
        See documentation for Cubes_lu_bounds
        """
        return self.Cubes_lu_bounds

    @Cubes_lu.setter
    def Cubes_lu(self, value):
        self.Cubes_lu_bounds = value



class _merge_molecules1(printable):
    """
    Enables the creation of connecting bridges (bonds, angles, torsions,
    impropers) between the two or more molecules defined with independent
    connectivity.
    """
    def __init__(self):
        self.BONDS = _bonds1()
        self.ANGLES = _angles1()
        self.TORSIONS = _torsions1()
        self.IMPROPERS = _impropers1()
        self._name = "MERGE_MOLECULES"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('BONDS', 'BONDS'), ('ANGLES', 'ANGLES'), ('TORSIONS', 'TORSIONS'), ('IMPROPERS', 'IMPROPERS')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each372(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each373(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each370(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each371(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each376(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each374(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each375(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each158(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each159(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each152(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each153(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each150(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each151(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each156(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each157(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each154(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each155(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _centroid_vel1(printable):
    """
    Controls the output of the centroid's velocity
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.Format = None
        """
        Output file format for the velocity of centroid

        Available values:
            ATOMIC
                Write only the coordinates X,Y,Z without element symbols to a
                formatted file
            DCD
                Write the coordinates (no element labels) and the cell information to
                a binary file
            XMOL
                Mostly known as XYZ format, provides in a formatted file:
                element_symbol X Y Z
            XYZ
                Alias name for XMOL
        """
        self.EACH = _each63()
        self._name = "CENTROID_VEL"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT'), ('Format', 'FORMAT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _rs_grid2(printable):
    """
    Set options that influence how the realspace grids are being
    distributed in parallel runs.
    """
    def __init__(self):
        self.Distribution_type = None
        """
        Parallelization strategy.

        Available values:
            AUTOMATIC
                Use heuristic rules to decide between distributed and replicated
            DISTRIBUTED
                Force a distributed setup if possible
            REPLICATED
                Force a replicated setup
        """
        self.Distribution_layout = None
        """
        Specifies the number of slices in the x, y and z directions.-1
        specifies that any number of slices is OK.If a given distribution can
        not be satisfied, a replicated grid will result.Also see
        LOCK_DISTRIBUTION.
        """
        self.Max_distributed_level = None
        """
        If the multigrid-level of a grid is larger than the parameter, it will
        not be distributed in the automatic scheme.
        """
        self.Lock_distribution = None
        """
        Expert use only, only basic QS deals correctly with a non-default
        value.If the distribution is locked, a grid will have the same
        distribution asthe next finer multigrid (provided it is
        distributed).If unlocked, all grids can be distributed freely.
        """
        self.Memory_factor = None
        """
        A grid will only be distributed if the memory usage for that grid
        (including halo) is smaller than a replicated grid by this parameter.
        """
        self.Halo_reduction_factor = None
        """
        Can be used to reduce the halo of the distributed grid (experimental
        features).
        """
        self._name = "RS_GRID"
        self._keywords = [('Distribution_type', 'DISTRIBUTION_TYPE'), ('Distribution_layout', 'DISTRIBUTION_LAYOUT'), ('Max_distributed_level', 'MAX_DISTRIBUTED_LEVEL'), ('Lock_distribution', 'LOCK_DISTRIBUTION'), ('Memory_factor', 'MEMORY_FACTOR'), ('Halo_reduction_factor', 'HALO_REDUCTION_FACTOR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _msst1(printable):
    """
    Parameters for Multi-Scale Shock Technique (MSST) which simulate the
    effect of a steady planar shock on a unit cell. Reed et. al. Physical
    Review Letters 90, 235503 (2003).
    """
    def __init__(self):
        self.Pressure = None
        """
        Initial pressure
        """
        self.Energy = None
        """
        Initial energy
        """
        self.Volume = None
        """
        Initial volume
        """
        self.Cmass = None
        """
        Effective cell mass
        """
        self.Vshock = None
        """
        Velocity shock
        """
        self.Gamma = None
        """
        Damping coefficient for cell volume
        """
        self._name = "MSST"
        self._keywords = [('Pressure', 'PRESSURE'), ('Energy', 'ENERGY'), ('Volume', 'VOLUME'), ('Cmass', 'CMASS'), ('Vshock', 'VSHOCK'), ('Gamma', 'GAMMA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def V_shock(self):
        """
        See documentation for Vshock
        """
        return self.Vshock

    @V_shock.setter
    def V_shock(self, value):
        self.Vshock = value



class _rs_grid1(printable):
    """
    Set options that influence how the realspace grids are being
    distributed in parallel runs.
    """
    def __init__(self):
        self.Distribution_type = None
        """
        Parallelization strategy.

        Available values:
            AUTOMATIC
                Use heuristic rules to decide between distributed and replicated
            DISTRIBUTED
                Force a distributed setup if possible
            REPLICATED
                Force a replicated setup
        """
        self.Distribution_layout = None
        """
        Specifies the number of slices in the x, y and z directions.-1
        specifies that any number of slices is OK.If a given distribution can
        not be satisfied, a replicated grid will result.Also see
        LOCK_DISTRIBUTION.
        """
        self.Max_distributed_level = None
        """
        If the multigrid-level of a grid is larger than the parameter, it will
        not be distributed in the automatic scheme.
        """
        self.Lock_distribution = None
        """
        Expert use only, only basic QS deals correctly with a non-default
        value.If the distribution is locked, a grid will have the same
        distribution asthe next finer multigrid (provided it is
        distributed).If unlocked, all grids can be distributed freely.
        """
        self.Memory_factor = None
        """
        A grid will only be distributed if the memory usage for that grid
        (including halo) is smaller than a replicated grid by this parameter.
        """
        self.Halo_reduction_factor = None
        """
        Can be used to reduce the halo of the distributed grid (experimental
        features).
        """
        self._name = "RS_GRID"
        self._keywords = [('Distribution_type', 'DISTRIBUTION_TYPE'), ('Distribution_layout', 'DISTRIBUTION_LAYOUT'), ('Max_distributed_level', 'MAX_DISTRIBUTED_LEVEL'), ('Lock_distribution', 'LOCK_DISTRIBUTION'), ('Memory_factor', 'MEMORY_FACTOR'), ('Halo_reduction_factor', 'HALO_REDUCTION_FACTOR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _rs_grid4(printable):
    """
    Set options that influence how the realspace grids are being
    distributed in parallel runs.
    """
    def __init__(self):
        self.Distribution_type = None
        """
        Parallelization strategy.

        Available values:
            AUTOMATIC
                Use heuristic rules to decide between distributed and replicated
            DISTRIBUTED
                Force a distributed setup if possible
            REPLICATED
                Force a replicated setup
        """
        self.Distribution_layout = None
        """
        Specifies the number of slices in the x, y and z directions.-1
        specifies that any number of slices is OK.If a given distribution can
        not be satisfied, a replicated grid will result.Also see
        LOCK_DISTRIBUTION.
        """
        self.Max_distributed_level = None
        """
        If the multigrid-level of a grid is larger than the parameter, it will
        not be distributed in the automatic scheme.
        """
        self.Lock_distribution = None
        """
        Expert use only, only basic QS deals correctly with a non-default
        value.If the distribution is locked, a grid will have the same
        distribution asthe next finer multigrid (provided it is
        distributed).If unlocked, all grids can be distributed freely.
        """
        self.Memory_factor = None
        """
        A grid will only be distributed if the memory usage for that grid
        (including halo) is smaller than a replicated grid by this parameter.
        """
        self.Halo_reduction_factor = None
        """
        Can be used to reduce the halo of the distributed grid (experimental
        features).
        """
        self._name = "RS_GRID"
        self._keywords = [('Distribution_type', 'DISTRIBUTION_TYPE'), ('Distribution_layout', 'DISTRIBUTION_LAYOUT'), ('Max_distributed_level', 'MAX_DISTRIBUTED_LEVEL'), ('Lock_distribution', 'LOCK_DISTRIBUTION'), ('Memory_factor', 'MEMORY_FACTOR'), ('Halo_reduction_factor', 'HALO_REDUCTION_FACTOR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _periodic_efield1(printable):
    """
    parameters for finite periodic electric field computed using the Berry
    phase approach. IMPORTANT: Can only be used in combination  with OT.
    Can not be used in combination with RTP or EMD.
    """
    def __init__(self):
        self.Intensity = None
        """
        Intensity of the electric field in a.u
        """
        self.Polarisation = None
        """
        Polarisation vector of electric field
        """
        self._name = "PERIODIC_EFIELD"
        self._keywords = [('Intensity', 'INTENSITY'), ('Polarisation', 'POLARISATION')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _fit_pseudo1(printable):
    """
    Controls the printing of FIT PSEUDO task
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each362()
        self._name = "FIT_PSEUDO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _qmmm_charges1(printable):
    """
    Print all charges generating the QM/MM potential
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each250()
        self._name = "QMMM_CHARGES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _u2(printable):
    """
    Section to define the energy as a generalized collective variable.
    """
    def __init__(self):
        self.MIXED = _mixed3()
        self._name = "U"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('MIXED', 'MIXED')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _u1(printable):
    """
    Section to define the energy as a generalized collective variable.
    """
    def __init__(self):
        self.MIXED = _mixed2()
        self._name = "U"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('MIXED', 'MIXED')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _optx3(printable):
    """
    Uses the OPTX functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self._name = "OPTX"
        self._keywords = [('Scale_x', 'SCALE_X')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _optx4(printable):
    """
    Uses the OPTX functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self._name = "OPTX"
        self._keywords = [('Scale_x', 'SCALE_X')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _ep1(printable):
    """
    parameter needed by an ep calculation
    """
    def __init__(self):
        self.Eps_lin_solv = None
        """
        Requested convergence of the linear solver (for psi1)
        """
        self.Rotate = None
        """
        If rotations from a unique set of coefficients should be used or if
        single molecule optimizations generate it
        """
        self.Start_coeffs = None
        """
        Starting coefficients for roatation based ep
        """
        self.E0_only = None
        """
        If only e0 should be calculated
        """
        self.Comp_input = None
        """
        Path to the input to be used for the component of the main system
        """
        self.At_per_mol = None
        """
        Number of atoms in each molecule (at the moment only uniform system
        cam be handled)
        """
        self.PRINT = _print39()
        self._name = "EP"
        self._keywords = [('Eps_lin_solv', 'EPS_LIN_SOLV'), ('Rotate', 'ROTATE'), ('Start_coeffs', 'START_COEFFS'), ('E0_only', 'E0_ONLY'), ('Comp_input', 'COMP_INPUT'), ('At_per_mol', 'AT_PER_MOL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _dft_plus_u1(printable):
    """
    Define the parameters for a DFT+U run
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Controls the activation of the DFT+U section
        """
        self.L = None
        """
        Angular momentum quantum number of theorbitals to which the correction
        is applied
        """
        self.U_minus_j = None
        """
        Effective parameter U(eff) = U - J
        """
        self.U_ramping = None
        """
        Increase the effective U parameter stepwise using the specified
        increment until the target value given by U_MINUS_J is reached.
        """
        self.Eps_u_ramping = None
        """
        Threshold value (SCF convergence) for incrementing the effective U
        value when U ramping is active.
        """
        self.Init_u_ramping_each_scf = None
        """
        Set the initial U ramping value to zero before each wavefunction
        optimisation. The default is to apply U ramping only for the initial
        wavefunction optimisation.
        """
        self.ENFORCE_OCCUPATION = _enforce_occupation1()
        self._name = "DFT_PLUS_U"
        self._keywords = [('L', 'L'), ('U_minus_j', 'U_MINUS_J'), ('U_ramping', 'U_RAMPING'), ('Eps_u_ramping', 'EPS_U_RAMPING'), ('Init_u_ramping_each_scf', 'INIT_U_RAMPING_EACH_SCF')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('ENFORCE_OCCUPATION', 'ENFORCE_OCCUPATION')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _interpolator9(printable):
    """
    kind of interpolation used between the multigrids
    """
    def __init__(self):
        self.Kind = None
        """
        the interpolator to use

        Available values:
            PW
            SPLINE3_NOPBC
            SPLINE3
        """
        self.Safe_computation = None
        """
        if a non unrolled calculation is to be performed in parallel
        """
        self.Aint_precond = None
        """
        the approximate inverse to use to get the starting point for the
        linear solver of the spline3 methods

        Available values:
            COPY
            SPL3_NOPBC_AINT1
            SPL3_NOPBC_AINT2
            SPL3_NOPBC_PRECOND1
            SPL3_NOPBC_PRECOND2
            SPL3_NOPBC_PRECOND3
        """
        self.Precond = None
        """
        The preconditioner used for the linear solver of the spline3 methods

        Available values:
            COPY
            SPL3_NOPBC_AINT1
            SPL3_NOPBC_AINT2
            SPL3_NOPBC_PRECOND1
            SPL3_NOPBC_PRECOND2
            SPL3_NOPBC_PRECOND3
        """
        self.Eps_x = None
        """
        accuracy on the solution for spline3 the interpolators
        """
        self.Eps_r = None
        """
        accuracy on the residual for spline3 the interpolators
        """
        self.Max_iter = None
        """
        the maximum number of iterations
        """
        self.CONV_INFO = _conv_info9()
        self._name = "INTERPOLATOR"
        self._keywords = [('Kind', 'KIND'), ('Safe_computation', 'SAFE_COMPUTATION'), ('Aint_precond', 'AINT_PRECOND'), ('Precond', 'PRECOND'), ('Eps_x', 'EPS_X'), ('Eps_r', 'EPS_R'), ('Max_iter', 'MAX_ITER')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('CONV_INFO', 'CONV_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Maxiter(self):
        """
        See documentation for Max_iter
        """
        return self.Max_iter

    @Maxiter.setter
    def Maxiter(self, value):
        self.Max_iter = value



class _spinspin1(printable):
    """
    Compute indirect spin-spin coupling constants.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        controls the activation of the nmr calculation
        """
        self.Restart_spinspin = None
        """
        Restart the spin-spin calculation from a previous run (NOT WORKING
        YET)
        """
        self.list_Issc_on_atom_list = []
        self.Do_fc = None
        """
        Compute the Fermi contact contribution
        """
        self.Do_sd = None
        """
        Compute the spin-dipolar contribution
        """
        self.Do_pso = None
        """
        Compute the paramagnetic spin-orbit contribution
        """
        self.Do_dso = None
        """
        Compute the diamagnetic spin-orbit contribution (NOT YET IMPLEMENTED)
        """
        self.PRINT = _print51()
        self.INTERPOLATOR = _interpolator10()
        self._name = "SPINSPIN"
        self._keywords = [('Restart_spinspin', 'RESTART_SPINSPIN'), ('Do_fc', 'DO_FC'), ('Do_sd', 'DO_SD'), ('Do_pso', 'DO_PSO'), ('Do_dso', 'DO_DSO')]
        self._repeated_keywords = [('Issc_on_atom_list', 'ISSC_ON_ATOM_LIST')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT', 'PRINT'), ('INTERPOLATOR', 'INTERPOLATOR')]
        self._repeated_subsections = []

    def add_Issc_on_atom_list(self, value):
        self.list_Issc_on_atom_list.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _ring_puckering4(printable):
    """
    Section to define general ring puckering collective variables.
    """
    def __init__(self):
        self.Atoms = None
        """
        Specifies the indexes of atoms/points defining the ring.At least 4
        Atoms are needed.
        """
        self.Coordinate = None
        """
        Indicate the coordinate to be used. Follow the Cremer-Pople definition
        for a N ring.0 is the total puckering variable Q,2..[N/2] are
        puckering coordinates.-2..-[N/2-1] are puckering angles.
        """
        self.list_POINT = []
        self._name = "RING_PUCKERING"
        self._keywords = [('Atoms', 'ATOMS'), ('Coordinate', 'COORDINATE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point71')]

    def add_POINT(self):
        new_section = _point71()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Points(self):
        """
        See documentation for Atoms
        """
        return self.Atoms

    @Points.setter
    def Points(self, value):
        self.Atoms = value



class _ring_puckering2(printable):
    """
    Section to define general ring puckering collective variables.
    """
    def __init__(self):
        self.Atoms = None
        """
        Specifies the indexes of atoms/points defining the ring.At least 4
        Atoms are needed.
        """
        self.Coordinate = None
        """
        Indicate the coordinate to be used. Follow the Cremer-Pople definition
        for a N ring.0 is the total puckering variable Q,2..[N/2] are
        puckering coordinates.-2..-[N/2-1] are puckering angles.
        """
        self.list_POINT = []
        self._name = "RING_PUCKERING"
        self._keywords = [('Atoms', 'ATOMS'), ('Coordinate', 'COORDINATE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point35')]

    def add_POINT(self):
        new_section = _point35()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Points(self):
        """
        See documentation for Atoms
        """
        return self.Atoms

    @Points.setter
    def Points(self, value):
        self.Atoms = value



class _ring_puckering3(printable):
    """
    Section to define general ring puckering collective variables.
    """
    def __init__(self):
        self.Atoms = None
        """
        Specifies the indexes of atoms/points defining the ring.At least 4
        Atoms are needed.
        """
        self.Coordinate = None
        """
        Indicate the coordinate to be used. Follow the Cremer-Pople definition
        for a N ring.0 is the total puckering variable Q,2..[N/2] are
        puckering coordinates.-2..-[N/2-1] are puckering angles.
        """
        self.list_POINT = []
        self._name = "RING_PUCKERING"
        self._keywords = [('Atoms', 'ATOMS'), ('Coordinate', 'COORDINATE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point53')]

    def add_POINT(self):
        new_section = _point53()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Points(self):
        """
        See documentation for Atoms
        """
        return self.Atoms

    @Points.setter
    def Points(self, value):
        self.Atoms = value



class _ring_puckering1(printable):
    """
    Section to define general ring puckering collective variables.
    """
    def __init__(self):
        self.Atoms = None
        """
        Specifies the indexes of atoms/points defining the ring.At least 4
        Atoms are needed.
        """
        self.Coordinate = None
        """
        Indicate the coordinate to be used. Follow the Cremer-Pople definition
        for a N ring.0 is the total puckering variable Q,2..[N/2] are
        puckering coordinates.-2..-[N/2-1] are puckering angles.
        """
        self.list_POINT = []
        self._name = "RING_PUCKERING"
        self._keywords = [('Atoms', 'ATOMS'), ('Coordinate', 'COORDINATE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point17')]

    def add_POINT(self):
        new_section = _point17()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Points(self):
        """
        See documentation for Atoms
        """
        return self.Atoms

    @Points.setter
    def Points(self, value):
        self.Atoms = value



class _pdos1(printable):
    """
    Print out the DOS projected per kind and per angular momentum
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Components = None
        """
        Print out pdos distinguishing all angular momentum components.
        """
        self.Append = None
        """
        Append the pdos obtained at different iterations to the pdos  output
        file.By defaut the file is overwritten
        """
        self.Nlumo = None
        """
        Number of virtual orbitals to be added to the MO set (-1=all)
        """
        self.Out_each_mo = None
        """
        Output on the status of the calculation every OUT_EACH_MO states. If
        -1 no output
        """
        self.EACH = _each197()
        self.list_LDOS = []
        self.list_R_LDOS = []
        self._name = "PDOS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Components', 'COMPONENTS'), ('Append', 'APPEND'), ('Nlumo', 'NLUMO'), ('Out_each_mo', 'OUT_EACH_MO')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = [('LDOS', '_ldos1'), ('R_LDOS', '_r_ldos1')]

    def add_LDOS(self):
        new_section = _ldos1()
        self.list_LDOS.append(new_section)
        return new_section

    def add_R_LDOS(self):
        new_section = _r_ldos1()
        self.list_R_LDOS.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _bond_rotation4(printable):
    """
    Section to define the rotation of a bond/line with respect toanother
    bond/line
    """
    def __init__(self):
        self.P1_bond1 = None
        """
        Specifies the index of atom/point defining the first pointof the first
        bond/line.
        """
        self.P2_bond1 = None
        """
        Specifies the index of atom/point defining the second pointof the
        first bond/line.
        """
        self.P1_bond2 = None
        """
        Specifies the index of atom/point defining the first pointof the
        second bond/line.
        """
        self.P2_bond2 = None
        """
        Specifies the index of atom/point defining the second pointof the
        second bond/line.
        """
        self.list_POINT = []
        self._name = "BOND_ROTATION"
        self._keywords = [('P1_bond1', 'P1_BOND1'), ('P2_bond1', 'P2_BOND1'), ('P1_bond2', 'P1_BOND2'), ('P2_bond2', 'P2_BOND2')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point63')]

    def add_POINT(self):
        new_section = _point63()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _upf_file1(printable):
    """
    Write GTH pseudopotential in UPF format
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each364()
        self._name = "UPF_FILE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _bond_rotation1(printable):
    """
    Section to define the rotation of a bond/line with respect toanother
    bond/line
    """
    def __init__(self):
        self.P1_bond1 = None
        """
        Specifies the index of atom/point defining the first pointof the first
        bond/line.
        """
        self.P2_bond1 = None
        """
        Specifies the index of atom/point defining the second pointof the
        first bond/line.
        """
        self.P1_bond2 = None
        """
        Specifies the index of atom/point defining the first pointof the
        second bond/line.
        """
        self.P2_bond2 = None
        """
        Specifies the index of atom/point defining the second pointof the
        second bond/line.
        """
        self.list_POINT = []
        self._name = "BOND_ROTATION"
        self._keywords = [('P1_bond1', 'P1_BOND1'), ('P2_bond1', 'P2_BOND1'), ('P1_bond2', 'P1_BOND2'), ('P2_bond2', 'P2_BOND2')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point9')]

    def add_POINT(self):
        new_section = _point9()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _restart_averages1(printable):
    """
    Stores information for restarting averages.
    """
    def __init__(self):
        self.Itimes_start = None
        """
        TIME STEP starting the evaluation of averages
        """
        self.Avecpu = None
        """
        CPU average
        """
        self.Avehugoniot = None
        """
        HUGONIOT average
        """
        self.Avetemp_baro = None
        """
        BAROSTAT TEMPERATURE average
        """
        self.Avepot = None
        """
        POTENTIAL ENERGY average
        """
        self.Avekin = None
        """
        KINETIC ENERGY average
        """
        self.Avetemp = None
        """
        TEMPERATURE average
        """
        self.Avekin_qm = None
        """
        QM KINETIC ENERGY average in QMMM runs
        """
        self.Avetemp_qm = None
        """
        QM TEMPERATURE average in QMMM runs
        """
        self.Avevol = None
        """
        VOLUME average
        """
        self.Avecell_a = None
        """
        CELL VECTOR A average
        """
        self.Avecell_b = None
        """
        CELL VECTOR B average
        """
        self.Avecell_c = None
        """
        CELL VECTOR C average
        """
        self.Avealpha = None
        """
        ALPHA cell angle average
        """
        self.Avebeta = None
        """
        BETA cell angle average
        """
        self.Avegamma = None
        """
        GAMMA cell angle average
        """
        self.Ave_econs = None
        """
        CONSTANT ENERGY average
        """
        self.Ave_press = None
        """
        PRESSURE average
        """
        self.Ave_pxx = None
        """
        P_{XX} average
        """
        self.Ave_pv_vir = None
        """
        PV VIRIAL average
        """
        self.Ave_pv_tot = None
        """
        PV TOTAL average
        """
        self.Ave_pv_kin = None
        """
        PV KINETIC average
        """
        self.Ave_pv_cnstr = None
        """
        PV CONSTRAINTS average
        """
        self.Ave_pv_xc = None
        """
        PV XC average
        """
        self.Ave_pv_fock_4c = None
        """
        PV XC average
        """
        self.Ave_colvars = None
        """
        COLVARS averages
        """
        self.Ave_mmatrix = None
        """
        METRIC TENSOR averages
        """
        self._name = "RESTART_AVERAGES"
        self._keywords = [('Itimes_start', 'ITIMES_START'), ('Avecpu', 'AVECPU'), ('Avehugoniot', 'AVEHUGONIOT'), ('Avetemp_baro', 'AVETEMP_BARO'), ('Avepot', 'AVEPOT'), ('Avekin', 'AVEKIN'), ('Avetemp', 'AVETEMP'), ('Avekin_qm', 'AVEKIN_QM'), ('Avetemp_qm', 'AVETEMP_QM'), ('Avevol', 'AVEVOL'), ('Avecell_a', 'AVECELL_A'), ('Avecell_b', 'AVECELL_B'), ('Avecell_c', 'AVECELL_C'), ('Avealpha', 'AVEALPHA'), ('Avebeta', 'AVEBETA'), ('Avegamma', 'AVEGAMMA'), ('Ave_econs', 'AVE_ECONS'), ('Ave_press', 'AVE_PRESS'), ('Ave_pxx', 'AVE_PXX'), ('Ave_pv_vir', 'AVE_PV_VIR'), ('Ave_pv_tot', 'AVE_PV_TOT'), ('Ave_pv_kin', 'AVE_PV_KIN'), ('Ave_pv_cnstr', 'AVE_PV_CNSTR'), ('Ave_pv_xc', 'AVE_PV_XC'), ('Ave_pv_fock_4c', 'AVE_PV_FOCK_4C'), ('Ave_colvars', 'AVE_COLVARS'), ('Ave_mmatrix', 'AVE_MMATRIX')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _bond_rotation3(printable):
    """
    Section to define the rotation of a bond/line with respect toanother
    bond/line
    """
    def __init__(self):
        self.P1_bond1 = None
        """
        Specifies the index of atom/point defining the first pointof the first
        bond/line.
        """
        self.P2_bond1 = None
        """
        Specifies the index of atom/point defining the second pointof the
        first bond/line.
        """
        self.P1_bond2 = None
        """
        Specifies the index of atom/point defining the first pointof the
        second bond/line.
        """
        self.P2_bond2 = None
        """
        Specifies the index of atom/point defining the second pointof the
        second bond/line.
        """
        self.list_POINT = []
        self._name = "BOND_ROTATION"
        self._keywords = [('P1_bond1', 'P1_BOND1'), ('P2_bond1', 'P2_BOND1'), ('P1_bond2', 'P1_BOND2'), ('P2_bond2', 'P2_BOND2')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point45')]

    def add_POINT(self):
        new_section = _point45()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _constraint_info1(printable):
    """
    Prints information about iterative constraints solutions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each46()
        self._name = "CONSTRAINT_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _radii1(printable):
    """
    controls the output of radii information
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.Core_charges_radii = None
        """
        If the printkey is activated controls the printing of the radii of the
        core charges
        """
        self.Pgf_radii = None
        """
        If the printkey is activated controls the printing of the core
        gaussian radii
        """
        self.Set_radii = None
        """
        If the printkey is activated controls the printing of the set_radii
        """
        self.Kind_radii = None
        """
        If the printkey is activated controls the printing of the kind_radii
        """
        self.Core_charge_radii = None
        """
        If the printkey is activated controls the printing of the
        core_charge_radii
        """
        self.Gth_ppl_radii = None
        """
        If the printkey is activated controls the printing of the gth pseudo
        potential local radii
        """
        self.Gth_ppnl_radii = None
        """
        If the printkey is activated controls the printing of the gth pseudo
        potential non local radii
        """
        self.Gapw_prj_radii = None
        """
        If the printkey is activated controls the printing of the gapw
        projector radii
        """
        self.EACH = _each285()
        self._name = "RADII"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT'), ('Core_charges_radii', 'CORE_CHARGES_RADII'), ('Pgf_radii', 'PGF_RADII'), ('Set_radii', 'SET_RADII'), ('Kind_radii', 'KIND_RADII'), ('Core_charge_radii', 'CORE_CHARGE_RADII'), ('Gth_ppl_radii', 'GTH_PPL_RADII'), ('Gth_ppnl_radii', 'GTH_PPNL_RADII'), ('Gapw_prj_radii', 'GAPW_PRJ_RADII')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _hf_info8(printable):
    """
    Controls the printing basic info about hf method
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each371()
        self._name = "HF_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _msd1(printable):
    """
    Loads an external trajectory file and performs analysis on the loaded
    snapshots.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        controls the activation of core-level spectroscopy simulations
        """
        self.Ref0_filename = None
        """
        Specify the filename where the initial reference configuration is
        stored.
        """
        self.Msd_per_kind = None
        """
        Set up the calculation of the MSD for each atomic kind
        """
        self.Msd_per_molkind = None
        """
        Set up the calculation of the MSD for each molecule kind.The position
        of the center of mass of the molecule is considered.
        """
        self.Msd_per_region = None
        """
        Set up the calculation of the MSD for each defined region.
        """
        self.Displaced_atom = None
        """
        Identify the atoms that moved from their initialposition of a distance
        larger than a given tolerance (see msd%displacement_tol).
        """
        self.Displacement_tol = None
        """
        Lower limit to define displaced atoms
        """
        self.list_DEFINE_REGION = []
        self._name = "MSD"
        self._keywords = [('Ref0_filename', 'REF0_FILENAME'), ('Msd_per_kind', 'MSD_PER_KIND'), ('Msd_per_molkind', 'MSD_PER_MOLKIND'), ('Msd_per_region', 'MSD_PER_REGION'), ('Displaced_atom', 'DISPLACED_ATOM'), ('Displacement_tol', 'DISPLACEMENT_TOL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('DEFINE_REGION', '_define_region5')]

    def add_DEFINE_REGION(self):
        new_section = _define_region5()
        self.list_DEFINE_REGION.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _eam1(printable):
    """
    This section specifies the input parameters for EAM potential type.
    """
    def __init__(self):
        self.Atoms = None
        """
        Defines the atomic kind involved in the nonbond potential
        """
        self.Parm_file_name = None
        """
        Specifies the filename that contains the tabulated EAM potential. File
        structure: the first line of the potential file contains a title. The
        second line contains: atomic number, mass and lattice constant. These
        information are parsed but not used in CP2K. The third line contains:
        dr: increment of r for the tabulated values of density and phi
        (assuming r starts in 0) [angstrom]; drho: increment of density for
        the tabulated values of the embedding function (assuming rho starts in
        0) [au_c]; cutoff: cutoff of the EAM potential; npoints: number of
        points in tabulated. Follow in order npoints lines for rho [au_c] and
        its derivative [au_c*angstrom^-1]; npoints lines for PHI [ev] and its
        derivative [ev*angstrom^-1] and npoint lines for the embedded function
        [ev] and its derivative [ev*au_c^-1].
        """
        self._name = "EAM"
        self._keywords = [('Atoms', 'ATOMS'), ('Parm_file_name', 'PARM_FILE_NAME')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Parmfile(self):
        """
        See documentation for Parm_file_name
        """
        return self.Parm_file_name

    @Parmfile.setter
    def Parmfile(self, value):
        self.Parm_file_name = value



class _ewald_info1(printable):
    """
    Activates the printing of the information for Ewald multipole
    summation in periodic SE.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each110()
        self._name = "EWALD_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _ewald_info2(printable):
    """
    Controls the printing of Ewald energy components during the evaluation
    of the electrostatics.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each223()
        self._name = "EWALD_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _wannier_centers3(printable):
    """
    Controls the printing of the wannier functions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.Ionspluscenters = None
        """
        prints out the wannier centers together with the particles
        """
        self.Format = None
        """
        Specifies the format of the output file when IONS+CENTERS is enabled.

        Available values:
            ATOMIC
                Write only the coordinates X,Y,Z without element symbols to a
                formatted file
            DCD
                Write the coordinates (no element labels) and the cell information to
                a binary file
            PDB
                Write the atomic information in PDB format to a formatted file
            XMOL
                Mostly known as XYZ format, provides in a formatted file:
                element_symbol X Y Z
            XYZ
                Alias name for XMOL
        """
        self.Charge_occup = None
        """
        Write the MM charges to the OCCUP field of the PDB file
        """
        self.Charge_beta = None
        """
        Write the MM charges to the BETA field of the PDB file
        """
        self.Charge_extended = None
        """
        Write the MM charges to the very last field of the PDB file (starting
        from column 81)
        """
        self.EACH = _each167()
        self._name = "WANNIER_CENTERS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT'), ('Ionspluscenters', 'IONS+CENTERS'), ('Format', 'FORMAT'), ('Charge_occup', 'CHARGE_OCCUP'), ('Charge_beta', 'CHARGE_BETA'), ('Charge_extended', 'CHARGE_EXTENDED')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Charge_o(self):
        """
        See documentation for Charge_occup
        """
        return self.Charge_occup

    @property
    def Charge_b(self):
        """
        See documentation for Charge_beta
        """
        return self.Charge_beta

    @Charge_o.setter
    def Charge_o(self, value):
        self.Charge_occup = value

    @Charge_b.setter
    def Charge_b(self, value):
        self.Charge_beta = value



class _wannier_centers2(printable):
    """
    Controls the printing of the wannier functions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.Ionspluscenters = None
        """
        prints out the wannier centers together with the particles
        """
        self.Format = None
        """
        Specifies the format of the output file when IONS+CENTERS is enabled.

        Available values:
            ATOMIC
                Write only the coordinates X,Y,Z without element symbols to a
                formatted file
            DCD
                Write the coordinates (no element labels) and the cell information to
                a binary file
            PDB
                Write the atomic information in PDB format to a formatted file
            XMOL
                Mostly known as XYZ format, provides in a formatted file:
                element_symbol X Y Z
            XYZ
                Alias name for XMOL
        """
        self.Charge_occup = None
        """
        Write the MM charges to the OCCUP field of the PDB file
        """
        self.Charge_beta = None
        """
        Write the MM charges to the BETA field of the PDB file
        """
        self.Charge_extended = None
        """
        Write the MM charges to the very last field of the PDB file (starting
        from column 81)
        """
        self.EACH = _each156()
        self._name = "WANNIER_CENTERS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT'), ('Ionspluscenters', 'IONS+CENTERS'), ('Format', 'FORMAT'), ('Charge_occup', 'CHARGE_OCCUP'), ('Charge_beta', 'CHARGE_BETA'), ('Charge_extended', 'CHARGE_EXTENDED')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Charge_o(self):
        """
        See documentation for Charge_occup
        """
        return self.Charge_occup

    @property
    def Charge_b(self):
        """
        See documentation for Charge_beta
        """
        return self.Charge_beta

    @Charge_o.setter
    def Charge_o(self, value):
        self.Charge_occup = value

    @Charge_b.setter
    def Charge_b(self, value):
        self.Charge_beta = value



class _wannier_centers1(printable):
    """
    Controls the printing of the wannier functions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.Ionspluscenters = None
        """
        prints out the wannier centers together with the particles
        """
        self.Format = None
        """
        Specifies the format of the output file when IONS+CENTERS is enabled.

        Available values:
            ATOMIC
                Write only the coordinates X,Y,Z without element symbols to a
                formatted file
            DCD
                Write the coordinates (no element labels) and the cell information to
                a binary file
            PDB
                Write the atomic information in PDB format to a formatted file
            XMOL
                Mostly known as XYZ format, provides in a formatted file:
                element_symbol X Y Z
            XYZ
                Alias name for XMOL
        """
        self.Charge_occup = None
        """
        Write the MM charges to the OCCUP field of the PDB file
        """
        self.Charge_beta = None
        """
        Write the MM charges to the BETA field of the PDB file
        """
        self.Charge_extended = None
        """
        Write the MM charges to the very last field of the PDB file (starting
        from column 81)
        """
        self.EACH = _each146()
        self._name = "WANNIER_CENTERS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT'), ('Ionspluscenters', 'IONS+CENTERS'), ('Format', 'FORMAT'), ('Charge_occup', 'CHARGE_OCCUP'), ('Charge_beta', 'CHARGE_BETA'), ('Charge_extended', 'CHARGE_EXTENDED')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Charge_o(self):
        """
        See documentation for Charge_occup
        """
        return self.Charge_occup

    @property
    def Charge_b(self):
        """
        See documentation for Charge_beta
        """
        return self.Charge_beta

    @Charge_o.setter
    def Charge_o(self, value):
        self.Charge_occup = value

    @Charge_b.setter
    def Charge_b(self, value):
        self.Charge_beta = value



class _wannier_centers5(printable):
    """
    Controls the printing of the wannier functions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.Ionspluscenters = None
        """
        prints out the wannier centers together with the particles
        """
        self.Format = None
        """
        Specifies the format of the output file when IONS+CENTERS is enabled.

        Available values:
            ATOMIC
                Write only the coordinates X,Y,Z without element symbols to a
                formatted file
            DCD
                Write the coordinates (no element labels) and the cell information to
                a binary file
            PDB
                Write the atomic information in PDB format to a formatted file
            XMOL
                Mostly known as XYZ format, provides in a formatted file:
                element_symbol X Y Z
            XYZ
                Alias name for XMOL
        """
        self.Charge_occup = None
        """
        Write the MM charges to the OCCUP field of the PDB file
        """
        self.Charge_beta = None
        """
        Write the MM charges to the BETA field of the PDB file
        """
        self.Charge_extended = None
        """
        Write the MM charges to the very last field of the PDB file (starting
        from column 81)
        """
        self.EACH = _each288()
        self._name = "WANNIER_CENTERS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT'), ('Ionspluscenters', 'IONS+CENTERS'), ('Format', 'FORMAT'), ('Charge_occup', 'CHARGE_OCCUP'), ('Charge_beta', 'CHARGE_BETA'), ('Charge_extended', 'CHARGE_EXTENDED')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Charge_o(self):
        """
        See documentation for Charge_occup
        """
        return self.Charge_occup

    @property
    def Charge_b(self):
        """
        See documentation for Charge_beta
        """
        return self.Charge_beta

    @Charge_o.setter
    def Charge_o(self, value):
        self.Charge_occup = value

    @Charge_b.setter
    def Charge_b(self, value):
        self.Charge_beta = value



class _wannier_centers4(printable):
    """
    Controls the printing of the wannier functions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.Ionspluscenters = None
        """
        prints out the wannier centers together with the particles
        """
        self.Format = None
        """
        Specifies the format of the output file when IONS+CENTERS is enabled.

        Available values:
            ATOMIC
                Write only the coordinates X,Y,Z without element symbols to a
                formatted file
            DCD
                Write the coordinates (no element labels) and the cell information to
                a binary file
            PDB
                Write the atomic information in PDB format to a formatted file
            XMOL
                Mostly known as XYZ format, provides in a formatted file:
                element_symbol X Y Z
            XYZ
                Alias name for XMOL
        """
        self.Charge_occup = None
        """
        Write the MM charges to the OCCUP field of the PDB file
        """
        self.Charge_beta = None
        """
        Write the MM charges to the BETA field of the PDB file
        """
        self.Charge_extended = None
        """
        Write the MM charges to the very last field of the PDB file (starting
        from column 81)
        """
        self.EACH = _each199()
        self._name = "WANNIER_CENTERS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT'), ('Ionspluscenters', 'IONS+CENTERS'), ('Format', 'FORMAT'), ('Charge_occup', 'CHARGE_OCCUP'), ('Charge_beta', 'CHARGE_BETA'), ('Charge_extended', 'CHARGE_EXTENDED')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Charge_o(self):
        """
        See documentation for Charge_occup
        """
        return self.Charge_occup

    @property
    def Charge_b(self):
        """
        See documentation for Charge_beta
        """
        return self.Charge_beta

    @Charge_o.setter
    def Charge_o(self, value):
        self.Charge_occup = value

    @Charge_b.setter
    def Charge_b(self, value):
        self.Charge_beta = value



class _point21(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _lr_correction1(printable):
    """
    Setup parameters for the evaluation of the long-range correction term
    in SE calculations.
    """
    def __init__(self):
        self.Cutoff = None
        """
        Atomic Cutoff Radius Cutoff for the evaluation of the long-ranbe
        correction integrals.
        """
        self.Rc_taper = None
        """
        Atomic Cutoff Radius Cutoff for Tapering the long-range correction
        integrals. If not specified it assumes the same value specified for
        the CUTOFF.
        """
        self.Rc_range = None
        """
        Range of cutoff switch function (tapering):
        0.5*(1-TANH((r-r0)/RC_RANGE)), where r0=2.0*RC_TAPER-20.0*RC_RANGE.
        """
        self._name = "LR_CORRECTION"
        self._keywords = [('Cutoff', 'CUTOFF'), ('Rc_taper', 'RC_TAPER'), ('Rc_range', 'RC_RANGE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _point23(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _dimer_vector1(printable):
    """
    Specifies the initial dimer vector (used frequently to restart DIMER
    calculations). If not provided the starting orientation of the dimer
    is chosen randomly.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify on each line the components of the dimer vector.
        """
        self._name = "DIMER_VECTOR"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _hf_info5(printable):
    """
    Controls the printing basic info about hf method
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each308()
        self._name = "HF_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _point24(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _ot2(printable):
    """
    Sets the various options for the orbital transformation (OT) method.
    Default settings already provide an efficient, yet robust method. Most
    systems benefit from using the FULL_ALL preconditioner combined with a
    small value (0.001) of ENERGY_GAP.Well-behaved systems might benefit
    from using a DIIS minimizer.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        controls the activation of the ot method
        """
        self.Algorithm = None
        """
        Algorithm to be used for OT

        Available values:
            STRICT
                Strict orthogonality: Taylor or diagonalization based algorithm.
            IRAC
                Orbital Transformation based Iterative Refinement of the Approximative
                Congruence transformation (OT/IR).
        """
        self.Irac_degree = None
        """
        The refinement polynomial degree (2, 3 or 4).
        """
        self.Max_irac = None
        """
        Maximum allowed refinement iteration.
        """
        self.Mixed_precision = None
        """
        Uses a mixed precision algorithm.With a well behaved basis set (i.e.
        condition number less than 1/eps_sp)it provides double precision
        accuracy results and up to a 2 fold speedup for building and applying
        the preconditioner.
        """
        self.Ortho_irac = None
        """
        The orthogonality method.

        Available values:
            CHOL
                Cholesky.
            POLY
                Polynomial.
            LWDN
                Loewdin.
        """
        self.Eps_irac_filter_matrix = None
        """
        Sets the threshold for filtering the matrices.
        """
        self.Eps_irac = None
        """
        Targeted accuracy during the refinement iteration.
        """
        self.Eps_irac_quick_exit = None
        """
        Only one extra refinement iteration is done when the norm is below
        this value.
        """
        self.Eps_irac_switch = None
        """
        The algorithm switches to the polynomial refinement when the norm is
        below this value.
        """
        self.On_the_fly_loc = None
        """
        On the fly localization of the molecular orbitals. Can only be used
        with OT/IRAC.
        """
        self.Minimizer = None
        """
        Minimizer to be used with the OT method

        Available values:
            SD
                Steepest descent: not recommended
            CG
                Conjugate Gradients: most reliable, use for difficult systems. The
                total energy should decrease at every OT CG step if the line search is
                appropriate.
            DIIS
                Direct inversion in the iterative subspace: less reliable than CG, but
                sometimes about 50% faster
            BROYDEN
                Broyden mixing approximating the inverse Hessian
        """
        self.Safe_diis = None
        """
        Reject DIIS steps if they point away from the minimum, do SD in that
        case.
        """
        self.N_history_vec = None
        """
        Number of history vectors to be used with DIIS or BROYDEN
        """
        self.Broyden_beta = None
        """
        Underrelaxation for the broyden mixer
        """
        self.Broyden_gamma = None
        """
        Backtracking parameter
        """
        self.Broyden_sigma = None
        """
        Curvature of energy functional.
        """
        self.Broyden_eta = None
        """
        Dampening of estimated energy curvature.
        """
        self.Broyden_omega = None
        """
        Growth limit of curvature.
        """
        self.Broyden_sigma_decrease = None
        """
        Reduction of curvature on bad approximation.
        """
        self.Broyden_sigma_min = None
        """
        Minimum adaptive curvature.
        """
        self.Broyden_forget_history = None
        """
        Forget history on bad approximation
        """
        self.Broyden_adaptive_sigma = None
        """
        Enable adaptive curvature estimation
        """
        self.Broyden_enable_flip = None
        """
        Ensure positive definite update
        """
        self.Linesearch = None
        """
        1D line search algorithm to be used with the OT minimizer, in
        increasing order of robustness and cost. MINIMIZER CG combined with
        LINESEARCH GOLD should always find an electronic minimum.  Whereas the
        2PNT minimizer is almost always OK, 3PNT might be needed for systems
        in which successive OT CG steps do not decrease the total energy.

        Available values:
            NONE
                take fixed lenght steps
            2PNT
                extrapolate based on 2 points
            3PNT
                ... or on 3 points
            GOLD
                perform 1D golden section search of the minimum (very expensive)
        """
        self.Stepsize = None
        """
        Initial stepsize used for the line search, sometimes this parameter
        can be reduced to stablize DIIS or to improve the CG behavior in the
        first few steps
        """
        self.Gold_target = None
        """
        Target relative uncertainty in the location of the minimum for
        LINESEARCH GOLD
        """
        self.Preconditioner = None
        """
        Type of preconditioner to be used with all minimization schemes. They
        differ in effectiveness, cost of construction, cost of application.
        Properly preconditioned minimization can be orders of magnitude faster
        than doing nothing.

        Available values:
            FULL_ALL
                Most effective state selective preconditioner based on
                diagonalization, requires the ENERGY_GAP parameter to be an
                underestimate of the HOMO-LUMO gap. This preconditioner is recommended
                for almost all systems, except very large systems where
                make_preconditioner would dominate the total computational cost.
            FULL_SINGLE_INVERSE
                Based on H-eS cholesky inversion, similar to FULL_SINGLE in
                preconditioning efficiency but cheaper to construct, might be somewhat
                less robust. Recommended for large systems.
            FULL_SINGLE
                Based on H-eS diagonalisation, not as good as FULL_ALL, but somewhat
                cheaper to apply.
            FULL_KINETIC
                Cholesky inversion of S and T, fast construction, robust, and
                relatively good, use for very large systems.
            FULL_S_INVERSE
                Cholesky inversion of S, not as good as FULL_KINETIC, yet equally
                expensive.
            SPARSE_DIAG
                Only based on atomic blocks, very cheap in construction but quite
                poor.
            SPARSE_KINETIC
                Toward -sparse- linear solver for T-eS.
            SPARSE_STABLE_APPROXIMATE_INVERSE
                Stabilized Approximate INVerse preconditioning using DBCSR sparse
                matrices (not working yet).
            NONE
                skip preconditioning
        """
        self.Precond_solver = None
        """
        How the preconditioner is applied to the residual.

        Available values:
            DEFAULT
                the default
            DIRECT
                Cholesky decomposition followed by triangular solve (works for
                FULL_KINETIC/SINGLE_INVERSE/S_INVERSE)
            INVERSE_CHOLESKY
                Cholesky decomposition followed by explicit inversion (works for
                FULL_KINETIC/SINGLE_INVERSE/S_INVERSE)
            SAINV
                SAINV inversion (works for FULL_KINETIC/SINGLE_INVERSE/S_INVERSE)
        """
        self.Energy_gap = None
        """
        Should be an estimate for the energy gap [a.u.] (HOMO-LUMO) and is
        used in preconditioning, especially effective with the FULL_ALL
        preconditioner, in which case it should be an underestimate of the gap
        (0.001 doing normally fine). For the other preconditioners, making
        this value larger (0.2) will tame the preconditioner in case of poor
        initial guesses.
        """
        self.Eps_taylor = None
        """
        Target accuracy of the taylor expansion for the matrix functions,
        should normally be kept as is.
        """
        self.Max_taylor = None
        """
        Maximum order of the Taylor expansion before diagonalisation is
        prefered, for large parallel runs a slightly higher order could
        sometimes result in a small speedup.
        """
        self.Rotation = None
        """
        Introduce additional variables so that rotations of the occupied
        subspace are allowed as well, only needed for cases where the energy
        is not invariant under  a rotation of the occupied subspace such as
        non-singlet restricted calculations  or fractional occupations.
        """
        self.Scp_dft = None
        """
        Introduce additional self-consistent polarization through additional
        response basis functions (read in through AUX_BASIS.)
        """
        self.Scp_nddo = None
        """
        Introduce additional self-consistent polarization through response
        basis set = orbital basis set for NDDO.)
        """
        self.Energies = None
        """
        Optimize orbital energies for use in Fermi-Dirac smearing (requires
        ROTATION and FD smearing to be active).
        """
        self.Occupation_preconditioner = None
        """
        Preconditioner with the occupation numbers (FD smearing)
        """
        self.Nondiag_energy = None
        """
        Add a non-diagonal energy penalty (FD smearing)
        """
        self.Nondiag_energy_strength = None
        """
        The prefactor for the non-diagonal energy penalty (FD smearing)
        """
        self._name = "OT"
        self._keywords = [('Algorithm', 'ALGORITHM'), ('Irac_degree', 'IRAC_DEGREE'), ('Max_irac', 'MAX_IRAC'), ('Mixed_precision', 'MIXED_PRECISION'), ('Ortho_irac', 'ORTHO_IRAC'), ('Eps_irac_filter_matrix', 'EPS_IRAC_FILTER_MATRIX'), ('Eps_irac', 'EPS_IRAC'), ('Eps_irac_quick_exit', 'EPS_IRAC_QUICK_EXIT'), ('Eps_irac_switch', 'EPS_IRAC_SWITCH'), ('On_the_fly_loc', 'ON_THE_FLY_LOC'), ('Minimizer', 'MINIMIZER'), ('Safe_diis', 'SAFE_DIIS'), ('N_history_vec', 'N_HISTORY_VEC'), ('Broyden_beta', 'BROYDEN_BETA'), ('Broyden_gamma', 'BROYDEN_GAMMA'), ('Broyden_sigma', 'BROYDEN_SIGMA'), ('Broyden_eta', 'BROYDEN_ETA'), ('Broyden_omega', 'BROYDEN_OMEGA'), ('Broyden_sigma_decrease', 'BROYDEN_SIGMA_DECREASE'), ('Broyden_sigma_min', 'BROYDEN_SIGMA_MIN'), ('Broyden_forget_history', 'BROYDEN_FORGET_HISTORY'), ('Broyden_adaptive_sigma', 'BROYDEN_ADAPTIVE_SIGMA'), ('Broyden_enable_flip', 'BROYDEN_ENABLE_FLIP'), ('Linesearch', 'LINESEARCH'), ('Stepsize', 'STEPSIZE'), ('Gold_target', 'GOLD_TARGET'), ('Preconditioner', 'PRECONDITIONER'), ('Precond_solver', 'PRECOND_SOLVER'), ('Energy_gap', 'ENERGY_GAP'), ('Eps_taylor', 'EPS_TAYLOR'), ('Max_taylor', 'MAX_TAYLOR'), ('Rotation', 'ROTATION'), ('Scp_dft', 'SCP_DFT'), ('Scp_nddo', 'SCP_NDDO'), ('Energies', 'ENERGIES'), ('Occupation_preconditioner', 'OCCUPATION_PRECONDITIONER'), ('Nondiag_energy', 'NONDIAG_ENERGY'), ('Nondiag_energy_strength', 'NONDIAG_ENERGY_STRENGTH')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Safer_diis(self):
        """
        See documentation for Safe_diis
        """
        return self.Safe_diis

    @property
    def Ndiis(self):
        """
        See documentation for N_history_vec
        """
        return self.N_history_vec

    @property
    def N_diis(self):
        """
        See documentation for N_history_vec
        """
        return self.N_history_vec

    @property
    def N_broyden(self):
        """
        See documentation for N_history_vec
        """
        return self.N_history_vec

    @property
    def Line_search(self):
        """
        See documentation for Linesearch
        """
        return self.Linesearch

    @property
    def Epstaylor(self):
        """
        See documentation for Eps_taylor
        """
        return self.Eps_taylor

    @Safer_diis.setter
    def Safer_diis(self, value):
        self.Safe_diis = value

    @Ndiis.setter
    def Ndiis(self, value):
        self.N_history_vec = value

    @N_diis.setter
    def N_diis(self, value):
        self.N_history_vec = value

    @N_broyden.setter
    def N_broyden(self, value):
        self.N_history_vec = value

    @Line_search.setter
    def Line_search(self, value):
        self.Linesearch = value

    @Epstaylor.setter
    def Epstaylor(self, value):
        self.Eps_taylor = value



class _ot1(printable):
    """
    Sets the various options for the orbital transformation (OT) method.
    Default settings already provide an efficient, yet robust method. Most
    systems benefit from using the FULL_ALL preconditioner combined with a
    small value (0.001) of ENERGY_GAP.Well-behaved systems might benefit
    from using a DIIS minimizer.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        controls the activation of the ot method
        """
        self.Algorithm = None
        """
        Algorithm to be used for OT

        Available values:
            STRICT
                Strict orthogonality: Taylor or diagonalization based algorithm.
            IRAC
                Orbital Transformation based Iterative Refinement of the Approximative
                Congruence transformation (OT/IR).
        """
        self.Irac_degree = None
        """
        The refinement polynomial degree (2, 3 or 4).
        """
        self.Max_irac = None
        """
        Maximum allowed refinement iteration.
        """
        self.Mixed_precision = None
        """
        Uses a mixed precision algorithm.With a well behaved basis set (i.e.
        condition number less than 1/eps_sp)it provides double precision
        accuracy results and up to a 2 fold speedup for building and applying
        the preconditioner.
        """
        self.Ortho_irac = None
        """
        The orthogonality method.

        Available values:
            CHOL
                Cholesky.
            POLY
                Polynomial.
            LWDN
                Loewdin.
        """
        self.Eps_irac_filter_matrix = None
        """
        Sets the threshold for filtering the matrices.
        """
        self.Eps_irac = None
        """
        Targeted accuracy during the refinement iteration.
        """
        self.Eps_irac_quick_exit = None
        """
        Only one extra refinement iteration is done when the norm is below
        this value.
        """
        self.Eps_irac_switch = None
        """
        The algorithm switches to the polynomial refinement when the norm is
        below this value.
        """
        self.On_the_fly_loc = None
        """
        On the fly localization of the molecular orbitals. Can only be used
        with OT/IRAC.
        """
        self.Minimizer = None
        """
        Minimizer to be used with the OT method

        Available values:
            SD
                Steepest descent: not recommended
            CG
                Conjugate Gradients: most reliable, use for difficult systems. The
                total energy should decrease at every OT CG step if the line search is
                appropriate.
            DIIS
                Direct inversion in the iterative subspace: less reliable than CG, but
                sometimes about 50% faster
            BROYDEN
                Broyden mixing approximating the inverse Hessian
        """
        self.Safe_diis = None
        """
        Reject DIIS steps if they point away from the minimum, do SD in that
        case.
        """
        self.N_history_vec = None
        """
        Number of history vectors to be used with DIIS or BROYDEN
        """
        self.Broyden_beta = None
        """
        Underrelaxation for the broyden mixer
        """
        self.Broyden_gamma = None
        """
        Backtracking parameter
        """
        self.Broyden_sigma = None
        """
        Curvature of energy functional.
        """
        self.Broyden_eta = None
        """
        Dampening of estimated energy curvature.
        """
        self.Broyden_omega = None
        """
        Growth limit of curvature.
        """
        self.Broyden_sigma_decrease = None
        """
        Reduction of curvature on bad approximation.
        """
        self.Broyden_sigma_min = None
        """
        Minimum adaptive curvature.
        """
        self.Broyden_forget_history = None
        """
        Forget history on bad approximation
        """
        self.Broyden_adaptive_sigma = None
        """
        Enable adaptive curvature estimation
        """
        self.Broyden_enable_flip = None
        """
        Ensure positive definite update
        """
        self.Linesearch = None
        """
        1D line search algorithm to be used with the OT minimizer, in
        increasing order of robustness and cost. MINIMIZER CG combined with
        LINESEARCH GOLD should always find an electronic minimum.  Whereas the
        2PNT minimizer is almost always OK, 3PNT might be needed for systems
        in which successive OT CG steps do not decrease the total energy.

        Available values:
            NONE
                take fixed lenght steps
            2PNT
                extrapolate based on 2 points
            3PNT
                ... or on 3 points
            GOLD
                perform 1D golden section search of the minimum (very expensive)
        """
        self.Stepsize = None
        """
        Initial stepsize used for the line search, sometimes this parameter
        can be reduced to stablize DIIS or to improve the CG behavior in the
        first few steps
        """
        self.Gold_target = None
        """
        Target relative uncertainty in the location of the minimum for
        LINESEARCH GOLD
        """
        self.Preconditioner = None
        """
        Type of preconditioner to be used with all minimization schemes. They
        differ in effectiveness, cost of construction, cost of application.
        Properly preconditioned minimization can be orders of magnitude faster
        than doing nothing.

        Available values:
            FULL_ALL
                Most effective state selective preconditioner based on
                diagonalization, requires the ENERGY_GAP parameter to be an
                underestimate of the HOMO-LUMO gap. This preconditioner is recommended
                for almost all systems, except very large systems where
                make_preconditioner would dominate the total computational cost.
            FULL_SINGLE_INVERSE
                Based on H-eS cholesky inversion, similar to FULL_SINGLE in
                preconditioning efficiency but cheaper to construct, might be somewhat
                less robust. Recommended for large systems.
            FULL_SINGLE
                Based on H-eS diagonalisation, not as good as FULL_ALL, but somewhat
                cheaper to apply.
            FULL_KINETIC
                Cholesky inversion of S and T, fast construction, robust, and
                relatively good, use for very large systems.
            FULL_S_INVERSE
                Cholesky inversion of S, not as good as FULL_KINETIC, yet equally
                expensive.
            SPARSE_DIAG
                Only based on atomic blocks, very cheap in construction but quite
                poor.
            SPARSE_KINETIC
                Toward -sparse- linear solver for T-eS.
            SPARSE_STABLE_APPROXIMATE_INVERSE
                Stabilized Approximate INVerse preconditioning using DBCSR sparse
                matrices (not working yet).
            NONE
                skip preconditioning
        """
        self.Precond_solver = None
        """
        How the preconditioner is applied to the residual.

        Available values:
            DEFAULT
                the default
            DIRECT
                Cholesky decomposition followed by triangular solve (works for
                FULL_KINETIC/SINGLE_INVERSE/S_INVERSE)
            INVERSE_CHOLESKY
                Cholesky decomposition followed by explicit inversion (works for
                FULL_KINETIC/SINGLE_INVERSE/S_INVERSE)
            SAINV
                SAINV inversion (works for FULL_KINETIC/SINGLE_INVERSE/S_INVERSE)
        """
        self.Energy_gap = None
        """
        Should be an estimate for the energy gap [a.u.] (HOMO-LUMO) and is
        used in preconditioning, especially effective with the FULL_ALL
        preconditioner, in which case it should be an underestimate of the gap
        (0.001 doing normally fine). For the other preconditioners, making
        this value larger (0.2) will tame the preconditioner in case of poor
        initial guesses.
        """
        self.Eps_taylor = None
        """
        Target accuracy of the taylor expansion for the matrix functions,
        should normally be kept as is.
        """
        self.Max_taylor = None
        """
        Maximum order of the Taylor expansion before diagonalisation is
        prefered, for large parallel runs a slightly higher order could
        sometimes result in a small speedup.
        """
        self.Rotation = None
        """
        Introduce additional variables so that rotations of the occupied
        subspace are allowed as well, only needed for cases where the energy
        is not invariant under  a rotation of the occupied subspace such as
        non-singlet restricted calculations  or fractional occupations.
        """
        self.Scp_dft = None
        """
        Introduce additional self-consistent polarization through additional
        response basis functions (read in through AUX_BASIS.)
        """
        self.Scp_nddo = None
        """
        Introduce additional self-consistent polarization through response
        basis set = orbital basis set for NDDO.)
        """
        self.Energies = None
        """
        Optimize orbital energies for use in Fermi-Dirac smearing (requires
        ROTATION and FD smearing to be active).
        """
        self.Occupation_preconditioner = None
        """
        Preconditioner with the occupation numbers (FD smearing)
        """
        self.Nondiag_energy = None
        """
        Add a non-diagonal energy penalty (FD smearing)
        """
        self.Nondiag_energy_strength = None
        """
        The prefactor for the non-diagonal energy penalty (FD smearing)
        """
        self._name = "OT"
        self._keywords = [('Algorithm', 'ALGORITHM'), ('Irac_degree', 'IRAC_DEGREE'), ('Max_irac', 'MAX_IRAC'), ('Mixed_precision', 'MIXED_PRECISION'), ('Ortho_irac', 'ORTHO_IRAC'), ('Eps_irac_filter_matrix', 'EPS_IRAC_FILTER_MATRIX'), ('Eps_irac', 'EPS_IRAC'), ('Eps_irac_quick_exit', 'EPS_IRAC_QUICK_EXIT'), ('Eps_irac_switch', 'EPS_IRAC_SWITCH'), ('On_the_fly_loc', 'ON_THE_FLY_LOC'), ('Minimizer', 'MINIMIZER'), ('Safe_diis', 'SAFE_DIIS'), ('N_history_vec', 'N_HISTORY_VEC'), ('Broyden_beta', 'BROYDEN_BETA'), ('Broyden_gamma', 'BROYDEN_GAMMA'), ('Broyden_sigma', 'BROYDEN_SIGMA'), ('Broyden_eta', 'BROYDEN_ETA'), ('Broyden_omega', 'BROYDEN_OMEGA'), ('Broyden_sigma_decrease', 'BROYDEN_SIGMA_DECREASE'), ('Broyden_sigma_min', 'BROYDEN_SIGMA_MIN'), ('Broyden_forget_history', 'BROYDEN_FORGET_HISTORY'), ('Broyden_adaptive_sigma', 'BROYDEN_ADAPTIVE_SIGMA'), ('Broyden_enable_flip', 'BROYDEN_ENABLE_FLIP'), ('Linesearch', 'LINESEARCH'), ('Stepsize', 'STEPSIZE'), ('Gold_target', 'GOLD_TARGET'), ('Preconditioner', 'PRECONDITIONER'), ('Precond_solver', 'PRECOND_SOLVER'), ('Energy_gap', 'ENERGY_GAP'), ('Eps_taylor', 'EPS_TAYLOR'), ('Max_taylor', 'MAX_TAYLOR'), ('Rotation', 'ROTATION'), ('Scp_dft', 'SCP_DFT'), ('Scp_nddo', 'SCP_NDDO'), ('Energies', 'ENERGIES'), ('Occupation_preconditioner', 'OCCUPATION_PRECONDITIONER'), ('Nondiag_energy', 'NONDIAG_ENERGY'), ('Nondiag_energy_strength', 'NONDIAG_ENERGY_STRENGTH')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Safer_diis(self):
        """
        See documentation for Safe_diis
        """
        return self.Safe_diis

    @property
    def Ndiis(self):
        """
        See documentation for N_history_vec
        """
        return self.N_history_vec

    @property
    def N_diis(self):
        """
        See documentation for N_history_vec
        """
        return self.N_history_vec

    @property
    def N_broyden(self):
        """
        See documentation for N_history_vec
        """
        return self.N_history_vec

    @property
    def Line_search(self):
        """
        See documentation for Linesearch
        """
        return self.Linesearch

    @property
    def Epstaylor(self):
        """
        See documentation for Eps_taylor
        """
        return self.Eps_taylor

    @Safer_diis.setter
    def Safer_diis(self, value):
        self.Safe_diis = value

    @Ndiis.setter
    def Ndiis(self, value):
        self.N_history_vec = value

    @N_diis.setter
    def N_diis(self, value):
        self.N_history_vec = value

    @N_broyden.setter
    def N_broyden(self, value):
        self.N_history_vec = value

    @Line_search.setter
    def Line_search(self, value):
        self.Linesearch = value

    @Epstaylor.setter
    def Epstaylor(self, value):
        self.Eps_taylor = value



class _hf_info7(printable):
    """
    Controls the printing basic info about hf method
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each365()
        self._name = "HF_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _centroid_gyr1(printable):
    """
    Controls the output of the centroid's radii of gyration
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.EACH = _each64()
        self._name = "CENTROID_GYR"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _point58(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point59(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _pbe_hole_t_c_lr3(printable):
    """
    PBE exchange hole model in trucanted coulomb potential
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Cutoff_radius = None
        """
        Defines cutoff for lower integration boundary
        """
        self._name = "PBE_HOLE_T_C_LR"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Cutoff_radius', 'CUTOFF_RADIUS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _kinetic_energy1(printable):
    """
    Controls the printing of the kinetic energy
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each180()
        self._name = "KINETIC_ENERGY"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _point55(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point56(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point57(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point50(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point51(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point52(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point53(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _each308(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _force_mixing1(printable):
    """
    This section enables and defines parameters for force-mixing based
    QM/MM, which actually does two conventional QM/MM calculations, on a
    small  and a large QM region, and combines the MM forces from one and
    QM  forces from the other to create a complete set of forces.  Energy
    is  not conserved (although the QM/MM energy from the large QM region
    calculation is reported)  so a proper thermostat (i.e. massive, and
    able to handle dissipation, such as  Adaptive Langevin (AD_LANGEVIN))
    must be used. For some propagation algorithms  (NVT and REFTRAJ MD
    ensembles) algorithm is adaptive,  including molecules hysteretically
    based on their instantaneous distance from the core region.
    Information on core/QM/buffer labels can be written in PDB file using
    MOTION&PRINT&FORCE_MIXING_LABELS.  Will fail if calculation requires a
    meaningfull stress, or an energy that is consistent with the forces.
    For GEO_OPT this means  only MOTION&GEO_OPT&TYPE CG,
    MOTION&GEO_OPT&CG&LINE_SEARCH&TYPE 2PNT, and
    MOTION&GEO_OPT&CG&LINE_SEARCH&2PNT&LINMIN_GRAD_ONLY T
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Enables force-mixing
        """
        self.Momentum_conservation_type = None
        """
        How to apply force to get momentum conservation

        Available values:
            NONE
                No momentum conservation
            EQUAL_F
                Equal force on each atom
            EQUAL_A
                Equal acceleration on each atom
        """
        self.Momentum_conservation_region = None
        """
        Region to apply correction force to for momentum conservation

        Available values:
            CORE
                Apply to QM core region
            QM
                Apply to full QM (dynamics) region
            BUFFER
                Apply to QM+buffer regions
        """
        self.R_core = None
        """
        Specify the inner and outer radii of core QM region.  All molecules
        with any atoms within this distance (hysteretically) of any atoms
        specified as QM in enclosing QM/MM section  will be core QM atoms in
        the force-mixing calculation.
        """
        self.R_qm = None
        """
        Specify the inner and outer radii of QM dynamics region.  All
        molecules with atoms within this distance (hysteretically) of any
        atoms in  core will follow QM dynamics in the force-mixing
        calculation.
        """
        self.Qm_extended_seed_is_only_core_list = None
        """
        Makes the extended QM zone be defined hysterestically  by distance
        from QM core list (i.e. atoms specified explicitly by  user) instead
        of from full QM core region (specified by user + hysteretic  selection
        + unbreakable bonds)
        """
        self.R_buf = None
        """
        Specify the inner and outer radii of buffer region.  All atoms within
        this distance (hysteretically) of any QM atoms  will be buffer atoms
        in the force-mixing calculation.
        """
        self.list_Qm_kind_element_mapping = []
        self.Max_n_qm = None
        """
        Maximum number of QM atoms, for detection of runaway adaptive
        selection.
        """
        self.Adaptive_exclude_molecules = None
        """
        List of molecule names to exclude from adaptive regions (e.g. big
        things like proteins)
        """
        self.Extended_delta_charge = None
        """
        Additional net charge in extended region relative to core (core charge
        is  specified in DFT section, as usual for a convetional QM/MM
        calculation)
        """
        self.list_QM_NON_ADAPTIVE = []
        self.list_BUFFER_NON_ADAPTIVE = []
        self.list_BUFFER_LINKS = []
        self.RESTART_INFO = _restart_info1()
        self.PRINT = _print37()
        self._name = "FORCE_MIXING"
        self._keywords = [('Momentum_conservation_type', 'MOMENTUM_CONSERVATION_TYPE'), ('Momentum_conservation_region', 'MOMENTUM_CONSERVATION_REGION'), ('R_core', 'R_CORE'), ('R_qm', 'R_QM'), ('Qm_extended_seed_is_only_core_list', 'QM_EXTENDED_SEED_IS_ONLY_CORE_LIST'), ('R_buf', 'R_BUF'), ('Max_n_qm', 'MAX_N_QM'), ('Adaptive_exclude_molecules', 'ADAPTIVE_EXCLUDE_MOLECULES'), ('Extended_delta_charge', 'EXTENDED_DELTA_CHARGE')]
        self._repeated_keywords = [('Qm_kind_element_mapping', 'QM_KIND_ELEMENT_MAPPING')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('RESTART_INFO', 'RESTART_INFO'), ('PRINT', 'PRINT')]
        self._repeated_subsections = [('QM_NON_ADAPTIVE', '_qm_non_adaptive1'), ('BUFFER_NON_ADAPTIVE', '_buffer_non_adaptive1'), ('BUFFER_LINKS', '_buffer_links1')]

    def add_QM_NON_ADAPTIVE(self):
        new_section = _qm_non_adaptive1()
        self.list_QM_NON_ADAPTIVE.append(new_section)
        return new_section

    def add_BUFFER_NON_ADAPTIVE(self):
        new_section = _buffer_non_adaptive1()
        self.list_BUFFER_NON_ADAPTIVE.append(new_section)
        return new_section

    def add_BUFFER_LINKS(self):
        new_section = _buffer_links1()
        self.list_BUFFER_LINKS.append(new_section)
        return new_section

    def add_Qm_kind_element_mapping(self, value):
        self.list_Qm_kind_element_mapping.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _barostat1(printable):
    """
    Parameters of barostat.
    """
    def __init__(self):
        self.Pressure = None
        """
        Initial pressure
        """
        self.Timecon = None
        """
        Barostat time constant
        """
        self.Temperature = None
        """
        Barostat initial temperature. If not set, the ensemble temperature is
        used instead.
        """
        self.Temp_tol = None
        """
        Maximum oscillation of the Barostat temperature imposed by recaling.
        """
        self.Virial = None
        """
        For NPT_F only: allows the screening of one or more components of the
        virial in order to relax the cell only along specific cartesian axis

        Available values:
            XYZ
            X
            Y
            Z
            XY
            XZ
            YZ
        """
        self.VELOCITY = _velocity1()
        self.MASS = _mass1()
        self.THERMOSTAT = _thermostat1()
        self.PRINT = _print7()
        self._name = "BAROSTAT"
        self._keywords = [('Pressure', 'PRESSURE'), ('Timecon', 'TIMECON'), ('Temperature', 'TEMPERATURE'), ('Temp_tol', 'TEMP_TOL'), ('Virial', 'VIRIAL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('VELOCITY', 'VELOCITY'), ('MASS', 'MASS'), ('THERMOSTAT', 'THERMOSTAT'), ('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _pz812(printable):
    """
    Uses the PZ functional.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Parametrization = None
        """
        Which one of parametrizations should be used

        Available values:
            ORIGINAL
            DMC
            VMC
        """
        self.Scale_c = None
        """
        scales the correlation part of the functional
        """
        self._name = "PZ81"
        self._keywords = [('Parametrization', 'PARAMETRIZATION'), ('Scale_c', 'SCALE_C')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _generate1(printable):
    """
    Setup of keywords controlling the generation of the connectivity
    """
    def __init__(self):
        self.Reorder = None
        """
        Reorder a list of atomic coordinates into order so it can be packed
        correctly.
        """
        self.Create_molecules = None
        """
        Create molecules names and definition. Can be used to override the
        molecules specifications of a possible input connectivity or to create
        molecules specifications for file types as XYZ, missing of molecules
        definitions.
        """
        self.Bondparm = None
        """
        Used in conjunction with BONDPARM_FACTOR to help determine wheather
        there is bonding between two atoms based on a distance criteria. Can
        use covalent radii information or VDW radii information

        Available values:
            COVALENT
            VDW
        """
        self.Bondparm_factor = None
        """
        Used in conjunction with BONDPARM to help determine wheather there is
        bonding between two atoms based on a distance criteria.
        """
        self.Bondlength_max = None
        """
        Maximum distance to generate neighbor lists to build connectivity
        """
        self.Bondlength_min = None
        """
        Minimum distance to generate neighbor lists to build connectivity
        """
        self.list_BOND = []
        self.list_ANGLE = []
        self.list_TORSION = []
        self.list_IMPROPER = []
        self.ISOLATED_ATOMS = _isolated_atoms1()
        self.NEIGHBOR_LISTS = _neighbor_lists8()
        self.PRINT = _print42()
        self._name = "GENERATE"
        self._keywords = [('Reorder', 'REORDER'), ('Create_molecules', 'CREATE_MOLECULES'), ('Bondparm', 'BONDPARM'), ('Bondparm_factor', 'BONDPARM_FACTOR'), ('Bondlength_max', 'BONDLENGTH_MAX'), ('Bondlength_min', 'BONDLENGTH_MIN')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('ISOLATED_ATOMS', 'ISOLATED_ATOMS'), ('NEIGHBOR_LISTS', 'NEIGHBOR_LISTS'), ('PRINT', 'PRINT')]
        self._repeated_subsections = [('BOND', '_bond2'), ('ANGLE', '_angle1'), ('TORSION', '_torsion2'), ('IMPROPER', '_improper2')]

    def add_BOND(self):
        new_section = _bond2()
        self.list_BOND.append(new_section)
        return new_section

    def add_ANGLE(self):
        new_section = _angle1()
        self.list_ANGLE.append(new_section)
        return new_section

    def add_TORSION(self):
        new_section = _torsion2()
        self.list_TORSION.append(new_section)
        return new_section

    def add_IMPROPER(self):
        new_section = _improper2()
        self.list_IMPROPER.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _pz811(printable):
    """
    Uses the PZ functional.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Parametrization = None
        """
        Which one of parametrizations should be used

        Available values:
            ORIGINAL
            DMC
            VMC
        """
        self.Scale_c = None
        """
        scales the correlation part of the functional
        """
        self._name = "PZ81"
        self._keywords = [('Parametrization', 'PARAMETRIZATION'), ('Scale_c', 'SCALE_C')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _pz814(printable):
    """
    Uses the PZ functional.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Parametrization = None
        """
        Which one of parametrizations should be used

        Available values:
            ORIGINAL
            DMC
            VMC
        """
        self.Scale_c = None
        """
        scales the correlation part of the functional
        """
        self._name = "PZ81"
        self._keywords = [('Parametrization', 'PARAMETRIZATION'), ('Scale_c', 'SCALE_C')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _cp_dbcsr1(printable):
    """
    Benchmark and test the cp_dbcsr routines
    """
    def __init__(self):
        self.N_loop = None
        """
        Number of operations being timed (useful for small matrices).
        """
        self.Data_type = None
        """
        Data type of the matrices

        Available values:
            REAL_4
                Real (Single Precision)
            REAL_8
                Real (Double Precision)
            COMPLEX_4
                Complex (Single Precision)
            COMPLEX_8
                Complex (Double Precision)
        """
        self.M = None
        """
        Dimension 1 of C
        """
        self.N = None
        """
        Dimension 2 of C
        """
        self.K = None
        """
        Inner dimension M
        """
        self.Transa = None
        """
        Transpose matrix A
        """
        self.Transb = None
        """
        Transpose matrix B
        """
        self.Bs_m = None
        """
        Row block sizes of C
        """
        self.Bs_n = None
        """
        Column block sizes of C
        """
        self.Bs_k = None
        """
        Block sizes of inner dimension
        """
        self.Atype = None
        """
        Matrix A type
        """
        self.Btype = None
        """
        Matrix B type
        """
        self.Ctype = None
        """
        Matrix C type
        """
        self.Nproc = None
        """
        Number of processors to test
        """
        self.Keepsparse = None
        """
        Keep product sparse
        """
        self.Asparsity = None
        """
        Sparsity of A matrix
        """
        self.Bsparsity = None
        """
        Sparsity of B matrix
        """
        self.Csparsity = None
        """
        Sparsity of C matrix
        """
        self.Alpha = None
        """
        Multiplication factor
        """
        self.Beta = None
        """
        Product premultiplication factor
        """
        self.Filter_eps = None
        """
        Threshold for on-the-fly and final filtering.
        """
        self.Deterministic = None
        """
        Attempt deterministic behavior (turn off for speed).
        """
        self._name = "CP_DBCSR"
        self._keywords = [('N_loop', 'N_LOOP'), ('Data_type', 'DATA_TYPE'), ('M', 'M'), ('N', 'N'), ('K', 'K'), ('Transa', 'TRANSA'), ('Transb', 'TRANSB'), ('Bs_m', 'BS_M'), ('Bs_n', 'BS_N'), ('Bs_k', 'BS_K'), ('Atype', 'ATYPE'), ('Btype', 'BTYPE'), ('Ctype', 'CTYPE'), ('Nproc', 'NPROC'), ('Keepsparse', 'KEEPSPARSE'), ('Asparsity', 'ASPARSITY'), ('Bsparsity', 'BSPARSITY'), ('Csparsity', 'CSPARSITY'), ('Alpha', 'ALPHA'), ('Beta', 'BETA'), ('Filter_eps', 'FILTER_EPS'), ('Deterministic', 'DETERMINISTIC')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _timings1(printable):
    """
    Controls the printing of the timing report at the end of CP2K
    execution
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Threshold = None
        """
        Specify % of CPUTIME above which the contribution will be inserted in
        the final timing report
        """
        self.Sort_by_self_time = None
        """
        Sort the final timing report by the average self (exclusive) time
        instead of the total (inclusive) time of a routine
        """
        self.EACH = _each1()
        self._name = "TIMINGS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Threshold', 'THRESHOLD'), ('Sort_by_self_time', 'SORT_BY_SELF_TIME')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _krylov1(printable):
    """"""
    def __init__(self):
        self.Nkrylov = None
        """
        Dimension of the Krylov space used for the Lanczos refinement
        """
        self.Nblock = None
        """
        Size of the block of vectors refined simultaneously by the Lanczos
        procedure
        """
        self.Eps_krylov = None
        """
        Convergence criterion for the MOs
        """
        self.Eps_std_diag = None
        """
        Level of convergence to be reached before starting the Lanczos
        procedure. Above this threshold a standard diagonalization method is
        used.  If negative Lanczos is started at the first iteration
        """
        self.Check_mos_conv = None
        """
        This requires to check the convergence of MOS also when standard
        diagonalization steps are performed, if the block krylov approach is
        active.
        """
        self._name = "KRYLOV"
        self._keywords = [('Nkrylov', 'NKRYLOV'), ('Nblock', 'NBLOCK'), ('Eps_krylov', 'EPS_KRYLOV'), ('Eps_std_diag', 'EPS_STD_DIAG'), ('Check_mos_conv', 'CHECK_MOS_CONV')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _quadrupoles1(printable):
    """
    Specifies the quadrupoles of the particles.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        The quadrupole components for each atom.
        """
        self._name = "QUADRUPOLES"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _topology1(printable):
    """
    Section specifying information regarding how to handle the topology
    for classical runs.
    """
    def __init__(self):
        self.Charge_occup = None
        """
        Read MM charges from the OCCUP field of PDB file.
        """
        self.Charge_beta = None
        """
        Read MM charges from the BETA field of PDB file.
        """
        self.Charge_extended = None
        """
        Read MM charges from the very last field of PDB file (starting from
        column 81). No limitations of number of digits.
        """
        self.Para_res = None
        """
        For a protein, each residue is now considered a molecule
        """
        self.Mol_check = None
        """
        Check molecules have the same number of atom and names.
        """
        self.Use_g96_velocity = None
        """
        Use the velocities in the G96 coordinate files as the starting
        velocity
        """
        self.Coord_file_name = None
        """
        Specifies the filename that contains coordinates.
        """
        self.Coord_file_format = None
        """
        Set up the way in which coordinates will be read.

        Available values:
            OFF
                Coordinates read in the &COORD section of the input file
            PDB
                Coordinates provided through a PDB file format
            XYZ
                Coordinates provided through an XYZ file format
            G96
                Coordinates provided through a GROMOS96 file format
            CRD
                Coordinates provided through an AMBER file format
            CIF
                Coordinates provided through a CIF (Crystallographic Information File)
                file format
            XTL
                Coordinates provided through a XTL (MSI native) file format
            CP2K
                Read the coordinates in CP2K &COORD section format from an external
                file. NOTE: This file will be overwritten with the latest coordinates.
        """
        self.Number_of_atoms = None
        """
        Optionally define the number of atoms read from an external file (see
        COORD_FILE_NAME) if the COORD_FILE_FORMAT CP2K is used
        """
        self.Conn_file_name = None
        """
        Specifies the filename that contains the molecular connectivity.
        """
        self.Conn_file_format = None
        """
        Ways to determine and generate a molecules. Default is to use GENERATE

        Available values:
            PSF
                Use  a PSF file to determine the connectivity. (support standard
                CHARMM/XPLOR and EXT CHARMM)
            UPSF
                Read a PSF file in an unformatted way (useful for not so standard
                PSF).
            MOL_SET
                Use multiple PSF (for now...) files to generate the whole sytem.
            GENERATE
                Use a simple distance criteria. (Look at keyword BONDPARM)
            OFF
                Do not generate molecules. (e.g. for QS or ill defined systems)
            G87
                Use GROMOS G87 topology file.
            G96
                Use GROMOS G96 topology file.
            AMBER
                Use AMBER topology file for reading connectivity (compatible starting
                from AMBER V.7)
            USER
                Allows the definition of molecules and residues based on the 5th and
                6th column of the COORD section. This option can be handy for the
                definition of molecules with QS or to save memory in the case of very
                large systems (use PARA_RES off).
        """
        self.Disable_exclusion_lists = None
        """
        Do not build any exclusion lists.
        """
        self.Exclude_vdw = None
        """
        Specifies which kind of Van der Waals interaction to skip.

        Available values:
            1-1
            1-2
            1-3
            1-4
        """
        self.Exclude_ei = None
        """
        Specifies which kind of Electrostatic interaction to skip.

        Available values:
            1-1
            1-2
            1-3
            1-4
        """
        self.Autogen_exclude_lists = None
        """
        When True, the exclude lists are solely based on the bond data in the
        topology. The (minimal) number of bonds between two atoms is used to
        determine if the atom pair is added to an exclusion list. When False,
        1-2 exclusion is based on bonds in the topology, 1-3 exclusion is
        based on bonds and bends in the topology, 1-4 exclusion is based on
        bonds, bends and dihedrals in the topology. This implies that a
        missing dihedral in the topology will cause the corresponding 1-4 pair
        not to be in the exclusion list, in case 1-4 exclusion is requested
        for VDW or EI interactions.
        """
        self.Multiple_unit_cell = None
        """
        Specifies the numbers of repetition in space (X, Y, Z) of the defined
        cell, assuming it as a unit cell. This keyword affects only the
        coordinates specification. The same keyword in
        SUBSYS%CELL%MULTIPLE_UNIT_CELL should be modified in order to affect
        the cell specification.
        """
        self.Memory_progression_factor = None
        """
        This keyword is quite technical and should normally not be changed by
        the user. It affects the memory allocation during the construction of
        the topology. It does NOT affect the memory used once the topology is
        built.
        """
        self.DUMP_PDB = _dump_pdb1()
        self.DUMP_PSF = _dump_psf1()
        self.EXCLUDE_VDW_LIST = _exclude_vdw_list1()
        self.EXCLUDE_EI_LIST = _exclude_ei_list1()
        self.CENTER_COORDINATES = _center_coordinates1()
        self.list_GENERATE = []
        self.MOL_SET = _mol_set1()
        self._name = "TOPOLOGY"
        self._keywords = [('Charge_occup', 'CHARGE_OCCUP'), ('Charge_beta', 'CHARGE_BETA'), ('Charge_extended', 'CHARGE_EXTENDED'), ('Para_res', 'PARA_RES'), ('Mol_check', 'MOL_CHECK'), ('Use_g96_velocity', 'USE_G96_VELOCITY'), ('Coord_file_name', 'COORD_FILE_NAME'), ('Coord_file_format', 'COORD_FILE_FORMAT'), ('Number_of_atoms', 'NUMBER_OF_ATOMS'), ('Conn_file_name', 'CONN_FILE_NAME'), ('Conn_file_format', 'CONN_FILE_FORMAT'), ('Disable_exclusion_lists', 'DISABLE_EXCLUSION_LISTS'), ('Exclude_vdw', 'EXCLUDE_VDW'), ('Exclude_ei', 'EXCLUDE_EI'), ('Autogen_exclude_lists', 'AUTOGEN_EXCLUDE_LISTS'), ('Multiple_unit_cell', 'MULTIPLE_UNIT_CELL'), ('Memory_progression_factor', 'MEMORY_PROGRESSION_FACTOR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('DUMP_PDB', 'DUMP_PDB'), ('DUMP_PSF', 'DUMP_PSF'), ('EXCLUDE_VDW_LIST', 'EXCLUDE_VDW_LIST'), ('EXCLUDE_EI_LIST', 'EXCLUDE_EI_LIST'), ('CENTER_COORDINATES', 'CENTER_COORDINATES'), ('MOL_SET', 'MOL_SET')]
        self._repeated_subsections = [('GENERATE', '_generate1')]

    def add_GENERATE(self):
        new_section = _generate1()
        self.list_GENERATE.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Charge_o(self):
        """
        See documentation for Charge_occup
        """
        return self.Charge_occup

    @property
    def Charge_b(self):
        """
        See documentation for Charge_beta
        """
        return self.Charge_beta

    @property
    def Coord_file(self):
        """
        See documentation for Coord_file_name
        """
        return self.Coord_file_name

    @property
    def Coordinate(self):
        """
        See documentation for Coord_file_format
        """
        return self.Coord_file_format

    @property
    def Natoms(self):
        """
        See documentation for Number_of_atoms
        """
        return self.Number_of_atoms

    @property
    def Natom(self):
        """
        See documentation for Number_of_atoms
        """
        return self.Number_of_atoms

    @property
    def Conn_file(self):
        """
        See documentation for Conn_file_name
        """
        return self.Conn_file_name

    @property
    def Connectivity(self):
        """
        See documentation for Conn_file_format
        """
        return self.Conn_file_format

    @Charge_o.setter
    def Charge_o(self, value):
        self.Charge_occup = value

    @Charge_b.setter
    def Charge_b(self, value):
        self.Charge_beta = value

    @Coord_file.setter
    def Coord_file(self, value):
        self.Coord_file_name = value

    @Coordinate.setter
    def Coordinate(self, value):
        self.Coord_file_format = value

    @Natoms.setter
    def Natoms(self, value):
        self.Number_of_atoms = value

    @Natom.setter
    def Natom(self, value):
        self.Number_of_atoms = value

    @Conn_file.setter
    def Conn_file(self, value):
        self.Conn_file_name = value

    @Connectivity.setter
    def Connectivity(self, value):
        self.Conn_file_format = value



class _spawned_hills_invdt1(printable):
    """
    The inverse of the DELTA_T parameter used for Well-Tempered
    metadynamics.Used for RESTART.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify the spawned hills
        """
        self._name = "SPAWNED_HILLS_INVDT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _restart11(printable):
    """
    controls the printing of the restart for FARMING.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each344()
        self._name = "RESTART"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _restart10(printable):
    """
    Controls the dumping of restart file of the response wavefunction.For
    each set of response functions, i.e. for each perturbation,one
    different restart file is dumped. These restart files should
    beemployed only to restart the same type of LINRES calculation, i.e.
    with the same perturbation.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each323()
        self._name = "RESTART"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _restart12(printable):
    """
    writes an input file that can be used to restart
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Backup_copies = None
        """
        Specifies the maximum index of backup copies.
        """
        self.EACH = _each348()
        self._name = "RESTART"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Backup_copies', 'BACKUP_COPIES')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _ddapc_restraint1(printable):
    """
    Use DDAPC charges in a restraint (check code for details)
    """
    def __init__(self):
        self.Type_of_density = None
        """
        Specifies the type of density used for the fitting

        Available values:
            FULL
                Full density
            SPIN
                Spin density
        """
        self.Strength = None
        """
        force constant of the restraint
        """
        self.Target = None
        """
        target value of the restraint
        """
        self.Atoms = None
        """
        Specifies the list of atoms that is summed in the restraint
        """
        self.Coeff = None
        """
        Defines the the coefficient of the atom in the atom list (default is
        one)
        """
        self.Functional_form = None
        """
        Specifies the functional form of the term added

        Available values:
            RESTRAINT
                Harmonic potential: s*(q-t)**2
            CONSTRAINT
                Constraint form: s*(q-t)
        """
        self.PROGRAM_RUN_INFO = _program_run_info15()
        self._name = "DDAPC_RESTRAINT"
        self._keywords = [('Type_of_density', 'TYPE_OF_DENSITY'), ('Strength', 'STRENGTH'), ('Target', 'TARGET'), ('Atoms', 'ATOMS'), ('Coeff', 'COEFF'), ('Functional_form', 'FUNCTIONAL_FORM')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _pair_potential4(printable):
    """
    Information on the pair potential to calculate dispersion
    """
    def __init__(self):
        self.R_cutoff = None
        """
        Range of potential. The cutoff will be 2 times this value
        """
        self.Type = None
        """
        Type of potential. DFTD2 and DFTD3 are the Grimme D2 and D3 methods
        respectively.

        Available values:
            DFTD2
            DFTD3
        """
        self.Parameter_file_name = None
        """
        Name of the parameter file, may include a path
        """
        self.Reference_functional = None
        """
        Use parameters for this specific density functional
        """
        self.Scaling = None
        """
        XC Functional dependent scaling parameter, if set to zero CP2K
        attempts to guess the xc functional that is in use and sets the
        associated scaling parameter.
        """
        self.Exp_pre = None
        """
        Prefactor in exponential damping factor (DFT-D2 potential)
        """
        self.Eps_cn = None
        """
        Cutoff value for coordination number function (DFT-D3 method)
        """
        self.D3_scaling = None
        """
        XC Functional dependent scaling parameters (s6,sr6,s8) for the DFT-D3
        method,  if set to zero CP2K attempts to guess the xc functional from
        REFERENCE_FUNCTIONAL and sets the associated scaling parameter.
        """
        self.Calculate_c9_term = None
        """
        Calculate C9 terms in DFT-D3 model
        """
        self.Reference_c9_term = None
        """
        Calculate C9 terms in DFT-D3 model using reference coordination
        numbers
        """
        self.Long_range_correction = None
        """
        Calculate a long range correction to the DFT-D3 model
        """
        self.Verbose_output = None
        """
        Extensive output for the DFT-D2 and DFT-D3 models
        """
        self.list_Kind_coordination_numbers = []
        self.list_Atom_coordination_numbers = []
        self.list_Atomparm = []
        self.PRINT_DFTD = _print_dftd4()
        self._name = "PAIR_POTENTIAL"
        self._keywords = [('R_cutoff', 'R_CUTOFF'), ('Type', 'TYPE'), ('Parameter_file_name', 'PARAMETER_FILE_NAME'), ('Reference_functional', 'REFERENCE_FUNCTIONAL'), ('Scaling', 'SCALING'), ('Exp_pre', 'EXP_PRE'), ('Eps_cn', 'EPS_CN'), ('D3_scaling', 'D3_SCALING'), ('Calculate_c9_term', 'CALCULATE_C9_TERM'), ('Reference_c9_term', 'REFERENCE_C9_TERM'), ('Long_range_correction', 'LONG_RANGE_CORRECTION'), ('Verbose_output', 'VERBOSE_OUTPUT')]
        self._repeated_keywords = [('Kind_coordination_numbers', 'KIND_COORDINATION_NUMBERS'), ('Atom_coordination_numbers', 'ATOM_COORDINATION_NUMBERS'), ('Atomparm', 'ATOMPARM')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT_DFTD', 'PRINT_DFTD')]
        self._repeated_subsections = []

    def add_Kind_coordination_numbers(self, value):
        self.list_Kind_coordination_numbers.append(value)

    def add_Atom_coordination_numbers(self, value):
        self.list_Atom_coordination_numbers.append(value)

    def add_Atomparm(self, value):
        self.list_Atomparm.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _xalpha1(printable):
    """
    Uses the XALPHA (SLATER) functional.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Xa = None
        """
        Value of the xa parameter (this does not change the exponent, just the
        mixing)
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self._name = "XALPHA"
        self._keywords = [('Xa', 'XA'), ('Scale_x', 'SCALE_X')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _optical_conductivity1(printable):
    """
    Controls the printing of the optical conductivity.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each191()
        self._name = "OPTICAL_CONDUCTIVITY"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _xalpha2(printable):
    """
    Uses the XALPHA (SLATER) functional.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Xa = None
        """
        Value of the xa parameter (this does not change the exponent, just the
        mixing)
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self._name = "XALPHA"
        self._keywords = [('Xa', 'XA'), ('Scale_x', 'SCALE_X')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _xalpha4(printable):
    """
    Uses the XALPHA (SLATER) functional.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Xa = None
        """
        Value of the xa parameter (this does not change the exponent, just the
        mixing)
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self._name = "XALPHA"
        self._keywords = [('Xa', 'XA'), ('Scale_x', 'SCALE_X')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _band1(printable):
    """
    The section that controls a BAND run
    """
    def __init__(self):
        self.Nproc_rep = None
        """
        Specify the number of processors to be used per replica environment
        (for parallel runs)
        """
        self.Proc_dist_type = None
        """
        Specify the topology of the mapping of processors into replicas.

        Available values:
            INTERLEAVED
                Interleaved distribution
            BLOCKED
                Blocked distribution
        """
        self.Band_type = None
        """
        Specifies the type of BAND calculation

        Available values:
            B-NEB
                Bisection NEB
            IT-NEB
                Improved tangent NEB
            CI-NEB
                Climbing Image NEB
            D-NEB
                Doubly NEB
            SM
                String Method
            EB
                Elastic Band (Hamiltonian formulation)
        """
        self.Number_of_replica = None
        """
        Specify the number of Replica to use in the BAND
        """
        self.Use_colvars = None
        """
        Uses a version of the band scheme projected in a subspace of colvars.
        """
        self.Pot_type = None
        """
        Specifies the type of potential used in the BAND calculation

        Available values:
            FULL
                Full potential (no projections in a subspace of colvars)
            FE
                Free energy (requires a projections in a subspace of colvars)
            ME
                Minimum energy (requires a projections in a subspace of colvars)
        """
        self.Rotate_frames = None
        """
        Compute at each BAND step the RMSD and rotate the frames in order to
        minimize it.
        """
        self.Align_frames = None
        """
        Enables the alignment of the frames at the beginning of a BAND
        calculation. This keyword does not affect the rotation of the replicas
        during a BAND calculation.
        """
        self.K_spring = None
        """
        Specify the value of the spring constant
        """
        self.CONVERGENCE_CONTROL = _convergence_control2()
        self.CI_NEB = _ci_neb1()
        self.STRING_METHOD = _string_method1()
        self.list_OPTIMIZE_BAND = []
        self.list_REPLICA = []
        self.PROGRAM_RUN_INFO = _program_run_info10()
        self.CONVERGENCE_INFO = _convergence_info1()
        self.REPLICA_INFO = _replica_info1()
        self.ENERGY = _energy8()
        self.BANNER = _banner1()
        self._name = "BAND"
        self._keywords = [('Nproc_rep', 'NPROC_REP'), ('Proc_dist_type', 'PROC_DIST_TYPE'), ('Band_type', 'BAND_TYPE'), ('Number_of_replica', 'NUMBER_OF_REPLICA'), ('Use_colvars', 'USE_COLVARS'), ('Pot_type', 'POT_TYPE'), ('Rotate_frames', 'ROTATE_FRAMES'), ('Align_frames', 'ALIGN_FRAMES'), ('K_spring', 'K_SPRING')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('CONVERGENCE_CONTROL', 'CONVERGENCE_CONTROL'), ('CI_NEB', 'CI_NEB'), ('STRING_METHOD', 'STRING_METHOD'), ('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('CONVERGENCE_INFO', 'CONVERGENCE_INFO'), ('REPLICA_INFO', 'REPLICA_INFO'), ('ENERGY', 'ENERGY'), ('BANNER', 'BANNER')]
        self._repeated_subsections = [('OPTIMIZE_BAND', '_optimize_band1'), ('REPLICA', '_replica1')]

    def add_OPTIMIZE_BAND(self):
        new_section = _optimize_band1()
        self.list_OPTIMIZE_BAND.append(new_section)
        return new_section

    def add_REPLICA(self):
        new_section = _replica1()
        self.list_REPLICA.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def K(self):
        """
        See documentation for K_spring
        """
        return self.K_spring

    @K.setter
    def K(self, value):
        self.K_spring = value



class _reftraj1(printable):
    """
    Loads an external trajectory file and performs analysis on the loaded
    snapshots.
    """
    def __init__(self):
        self.Traj_file_name = None
        """
        Specify the filename where the trajectory is stored.
        """
        self.Cell_file_name = None
        """
        Specify the filename where the cell is stored (for trajectories
        generated within variable cell ensembles).
        """
        self.Variable_volume = None
        """
        Enables the possibility to read a CELL file with information on the
        CELL size during the MD.
        """
        self.First_snapshot = None
        """
        Index of the snapshot stored in the trajectory file from which to
        start a REFTRAJ run
        """
        self.Last_snapshot = None
        """
        Index of the last snapshot stored in the trajectory file that is read
        along a REFTRAJ run
        """
        self.Stride = None
        """
         Stride in number of snapshot for the  reftraj analysis
        """
        self.Eval_energy_forces = None
        """
        Evaluate energy and forces for each retrieved snapshot during a
        REFTRAJ run
        """
        self.MSD = _msd1()
        self.PRINT = _print10()
        self._name = "REFTRAJ"
        self._keywords = [('Traj_file_name', 'TRAJ_FILE_NAME'), ('Cell_file_name', 'CELL_FILE_NAME'), ('Variable_volume', 'VARIABLE_VOLUME'), ('First_snapshot', 'FIRST_SNAPSHOT'), ('Last_snapshot', 'LAST_SNAPSHOT'), ('Stride', 'STRIDE'), ('Eval_energy_forces', 'EVAL_ENERGY_FORCES')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('MSD', 'MSD'), ('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _atomic_coordinates1(printable):
    """
    controls the output of the atomic coordinates when setting up theforce
    environment. For printing coordinates during MD or GEO refer to the
    keyword trajectory.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.EACH = _each277()
        self._name = "ATOMIC_COORDINATES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _interaction_potential11(printable):
    """
    Sets up interaction potential if requested
    """
    def __init__(self):
        self.Potential_type = None
        """
        Which interaction potential should be used (Coulomb, longrange or
        shortrange).

        Available values:
            COULOMB
                Coulomb potential: 1/r
            SHORTRANGE
                Shortrange potential: erfc(omega*r)/r
            LONGRANGE
                Longrange potential: erf(omega*r)/r
            MIX_CL
                Mix coulomb and longrange potential: 1/r + erf(omega*r)/r
            GAUSSIAN
                Damped Gaussian potential: exp(-omega^2*r^2)
            MIX_LG
                Mix Gaussian and longrange potential: erf(omega*r)/r +
                exp(-omega^2*r^2)
            IDENTITY
                Overlap
            TRUNCATED
                Truncated coulomb potential: if(r<R_c) 1/r else 0
            MIX_CL_TRUNC
                Truncated Mix coulomb and longrange potential, assumes/requires that
                the erf has fully decayed at R_c
        """
        self.Omega = None
        """
        Parameter for short/longrange interaction
        """
        self.Scale_coulomb = None
        """
        Scales Hartree-Fock contribution arising from a coulomb potential.
        Only valid when doing a mixed potential calculation
        """
        self.Scale_longrange = None
        """
        Scales Hartree-Fock contribution arising from a longrange potential.
        Only valid when doing a mixed potential calculation
        """
        self.Scale_gaussian = None
        """
        Scales Hartree-Fock contribution arising from a gaussian potential.
        Only valid when doing a mixed potential calculation
        """
        self.Cutoff_radius = None
        """
        Determines cutoff radius for the truncated 1/r potential. Only valid
        when doing truncated calculation
        """
        self.T_c_g_data = None
        """
        Location of the file t_c_g.dat that contains the data for the
        evaluation of the truncated gamma function
        """
        self._name = "INTERACTION_POTENTIAL"
        self._keywords = [('Potential_type', 'POTENTIAL_TYPE'), ('Omega', 'OMEGA'), ('Scale_coulomb', 'SCALE_COULOMB'), ('Scale_longrange', 'SCALE_LONGRANGE'), ('Scale_gaussian', 'SCALE_GAUSSIAN'), ('Cutoff_radius', 'CUTOFF_RADIUS'), ('T_c_g_data', 'T_C_G_DATA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _interaction_potential10(printable):
    """
    Sets up interaction potential if requested
    """
    def __init__(self):
        self.Potential_type = None
        """
        Which interaction potential should be used (Coulomb, longrange or
        shortrange).

        Available values:
            COULOMB
                Coulomb potential: 1/r
            SHORTRANGE
                Shortrange potential: erfc(omega*r)/r
            LONGRANGE
                Longrange potential: erf(omega*r)/r
            MIX_CL
                Mix coulomb and longrange potential: 1/r + erf(omega*r)/r
            GAUSSIAN
                Damped Gaussian potential: exp(-omega^2*r^2)
            MIX_LG
                Mix Gaussian and longrange potential: erf(omega*r)/r +
                exp(-omega^2*r^2)
            IDENTITY
                Overlap
            TRUNCATED
                Truncated coulomb potential: if(r<R_c) 1/r else 0
            MIX_CL_TRUNC
                Truncated Mix coulomb and longrange potential, assumes/requires that
                the erf has fully decayed at R_c
        """
        self.Omega = None
        """
        Parameter for short/longrange interaction
        """
        self.Scale_coulomb = None
        """
        Scales Hartree-Fock contribution arising from a coulomb potential.
        Only valid when doing a mixed potential calculation
        """
        self.Scale_longrange = None
        """
        Scales Hartree-Fock contribution arising from a longrange potential.
        Only valid when doing a mixed potential calculation
        """
        self.Scale_gaussian = None
        """
        Scales Hartree-Fock contribution arising from a gaussian potential.
        Only valid when doing a mixed potential calculation
        """
        self.Cutoff_radius = None
        """
        Determines cutoff radius for the truncated 1/r potential. Only valid
        when doing truncated calculation
        """
        self.T_c_g_data = None
        """
        Location of the file t_c_g.dat that contains the data for the
        evaluation of the truncated gamma function
        """
        self._name = "INTERACTION_POTENTIAL"
        self._keywords = [('Potential_type', 'POTENTIAL_TYPE'), ('Omega', 'OMEGA'), ('Scale_coulomb', 'SCALE_COULOMB'), ('Scale_longrange', 'SCALE_LONGRANGE'), ('Scale_gaussian', 'SCALE_GAUSSIAN'), ('Cutoff_radius', 'CUTOFF_RADIUS'), ('T_c_g_data', 'T_C_G_DATA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _interaction_potential12(printable):
    """
    Parameters the interaction potential in computing the biel integrals
    """
    def __init__(self):
        self.Potential_type = None
        """
        Which interaction potential should be used (Coulomb, TShPSC operator).

        Available values:
            COULOMB
                Coulomb potential: 1/r
            TSHPSC
                TShPSC: 1/x - s/Rc  ->  for x<=Rc (1-s)/Rc - (x-Rc)/Rc^2 +
                (x-Rc)^2/Rc^3 - (2*n^2-7*n+9-4*s)*(x-Rc)^3/(Rc^4*(n^2-2*n+1)*(n-1)) +
                (6-3*s-4*n+n^2)*(x-Rc)^4/(Rc^5*(n^4-4*n^3+6*n^2-4*n+1))   -> for
                Rc<x<=n*Rc (4th order polynomial)  0  -> for x>n*Rc
        """
        self.Truncation_radius = None
        """
        Determines truncation radius for the truncated TShPSC potential. Only
        valid when doing truncated calculation
        """
        self.Tshpsc_data = None
        """
        Location of the file TShPSC.dat that contains the data for the
        evaluation of the TShPSC G0
        """
        self._name = "INTERACTION_POTENTIAL"
        self._keywords = [('Potential_type', 'POTENTIAL_TYPE'), ('Truncation_radius', 'TRUNCATION_RADIUS'), ('Tshpsc_data', 'TSHPSC_DATA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each365(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each364(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each367(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each366(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each361(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each360(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each363(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each362(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _define_region1(printable):
    """
    This section provides the possibility to define arbitrary region  for
    the thermostat.
    """
    def __init__(self):
        self.list_List = []
        self.list_Molname = []
        self.list_Segname = self.list_Molname
        self.Mm_subsys = None
        """
        In a QM/MM run all  MM atoms are specified as a whole ensemble to be
        thermostated

        Available values:
            NONE
                Thermostat nothing
            ATOMIC
                Only the MM atoms itself
            MOLECULAR
                The full molecule/residue that contains a MM atom
        """
        self.Qm_subsys = None
        """
        In a QM/MM run all QM atoms are specified as a whole ensemble to be
        thermostated

        Available values:
            NONE
                Thermostat nothing
            ATOMIC
                Only the QM atoms itself
            MOLECULAR
                The full molecule/residue that contains a QM atom
        """
        self._name = "DEFINE_REGION"
        self._keywords = [('Mm_subsys', 'MM_SUBSYS'), ('Qm_subsys', 'QM_SUBSYS')]
        self._repeated_keywords = [('List', 'LIST'), ('Molname', 'MOLNAME')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_List(self, value):
        self.list_List.append(value)

    def add_Molname(self, value):
        self.list_Molname.append(value)

    def add_Segname(self, value):
        self.list_MOLNAME.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Protein(self):
        """
        See documentation for Mm_subsys
        """
        return self.Mm_subsys

    @Protein.setter
    def Protein(self, value):
        self.Mm_subsys = value



class _define_region2(printable):
    """
    This section provides the possibility to define arbitrary region  for
    the thermostat.
    """
    def __init__(self):
        self.list_List = []
        self.list_Molname = []
        self.list_Segname = self.list_Molname
        self.Mm_subsys = None
        """
        In a QM/MM run all  MM atoms are specified as a whole ensemble to be
        thermostated

        Available values:
            NONE
                Thermostat nothing
            ATOMIC
                Only the MM atoms itself
            MOLECULAR
                The full molecule/residue that contains a MM atom
        """
        self.Qm_subsys = None
        """
        In a QM/MM run all QM atoms are specified as a whole ensemble to be
        thermostated

        Available values:
            NONE
                Thermostat nothing
            ATOMIC
                Only the QM atoms itself
            MOLECULAR
                The full molecule/residue that contains a QM atom
        """
        self._name = "DEFINE_REGION"
        self._keywords = [('Mm_subsys', 'MM_SUBSYS'), ('Qm_subsys', 'QM_SUBSYS')]
        self._repeated_keywords = [('List', 'LIST'), ('Molname', 'MOLNAME')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_List(self, value):
        self.list_List.append(value)

    def add_Molname(self, value):
        self.list_Molname.append(value)

    def add_Segname(self, value):
        self.list_MOLNAME.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Protein(self):
        """
        See documentation for Mm_subsys
        """
        return self.Mm_subsys

    @Protein.setter
    def Protein(self, value):
        self.Mm_subsys = value



class _define_region3(printable):
    """
    This section provides the possibility to define arbitrary region  for
    the fast thermostat.
    """
    def __init__(self):
        self.list_List = []
        self.list_Molname = []
        self.list_Segname = self.list_Molname
        self.Mm_subsys = None
        """
        In a QM/MM run all  MM atoms are specified as a whole ensemble to be
        thermostated

        Available values:
            NONE
                Thermostat nothing
            ATOMIC
                Only the MM atoms itself
            MOLECULAR
                The full molecule/residue that contains a MM atom
        """
        self.Qm_subsys = None
        """
        In a QM/MM run all QM atoms are specified as a whole ensemble to be
        thermostated

        Available values:
            NONE
                Thermostat nothing
            ATOMIC
                Only the QM atoms itself
            MOLECULAR
                The full molecule/residue that contains a QM atom
        """
        self._name = "DEFINE_REGION"
        self._keywords = [('Mm_subsys', 'MM_SUBSYS'), ('Qm_subsys', 'QM_SUBSYS')]
        self._repeated_keywords = [('List', 'LIST'), ('Molname', 'MOLNAME')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_List(self, value):
        self.list_List.append(value)

    def add_Molname(self, value):
        self.list_Molname.append(value)

    def add_Segname(self, value):
        self.list_MOLNAME.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Protein(self):
        """
        See documentation for Mm_subsys
        """
        return self.Mm_subsys

    @Protein.setter
    def Protein(self, value):
        self.Mm_subsys = value



class _define_region4(printable):
    """
    This section provides the possibility to define arbitrary region  for
    the slow thermostat.
    """
    def __init__(self):
        self.list_List = []
        self.list_Molname = []
        self.list_Segname = self.list_Molname
        self.Mm_subsys = None
        """
        In a QM/MM run all  MM atoms are specified as a whole ensemble to be
        thermostated

        Available values:
            NONE
                Thermostat nothing
            ATOMIC
                Only the MM atoms itself
            MOLECULAR
                The full molecule/residue that contains a MM atom
        """
        self.Qm_subsys = None
        """
        In a QM/MM run all QM atoms are specified as a whole ensemble to be
        thermostated

        Available values:
            NONE
                Thermostat nothing
            ATOMIC
                Only the QM atoms itself
            MOLECULAR
                The full molecule/residue that contains a QM atom
        """
        self._name = "DEFINE_REGION"
        self._keywords = [('Mm_subsys', 'MM_SUBSYS'), ('Qm_subsys', 'QM_SUBSYS')]
        self._repeated_keywords = [('List', 'LIST'), ('Molname', 'MOLNAME')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_List(self, value):
        self.list_List.append(value)

    def add_Molname(self, value):
        self.list_Molname.append(value)

    def add_Segname(self, value):
        self.list_MOLNAME.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Protein(self):
        """
        See documentation for Mm_subsys
        """
        return self.Mm_subsys

    @Protein.setter
    def Protein(self, value):
        self.Mm_subsys = value



class _define_region5(printable):
    """
    This section provides the possibility to define arbitrary region  for
    the MSD calculation.
    """
    def __init__(self):
        self.list_List = []
        self.list_Molname = []
        self.list_Segname = self.list_Molname
        self.Mm_subsys = None
        """
        In a QM/MM run all  MM atoms are specified as a whole ensemble to be
        thermostated

        Available values:
            NONE
                Thermostat nothing
            ATOMIC
                Only the MM atoms itself
            MOLECULAR
                The full molecule/residue that contains a MM atom
        """
        self.Qm_subsys = None
        """
        In a QM/MM run all QM atoms are specified as a whole ensemble to be
        thermostated

        Available values:
            NONE
                Thermostat nothing
            ATOMIC
                Only the QM atoms itself
            MOLECULAR
                The full molecule/residue that contains a QM atom
        """
        self._name = "DEFINE_REGION"
        self._keywords = [('Mm_subsys', 'MM_SUBSYS'), ('Qm_subsys', 'QM_SUBSYS')]
        self._repeated_keywords = [('List', 'LIST'), ('Molname', 'MOLNAME')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_List(self, value):
        self.list_List.append(value)

    def add_Molname(self, value):
        self.list_Molname.append(value)

    def add_Segname(self, value):
        self.list_MOLNAME.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Protein(self):
        """
        See documentation for Mm_subsys
        """
        return self.Mm_subsys

    @Protein.setter
    def Protein(self, value):
        self.Mm_subsys = value



class _define_region6(printable):
    """
    This section provides the possibility to define arbitrary region
    """
    def __init__(self):
        self.list_List = []
        self.Temperature = None
        """
        The temperature in K used to  initialize the velocities of the atoms
        in this region
        """
        self.Temp_tol = None
        """
        Maximum accepted  temperature deviation  from the expected value for
        this region.If  temp_tol=0 no rescaling is performed
        """
        self._name = "DEFINE_REGION"
        self._keywords = [('Temperature', 'TEMPERATURE'), ('Temp_tol', 'TEMP_TOL')]
        self._repeated_keywords = [('List', 'LIST')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_List(self, value):
        self.list_List.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _each149(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each148(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each145(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each144(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each147(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each146(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each141(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each140(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each143(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each142(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _temperature1(printable):
    """
    Controls the output of the temperatures of the regions corresponding
    to the present thermostat
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each19()
        self._name = "TEMPERATURE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _temperature2(printable):
    """
    Controls the output of the temperatures of the regions corresponding
    to the present thermostat
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each23()
        self._name = "TEMPERATURE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _temperature3(printable):
    """
    Controls the output of the temperatures of the regions corresponding
    to the present thermostat
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each26()
        self._name = "TEMPERATURE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _temperature4(printable):
    """
    Controls output of temperature per region.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each32()
        self._name = "TEMPERATURE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _fragment_energies1(printable):
    """
    This section contains the energies of the fragments already computed.
    It is useful as a summary and specifically for restarting BSSE runs.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        The energy computed for each fragment
        """
        self._name = "FRAGMENT_ENERGIES"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _msd_molecule1(printable):
    """
    Controls the output of msd per molecule kind
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each29()
        self._name = "MSD_MOLECULE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _nonbonded2(printable):
    """
    Specify information on the QM/MM non-bonded forcefield
    """
    def __init__(self):
        self.list_LENNARD_JONES = []
        self.list_WILLIAMS = []
        self.list_GOODWIN = []
        self.list_GENPOT = []
        self._name = "NONBONDED"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('LENNARD_JONES', '_lennard_jones3'), ('WILLIAMS', '_williams3'), ('GOODWIN', '_goodwin3'), ('GENPOT', '_genpot3')]

    def add_LENNARD_JONES(self):
        new_section = _lennard_jones3()
        self.list_LENNARD_JONES.append(new_section)
        return new_section

    def add_WILLIAMS(self):
        new_section = _williams3()
        self.list_WILLIAMS.append(new_section)
        return new_section

    def add_GOODWIN(self):
        new_section = _goodwin3()
        self.list_GOODWIN.append(new_section)
        return new_section

    def add_GENPOT(self):
        new_section = _genpot3()
        self.list_GENPOT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _nonbonded1(printable):
    """
    This section specifies the input parameters for NON-BONDED
    interactions.
    """
    def __init__(self):
        self.list_LENNARD_JONES = []
        self.list_WILLIAMS = []
        self.list_EAM = []
        self.list_GOODWIN = []
        self.list_IPBV = []
        self.list_BMHFT = []
        self.list_BMHFTD = []
        self.list_BUCK4RANGES = []
        self.list_BUCKMORSE = []
        self.list_GENPOT = []
        self.list_TERSOFF = []
        self.list_SIEPMANN = []
        self._name = "NONBONDED"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('LENNARD_JONES', '_lennard_jones1'), ('WILLIAMS', '_williams1'), ('EAM', '_eam1'), ('GOODWIN', '_goodwin1'), ('IPBV', '_ipbv1'), ('BMHFT', '_bmhft1'), ('BMHFTD', '_bmhftd1'), ('BUCK4RANGES', '_buck4ranges1'), ('BUCKMORSE', '_buckmorse1'), ('GENPOT', '_genpot1'), ('TERSOFF', '_tersoff1'), ('SIEPMANN', '_siepmann1')]

    def add_LENNARD_JONES(self):
        new_section = _lennard_jones1()
        self.list_LENNARD_JONES.append(new_section)
        return new_section

    def add_WILLIAMS(self):
        new_section = _williams1()
        self.list_WILLIAMS.append(new_section)
        return new_section

    def add_EAM(self):
        new_section = _eam1()
        self.list_EAM.append(new_section)
        return new_section

    def add_GOODWIN(self):
        new_section = _goodwin1()
        self.list_GOODWIN.append(new_section)
        return new_section

    def add_IPBV(self):
        new_section = _ipbv1()
        self.list_IPBV.append(new_section)
        return new_section

    def add_BMHFT(self):
        new_section = _bmhft1()
        self.list_BMHFT.append(new_section)
        return new_section

    def add_BMHFTD(self):
        new_section = _bmhftd1()
        self.list_BMHFTD.append(new_section)
        return new_section

    def add_BUCK4RANGES(self):
        new_section = _buck4ranges1()
        self.list_BUCK4RANGES.append(new_section)
        return new_section

    def add_BUCKMORSE(self):
        new_section = _buckmorse1()
        self.list_BUCKMORSE.append(new_section)
        return new_section

    def add_GENPOT(self):
        new_section = _genpot1()
        self.list_GENPOT.append(new_section)
        return new_section

    def add_TERSOFF(self):
        new_section = _tersoff1()
        self.list_TERSOFF.append(new_section)
        return new_section

    def add_SIEPMANN(self):
        new_section = _siepmann1()
        self.list_SIEPMANN.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _force_eval_mixed1(printable):
    """
    Defines the fragments for the mixed force_eval (reference)
    """
    def __init__(self):
        self.list_FRAGMENT = []
        self._name = "FORCE_EVAL_MIXED"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('FRAGMENT', '_fragment1')]

    def add_FRAGMENT(self):
        new_section = _fragment1()
        self.list_FRAGMENT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info1(printable):
    """
    controls the printing of  initialization controlled by the global
    section
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each3()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info2(printable):
    """
    controls the printing of tests output
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each6()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info3(printable):
    """
    controls the printing of DEBUG specific output
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each7()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info4(printable):
    """
    Controls the printing of basic information during the Geometry
    Optimization
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each10()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info5(printable):
    """
    Controls the printing of basic information during the Geometry
    Optimization
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each12()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info6(printable):
    """
    Controls the printing of basic information during the Geometry
    Optimization
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each14()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info7(printable):
    """
    Controls the printing of basic information during the Optimization
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each17()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info8(printable):
    """
    Controls the printing of basic and summary information during the
    Molecular Dynamics
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each40()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info9(printable):
    """
    Controls the printing of basic and summary information during
    metadynamics.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each41()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _hf_info6(printable):
    """
    Controls the printing basic info about hf method
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each314()
        self._name = "HF_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _becke974(printable):
    """
    Uses the Becke 97 exchange correlation functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional, if -1 the default for the
        given parametrization is used
        """
        self.Scale_c = None
        """
        scales the correlation part of the functional
        """
        self.Parametrization = None
        """
        switches between the B97 and Grimme parametrization

        Available values:
            ORIG
            B97GRIMME
            B97_GRIMME
        """
        self._name = "BECKE97"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Scale_c', 'SCALE_C'), ('Parametrization', 'PARAMETRIZATION')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _becke971(printable):
    """
    Uses the Becke 97 exchange correlation functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional, if -1 the default for the
        given parametrization is used
        """
        self.Scale_c = None
        """
        scales the correlation part of the functional
        """
        self.Parametrization = None
        """
        switches between the B97 and Grimme parametrization

        Available values:
            ORIG
            B97GRIMME
            B97_GRIMME
        """
        self._name = "BECKE97"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Scale_c', 'SCALE_C'), ('Parametrization', 'PARAMETRIZATION')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _becke972(printable):
    """
    Uses the Becke 97 exchange correlation functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional, if -1 the default for the
        given parametrization is used
        """
        self.Scale_c = None
        """
        scales the correlation part of the functional
        """
        self.Parametrization = None
        """
        switches between the B97 and Grimme parametrization

        Available values:
            ORIG
            B97GRIMME
            B97_GRIMME
        """
        self._name = "BECKE97"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Scale_c', 'SCALE_C'), ('Parametrization', 'PARAMETRIZATION')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _becke973(printable):
    """
    Uses the Becke 97 exchange correlation functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional, if -1 the default for the
        given parametrization is used
        """
        self.Scale_c = None
        """
        scales the correlation part of the functional
        """
        self.Parametrization = None
        """
        switches between the B97 and Grimme parametrization

        Available values:
            ORIG
            B97GRIMME
            B97_GRIMME
        """
        self._name = "BECKE97"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Scale_c', 'SCALE_C'), ('Parametrization', 'PARAMETRIZATION')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _pair_potential3(printable):
    """
    Information on the pair potential to calculate dispersion
    """
    def __init__(self):
        self.R_cutoff = None
        """
        Range of potential. The cutoff will be 2 times this value
        """
        self.Type = None
        """
        Type of potential. DFTD2 and DFTD3 are the Grimme D2 and D3 methods
        respectively.

        Available values:
            DFTD2
            DFTD3
        """
        self.Parameter_file_name = None
        """
        Name of the parameter file, may include a path
        """
        self.Reference_functional = None
        """
        Use parameters for this specific density functional
        """
        self.Scaling = None
        """
        XC Functional dependent scaling parameter, if set to zero CP2K
        attempts to guess the xc functional that is in use and sets the
        associated scaling parameter.
        """
        self.Exp_pre = None
        """
        Prefactor in exponential damping factor (DFT-D2 potential)
        """
        self.Eps_cn = None
        """
        Cutoff value for coordination number function (DFT-D3 method)
        """
        self.D3_scaling = None
        """
        XC Functional dependent scaling parameters (s6,sr6,s8) for the DFT-D3
        method,  if set to zero CP2K attempts to guess the xc functional from
        REFERENCE_FUNCTIONAL and sets the associated scaling parameter.
        """
        self.Calculate_c9_term = None
        """
        Calculate C9 terms in DFT-D3 model
        """
        self.Reference_c9_term = None
        """
        Calculate C9 terms in DFT-D3 model using reference coordination
        numbers
        """
        self.Long_range_correction = None
        """
        Calculate a long range correction to the DFT-D3 model
        """
        self.Verbose_output = None
        """
        Extensive output for the DFT-D2 and DFT-D3 models
        """
        self.list_Kind_coordination_numbers = []
        self.list_Atom_coordination_numbers = []
        self.list_Atomparm = []
        self.PRINT_DFTD = _print_dftd3()
        self._name = "PAIR_POTENTIAL"
        self._keywords = [('R_cutoff', 'R_CUTOFF'), ('Type', 'TYPE'), ('Parameter_file_name', 'PARAMETER_FILE_NAME'), ('Reference_functional', 'REFERENCE_FUNCTIONAL'), ('Scaling', 'SCALING'), ('Exp_pre', 'EXP_PRE'), ('Eps_cn', 'EPS_CN'), ('D3_scaling', 'D3_SCALING'), ('Calculate_c9_term', 'CALCULATE_C9_TERM'), ('Reference_c9_term', 'REFERENCE_C9_TERM'), ('Long_range_correction', 'LONG_RANGE_CORRECTION'), ('Verbose_output', 'VERBOSE_OUTPUT')]
        self._repeated_keywords = [('Kind_coordination_numbers', 'KIND_COORDINATION_NUMBERS'), ('Atom_coordination_numbers', 'ATOM_COORDINATION_NUMBERS'), ('Atomparm', 'ATOMPARM')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT_DFTD', 'PRINT_DFTD')]
        self._repeated_subsections = []

    def add_Kind_coordination_numbers(self, value):
        self.list_Kind_coordination_numbers.append(value)

    def add_Atom_coordination_numbers(self, value):
        self.list_Atom_coordination_numbers.append(value)

    def add_Atomparm(self, value):
        self.list_Atomparm.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _exclude_ei_list1(printable):
    """
    Speficy bonds (via atom kinds) for fine tuning of 1-2 exclusion lists.
    If this section is not present the 1-2 exclusion is applied to all
    bond kinds. When this section is present the 1-2 exclusion is applied
    ONLY to the bonds defined herein. This section allows ONLY fine tuning
    of 1-2 interactions.
    """
    def __init__(self):
        self.Bond = None
        """
        Specify the atom kinds involved in the bond for which 1-2 exclusion
        holds.
        """
        self._name = "EXCLUDE_EI_LIST"
        self._keywords = [('Bond', 'BOND')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _force_matching1(printable):
    """
    Specify the force matching input.
    """
    def __init__(self):
        self.Optimize_file_name = None
        """
        the filename of the input file which contains the parameters to be
        optimized
        """
        self.Ref_traj_file_name = None
        """
        the filename of the reference coordinates.
        """
        self.Ref_force_file_name = None
        """
        the filename of the reference forces, should also contain the energy
        """
        self.Ref_cell_file_name = None
        """
        the filename of the reference cell
        """
        self.Group_size = None
        """
        Gives the preferred size of a working group, groups will always be
        equal or larger than this size.Usually this should take the number of
        cores per socket into account for good performance.
        """
        self.Frame_start = None
        """
        starting frame to be used from the reference trajectory
        """
        self.Frame_stop = None
        """
        final frame to be used from the reference trajectory (all=-1)
        """
        self.Frame_stride = None
        """
        stride when using the reference trajectory
        """
        self.Frame_count = None
        """
        Use at most FRAME_COUNT frames from the reference trajectory,
        adjusting the stride to have them as fas apart as possible (all=-1).
        """
        self.Energy_weight = None
        """
        Relative weight of the energy RMSD vs the force RMSD
        """
        self.Shift_average = None
        """
        Shift averages of the energies before computing energy RMSD.
        """
        self.Shift_qm = None
        """
        Shift of the reference energies applied before computing energy RMSD.
        """
        self.Shift_mm = None
        """
        Shift of the fit energies applied before computing energy RMSD.
        """
        self.COMPARE_ENERGIES = _compare_energies1()
        self.COMPARE_FORCES = _compare_forces1()
        self._name = "FORCE_MATCHING"
        self._keywords = [('Optimize_file_name', 'OPTIMIZE_FILE_NAME'), ('Ref_traj_file_name', 'REF_TRAJ_FILE_NAME'), ('Ref_force_file_name', 'REF_FORCE_FILE_NAME'), ('Ref_cell_file_name', 'REF_CELL_FILE_NAME'), ('Group_size', 'GROUP_SIZE'), ('Frame_start', 'FRAME_START'), ('Frame_stop', 'FRAME_STOP'), ('Frame_stride', 'FRAME_STRIDE'), ('Frame_count', 'FRAME_COUNT'), ('Energy_weight', 'ENERGY_WEIGHT'), ('Shift_average', 'SHIFT_AVERAGE'), ('Shift_qm', 'SHIFT_QM'), ('Shift_mm', 'SHIFT_MM')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('COMPARE_ENERGIES', 'COMPARE_ENERGIES'), ('COMPARE_FORCES', 'COMPARE_FORCES')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _ipbv1(printable):
    """
    This section specifies the input parameters for IPBV potential
    type.Functional form: Implicit table function.
    """
    def __init__(self):
        self.Atoms = None
        """
        Defines the atomic kind involved in the IPBV nonbond potential
        """
        self.Rcut = None
        """
        Defines the cutoff parameter of the IPBV potential
        """
        self.Rmin = None
        """
        Defines the lower bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self.Rmax = None
        """
        Defines the upper bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self._name = "IPBV"
        self._keywords = [('Atoms', 'ATOMS'), ('Rcut', 'RCUT'), ('Rmin', 'RMIN'), ('Rmax', 'RMAX')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _num2pnt2(printable):
    """
    Provides parameters to tune the line search for the two point based
    line search.
    """
    def __init__(self):
        self.Max_allowed_step = None
        """
        Max allowed value for the line search step.
        """
        self.Linmin_grad_only = None
        """
        Use only the gradient, not the energy for line minimizations (e.g. in
        conjugate gradients).
        """
        self._name = "2PNT"
        self._keywords = [('Max_allowed_step', 'MAX_ALLOWED_STEP'), ('Linmin_grad_only', 'LINMIN_GRAD_ONLY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _cp_fm_gemm1(printable):
    """
    Benchmark and test the cp_fm_gemm routines by multiplying C=A*B
    """
    def __init__(self):
        self.N_loop = None
        """
        Number of cp_fm_gemm operations being timed (useful for small
        matrices).
        """
        self.K = None
        """
        Dimension 1 of C
        """
        self.M = None
        """
        Inner dimension M
        """
        self.N = None
        """
        Dimension 2 of C
        """
        self.Nrow_block = None
        """
        block_size for rows
        """
        self.Ncol_block = None
        """
        block_size for cols
        """
        self.Row_major = None
        """
        Use a row major blacs grid
        """
        self.Force_blocksize = None
        """
        Forces the blocksize, even if this implies that a few processes might
        have no data
        """
        self.Grid_2d = None
        """
        Explicitly set the blacs 2D processor layout. If the product differs
        from the number of MPI ranks, it is ignored and a default nearly
        square layout is used.
        """
        self.Transa = None
        """
        Transpose matrix A
        """
        self.Transb = None
        """
        Transpose matrix B
        """
        self._name = "CP_FM_GEMM"
        self._keywords = [('N_loop', 'N_LOOP'), ('K', 'K'), ('M', 'M'), ('N', 'N'), ('Nrow_block', 'NROW_BLOCK'), ('Ncol_block', 'NCOL_BLOCK'), ('Row_major', 'ROW_MAJOR'), ('Force_blocksize', 'FORCE_BLOCKSIZE'), ('Grid_2d', 'GRID_2D'), ('Transa', 'TRANSA'), ('Transb', 'TRANSB')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _scf_info1(printable):
    """
    Controls the printing of SCF information
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each360()
        self._name = "SCF_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _pade3(printable):
    """
    Uses the PADE functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self._name = "PADE"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _pade2(printable):
    """
    Uses the PADE functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self._name = "PADE"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _pade1(printable):
    """
    Uses the PADE functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self._name = "PADE"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _pade4(printable):
    """
    Uses the PADE functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self._name = "PADE"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _davidson1(printable):
    """"""
    def __init__(self):
        self.Preconditioner = None
        """
        Type of preconditioner to be used with all minimization schemes.

        Available values:
            FULL_ALL
                Most effective state selective preconditioner based on diagonalization
            FULL_SINGLE_INVERSE
                Based on H-eS cholesky inversion, similar to FULL_SINGLE in
                preconditioning efficiency but cheaper to construct, might be somewhat
                less robust. Recommended for large systems.
            NONE
                skip preconditioning
        """
        self.Precond_solver = None
        """
        How the preconditioner is applied to the residual.

        Available values:
            DEFAULT
                the default
            DIRECT
                Cholesky decomposition followed by triangular solve (works for
                FULL_KINETIC/SINGLE_INVERSE/S_INVERSE)
            INVERSE_CHOLESKY
                Cholesky decomposition followed by explicit inversion (works for
                FULL_KINETIC/SINGLE_INVERSE/S_INVERSE)
            SAINV
                SAINV inversion (works for FULL_KINETIC/SINGLE_INVERSE/S_INVERSE)
        """
        self.Energy_gap = None
        """
        Should be an estimate for the energy gap [a.u.] (HOMO-LUMO) and is
        used in preconditioning, especially effective with the FULL_ALL
        preconditioner, in which case it should be an underestimate of the gap
        (0.001 doing normally fine). For the other preconditioners, making
        this value larger (0.2) will tame the preconditioner in case of poor
        initial guesses.
        """
        self.New_prec_each = None
        """
        Number of SCF iterations after which a new Preconditioner is computed
        """
        self.First_prec = None
        """
        First SCF iteration at which a Preconditioner is employed
        """
        self.Conv_mos_percent = None
        """
        Minimal percent of MOS that have to converge within the Davidson loop
        before the SCF iteration is completed and a new Hamiltonian is
        computed
        """
        self.Sparse_mos = None
        """
        Use MOS as sparse matrix and avoid as much as possible multiplications
        with full matrices
        """
        self._name = "DAVIDSON"
        self._keywords = [('Preconditioner', 'PRECONDITIONER'), ('Precond_solver', 'PRECOND_SOLVER'), ('Energy_gap', 'ENERGY_GAP'), ('New_prec_each', 'NEW_PREC_EACH'), ('First_prec', 'FIRST_PREC'), ('Conv_mos_percent', 'CONV_MOS_PERCENT'), ('Sparse_mos', 'SPARSE_MOS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _davidson2(printable):
    """
    Controls the printing of information on Davidson iterations.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each102()
        self._name = "DAVIDSON"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _dimer1(printable):
    """
    Specifies parameters for Dimer Method
    """
    def __init__(self):
        self.Dr = None
        """
        This keyword sets the value for the DR parameter.
        """
        self.Interpolate_gradient = None
        """
        This keyword controls the interpolation of the gradient whenever
        possible during the optimization of the Dimer. The use of this
        keywords saves 1 evaluation  of energy/forces.
        """
        self.Angle_tolerance = None
        """
        This keyword sets the value of the tolerance angle for the line search
        performed to optimize the orientation of the dimer.
        """
        self.ROT_OPT = _rot_opt1()
        self.DIMER_VECTOR = _dimer_vector1()
        self._name = "DIMER"
        self._keywords = [('Dr', 'DR'), ('Interpolate_gradient', 'INTERPOLATE_GRADIENT'), ('Angle_tolerance', 'ANGLE_TOLERANCE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('ROT_OPT', 'ROT_OPT'), ('DIMER_VECTOR', 'DIMER_VECTOR')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _goodwin4(printable):
    """
    This section specifies the input parameters for GOODWIN potential
    type.Functional form: V(r) =
    EXP(M*(-(r/DC)**MC+(D/DC)**MC))*VR0*(D/r)**M.
    """
    def __init__(self):
        self.Atoms = None
        """
        Defines the atomic kind involved in the nonbond potential
        """
        self.Vr0 = None
        """
        Defines the VR0 parameter of the Goodwin potential
        """
        self.D = None
        """
        Defines the D parameter of the Goodwin potential
        """
        self.Dc = None
        """
        Defines the DC parameter of the Goodwin potential
        """
        self.M = None
        """
        Defines the M parameter of the Goodwin potential
        """
        self.Mc = None
        """
        Defines the MC parameter of the Goodwin potential
        """
        self.Rcut = None
        """
        Defines the cutoff parameter of the Goodwin potential
        """
        self.Rmin = None
        """
        Defines the lower bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self.Rmax = None
        """
        Defines the upper bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self._name = "GOODWIN"
        self._keywords = [('Atoms', 'ATOMS'), ('Vr0', 'VR0'), ('D', 'D'), ('Dc', 'DC'), ('M', 'M'), ('Mc', 'MC'), ('Rcut', 'RCUT'), ('Rmin', 'RMIN'), ('Rmax', 'RMAX')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _goodwin3(printable):
    """
    This section specifies the input parameters for GOODWIN potential
    type.Functional form: V(r) =
    EXP(M*(-(r/DC)**MC+(D/DC)**MC))*VR0*(D/r)**M.
    """
    def __init__(self):
        self.Atoms = None
        """
        Defines the atomic kind involved in the nonbond potential
        """
        self.Vr0 = None
        """
        Defines the VR0 parameter of the Goodwin potential
        """
        self.D = None
        """
        Defines the D parameter of the Goodwin potential
        """
        self.Dc = None
        """
        Defines the DC parameter of the Goodwin potential
        """
        self.M = None
        """
        Defines the M parameter of the Goodwin potential
        """
        self.Mc = None
        """
        Defines the MC parameter of the Goodwin potential
        """
        self.Rcut = None
        """
        Defines the cutoff parameter of the Goodwin potential
        """
        self.Rmin = None
        """
        Defines the lower bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self.Rmax = None
        """
        Defines the upper bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self._name = "GOODWIN"
        self._keywords = [('Atoms', 'ATOMS'), ('Vr0', 'VR0'), ('D', 'D'), ('Dc', 'DC'), ('M', 'M'), ('Mc', 'MC'), ('Rcut', 'RCUT'), ('Rmin', 'RMIN'), ('Rmax', 'RMAX')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _goodwin2(printable):
    """
    This section specifies the input parameters for GOODWIN potential
    type.Functional form: V(r) =
    EXP(M*(-(r/DC)**MC+(D/DC)**MC))*VR0*(D/r)**M.
    """
    def __init__(self):
        self.Atoms = None
        """
        Defines the atomic kind involved in the nonbond potential
        """
        self.Vr0 = None
        """
        Defines the VR0 parameter of the Goodwin potential
        """
        self.D = None
        """
        Defines the D parameter of the Goodwin potential
        """
        self.Dc = None
        """
        Defines the DC parameter of the Goodwin potential
        """
        self.M = None
        """
        Defines the M parameter of the Goodwin potential
        """
        self.Mc = None
        """
        Defines the MC parameter of the Goodwin potential
        """
        self.Rcut = None
        """
        Defines the cutoff parameter of the Goodwin potential
        """
        self.Rmin = None
        """
        Defines the lower bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self.Rmax = None
        """
        Defines the upper bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self._name = "GOODWIN"
        self._keywords = [('Atoms', 'ATOMS'), ('Vr0', 'VR0'), ('D', 'D'), ('Dc', 'DC'), ('M', 'M'), ('Mc', 'MC'), ('Rcut', 'RCUT'), ('Rmin', 'RMIN'), ('Rmax', 'RMAX')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _goodwin1(printable):
    """
    This section specifies the input parameters for GOODWIN potential
    type.Functional form: V(r) =
    EXP(M*(-(r/DC)**MC+(D/DC)**MC))*VR0*(D/r)**M.
    """
    def __init__(self):
        self.Atoms = None
        """
        Defines the atomic kind involved in the nonbond potential
        """
        self.Vr0 = None
        """
        Defines the VR0 parameter of the Goodwin potential
        """
        self.D = None
        """
        Defines the D parameter of the Goodwin potential
        """
        self.Dc = None
        """
        Defines the DC parameter of the Goodwin potential
        """
        self.M = None
        """
        Defines the M parameter of the Goodwin potential
        """
        self.Mc = None
        """
        Defines the MC parameter of the Goodwin potential
        """
        self.Rcut = None
        """
        Defines the cutoff parameter of the Goodwin potential
        """
        self.Rmin = None
        """
        Defines the lower bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self.Rmax = None
        """
        Defines the upper bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self._name = "GOODWIN"
        self._keywords = [('Atoms', 'ATOMS'), ('Vr0', 'VR0'), ('D', 'D'), ('Dc', 'DC'), ('M', 'M'), ('Mc', 'MC'), ('Rcut', 'RCUT'), ('Rmin', 'RMIN'), ('Rmax', 'RMAX')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _impropers1(printable):
    """
    Defines new impropers
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Four integer indexes per line defining the new improper Indexes must
        be relative to the full system and not to the single molecules
        """
        self._name = "IMPROPERS"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _alpha1(printable):
    """
    alpha spin
    """
    def __init__(self):
        self.Nel = None
        """
        Orbital ccupation change per angular momentum quantum number.In
        unrestricted calculations applied to spin alpha.
        """
        self.L = None
        """
        Angular momentum quantum number of theorbitals whose occupation is
        changed
        """
        self.L = None
        """
        Angular momentum quantum number of theorbitals whose occupation is
        changed
        """
        self.N = None
        """
        Principal quantum number of theorbitals whose occupation is changed.
        Default is the first not occupied
        """
        self.N = None
        """
        Principal quantum number of theorbitals whose occupation is changed.
        Default is the first not occupied
        """
        self._name = "ALPHA"
        self._keywords = [('Nel', 'NEL'), ('L', 'L'), ('L', 'L'), ('N', 'N'), ('N', 'N')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _test1(printable):
    """
    Tests to perform on the supported libraries.
    """
    def __init__(self):
        self.Memory = None
        """
        Set the maximum amount of memory allocated for a given test (in bytes)
        """
        self.Copy = None
        """
        Tests the performance to copy two vectors.The results of these tests
        allow to determine the size of the cache of the CPU. This can be used
        to optimize the performance of theFFTSG library. Tests are repeated
        the given number of times.
        """
        self.Matmul = None
        """
        Tests the performance of different kinds of matrix matrix multiply
        kernels for the F95 INTRINSIC matmul. Matrices up to 2**N+1 will be
        tested.
        """
        self.Dgemm = None
        """
        Tests the performance of different kinds of matrix matrix multiply
        kernels for the BLAS INTRINSIC DGEMM. Matrices up to 2**N+1 will be
        tested.
        """
        self.Fft = None
        """
        Tests the performance of all available FFT libraries for 3D FFTs Tests
        are repeated the given number of times.
        """
        self.Eri = None
        """
        Tests the performance and correctness of ERI libraries
        """
        self.Clebsch_gordon = None
        """
        Tests the Clebsch-Gordon Coefficients. Tests are repeated the given
        number of times.
        """
        self.Mpi = None
        """
        Tests mpi, quickly adapted benchmark code,will ONLY work on an even
        number of CPUs. comm is the relevant, initialized communicator. This
        test will produce messages of the size 8*10**requested_size, where
        requested_size is the value given to this keyword
        """
        self.Random_number_generator = None
        """
         Tests the parallel random number generator (RNG)
        """
        self.GRID_INFORMATION = _grid_information1()
        self.PROGRAM_RUN_INFO = _program_run_info2()
        self.RS_PW_TRANSFER = _rs_pw_transfer1()
        self.list_EIGENSOLVER = []
        self.list_PW_TRANSFER = []
        self.list_CP_FM_GEMM = []
        self.list_CP_DBCSR = []
        self._name = "TEST"
        self._keywords = [('Memory', 'MEMORY'), ('Copy', 'COPY'), ('Matmul', 'MATMUL'), ('Dgemm', 'DGEMM'), ('Fft', 'FFT'), ('Eri', 'ERI'), ('Clebsch_gordon', 'CLEBSCH_GORDON'), ('Mpi', 'MPI'), ('Random_number_generator', 'RANDOM_NUMBER_GENERATOR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('GRID_INFORMATION', 'GRID_INFORMATION'), ('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('RS_PW_TRANSFER', 'RS_PW_TRANSFER')]
        self._repeated_subsections = [('EIGENSOLVER', '_eigensolver1'), ('PW_TRANSFER', '_pw_transfer1'), ('CP_FM_GEMM', '_cp_fm_gemm1'), ('CP_DBCSR', '_cp_dbcsr1')]

    def add_EIGENSOLVER(self):
        new_section = _eigensolver1()
        self.list_EIGENSOLVER.append(new_section)
        return new_section

    def add_PW_TRANSFER(self):
        new_section = _pw_transfer1()
        self.list_PW_TRANSFER.append(new_section)
        return new_section

    def add_CP_FM_GEMM(self):
        new_section = _cp_fm_gemm1()
        self.list_CP_FM_GEMM.append(new_section)
        return new_section

    def add_CP_DBCSR(self):
        new_section = _cp_dbcsr1()
        self.list_CP_DBCSR.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Clebsch(self):
        """
        See documentation for Clebsch_gordon
        """
        return self.Clebsch_gordon

    @property
    def Rng(self):
        """
        See documentation for Random_number_generator
        """
        return self.Random_number_generator

    @Clebsch.setter
    def Clebsch(self, value):
        self.Clebsch_gordon = value

    @Rng.setter
    def Rng(self, value):
        self.Random_number_generator = value



class _map1(printable):
    """
    Activating this print key will print once a file with the values of
    the FUNCTION on a grid of COLVAR values in a specified range.
    GRID_SPACING and RANGE for every COLVAR has to be specified again in
    the same order as they are in the input.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.list_Range = []
        self.list_Grid_spacing = []
        self.EACH = _each272()
        self._name = "MAP"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = [('Range', 'RANGE'), ('Grid_spacing', 'GRID_SPACING')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def add_Range(self, value):
        self.list_Range.append(value)

    def add_Grid_spacing(self, value):
        self.list_Grid_spacing.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _map2(printable):
    """
    Activating this print key will print once a file with the values of
    the FUNCTION on a grid of COLVAR values in a specified range.
    GRID_SPACING and RANGE for every COLVAR has to be specified again in
    the same order as they are in the input.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.list_Range = []
        self.list_Grid_spacing = []
        self.EACH = _each274()
        self._name = "MAP"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = [('Range', 'RANGE'), ('Grid_spacing', 'GRID_SPACING')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def add_Range(self, value):
        self.list_Range.append(value)

    def add_Grid_spacing(self, value):
        self.list_Grid_spacing.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _interaction_potential9(printable):
    """
    Parameters the interaction potential in computing the biel integrals
    """
    def __init__(self):
        self.Potential_type = None
        """
        Which interaction potential should be used (Coulomb, TShPSC operator).

        Available values:
            COULOMB
                Coulomb potential: 1/r
            TSHPSC
                TShPSC: 1/x - s/Rc  ->  for x<=Rc (1-s)/Rc - (x-Rc)/Rc^2 +
                (x-Rc)^2/Rc^3 - (2*n^2-7*n+9-4*s)*(x-Rc)^3/(Rc^4*(n^2-2*n+1)*(n-1)) +
                (6-3*s-4*n+n^2)*(x-Rc)^4/(Rc^5*(n^4-4*n^3+6*n^2-4*n+1))   -> for
                Rc<x<=n*Rc (4th order polynomial)  0  -> for x>n*Rc
        """
        self.Truncation_radius = None
        """
        Determines truncation radius for the truncated TShPSC potential. Only
        valid when doing truncated calculation
        """
        self.Tshpsc_data = None
        """
        Location of the file TShPSC.dat that contains the data for the
        evaluation of the TShPSC G0
        """
        self._name = "INTERACTION_POTENTIAL"
        self._keywords = [('Potential_type', 'POTENTIAL_TYPE'), ('Truncation_radius', 'TRUNCATION_RADIUS'), ('Tshpsc_data', 'TSHPSC_DATA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _interaction_potential8(printable):
    """
    Sets up interaction potential if requested
    """
    def __init__(self):
        self.Potential_type = None
        """
        Which interaction potential should be used (Coulomb, longrange or
        shortrange).

        Available values:
            COULOMB
                Coulomb potential: 1/r
            SHORTRANGE
                Shortrange potential: erfc(omega*r)/r
            LONGRANGE
                Longrange potential: erf(omega*r)/r
            MIX_CL
                Mix coulomb and longrange potential: 1/r + erf(omega*r)/r
            GAUSSIAN
                Damped Gaussian potential: exp(-omega^2*r^2)
            MIX_LG
                Mix Gaussian and longrange potential: erf(omega*r)/r +
                exp(-omega^2*r^2)
            IDENTITY
                Overlap
            TRUNCATED
                Truncated coulomb potential: if(r<R_c) 1/r else 0
            MIX_CL_TRUNC
                Truncated Mix coulomb and longrange potential, assumes/requires that
                the erf has fully decayed at R_c
        """
        self.Omega = None
        """
        Parameter for short/longrange interaction
        """
        self.Scale_coulomb = None
        """
        Scales Hartree-Fock contribution arising from a coulomb potential.
        Only valid when doing a mixed potential calculation
        """
        self.Scale_longrange = None
        """
        Scales Hartree-Fock contribution arising from a longrange potential.
        Only valid when doing a mixed potential calculation
        """
        self.Scale_gaussian = None
        """
        Scales Hartree-Fock contribution arising from a gaussian potential.
        Only valid when doing a mixed potential calculation
        """
        self.Cutoff_radius = None
        """
        Determines cutoff radius for the truncated 1/r potential. Only valid
        when doing truncated calculation
        """
        self.T_c_g_data = None
        """
        Location of the file t_c_g.dat that contains the data for the
        evaluation of the truncated gamma function
        """
        self._name = "INTERACTION_POTENTIAL"
        self._keywords = [('Potential_type', 'POTENTIAL_TYPE'), ('Omega', 'OMEGA'), ('Scale_coulomb', 'SCALE_COULOMB'), ('Scale_longrange', 'SCALE_LONGRANGE'), ('Scale_gaussian', 'SCALE_GAUSSIAN'), ('Cutoff_radius', 'CUTOFF_RADIUS'), ('T_c_g_data', 'T_C_G_DATA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _point49(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point48(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _interaction_potential5(printable):
    """
    Sets up interaction potential if requested
    """
    def __init__(self):
        self.Potential_type = None
        """
        Which interaction potential should be used (Coulomb, longrange or
        shortrange).

        Available values:
            COULOMB
                Coulomb potential: 1/r
            SHORTRANGE
                Shortrange potential: erfc(omega*r)/r
            LONGRANGE
                Longrange potential: erf(omega*r)/r
            MIX_CL
                Mix coulomb and longrange potential: 1/r + erf(omega*r)/r
            GAUSSIAN
                Damped Gaussian potential: exp(-omega^2*r^2)
            MIX_LG
                Mix Gaussian and longrange potential: erf(omega*r)/r +
                exp(-omega^2*r^2)
            IDENTITY
                Overlap
            TRUNCATED
                Truncated coulomb potential: if(r<R_c) 1/r else 0
            MIX_CL_TRUNC
                Truncated Mix coulomb and longrange potential, assumes/requires that
                the erf has fully decayed at R_c
        """
        self.Omega = None
        """
        Parameter for short/longrange interaction
        """
        self.Scale_coulomb = None
        """
        Scales Hartree-Fock contribution arising from a coulomb potential.
        Only valid when doing a mixed potential calculation
        """
        self.Scale_longrange = None
        """
        Scales Hartree-Fock contribution arising from a longrange potential.
        Only valid when doing a mixed potential calculation
        """
        self.Scale_gaussian = None
        """
        Scales Hartree-Fock contribution arising from a gaussian potential.
        Only valid when doing a mixed potential calculation
        """
        self.Cutoff_radius = None
        """
        Determines cutoff radius for the truncated 1/r potential. Only valid
        when doing truncated calculation
        """
        self.T_c_g_data = None
        """
        Location of the file t_c_g.dat that contains the data for the
        evaluation of the truncated gamma function
        """
        self._name = "INTERACTION_POTENTIAL"
        self._keywords = [('Potential_type', 'POTENTIAL_TYPE'), ('Omega', 'OMEGA'), ('Scale_coulomb', 'SCALE_COULOMB'), ('Scale_longrange', 'SCALE_LONGRANGE'), ('Scale_gaussian', 'SCALE_GAUSSIAN'), ('Cutoff_radius', 'CUTOFF_RADIUS'), ('T_c_g_data', 'T_C_G_DATA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _interaction_potential4(printable):
    """
    Sets up interaction potential if requested
    """
    def __init__(self):
        self.Potential_type = None
        """
        Which interaction potential should be used (Coulomb, longrange or
        shortrange).

        Available values:
            COULOMB
                Coulomb potential: 1/r
            SHORTRANGE
                Shortrange potential: erfc(omega*r)/r
            LONGRANGE
                Longrange potential: erf(omega*r)/r
            MIX_CL
                Mix coulomb and longrange potential: 1/r + erf(omega*r)/r
            GAUSSIAN
                Damped Gaussian potential: exp(-omega^2*r^2)
            MIX_LG
                Mix Gaussian and longrange potential: erf(omega*r)/r +
                exp(-omega^2*r^2)
            IDENTITY
                Overlap
            TRUNCATED
                Truncated coulomb potential: if(r<R_c) 1/r else 0
            MIX_CL_TRUNC
                Truncated Mix coulomb and longrange potential, assumes/requires that
                the erf has fully decayed at R_c
        """
        self.Omega = None
        """
        Parameter for short/longrange interaction
        """
        self.Scale_coulomb = None
        """
        Scales Hartree-Fock contribution arising from a coulomb potential.
        Only valid when doing a mixed potential calculation
        """
        self.Scale_longrange = None
        """
        Scales Hartree-Fock contribution arising from a longrange potential.
        Only valid when doing a mixed potential calculation
        """
        self.Scale_gaussian = None
        """
        Scales Hartree-Fock contribution arising from a gaussian potential.
        Only valid when doing a mixed potential calculation
        """
        self.Cutoff_radius = None
        """
        Determines cutoff radius for the truncated 1/r potential. Only valid
        when doing truncated calculation
        """
        self.T_c_g_data = None
        """
        Location of the file t_c_g.dat that contains the data for the
        evaluation of the truncated gamma function
        """
        self._name = "INTERACTION_POTENTIAL"
        self._keywords = [('Potential_type', 'POTENTIAL_TYPE'), ('Omega', 'OMEGA'), ('Scale_coulomb', 'SCALE_COULOMB'), ('Scale_longrange', 'SCALE_LONGRANGE'), ('Scale_gaussian', 'SCALE_GAUSSIAN'), ('Cutoff_radius', 'CUTOFF_RADIUS'), ('T_c_g_data', 'T_C_G_DATA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _point45(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _interaction_potential6(printable):
    """
    Parameters the interaction potential in computing the biel integrals
    """
    def __init__(self):
        self.Potential_type = None
        """
        Which interaction potential should be used (Coulomb, TShPSC operator).

        Available values:
            COULOMB
                Coulomb potential: 1/r
            TSHPSC
                TShPSC: 1/x - s/Rc  ->  for x<=Rc (1-s)/Rc - (x-Rc)/Rc^2 +
                (x-Rc)^2/Rc^3 - (2*n^2-7*n+9-4*s)*(x-Rc)^3/(Rc^4*(n^2-2*n+1)*(n-1)) +
                (6-3*s-4*n+n^2)*(x-Rc)^4/(Rc^5*(n^4-4*n^3+6*n^2-4*n+1))   -> for
                Rc<x<=n*Rc (4th order polynomial)  0  -> for x>n*Rc
        """
        self.Truncation_radius = None
        """
        Determines truncation radius for the truncated TShPSC potential. Only
        valid when doing truncated calculation
        """
        self.Tshpsc_data = None
        """
        Location of the file TShPSC.dat that contains the data for the
        evaluation of the TShPSC G0
        """
        self._name = "INTERACTION_POTENTIAL"
        self._keywords = [('Potential_type', 'POTENTIAL_TYPE'), ('Truncation_radius', 'TRUNCATION_RADIUS'), ('Tshpsc_data', 'TSHPSC_DATA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _interaction_potential1(printable):
    """
    Sets up interaction potential if requested
    """
    def __init__(self):
        self.Potential_type = None
        """
        Which interaction potential should be used (Coulomb, longrange or
        shortrange).

        Available values:
            COULOMB
                Coulomb potential: 1/r
            SHORTRANGE
                Shortrange potential: erfc(omega*r)/r
            LONGRANGE
                Longrange potential: erf(omega*r)/r
            MIX_CL
                Mix coulomb and longrange potential: 1/r + erf(omega*r)/r
            GAUSSIAN
                Damped Gaussian potential: exp(-omega^2*r^2)
            MIX_LG
                Mix Gaussian and longrange potential: erf(omega*r)/r +
                exp(-omega^2*r^2)
            IDENTITY
                Overlap
            TRUNCATED
                Truncated coulomb potential: if(r<R_c) 1/r else 0
            MIX_CL_TRUNC
                Truncated Mix coulomb and longrange potential, assumes/requires that
                the erf has fully decayed at R_c
        """
        self.Omega = None
        """
        Parameter for short/longrange interaction
        """
        self.Scale_coulomb = None
        """
        Scales Hartree-Fock contribution arising from a coulomb potential.
        Only valid when doing a mixed potential calculation
        """
        self.Scale_longrange = None
        """
        Scales Hartree-Fock contribution arising from a longrange potential.
        Only valid when doing a mixed potential calculation
        """
        self.Scale_gaussian = None
        """
        Scales Hartree-Fock contribution arising from a gaussian potential.
        Only valid when doing a mixed potential calculation
        """
        self.Cutoff_radius = None
        """
        Determines cutoff radius for the truncated 1/r potential. Only valid
        when doing truncated calculation
        """
        self.T_c_g_data = None
        """
        Location of the file t_c_g.dat that contains the data for the
        evaluation of the truncated gamma function
        """
        self._name = "INTERACTION_POTENTIAL"
        self._keywords = [('Potential_type', 'POTENTIAL_TYPE'), ('Omega', 'OMEGA'), ('Scale_coulomb', 'SCALE_COULOMB'), ('Scale_longrange', 'SCALE_LONGRANGE'), ('Scale_gaussian', 'SCALE_GAUSSIAN'), ('Cutoff_radius', 'CUTOFF_RADIUS'), ('T_c_g_data', 'T_C_G_DATA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _point42(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point41(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point40(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _plus_u1(printable):
    """
    Controls the printing for the DFT+U methods
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each217()
        self._name = "PLUS_U"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _respa1(printable):
    """
    Multiple timestep integration based on RESPA (implemented for NVE
    only). RESPA exploits multiple force_eval. In this case the order of
    the force_eval maps  the order of the respa shells from the slowest to
    the fastest force evaluation. If force_evals share the same subsys,
    it's enough then to specify the  subsys in the force_eval
    corresponding at the first index in the multiple_force_eval list
    """
    def __init__(self):
        self.Frequency = None
        """
        The number of reference MD steps between two RESPA corrections.
        """
        self._name = "RESPA"
        self._keywords = [('Frequency', 'FREQUENCY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _perm1(printable):
    """
    Permutation state used for restart
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify particle index permutation for every helium atom
        """
        self._name = "PERM"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _perm2(printable):
    """
    Controls the output of the helium permutation state
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each57()
        self._name = "PERM"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _add_mm_charge3(printable):
    """
    Specify information to add a classical charge before the QM/MM
    energies and forces evaluation
    """
    def __init__(self):
        self.Atom_index_1 = None
        """
        Specifies the index of the first atom defining the direction along
        which the atom will be added
        """
        self.Atom_index_2 = None
        """
        Specifies the index of the second atom defining the direction along
        which  the atom will be added
        """
        self.Alpha = None
        """
        Specifies the scaling factor that defines the movement along the
        defined direction
        """
        self.Radius = None
        """
        Specifies the radius used for the QM/MM electrostatic coupling for the
        added source
        """
        self.Corr_radius = None
        """
        Specifies the correction radius used for the QM/MM electrostatic
        coupling for the added source
        """
        self.Charge = None
        """
        Specifies the charge for the added source of QM/MM potential
        """
        self._name = "ADD_MM_CHARGE"
        self._keywords = [('Atom_index_1', 'ATOM_INDEX_1'), ('Atom_index_2', 'ATOM_INDEX_2'), ('Alpha', 'ALPHA'), ('Radius', 'RADIUS'), ('Corr_radius', 'CORR_RADIUS'), ('Charge', 'CHARGE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Mm1(self):
        """
        See documentation for Atom_index_1
        """
        return self.Atom_index_1

    @property
    def Mm2(self):
        """
        See documentation for Atom_index_2
        """
        return self.Atom_index_2

    @Mm1.setter
    def Mm1(self, value):
        self.Atom_index_1 = value

    @Mm2.setter
    def Mm2(self, value):
        self.Atom_index_2 = value



class _add_mm_charge2(printable):
    """
    Specify information to add a classical charge before the QM/MM
    energies and forces evaluation
    """
    def __init__(self):
        self.Atom_index_1 = None
        """
        Specifies the index of the first atom defining the direction along
        which the atom will be added
        """
        self.Atom_index_2 = None
        """
        Specifies the index of the second atom defining the direction along
        which  the atom will be added
        """
        self.Alpha = None
        """
        Specifies the scaling factor that defines the movement along the
        defined direction
        """
        self.Radius = None
        """
        Specifies the radius used for the QM/MM electrostatic coupling for the
        added source
        """
        self.Corr_radius = None
        """
        Specifies the correction radius used for the QM/MM electrostatic
        coupling for the added source
        """
        self.Charge = None
        """
        Specifies the charge for the added source of QM/MM potential
        """
        self._name = "ADD_MM_CHARGE"
        self._keywords = [('Atom_index_1', 'ATOM_INDEX_1'), ('Atom_index_2', 'ATOM_INDEX_2'), ('Alpha', 'ALPHA'), ('Radius', 'RADIUS'), ('Corr_radius', 'CORR_RADIUS'), ('Charge', 'CHARGE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Mm1(self):
        """
        See documentation for Atom_index_1
        """
        return self.Atom_index_1

    @property
    def Mm2(self):
        """
        See documentation for Atom_index_2
        """
        return self.Atom_index_2

    @Mm1.setter
    def Mm1(self, value):
        self.Atom_index_1 = value

    @Mm2.setter
    def Mm2(self, value):
        self.Atom_index_2 = value



class _add_mm_charge1(printable):
    """
    Specify information to add a classical charge before the QM/MM
    energies and forces evaluation
    """
    def __init__(self):
        self.Atom_index_1 = None
        """
        Specifies the index of the first atom defining the direction along
        which the atom will be added
        """
        self.Atom_index_2 = None
        """
        Specifies the index of the second atom defining the direction along
        which  the atom will be added
        """
        self.Alpha = None
        """
        Specifies the scaling factor that defines the movement along the
        defined direction
        """
        self.Radius = None
        """
        Specifies the radius used for the QM/MM electrostatic coupling for the
        added source
        """
        self.Corr_radius = None
        """
        Specifies the correction radius used for the QM/MM electrostatic
        coupling for the added source
        """
        self.Charge = None
        """
        Specifies the charge for the added source of QM/MM potential
        """
        self._name = "ADD_MM_CHARGE"
        self._keywords = [('Atom_index_1', 'ATOM_INDEX_1'), ('Atom_index_2', 'ATOM_INDEX_2'), ('Alpha', 'ALPHA'), ('Radius', 'RADIUS'), ('Corr_radius', 'CORR_RADIUS'), ('Charge', 'CHARGE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Mm1(self):
        """
        See documentation for Atom_index_1
        """
        return self.Atom_index_1

    @property
    def Mm2(self):
        """
        See documentation for Atom_index_2
        """
        return self.Atom_index_2

    @Mm1.setter
    def Mm1(self, value):
        self.Atom_index_1 = value

    @Mm2.setter
    def Mm2(self, value):
        self.Atom_index_2 = value



class _se1(printable):
    """
    Parameters needed to set up the Semi-empirical methods
    """
    def __init__(self):
        self.Orthogonal_basis = None
        """
        Assume orthogonal basis set. This flag is overwritten by methods with
        fixed orthogonal/non-orthogonal basis set.
        """
        self.Sto_ng = None
        """
        Provides the order of the Slater orbital expansion of Gaussian-Type
        Orbitals.
        """
        self.Analytical_gradients = None
        """
        Nuclear Gradients are computed analytically or numerically
        """
        self.Delta = None
        """
        Step size in finite difference force calculation
        """
        self.Integral_screening = None
        """
        Specifies the functional form for the

        Available values:
            KDSO
                Uses the standard NDDO Klopman-Dewar-Sabelli-Ohno equation for the
                screening of the Coulomb interactions.
            KDSO-D
                Uses a modified Klopman-Dewar-Sabelli-Ohno equation, dumping the
                screening parameter for the Coulomb interactions.
            SLATER
                Uses an exponential Slater-type function for modelling the Coulomb
                interactions.
        """
        self.Periodic = None
        """
        Specifies the type of treatment for the electrostatic long-range part
        in semi-empirical calculations.

        Available values:
            NONE
                The long-range part is not explicitly treaten. The interaction depends
                uniquely on the Cutoffs used for the calculation.
            EWALD
                Enables the usage of Multipoles Ewald summation schemes. The short-
                range part is tapered according the value of RC_COULOMB.
            EWALD_R3
                Enables the usage of Multipoles Ewald summation schemes together with
                a long-range treatment for the 1/R^3 term, deriving from the short-
                range component. This option is active only for K-DSO integral
                screening type.
            EWALD_GKS
                Use Ewald directly in Coulomb integral evaluation, works only with
                Slater screening
        """
        self.Scp = None
        """
        Perform a SCP-NDDO calculation
        """
        self.Force_kdso_d_exchange = None
        """
        This keywords forces the usage of the KDSO-D integral screening for
        the Exchange integrals (default is to apply the screening only to the
        Coulomb integrals.
        """
        self.COULOMB = _coulomb1()
        self.EXCHANGE = _exchange1()
        self.SCREENING = _screening1()
        self.LR_CORRECTION = _lr_correction1()
        self.NEIGHBOR_LISTS = _neighbor_lists2()
        self.MEMORY = _memory1()
        self.PRINT = _print20()
        self.GA = _ga1()
        self._name = "SE"
        self._keywords = [('Orthogonal_basis', 'ORTHOGONAL_BASIS'), ('Sto_ng', 'STO_NG'), ('Analytical_gradients', 'ANALYTICAL_GRADIENTS'), ('Delta', 'DELTA'), ('Integral_screening', 'INTEGRAL_SCREENING'), ('Periodic', 'PERIODIC'), ('Scp', 'SCP'), ('Force_kdso_d_exchange', 'FORCE_KDSO-D_EXCHANGE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('COULOMB', 'COULOMB'), ('EXCHANGE', 'EXCHANGE'), ('SCREENING', 'SCREENING'), ('LR_CORRECTION', 'LR_CORRECTION'), ('NEIGHBOR_LISTS', 'NEIGHBOR_LISTS'), ('MEMORY', 'MEMORY'), ('PRINT', 'PRINT'), ('GA', 'GA')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _mol_set1(printable):
    """
    Specify the connectivity of a full system specifying the connectivity
    of the fragments of the system.
    """
    def __init__(self):
        self.list_MOLECULE = []
        self.MERGE_MOLECULES = _merge_molecules1()
        self._name = "MOL_SET"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('MERGE_MOLECULES', 'MERGE_MOLECULES')]
        self._repeated_subsections = [('MOLECULE', '_molecule1')]

    def add_MOLECULE(self):
        new_section = _molecule1()
        self.list_MOLECULE.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _temp_kind1(printable):
    """
    Controls the output of the temperature computed separately for each
    kind
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each35()
        self._name = "TEMP_KIND"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _v_resp_cube1(printable):
    """
    Controls the printing of the potential generated by the RESP CHARGES
    to a cube file. Prints the relative root-mean-square (RRMS) and root-
    mean-square (RMS) errors.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Stride = None
        """
        The stride (X,Y,Z) used to write the cube file (larger values result
        in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1
        number valid for all components.
        """
        self.Append = None
        """
        append the cube files when they already exist
        """
        self.EACH = _each332()
        self._name = "V_RESP_CUBE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Stride', 'STRIDE'), ('Append', 'APPEND')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _transition_state1(printable):
    """
    Specifies parameters to perform a transition state search
    """
    def __init__(self):
        self.Method = None
        """
        Specify which kind of method to use for locating transition states

        Available values:
            DIMER
                Uses the dimer method to optimize transition states.
        """
        self.DIMER = _dimer1()
        self._name = "TRANSITION_STATE"
        self._keywords = [('Method', 'METHOD')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('DIMER', 'DIMER')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _mgrid1(printable):
    """
    multigrid information
    """
    def __init__(self):
        self.Ngrids = None
        """
        The number of multigrids to use
        """
        self.Cutoff = None
        """
        The cutoff of the finest grid level. Default value for SE or DFTB
        calculation is 1.0 [Ry].
        """
        self.Progression_factor = None
        """
        Factor used to find the cutoff of the multigrids that where not given
        explicitly
        """
        self.Commensurate = None
        """
        If the grids should be commensurate. If true overrides the progression
        factor and the cutoffs of the sub grids
        """
        self.Realspace = None
        """
        If both rho and rho_gspace are needed
        """
        self.Rel_cutoff = None
        """
        Determines the grid at which a Gaussian is mapped, giving the cutoff
        used for a gaussian with alpha=1. A value 50+-10Ry might be required
        for highly accurate results,  Or for simulations with a variable cell.
        Versions prior to 2.3 used a default of 30Ry.
        """
        self.Multigrid_set = None
        """
        Activate a manual setting of the multigrids
        """
        self.Skip_load_balance_distributed = None
        """
        Skip load balancing on distributed multigrids, which might be memory
        intensive.If not explicitly specified, runs using more than 1024 MPI
        tasks will default to .TRUE.
        """
        self.Multigrid_cutoff = None
        """
        List of cutoff values to set up multigrids manually
        """
        self.list_RS_GRID = []
        self.INTERPOLATOR = _interpolator1()
        self._name = "MGRID"
        self._keywords = [('Ngrids', 'NGRIDS'), ('Cutoff', 'CUTOFF'), ('Progression_factor', 'PROGRESSION_FACTOR'), ('Commensurate', 'COMMENSURATE'), ('Realspace', 'REALSPACE'), ('Rel_cutoff', 'REL_CUTOFF'), ('Multigrid_set', 'MULTIGRID_SET'), ('Skip_load_balance_distributed', 'SKIP_LOAD_BALANCE_DISTRIBUTED'), ('Multigrid_cutoff', 'MULTIGRID_CUTOFF')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('INTERPOLATOR', 'INTERPOLATOR')]
        self._repeated_subsections = [('RS_GRID', '_rs_grid2')]

    def add_RS_GRID(self):
        new_section = _rs_grid2()
        self.list_RS_GRID.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Relative_cutoff(self):
        """
        See documentation for Rel_cutoff
        """
        return self.Rel_cutoff

    @property
    def Cutoff_list(self):
        """
        See documentation for Multigrid_cutoff
        """
        return self.Multigrid_cutoff

    @Relative_cutoff.setter
    def Relative_cutoff(self, value):
        self.Rel_cutoff = value

    @Cutoff_list.setter
    def Cutoff_list(self, value):
        self.Multigrid_cutoff = value



class _eip1(printable):
    """
    This section contains all information to run a EIP calculation.
    """
    def __init__(self):
        self.Eip_model = None
        """
        Selects the empirical interaction potential model

        Available values:
            BAZANT
            EDIP
            LENOSKY
        """
        self.Eip_model = None
        """
        Selects the empirical interaction potential model

        Available values:
            BAZANT
            EDIP
            LENOSKY
        """
        self.PRINT = _print40()
        self._name = "EIP"
        self._keywords = [('Eip_model', 'EIP_MODEL'), ('Eip_model', 'EIP-MODEL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _charges1(printable):
    """
    Allow to specify an array of classical charges, thus avoiding the
    packing and permitting the usage of different charges for same atomic
    types.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Value of the charge for the individual atom. Order MUST reflect the
        one specified for the geometry.
        """
        self._name = "CHARGES"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _eigensolver1(printable):
    """
    Benchmark and test the eigensolver routines.
    """
    def __init__(self):
        self.N = None
        """
        Dimension of the square matrix
        """
        self.N_loop = None
        """
        Number of operations being timed (useful for small matrices).
        """
        self.Diag_method = None
        """
        Diagonalization strategy

        Available values:
            SYEVD
                (sca)lapacks syevd
            SYEVX
                (sca)lapacks syevx
        """
        self.Eigenvalues = None
        """
        number of eigenvalues to be computed (all=<0)
        """
        self.Init_method = None
        """
        Initialization approach

        Available values:
            RANDOM
                use a random initial matrix
            READ
                read a matrix from file MATRIX
        """
        self._name = "EIGENSOLVER"
        self._keywords = [('N', 'N'), ('N_loop', 'N_LOOP'), ('Diag_method', 'DIAG_METHOD'), ('Eigenvalues', 'EIGENVALUES'), ('Init_method', 'INIT_METHOD')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _diis1(printable):
    """
    Activate the DIIS based optimization procedure for BAND
    """
    def __init__(self):
        self.Max_sd_steps = None
        """
        Specify the maximum number of SD steps to perform before switching on
        DIIS (the minimum number will always be equal to N_DIIS).
        """
        self.Max_steps = None
        """
        Specify the maximum number of optimization steps
        """
        self.N_diis = None
        """
        Number of history vectors to be used with DIIS
        """
        self.Stepsize = None
        """
        Initial stepsize used for the line search, sometimes this parametercan
        be reduced to stablize DIIS
        """
        self.Max_stepsize = None
        """
        Maximum stepsize used for the line search, sometimes this parametercan
        be reduced to stablize the LS for particularly difficult initial
        geometries
        """
        self.Np_ls = None
        """
        Number of points used in the line search SD.
        """
        self.No_ls = None
        """
        Does not perform LS during SD. Useful in combination with a proper
        STEPSIZE for particularly out of equilibrium starting geometries.
        """
        self.Check_diis = None
        """
        Performes a series of checks on the DIIS solution in order to accept
        the DIIS step. If set to .FALSE. the only check performed is that the
        angle between the DIIS solution and the reference vector is less than
        Pi/2. Can be useful if many DIIS steps are rejected.
        """
        self.DIIS_INFO = _diis_info1()
        self._name = "DIIS"
        self._keywords = [('Max_sd_steps', 'MAX_SD_STEPS'), ('Max_steps', 'MAX_STEPS'), ('N_diis', 'N_DIIS'), ('Stepsize', 'STEPSIZE'), ('Max_stepsize', 'MAX_STEPSIZE'), ('Np_ls', 'NP_LS'), ('No_ls', 'NO_LS'), ('Check_diis', 'CHECK_DIIS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('DIIS_INFO', 'DIIS_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Ndiis(self):
        """
        See documentation for N_diis
        """
        return self.N_diis

    @Ndiis.setter
    def Ndiis(self, value):
        self.N_diis = value



class _distance_point_plane4(printable):
    """
    Section to define the distance of a point from a plane as a collective
    variables.
    """
    def __init__(self):
        self.Pbc = None
        """
        Whether periodic boundary conditions should be applied on the atomic
        position before computing the colvar or not.
        """
        self.Atoms_plane = None
        """
        Specifies the indexes of atoms/points defining the plane.
        """
        self.Atom_point = None
        """
        Specifies the atom/point index defining the point.
        """
        self.list_POINT = []
        self._name = "DISTANCE_POINT_PLANE"
        self._keywords = [('Pbc', 'PBC'), ('Atoms_plane', 'ATOMS_PLANE'), ('Atom_point', 'ATOM_POINT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point61')]

    def add_POINT(self):
        new_section = _point61()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Points_plane(self):
        """
        See documentation for Atoms_plane
        """
        return self.Atoms_plane

    @property
    def Point_point(self):
        """
        See documentation for Atom_point
        """
        return self.Atom_point

    @Points_plane.setter
    def Points_plane(self, value):
        self.Atoms_plane = value

    @Point_point.setter
    def Point_point(self, value):
        self.Atom_point = value



class _distance_point_plane1(printable):
    """
    Section to define the distance of a point from a plane as a collective
    variables.
    """
    def __init__(self):
        self.Pbc = None
        """
        Whether periodic boundary conditions should be applied on the atomic
        position before computing the colvar or not.
        """
        self.Atoms_plane = None
        """
        Specifies the indexes of atoms/points defining the plane.
        """
        self.Atom_point = None
        """
        Specifies the atom/point index defining the point.
        """
        self.list_POINT = []
        self._name = "DISTANCE_POINT_PLANE"
        self._keywords = [('Pbc', 'PBC'), ('Atoms_plane', 'ATOMS_PLANE'), ('Atom_point', 'ATOM_POINT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point7')]

    def add_POINT(self):
        new_section = _point7()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Points_plane(self):
        """
        See documentation for Atoms_plane
        """
        return self.Atoms_plane

    @property
    def Point_point(self):
        """
        See documentation for Atom_point
        """
        return self.Atom_point

    @Points_plane.setter
    def Points_plane(self, value):
        self.Atoms_plane = value

    @Point_point.setter
    def Point_point(self, value):
        self.Atom_point = value



class _distance_point_plane2(printable):
    """
    Section to define the distance of a point from a plane as a collective
    variables.
    """
    def __init__(self):
        self.Pbc = None
        """
        Whether periodic boundary conditions should be applied on the atomic
        position before computing the colvar or not.
        """
        self.Atoms_plane = None
        """
        Specifies the indexes of atoms/points defining the plane.
        """
        self.Atom_point = None
        """
        Specifies the atom/point index defining the point.
        """
        self.list_POINT = []
        self._name = "DISTANCE_POINT_PLANE"
        self._keywords = [('Pbc', 'PBC'), ('Atoms_plane', 'ATOMS_PLANE'), ('Atom_point', 'ATOM_POINT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point25')]

    def add_POINT(self):
        new_section = _point25()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Points_plane(self):
        """
        See documentation for Atoms_plane
        """
        return self.Atoms_plane

    @property
    def Point_point(self):
        """
        See documentation for Atom_point
        """
        return self.Atom_point

    @Points_plane.setter
    def Points_plane(self, value):
        self.Atoms_plane = value

    @Point_point.setter
    def Point_point(self, value):
        self.Atom_point = value



class _distance_point_plane3(printable):
    """
    Section to define the distance of a point from a plane as a collective
    variables.
    """
    def __init__(self):
        self.Pbc = None
        """
        Whether periodic boundary conditions should be applied on the atomic
        position before computing the colvar or not.
        """
        self.Atoms_plane = None
        """
        Specifies the indexes of atoms/points defining the plane.
        """
        self.Atom_point = None
        """
        Specifies the atom/point index defining the point.
        """
        self.list_POINT = []
        self._name = "DISTANCE_POINT_PLANE"
        self._keywords = [('Pbc', 'PBC'), ('Atoms_plane', 'ATOMS_PLANE'), ('Atom_point', 'ATOM_POINT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point43')]

    def add_POINT(self):
        new_section = _point43()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Points_plane(self):
        """
        See documentation for Atoms_plane
        """
        return self.Atoms_plane

    @property
    def Point_point(self):
        """
        See documentation for Atom_point
        """
        return self.Atom_point

    @Points_plane.setter
    def Points_plane(self, value):
        self.Atoms_plane = value

    @Point_point.setter
    def Point_point(self, value):
        self.Atom_point = value



class _staging1(printable):
    """
    The section that controls the staging transformation
    """
    def __init__(self):
        self.J = None
        """
        Value of the j parameter for the staging transformation
        """
        self.Q_end = None
        """
        Value of the nose-hoover mass for the endbead (Q_end)
        """
        self._name = "STAGING"
        self._keywords = [('J', 'J'), ('Q_end', 'Q_END')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _tersoff1(printable):
    """
    This section specifies the input parameters for Tersoff potential
    type.
    """
    def __init__(self):
        self.Atoms = None
        """
        Defines the atomic kind involved in the nonbond potential
        """
        self.A = None
        """
        Defines the A parameter of Tersoff potential
        """
        self.B = None
        """
        Defines the B parameter of Tersoff potential
        """
        self.Lambda1 = None
        """
        Defines the lambda1 parameter of Tersoff potential
        """
        self.Lambda2 = None
        """
        Defines the lambda2 parameter of Tersoff potential
        """
        self.Alpha = None
        """
        Defines the alpha parameter of Tersoff potential
        """
        self.Beta = None
        """
        Defines the beta parameter of Tersoff potential
        """
        self.N = None
        """
        Defines the n parameter of Tersoff potential
        """
        self.C = None
        """
        Defines the c parameter of Tersoff potential
        """
        self.D = None
        """
        Defines the d parameter of Tersoff potential
        """
        self.H = None
        """
        Defines the h parameter of Tersoff potential
        """
        self.Lambda3 = None
        """
        Defines the lambda3 parameter of Tersoff potential
        """
        self.Bigr = None
        """
        Defines the bigR parameter of Tersoff potential
        """
        self.Bigd = None
        """
        Defines the D parameter of Tersoff potential
        """
        self.Rcut = None
        """
        Defines the cutoff parameter of the tersoff potential.  This parameter
        is in principle already defined by the values of  bigD and bigR. But
        it is necessary to define it when using the tersoff  in conjuction
        with other potentials (for the same atomic pair) in order to have the
        same consistent definition of RCUT for all potentials.
        """
        self._name = "TERSOFF"
        self._keywords = [('Atoms', 'ATOMS'), ('A', 'A'), ('B', 'B'), ('Lambda1', 'LAMBDA1'), ('Lambda2', 'LAMBDA2'), ('Alpha', 'ALPHA'), ('Beta', 'BETA'), ('N', 'N'), ('C', 'C'), ('D', 'D'), ('H', 'H'), ('Lambda3', 'LAMBDA3'), ('Bigr', 'BIGR'), ('Bigd', 'BIGD'), ('Rcut', 'RCUT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _multipoles1(printable):
    """
    Enables the use of multipoles in the treatment of the electrostatics.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Controls the activation of the Multipoles
        """
        self.Max_multipole_expansion = None
        """
        Specify the maximum level of multipoles expansion used  for the
        electrostatics.

        Available values:
            NONE
                No multipolar terms! Check the codes providing a zero contribution.
            CHARGE
                Use up to the Charge term
            DIPOLE
                Use up to the Dipole term
            QUADRUPOLE
                Use up to the Quadrupole term
        """
        self.Pol_scf = None
        """
        Specify the method to obtain self consistent induced multipole
        moments.

        Available values:
            NONE
                No inducible multipoles.
            SELF_CONSISTENT
                Conventional self-consistent iteration.
            CONJUGATE_GRADIENT
                Linear conjugate-gradient optimization of the sum of the electrostatic
                and induction energy. This method does not support non-linear
                polarization but is sometimes faster.
        """
        self.Max_ipol_iter = None
        """
        Specify the maximum number of iterations for induced dipoles
        """
        self.Eps_pol = None
        """
        Specify the rmsd threshold for the derivatives of the energy towards
        the Cartesian dipoles components
        """
        self._name = "MULTIPOLES"
        self._keywords = [('Max_multipole_expansion', 'MAX_MULTIPOLE_EXPANSION'), ('Pol_scf', 'POL_SCF'), ('Max_ipol_iter', 'MAX_IPOL_ITER'), ('Eps_pol', 'EPS_POL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _angle5(printable):
    """
    Section to define the angle as a collective variables.
    """
    def __init__(self):
        self.Atoms = None
        """
        Specifies the indexes of atoms/points defining the angle.
        """
        self.list_POINT = []
        self._name = "ANGLE"
        self._keywords = [('Atoms', 'ATOMS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point56')]

    def add_POINT(self):
        new_section = _point56()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Points(self):
        """
        See documentation for Atoms
        """
        return self.Atoms

    @Points.setter
    def Points(self, value):
        self.Atoms = value



class _angle4(printable):
    """
    Section to define the angle as a collective variables.
    """
    def __init__(self):
        self.Atoms = None
        """
        Specifies the indexes of atoms/points defining the angle.
        """
        self.list_POINT = []
        self._name = "ANGLE"
        self._keywords = [('Atoms', 'ATOMS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point38')]

    def add_POINT(self):
        new_section = _point38()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Points(self):
        """
        See documentation for Atoms
        """
        return self.Atoms

    @Points.setter
    def Points(self, value):
        self.Atoms = value



class _angle3(printable):
    """
    Section to define the angle as a collective variables.
    """
    def __init__(self):
        self.Atoms = None
        """
        Specifies the indexes of atoms/points defining the angle.
        """
        self.list_POINT = []
        self._name = "ANGLE"
        self._keywords = [('Atoms', 'ATOMS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point20')]

    def add_POINT(self):
        new_section = _point20()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Points(self):
        """
        See documentation for Atoms
        """
        return self.Atoms

    @Points.setter
    def Points(self, value):
        self.Atoms = value



class _angle2(printable):
    """
    Section to define the angle as a collective variables.
    """
    def __init__(self):
        self.Atoms = None
        """
        Specifies the indexes of atoms/points defining the angle.
        """
        self.list_POINT = []
        self._name = "ANGLE"
        self._keywords = [('Atoms', 'ATOMS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point2')]

    def add_POINT(self):
        new_section = _point2()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Points(self):
        """
        See documentation for Atoms
        """
        return self.Atoms

    @Points.setter
    def Points(self, value):
        self.Atoms = value



class _angle1(printable):
    """
    Section used to add/remove angles in the connectivity. Useful for
    systems with a complex connectivity, difficult to find out
    automatically.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        controls the activation of the bond

        Available values:
            ADD
            REMOVE
        """
        self.list_Atoms = []
        self._name = "ANGLE"
        self._keywords = []
        self._repeated_keywords = [('Atoms', 'ATOMS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _molecular_dipoles4(printable):
    """
    Section controlling the calculation of MOLECULAR_DIPOLES. Note that
    the result in the periodic case might be defined modulo a certain
    period, determined by the lattice vectors. During MD, this can lead to
    jumps.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Periodic = None
        """
        Use Berry phase formula (PERIODIC=T) or simple operator (PERIODIC=F).
        The latter normally requires that the CELL is periodic NONE.
        """
        self.Reference = None
        """
        Define the reference point for the calculation of the electrostatic
        moment.

        Available values:
            COM
                Use Center of Mass
            COAC
                Use Center of Atomic Charges
            USER_DEFINED
                Use User Defined Point (Keyword:REF_POINT)
            ZERO
                Use Origin of Coordinate System
        """
        self.Reference_point = None
        """
        Fixed reference point for the calculations of the electrostatic
        moment.
        """
        self.EACH = _each292()
        self._name = "MOLECULAR_DIPOLES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Periodic', 'PERIODIC'), ('Reference', 'REFERENCE'), ('Reference_point', 'REFERENCE_POINT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Ref(self):
        """
        See documentation for Reference
        """
        return self.Reference

    @property
    def Ref_point(self):
        """
        See documentation for Reference_point
        """
        return self.Reference_point

    @Ref.setter
    def Ref(self, value):
        self.Reference = value

    @Ref_point.setter
    def Ref_point(self, value):
        self.Reference_point = value



class _molecular_dipoles3(printable):
    """
    Section controlling the calculation of MOLECULAR_DIPOLES. Note that
    the result in the periodic case might be defined modulo a certain
    period, determined by the lattice vectors. During MD, this can lead to
    jumps.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Periodic = None
        """
        Use Berry phase formula (PERIODIC=T) or simple operator (PERIODIC=F).
        The latter normally requires that the CELL is periodic NONE.
        """
        self.Reference = None
        """
        Define the reference point for the calculation of the electrostatic
        moment.

        Available values:
            COM
                Use Center of Mass
            COAC
                Use Center of Atomic Charges
            USER_DEFINED
                Use User Defined Point (Keyword:REF_POINT)
            ZERO
                Use Origin of Coordinate System
        """
        self.Reference_point = None
        """
        Fixed reference point for the calculations of the electrostatic
        moment.
        """
        self.EACH = _each203()
        self._name = "MOLECULAR_DIPOLES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Periodic', 'PERIODIC'), ('Reference', 'REFERENCE'), ('Reference_point', 'REFERENCE_POINT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Ref(self):
        """
        See documentation for Reference
        """
        return self.Reference

    @property
    def Ref_point(self):
        """
        See documentation for Reference_point
        """
        return self.Reference_point

    @Ref.setter
    def Ref(self, value):
        self.Reference = value

    @Ref_point.setter
    def Ref_point(self, value):
        self.Reference_point = value



class _molecular_dipoles2(printable):
    """
    Section controlling the calculation of MOLECULAR_DIPOLES. Note that
    the result in the periodic case might be defined modulo a certain
    period, determined by the lattice vectors. During MD, this can lead to
    jumps.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Periodic = None
        """
        Use Berry phase formula (PERIODIC=T) or simple operator (PERIODIC=F).
        The latter normally requires that the CELL is periodic NONE.
        """
        self.Reference = None
        """
        Define the reference point for the calculation of the electrostatic
        moment.

        Available values:
            COM
                Use Center of Mass
            COAC
                Use Center of Atomic Charges
            USER_DEFINED
                Use User Defined Point (Keyword:REF_POINT)
            ZERO
                Use Origin of Coordinate System
        """
        self.Reference_point = None
        """
        Fixed reference point for the calculations of the electrostatic
        moment.
        """
        self.EACH = _each171()
        self._name = "MOLECULAR_DIPOLES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Periodic', 'PERIODIC'), ('Reference', 'REFERENCE'), ('Reference_point', 'REFERENCE_POINT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Ref(self):
        """
        See documentation for Reference
        """
        return self.Reference

    @property
    def Ref_point(self):
        """
        See documentation for Reference_point
        """
        return self.Reference_point

    @Ref.setter
    def Ref(self, value):
        self.Reference = value

    @Ref_point.setter
    def Ref_point(self, value):
        self.Reference_point = value



class _molecular_dipoles1(printable):
    """
    Section controlling the calculation of MOLECULAR_DIPOLES. Note that
    the result in the periodic case might be defined modulo a certain
    period, determined by the lattice vectors. During MD, this can lead to
    jumps.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Periodic = None
        """
        Use Berry phase formula (PERIODIC=T) or simple operator (PERIODIC=F).
        The latter normally requires that the CELL is periodic NONE.
        """
        self.Reference = None
        """
        Define the reference point for the calculation of the electrostatic
        moment.

        Available values:
            COM
                Use Center of Mass
            COAC
                Use Center of Atomic Charges
            USER_DEFINED
                Use User Defined Point (Keyword:REF_POINT)
            ZERO
                Use Origin of Coordinate System
        """
        self.Reference_point = None
        """
        Fixed reference point for the calculations of the electrostatic
        moment.
        """
        self.EACH = _each150()
        self._name = "MOLECULAR_DIPOLES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Periodic', 'PERIODIC'), ('Reference', 'REFERENCE'), ('Reference_point', 'REFERENCE_POINT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Ref(self):
        """
        See documentation for Reference
        """
        return self.Reference

    @property
    def Ref_point(self):
        """
        See documentation for Reference_point
        """
        return self.Reference_point

    @Ref.setter
    def Ref(self, value):
        self.Reference = value

    @Ref_point.setter
    def Ref_point(self, value):
        self.Reference_point = value



class _velocity1(printable):
    """
    The velocities for BAROSTAT used for restart
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify velocities of the system
        """
        self._name = "VELOCITY"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _velocity2(printable):
    """
    The velocities for NOSE HOOVER used for restart
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify velocities of the system
        """
        self._name = "VELOCITY"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _mixed_energies1(printable):
    """
    Controls the output of the energies of the tworegular FORCE_EVALS in
    the MIXED methodprinted is step,time,Etot,E_F1,E_F2,CONS_QNT
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each84()
        self._name = "MIXED_ENERGIES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _p86c3(printable):
    """
    Uses the P86C functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_c = None
        """
        scales the correlation part of the functional
        """
        self._name = "P86C"
        self._keywords = [('Scale_c', 'SCALE_C')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _free_energy1(printable):
    """
    Controls the calculation of free energy and free energy derivatives
    with different possible methods
    """
    def __init__(self):
        self.Method = None
        """
        Defines the method to use to compute free energy.

        Available values:
            METADYN
                Metadynamics
            UI
                Umbrella Integration
            AC
                Alchemical Change
        """
        self.METADYN = _metadyn1()
        self.UMBRELLA_INTEGRATION = _umbrella_integration1()
        self.ALCHEMICAL_CHANGE = _alchemical_change1()
        self.FREE_ENERGY_INFO = _free_energy_info1()
        self._name = "FREE_ENERGY"
        self._keywords = [('Method', 'METHOD')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('METADYN', 'METADYN'), ('UMBRELLA_INTEGRATION', 'UMBRELLA_INTEGRATION'), ('ALCHEMICAL_CHANGE', 'ALCHEMICAL_CHANGE'), ('FREE_ENERGY_INFO', 'FREE_ENERGY_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _p86c4(printable):
    """
    Uses the P86C functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_c = None
        """
        scales the correlation part of the functional
        """
        self._name = "P86C"
        self._keywords = [('Scale_c', 'SCALE_C')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _molecule1(printable):
    """
    Specify information about the connectivity of single molecules
    """
    def __init__(self):
        self.Nmol = None
        """
        number of molecules
        """
        self.Conn_file_name = None
        """
        Specifies the filename that contains the molecular connectivity.
        """
        self.Conn_file_format = None
        """
        Ways to determine and generate a molecules. Default is to use GENERATE

        Available values:
            PSF
                Use  a PSF file to determine the connectivity. (support standard
                CHARMM/XPLOR and EXT CHARMM)
            UPSF
                Read a PSF file in an unformatted way (useful for not so standard
                PSF).
            MOL_SET
                Use multiple PSF (for now...) files to generate the whole sytem.
            GENERATE
                Use a simple distance criteria. (Look at keyword BONDPARM)
            OFF
                Do not generate molecules. (e.g. for QS or ill defined systems)
            G87
                Use GROMOS G87 topology file.
            G96
                Use GROMOS G96 topology file.
            AMBER
                Use AMBER topology file for reading connectivity (compatible starting
                from AMBER V.7)
            USER
                Allows the definition of molecules and residues based on the 5th and
                6th column of the COORD section. This option can be handy for the
                definition of molecules with QS or to save memory in the case of very
                large systems (use PARA_RES off).
        """
        self._name = "MOLECULE"
        self._keywords = [('Nmol', 'NMOL'), ('Conn_file_name', 'CONN_FILE_NAME'), ('Conn_file_format', 'CONN_FILE_FORMAT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Conn_file(self):
        """
        See documentation for Conn_file_name
        """
        return self.Conn_file_name

    @property
    def Connectivity(self):
        """
        See documentation for Conn_file_format
        """
        return self.Conn_file_format

    @Conn_file.setter
    def Conn_file(self, value):
        self.Conn_file_name = value

    @Connectivity.setter
    def Connectivity(self, value):
        self.Conn_file_format = value



class _rotational_info2(printable):
    """
    Controls the printing basic info during the calculation of the
    translational/rotational degrees of freedom.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Coordinates = None
        """
        Prints atomic coordinates in the standard orientation. Coordinates are
        not affected during the calculation.
        """
        self.EACH = _each39()
        self._name = "ROTATIONAL_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Coordinates', 'COORDINATES')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _rotational_info3(printable):
    """
    Controls the printing basic info during the cleaning of the rotational
    degrees of freedom.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Coordinates = None
        """
        Prints atomic coordinates after rotation
        """
        self.EACH = _each353()
        self._name = "ROTATIONAL_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Coordinates', 'COORDINATES')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _rotational_info1(printable):
    """
    Controls the printing basic info during the cleaning of the rotational
    degrees of freedom.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Coordinates = None
        """
        Prints atomic coordinates after rotation
        """
        self.EACH = _each11()
        self._name = "ROTATIONAL_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Coordinates', 'COORDINATES')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _free_energy_info1(printable):
    """
    Controls the printing of basic and summary information during the Free
    Energy calculation
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each45()
        self._name = "FREE_ENERGY_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _flexible_partitioning1(printable):
    """
    This section sets up flexible_partitioning
    """
    def __init__(self):
        self.Central_atom = None
        """
        Specifies the central atom.
        """
        self.Inner_atoms = None
        """
        Specifies the list of atoms that should remain close to the central
        atom.
        """
        self.Outer_atoms = None
        """
        Specifies the list of atoms that should remain far from the central
        atom.
        """
        self.Inner_radius = None
        """
        radius of the inner wall
        """
        self.Outer_radius = None
        """
        radius of the outer wall
        """
        self.Strength = None
        """
        Sets the force constant of the repulsive harmonic potential
        """
        self.Bias = None
        """
        If a bias potential counter-acting the weight term should be applied
        (recommended).
        """
        self.Temperature = None
        """
        Sets the temperature parameter that is used in the baising
        potential.It is recommended to use the actual simulation temperature
        """
        self.Smooth_width = None
        """
        Sets the width of the smooth counting function.
        """
        self.WEIGHTS = _weights1()
        self.CONTROL = _control1()
        self._name = "FLEXIBLE_PARTITIONING"
        self._keywords = [('Central_atom', 'CENTRAL_ATOM'), ('Inner_atoms', 'INNER_ATOMS'), ('Outer_atoms', 'OUTER_ATOMS'), ('Inner_radius', 'INNER_RADIUS'), ('Outer_radius', 'OUTER_RADIUS'), ('Strength', 'STRENGTH'), ('Bias', 'BIAS'), ('Temperature', 'TEMPERATURE'), ('Smooth_width', 'SMOOTH_WIDTH')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('WEIGHTS', 'WEIGHTS'), ('CONTROL', 'CONTROL')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _mm_kind1(printable):
    """
    Information about the mm kind in the qm/mm scheme
    """
    def __init__(self):
        self.Section_parameters = None
        """
        The MM  kind
        """
        self.Radius = None
        """
        Specifies the radius of the atomic kinds
        """
        self.Corr_radius = None
        """
        Specifies the correction radius of the atomic kinds The correction
        radius is connected to the use of the compatibility keyword.
        """
        self._name = "MM_KIND"
        self._keywords = [('Radius', 'RADIUS'), ('Corr_radius', 'CORR_RADIUS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _global1(printable):
    """
    Section with general information regarding which kind of simulation to
    perform an parameters for the whole PROGRAM
    """
    def __init__(self):
        self.Blacs_grid = None
        """
        how to distribute the processors on the 2d grid needed by BLACS (and
        thus SCALAPACK)

        Available values:
            SQUARE
                Distribution by matrix blocks
            ROW
                Distribution by matrix rows
            COLUMN
                Distribution by matrix columns
        """
        self.Blacs_repeatable = None
        """
        Use a topology for BLACS collectives that is guaranteed to be
        repeatable on homegeneous architectures
        """
        self.Preferred_fft_library = None
        """
        Specifies the FFT library which should be preferred. If it is not
        available, use FFTW3 if this is linked in, if FFTW3 is not available
        use FFTSG. Improved performance with FFTW3 can be obtained specifying
        a proper value for FFTW_PLAN_TYPE. Contrary to earlier CP2K versions,
        all libraries will result in the same grids, i.e. the subset of grids
        which all FFT libraries can transform. See EXTENDED_FFT_LENGTHS if
        larger FFTs or grids that more precisely match a given cutoff are
        needed, or older results need to be reproduced. FFTW3 is often (close
        to) optimal, and well tested with CP2K.

        Available values:
            FFTSG
                Stefan Goedecker''s FFT (FFTSG), always available,will be used in case
                a FFT lib is specified and not available
            FFTW3
                a fast portable FFT library. Recommended.See also the FFTW_PLAN_TYPE,
                and FFTW_WISDOM_FILE_NAME keywords.
            FFTW
                Same as FFTW3 (for compatability with CP2K 2.3)
        """
        self.Fftw_wisdom_file_name = None
        """
        The name of the file that contains wisdom (pre-planned FFTs) for use
        with FFTW3. Using wisdom can significantly speed up the FFTs (see the
        FFTW homepage for details). Note that wisdom is not transferable
        between different computer (architectures). Wisdom can be generated
        using the fftw-wisdom tool that is part of the fftw installation.
        cp2k/tools/cp2k-wisdom is a script that contains some additional info,
        and can help to generate a useful default for /etc/fftw/wisdom or
        particular values for a given simulation.
        """
        self.Fftw_plan_type = None
        """
        FFTW can have improved performance if it is allowed to plan with
        explicit measurements which strategy is best for a given FFT. While a
        plan based on measurements is generally faster, differences in machine
        load will lead to different plans for the same input file, and thus
        numerics for the FFTs will be slightly different from run to
        run.PATIENT planning is recommended for long ab initio MD runs.

        Available values:
            ESTIMATE
                Quick estimate, no runtime measurements.
            MEASURE
                Quick measurement, somewhat faster FFTs.
            PATIENT
                Measurements trying a wider range of possibilities.
            EXHAUSTIVE
                Measurements trying all possibilities - use with caution.
        """
        self.Extended_fft_lengths = None
        """
        Use fft library specific values for the allows number of points in
        FFTs. The default is to use the internal FFT lengths. For external fft
        libraries this may create an error at the external library level,
        because the length provided by cp2k is not supported by the external
        library. In this case switch on this keyword to obtain, with certain
        fft libraries, lengths matching the external fft library lengths, or
        larger allowed grids, or grids that more precisely match a given
        cutoff. IMPORTANT NOTE: in this case, the actual grids used in CP2K
        depends on the FFT library. A change of FFT library must therefore be
        considered equivalent to a change of basis, which implies a change of
        total energy.
        """
        self.Fft_pool_scratch_limit = None
        """
        Limits the memory usage of the FFT scratch pool, potentially reducing
        efficiency a bit
        """
        self.Alltoall_sgl = None
        """
        All-to-all communication (FFT) should use single precision
        """
        self.Print_level = None
        """
        How much output is written out.

        Available values:
            SILENT
                Almost no output
            LOW
                Little output
            MEDIUM
                Quite some output
            HIGH
                Lots of output
            DEBUG
                Everything is written out, useful for debugging purposes only
        """
        self.Program_name = None
        """
        Which program should be run

        Available values:
            ATOM
                Runs single atom calculations
            FARMING
                Runs N independent jobs in a single run
            TEST
                Do some benchmarking and testing
            CP2K
                Runs one of the CP2K package
            OPTIMIZE_INPUT
                A tool do optimize parameters in a CP2K input
            OPTIMIZE_BASIS
                A tool to create a MOLOPT or ADMM basis for a given set of training
                structures
        """
        self.Project_name = None
        """
        Name of the project (used to build the name of the trajectory, and
        other files generated by the program)
        """
        self.Output_file_name = None
        """
        Name of the output file. Relevant only if automatically started
        (through farming for example). If empty uses the project name as basis
        for it.
        """
        self.Run_type = None
        """
        Type of run that you want to perform Geometry optimization, md,
        montecarlo,...

        Available values:
            NONE
                Perform no tasks
            ENERGY
                Computes energy
            ENERGY_FORCE
                Computes energy and forces
            MD
                Molecular Dynamics
            GEO_OPT
                Geometry Optimization
            MC
                Monte Carlo
            SPECTRA
                Computes absorption Spectra
            DEBUG
                Performs a Debug analysis
            BSSE
                Basis set superposition error
            LR
                Linear Response
            PINT
                Path integral
            VIBRATIONAL_ANALYSIS
                Vibrational analysis
            BAND
                Band methods
            CELL_OPT
                Cell optimization
            WFN_OPT
                Alias for ENERGY
            WAVEFUNCTION_OPTIMIZATION
                Alias for ENERGY
            MOLECULAR_DYNAMICS
                Alias for MD
            GEOMETRY_OPTIMIZATION
                Alias for GEO_OPT
            MONTECARLO
                Alias for MC
            ELECTRONIC_SPECTRA
                Alias for SPECTRA
            LINEAR_RESPONSE
                Alias for LR
            NORMAL_MODES
                Alias for VIBRATIONAL_ANALYSIS
            RT_PROPAGATION
                Real Time propagation run (fixed ionic positions)
            EHRENFEST_DYN
                Ehrenfest dynamics (using real time propagation of the wavefunction)
            TAMC
                TAMC
        """
        self.Walltime = None
        """
        Maximum execution time for this run. Time in seconds.
        """
        self.Echo_input = None
        """
        If the input should be echoed to the output with all the defaults made
        explicit
        """
        self.Echo_all_hosts = None
        """
        Echo a list of hostname and pid for all MPI processes.
        """
        self.Trace = None
        """
        If a debug trace of the execution of the program should be written
        """
        self.Trace_master = None
        """
        For parallel TRACEd runs: only the master node writes output.
        """
        self.Trace_max = None
        """
        Limit the total number a given subroutine is printed in the trace.
        Accounting is not influenced.
        """
        self.Trace_routines = None
        """
        A list of routines to trace. If left empty all routines are traced.
        Accounting is not influenced.
        """
        self.Flush_should_flush = None
        """
        Flush output regularly, enabling this option might degrade performance
        significantly on certain machines.
        """
        self.Callgraph = None
        """
        At the end of the run write a callgraph to file, which contains
        detailed timing informations. This callgraph can be viewed e.g. with
        the open-source program kcachegrind.

        Available values:
            NONE
                No callgraph gets written
            MASTER
                Only the master process writes his callgraph
            ALL
                All processes write their callgraph (into a separate files).
        """
        self.Callgraph_file_name = None
        """
        Name of the callgraph file, which is writte a the end of the run. If
        not specified the project name will be used as filename.
        """
        self.Seed = None
        """
        Initial seed for the global (pseudo)random number generator to create
        a stream of normally Gaussian distributed random numbers.
        """
        self.Save_mem = None
        """
        Some sections of the input structure are deallocated when not needed,
        and reallocated only when used. This reduces the required maximum
        memory
        """
        self.Enable_unsupported_features = None
        """
        This keywords enables the usage of unsupported features in a release
        version. It affects ONLY release versions of CP2K (no effects on
        development versions).
        """
        self.TIMINGS = _timings1()
        self.REFERENCES = _references1()
        self.PROGRAM_RUN_INFO = _program_run_info1()
        self.PRINT = _print1()
        self.CUDA = _cuda1()
        self.MACHINE_ARCH = _machine_arch1()
        self.DBCSR = _dbcsr1()
        self._name = "GLOBAL"
        self._keywords = [('Blacs_grid', 'BLACS_GRID'), ('Blacs_repeatable', 'BLACS_REPEATABLE'), ('Preferred_fft_library', 'PREFERRED_FFT_LIBRARY'), ('Fftw_wisdom_file_name', 'FFTW_WISDOM_FILE_NAME'), ('Fftw_plan_type', 'FFTW_PLAN_TYPE'), ('Extended_fft_lengths', 'EXTENDED_FFT_LENGTHS'), ('Fft_pool_scratch_limit', 'FFT_POOL_SCRATCH_LIMIT'), ('Alltoall_sgl', 'ALLTOALL_SGL'), ('Print_level', 'PRINT_LEVEL'), ('Program_name', 'PROGRAM_NAME'), ('Project_name', 'PROJECT_NAME'), ('Output_file_name', 'OUTPUT_FILE_NAME'), ('Run_type', 'RUN_TYPE'), ('Walltime', 'WALLTIME'), ('Echo_input', 'ECHO_INPUT'), ('Echo_all_hosts', 'ECHO_ALL_HOSTS'), ('Trace', 'TRACE'), ('Trace_master', 'TRACE_MASTER'), ('Trace_max', 'TRACE_MAX'), ('Trace_routines', 'TRACE_ROUTINES'), ('Flush_should_flush', 'FLUSH_SHOULD_FLUSH'), ('Callgraph', 'CALLGRAPH'), ('Callgraph_file_name', 'CALLGRAPH_FILE_NAME'), ('Seed', 'SEED'), ('Save_mem', 'SAVE_MEM'), ('Enable_unsupported_features', 'ENABLE_UNSUPPORTED_FEATURES')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('TIMINGS', 'TIMINGS'), ('REFERENCES', 'REFERENCES'), ('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('PRINT', 'PRINT'), ('CUDA', 'CUDA'), ('MACHINE_ARCH', 'MACHINE_ARCH'), ('DBCSR', 'DBCSR')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Iolevel(self):
        """
        See documentation for Print_level
        """
        return self.Print_level

    @property
    def Program(self):
        """
        See documentation for Program_name
        """
        return self.Program_name

    @property
    def Project(self):
        """
        See documentation for Project_name
        """
        return self.Project_name

    @property
    def Wallti(self):
        """
        See documentation for Walltime
        """
        return self.Walltime

    @Iolevel.setter
    def Iolevel(self, value):
        self.Print_level = value

    @Program.setter
    def Program(self, value):
        self.Program_name = value

    @Project.setter
    def Project(self, value):
        self.Project_name = value

    @Wallti.setter
    def Wallti(self, value):
        self.Walltime = value



class _chi_tensor1(printable):
    """
    Controls the printing of susceptibility
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each301()
        self._name = "CHI_TENSOR"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _scf1(printable):
    """
    parameters needed perform an scf run
    """
    def __init__(self):
        self.Max_iter_lumo = None
        """
        The maximum number of iteration for the lumo computation
        """
        self.Eps_lumo = None
        """
        target accuracy of the computation of the lumo energy
        """
        self.Max_scf = None
        """
        Maximum number of SCF iteration to be performed for one optimization
        """
        self.Max_scf_history = None
        """
        Maximum number of SCF iterations after the history pipeline is filled
        """
        self.Max_diis = None
        """
        Maximum number of DIIS vectors to be used
        """
        self.Level_shift = None
        """
        Use level shifting to improve convergence
        """
        self.Eps_scf = None
        """
        target accuracy for the scf convergence
        """
        self.Eps_scf_history = None
        """
        target accuracy for the scf convergence after the history pipeline is
        filled
        """
        self.Cholesky = None
        """
        If the cholesky method should be used for computing the inverse of S,
        and in this case calling which Lapack routines

        Available values:
            OFF
                The cholesky algorithm is not used
            REDUCE
                Reduce is called
            RESTORE
                Reduce is replaced by two restore
            INVERSE
                Restore uses operator multiply by inverse of the triangular matrix
        """
        self.Eps_eigval = None
        """
        Throw away linear combinations of basis functions with a small
        eigenvalue in S
        """
        self.Eps_diis = None
        """
        Threshold on the convergence to start using DIAG/DIIS
        """
        self.Scf_guess = None
        """
        Change the initial guess for the wavefunction.

        Available values:
            ATOMIC
                Generate an atomic density using the atomic code
            RESTART
                Use the RESTART file as an initial guess (and ATOMIC if not present).
            RANDOM
                Use random wavefunction coefficients.
            CORE
                Diagonalize the core hamiltonian for an initial guess.
            DENSITIES
                Use the aux_basis_set for collocation.
            HISTORY_RESTART
                Extrapolated from previous RESTART files.
            MOPAC
                Use same guess as MOPAC for semi-empirical methods or a simple
                diagonal density matrix for other methods
            SPARSE
                Generate a sparse wavefunction using the atomic code (for OT based
                methods)
            NONE
                Skip initial guess (only for NON-SCC DFTB).
        """
        self.Nrow_block = None
        """
        sets the number of rows in a scalapack block
        """
        self.Ncol_block = None
        """
        Sets the number of columns in a scalapack block
        """
        self.Added_mos = None
        """
        Number of additional MOS added for each spin
        """
        self.Roks_scheme = None
        """
        Selects the ROKS scheme when ROKS is applied.

        Available values:
            GENERAL
            HIGH-SPIN
        """
        self.Roks_f = None
        """
        Allows to define the parameter f for the general ROKS scheme.
        """
        self.Roks_parameters = None
        """
        Allows to define all parameters for the high-spin ROKS scheme
        explicitly. The full set of 6 parameters has to be specified in the
        order acc, bcc, aoo, boo, avv, bvv
        """
        self.OT = _ot1()
        self.DIAGONALIZATION = _diagonalization1()
        self.OUTER_SCF = _outer_scf1()
        self.SMEAR = _smear1()
        self.MIXING = _mixing2()
        self.PRINT = _print18()
        self._name = "SCF"
        self._keywords = [('Max_iter_lumo', 'MAX_ITER_LUMO'), ('Eps_lumo', 'EPS_LUMO'), ('Max_scf', 'MAX_SCF'), ('Max_scf_history', 'MAX_SCF_HISTORY'), ('Max_diis', 'MAX_DIIS'), ('Level_shift', 'LEVEL_SHIFT'), ('Eps_scf', 'EPS_SCF'), ('Eps_scf_history', 'EPS_SCF_HISTORY'), ('Cholesky', 'CHOLESKY'), ('Eps_eigval', 'EPS_EIGVAL'), ('Eps_diis', 'EPS_DIIS'), ('Scf_guess', 'SCF_GUESS'), ('Nrow_block', 'NROW_BLOCK'), ('Ncol_block', 'NCOL_BLOCK'), ('Added_mos', 'ADDED_MOS'), ('Roks_scheme', 'ROKS_SCHEME'), ('Roks_f', 'ROKS_F'), ('Roks_parameters', 'ROKS_PARAMETERS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('OT', 'OT'), ('DIAGONALIZATION', 'DIAGONALIZATION'), ('OUTER_SCF', 'OUTER_SCF'), ('SMEAR', 'SMEAR'), ('MIXING', 'MIXING'), ('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Max_iter_lumos(self):
        """
        See documentation for Max_iter_lumo
        """
        return self.Max_iter_lumo

    @property
    def Eps_lumos(self):
        """
        See documentation for Eps_lumo
        """
        return self.Eps_lumo

    @property
    def Max_scf_hist(self):
        """
        See documentation for Max_scf_history
        """
        return self.Max_scf_history

    @property
    def Max_diis_buffer_size(self):
        """
        See documentation for Max_diis
        """
        return self.Max_diis

    @property
    def Lshift(self):
        """
        See documentation for Level_shift
        """
        return self.Level_shift

    @property
    def Eps_scf_hist(self):
        """
        See documentation for Eps_scf_history
        """
        return self.Eps_scf_history

    @property
    def F_roks(self):
        """
        See documentation for Roks_f
        """
        return self.Roks_f

    @property
    def Roks_parameter(self):
        """
        See documentation for Roks_parameters
        """
        return self.Roks_parameters

    @Max_iter_lumos.setter
    def Max_iter_lumos(self, value):
        self.Max_iter_lumo = value

    @Eps_lumos.setter
    def Eps_lumos(self, value):
        self.Eps_lumo = value

    @Max_scf_hist.setter
    def Max_scf_hist(self, value):
        self.Max_scf_history = value

    @Max_diis_buffer_size.setter
    def Max_diis_buffer_size(self, value):
        self.Max_diis = value

    @Lshift.setter
    def Lshift(self, value):
        self.Level_shift = value

    @Eps_scf_hist.setter
    def Eps_scf_hist(self, value):
        self.Eps_scf_history = value

    @F_roks.setter
    def F_roks(self, value):
        self.Roks_f = value

    @Roks_parameter.setter
    def Roks_parameter(self, value):
        self.Roks_parameters = value



class _bfgs4(printable):
    """
    Provides parameters to tune the BFGS optimization
    """
    def __init__(self):
        self.Trust_radius = None
        """
        Trust radius used in BFGS. Previously set to 0.1. Large values can
        lead to instabilities
        """
        self.Use_model_hessian = None
        """
        Uses a model Hessian as initial guess instead of a unit matrix. Should
        lead in general to improved convergence might be switched off for
        exotic cases
        """
        self.Use_rat_fun_opt = None
        """
        Includes a rational function optimization to determine the step.
        Previously default but did not improve convergence in many cases
        """
        self.Restart_hessian = None
        """
        Controls the reading of the initial Hessian from file.
        """
        self.Restart_file_name = None
        """
        Specifies the name of the file used to read the initial Hessian.
        """
        self.RESTART = _restart4()
        self._name = "BFGS"
        self._keywords = [('Trust_radius', 'TRUST_RADIUS'), ('Use_model_hessian', 'USE_MODEL_HESSIAN'), ('Use_rat_fun_opt', 'USE_RAT_FUN_OPT'), ('Restart_hessian', 'RESTART_HESSIAN'), ('Restart_file_name', 'RESTART_FILE_NAME')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('RESTART', 'RESTART')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _bfgs1(printable):
    """
    Provides parameters to tune the BFGS optimization
    """
    def __init__(self):
        self.Trust_radius = None
        """
        Trust radius used in BFGS. Previously set to 0.1. Large values can
        lead to instabilities
        """
        self.Use_model_hessian = None
        """
        Uses a model Hessian as initial guess instead of a unit matrix. Should
        lead in general to improved convergence might be switched off for
        exotic cases
        """
        self.Use_rat_fun_opt = None
        """
        Includes a rational function optimization to determine the step.
        Previously default but did not improve convergence in many cases
        """
        self.Restart_hessian = None
        """
        Controls the reading of the initial Hessian from file.
        """
        self.Restart_file_name = None
        """
        Specifies the name of the file used to read the initial Hessian.
        """
        self.RESTART = _restart1()
        self._name = "BFGS"
        self._keywords = [('Trust_radius', 'TRUST_RADIUS'), ('Use_model_hessian', 'USE_MODEL_HESSIAN'), ('Use_rat_fun_opt', 'USE_RAT_FUN_OPT'), ('Restart_hessian', 'RESTART_HESSIAN'), ('Restart_file_name', 'RESTART_FILE_NAME')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('RESTART', 'RESTART')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _bfgs3(printable):
    """
    Provides parameters to tune the BFGS optimization
    """
    def __init__(self):
        self.Trust_radius = None
        """
        Trust radius used in BFGS. Previously set to 0.1. Large values can
        lead to instabilities
        """
        self.Use_model_hessian = None
        """
        Uses a model Hessian as initial guess instead of a unit matrix. Should
        lead in general to improved convergence might be switched off for
        exotic cases
        """
        self.Use_rat_fun_opt = None
        """
        Includes a rational function optimization to determine the step.
        Previously default but did not improve convergence in many cases
        """
        self.Restart_hessian = None
        """
        Controls the reading of the initial Hessian from file.
        """
        self.Restart_file_name = None
        """
        Specifies the name of the file used to read the initial Hessian.
        """
        self.RESTART = _restart3()
        self._name = "BFGS"
        self._keywords = [('Trust_radius', 'TRUST_RADIUS'), ('Use_model_hessian', 'USE_MODEL_HESSIAN'), ('Use_rat_fun_opt', 'USE_RAT_FUN_OPT'), ('Restart_hessian', 'RESTART_HESSIAN'), ('Restart_file_name', 'RESTART_FILE_NAME')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('RESTART', 'RESTART')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _bfgs2(printable):
    """
    Provides parameters to tune the BFGS optimization
    """
    def __init__(self):
        self.Trust_radius = None
        """
        Trust radius used in BFGS. Previously set to 0.1. Large values can
        lead to instabilities
        """
        self.Use_model_hessian = None
        """
        Uses a model Hessian as initial guess instead of a unit matrix. Should
        lead in general to improved convergence might be switched off for
        exotic cases
        """
        self.Use_rat_fun_opt = None
        """
        Includes a rational function optimization to determine the step.
        Previously default but did not improve convergence in many cases
        """
        self.Restart_hessian = None
        """
        Controls the reading of the initial Hessian from file.
        """
        self.Restart_file_name = None
        """
        Specifies the name of the file used to read the initial Hessian.
        """
        self.RESTART = _restart2()
        self._name = "BFGS"
        self._keywords = [('Trust_radius', 'TRUST_RADIUS'), ('Use_model_hessian', 'USE_MODEL_HESSIAN'), ('Use_rat_fun_opt', 'USE_RAT_FUN_OPT'), ('Restart_hessian', 'RESTART_HESSIAN'), ('Restart_file_name', 'RESTART_FILE_NAME')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('RESTART', 'RESTART')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _trajectory1(printable):
    """
    Controls the output of the trajectory
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.Format = None
        """
        Specifies the format of the output file for the trajectory.

        Available values:
            ATOMIC
                Write only the coordinates X,Y,Z without element symbols to a
                formatted file
            DCD
                Write the coordinates (no element labels) and the cell information to
                a binary file
            PDB
                Write the atomic information in PDB format to a formatted file
            XMOL
                Mostly known as XYZ format, provides in a formatted file:
                element_symbol X Y Z
            XYZ
                Alias name for XMOL
        """
        self.Charge_occup = None
        """
        Write the MM charges to the OCCUP field of the PDB file
        """
        self.Charge_beta = None
        """
        Write the MM charges to the BETA field of the PDB file
        """
        self.Charge_extended = None
        """
        Write the MM charges to the very last field of the PDB file (starting
        from column 81)
        """
        self.EACH = _each72()
        self._name = "TRAJECTORY"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT'), ('Format', 'FORMAT'), ('Charge_occup', 'CHARGE_OCCUP'), ('Charge_beta', 'CHARGE_BETA'), ('Charge_extended', 'CHARGE_EXTENDED')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Charge_o(self):
        """
        See documentation for Charge_occup
        """
        return self.Charge_occup

    @property
    def Charge_b(self):
        """
        See documentation for Charge_beta
        """
        return self.Charge_beta

    @Charge_o.setter
    def Charge_o(self, value):
        self.Charge_occup = value

    @Charge_b.setter
    def Charge_b(self, value):
        self.Charge_beta = value



class _qparm1(printable):
    """
    Section to define the Q parameter (crystalline order parameter) as a
    collective variable.
    """
    def __init__(self):
        self.list_Atoms_from = []
        self.list_Points_from = self.list_Atoms_from
        self.list_Atoms_to = []
        self.list_Points_to = self.list_Atoms_to
        self.Rcut = None
        """
        Specifies the distance cutoff for neighbors.
        """
        self.L = None
        """
        Specifies the L spherical harmonics from Ylm.
        """
        self.Alpha = None
        """
        Specifies the width of the Fermi-Dirac style smearing around RCUT.
        """
        self.list_POINT = []
        self._name = "QPARM"
        self._keywords = [('Rcut', 'RCUT'), ('L', 'L'), ('Alpha', 'ALPHA')]
        self._repeated_keywords = [('Atoms_from', 'ATOMS_FROM'), ('Atoms_to', 'ATOMS_TO')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point11')]

    def add_POINT(self):
        new_section = _point11()
        self.list_POINT.append(new_section)
        return new_section

    def add_Atoms_from(self, value):
        self.list_Atoms_from.append(value)

    def add_Atoms_to(self, value):
        self.list_Atoms_to.append(value)

    def add_Points_from(self, value):
        self.list_ATOMS_TO.append(value)

    def add_Points_to(self, value):
        self.list_ATOMS_TO.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _xc_functional4(printable):
    """
    The xc functional to use
    """
    def __init__(self):
        self.Section_parameters = None
        """
        shorcut for the most commont functionals combinations

        Available values:
            B3LYP
            PBE0
            BLYP
            BP
            PADE
            PBE
            TPSS
            HCTH120
            OLYP
            NO_SHORTCUT
            NONE
        """
        self.BECKE88 = _becke884()
        self.LYP_ADIABATIC = _lyp_adiabatic4()
        self.BECKE88_LR_ADIABATIC = _becke88_lr_adiabatic4()
        self.BECKE88_LR = _becke88_lr4()
        self.LYP = _lyp4()
        self.PADE = _pade4()
        self.list_HCTH = []
        self.OPTX = _optx4()
        self.LIBXC = _libxc4()
        self.KE_LIBXC = _ke_libxc4()
        self.CS1 = _cs14()
        self.list_XGGA = []
        self.list_KE_GGA = []
        self.P86C = _p86c4()
        self.list_PW92 = []
        self.list_PZ81 = []
        self.TFW = _tfw4()
        self.TF = _tf4()
        self.VWN = _vwn4()
        self.list_XALPHA = []
        self.TPSS = _tpss4()
        self.PBE = _pbe4()
        self.XWPBE = _xwpbe4()
        self.BECKE97 = _becke974()
        self.BECKE_ROUSSEL = _becke_roussel4()
        self.LDA_HOLE_T_C_LR = _lda_hole_t_c_lr4()
        self.PBE_HOLE_T_C_LR = _pbe_hole_t_c_lr4()
        self.GV09 = _gv094()
        self._name = "XC_FUNCTIONAL"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('BECKE88', 'BECKE88'), ('LYP_ADIABATIC', 'LYP_ADIABATIC'), ('BECKE88_LR_ADIABATIC', 'BECKE88_LR_ADIABATIC'), ('BECKE88_LR', 'BECKE88_LR'), ('LYP', 'LYP'), ('PADE', 'PADE'), ('OPTX', 'OPTX'), ('LIBXC', 'LIBXC'), ('KE_LIBXC', 'KE_LIBXC'), ('CS1', 'CS1'), ('P86C', 'P86C'), ('TFW', 'TFW'), ('TF', 'TF'), ('VWN', 'VWN'), ('TPSS', 'TPSS'), ('PBE', 'PBE'), ('XWPBE', 'XWPBE'), ('BECKE97', 'BECKE97'), ('BECKE_ROUSSEL', 'BECKE_ROUSSEL'), ('LDA_HOLE_T_C_LR', 'LDA_HOLE_T_C_LR'), ('PBE_HOLE_T_C_LR', 'PBE_HOLE_T_C_LR'), ('GV09', 'GV09')]
        self._repeated_subsections = [('HCTH', '_hcth4'), ('XGGA', '_xgga4'), ('KE_GGA', '_ke_gga4'), ('PW92', '_pw924'), ('PZ81', '_pz814'), ('XALPHA', '_xalpha4')]

    def add_HCTH(self):
        new_section = _hcth4()
        self.list_HCTH.append(new_section)
        return new_section

    def add_XGGA(self):
        new_section = _xgga4()
        self.list_XGGA.append(new_section)
        return new_section

    def add_KE_GGA(self):
        new_section = _ke_gga4()
        self.list_KE_GGA.append(new_section)
        return new_section

    def add_PW92(self):
        new_section = _pw924()
        self.list_PW92.append(new_section)
        return new_section

    def add_PZ81(self):
        new_section = _pz814()
        self.list_PZ81.append(new_section)
        return new_section

    def add_XALPHA(self):
        new_section = _xalpha4()
        self.list_XALPHA.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _qparm3(printable):
    """
    Section to define the Q parameter (crystalline order parameter) as a
    collective variable.
    """
    def __init__(self):
        self.list_Atoms_from = []
        self.list_Points_from = self.list_Atoms_from
        self.list_Atoms_to = []
        self.list_Points_to = self.list_Atoms_to
        self.Rcut = None
        """
        Specifies the distance cutoff for neighbors.
        """
        self.L = None
        """
        Specifies the L spherical harmonics from Ylm.
        """
        self.Alpha = None
        """
        Specifies the width of the Fermi-Dirac style smearing around RCUT.
        """
        self.list_POINT = []
        self._name = "QPARM"
        self._keywords = [('Rcut', 'RCUT'), ('L', 'L'), ('Alpha', 'ALPHA')]
        self._repeated_keywords = [('Atoms_from', 'ATOMS_FROM'), ('Atoms_to', 'ATOMS_TO')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point47')]

    def add_POINT(self):
        new_section = _point47()
        self.list_POINT.append(new_section)
        return new_section

    def add_Atoms_from(self, value):
        self.list_Atoms_from.append(value)

    def add_Atoms_to(self, value):
        self.list_Atoms_to.append(value)

    def add_Points_from(self, value):
        self.list_ATOMS_TO.append(value)

    def add_Points_to(self, value):
        self.list_ATOMS_TO.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _qparm2(printable):
    """
    Section to define the Q parameter (crystalline order parameter) as a
    collective variable.
    """
    def __init__(self):
        self.list_Atoms_from = []
        self.list_Points_from = self.list_Atoms_from
        self.list_Atoms_to = []
        self.list_Points_to = self.list_Atoms_to
        self.Rcut = None
        """
        Specifies the distance cutoff for neighbors.
        """
        self.L = None
        """
        Specifies the L spherical harmonics from Ylm.
        """
        self.Alpha = None
        """
        Specifies the width of the Fermi-Dirac style smearing around RCUT.
        """
        self.list_POINT = []
        self._name = "QPARM"
        self._keywords = [('Rcut', 'RCUT'), ('L', 'L'), ('Alpha', 'ALPHA')]
        self._repeated_keywords = [('Atoms_from', 'ATOMS_FROM'), ('Atoms_to', 'ATOMS_TO')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point29')]

    def add_POINT(self):
        new_section = _point29()
        self.list_POINT.append(new_section)
        return new_section

    def add_Atoms_from(self, value):
        self.list_Atoms_from.append(value)

    def add_Atoms_to(self, value):
        self.list_Atoms_to.append(value)

    def add_Points_from(self, value):
        self.list_ATOMS_TO.append(value)

    def add_Points_to(self, value):
        self.list_ATOMS_TO.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _qparm4(printable):
    """
    Section to define the Q parameter (crystalline order parameter) as a
    collective variable.
    """
    def __init__(self):
        self.list_Atoms_from = []
        self.list_Points_from = self.list_Atoms_from
        self.list_Atoms_to = []
        self.list_Points_to = self.list_Atoms_to
        self.Rcut = None
        """
        Specifies the distance cutoff for neighbors.
        """
        self.L = None
        """
        Specifies the L spherical harmonics from Ylm.
        """
        self.Alpha = None
        """
        Specifies the width of the Fermi-Dirac style smearing around RCUT.
        """
        self.list_POINT = []
        self._name = "QPARM"
        self._keywords = [('Rcut', 'RCUT'), ('L', 'L'), ('Alpha', 'ALPHA')]
        self._repeated_keywords = [('Atoms_from', 'ATOMS_FROM'), ('Atoms_to', 'ATOMS_TO')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point65')]

    def add_POINT(self):
        new_section = _point65()
        self.list_POINT.append(new_section)
        return new_section

    def add_Atoms_from(self, value):
        self.list_Atoms_from.append(value)

    def add_Atoms_to(self, value):
        self.list_Atoms_to.append(value)

    def add_Points_from(self, value):
        self.list_ATOMS_TO.append(value)

    def add_Points_to(self, value):
        self.list_ATOMS_TO.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _lanczos1(printable):
    """
    Controls the printing of information on Lanczos refinement iterations.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each100()
        self._name = "LANCZOS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _mo_cubes1(printable):
    """
    Controls the printing of cubes of the molecular orbitals.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Stride = None
        """
        The stride (X,Y,Z) used to write the cube file (larger values result
        in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1
        number valid for all components.
        """
        self.Write_cube = None
        """
        If the MO cube file should be written. If false, the eigenvalues are
        still computed. Can also be useful in combination with STM
        calculations
        """
        self.Nlumo = None
        """
        If the printkey is activated controls the number of lumosthat are
        printed and dumped as a cube (-1=all)
        """
        self.Nhomo = None
        """
        If the printkey is activated controls the number of homos that dumped
        as a cube (-1=all), eigenvalues are always all dumped
        """
        self.Append = None
        """
        append the cube files when they already exist
        """
        self.EACH = _each186()
        self._name = "MO_CUBES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Stride', 'STRIDE'), ('Write_cube', 'WRITE_CUBE'), ('Nlumo', 'NLUMO'), ('Nhomo', 'NHOMO'), ('Append', 'APPEND')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _atom_list1(printable):
    """
    Defines a list of atoms for which the initial velocities are modified
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Defines the list of atoms for which the velocities are modified. Each
        record consists of the atomic index, the velocity vector, and a weight
        to define which fraction of the total energy is assigned to the
        current atom.
        """
        self._name = "ATOM_LIST"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _control1(printable):
    """
    Controls the printing of FP info at startup
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each49()
        self._name = "CONTROL"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print_averages1(printable):
    """
    Controls the output the averaged quantities
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each31()
        self._name = "PRINT_AVERAGES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _point72(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point70(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point71(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _metavar1(printable):
    """
    This section specify the nature of the collective variables.
    """
    def __init__(self):
        self.Lambda = None
        """
        Specifies the lambda parameter of the collective variable in the
        extended lagrangian scheme.
        """
        self.Mass = None
        """
        Specifies the mass parameter of the collective variable in the
        extended lagrangian scheme.
        """
        self.Gamma = None
        """
        Specifies the friction term in Langevin integration of the collective
        variable in the extended lagrangian scheme.
        """
        self.Scale = None
        """
        Specifies the scale factor for the following collective variable. The
        history dependent term has the expression: WW * Sum_{j=1}^{nhills}
        Prod_{k=1}^{ncolvar} [EXP[-0.5*((ss-ss0(k,j))/SCALE(k))^2]], where
        ncolvar is the number of defined METAVAR and nhills is the number of
        spawned hills.
        """
        self.Colvar = None
        """
        Specifies the colvar on which to apply metadynamics.
        """
        self.list_WALL = []
        self._name = "METAVAR"
        self._keywords = [('Lambda', 'LAMBDA'), ('Mass', 'MASS'), ('Gamma', 'GAMMA'), ('Scale', 'SCALE'), ('Colvar', 'COLVAR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('WALL', '_wall1')]

    def add_WALL(self):
        new_section = _wall1()
        self.list_WALL.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Width(self):
        """
        See documentation for Scale
        """
        return self.Scale

    @Width.setter
    def Width(self, value):
        self.Scale = value



class _ci_neb1(printable):
    """
    Controls parameters for CI-NEB type calculation only.
    """
    def __init__(self):
        self.Nsteps_it = None
        """
        Specify the number of steps of IT-NEB to perform before switching on
        the CI algorithm
        """
        self._name = "CI_NEB"
        self._keywords = [('Nsteps_it', 'NSTEPS_IT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _velocities1(printable):
    """
    Controls the output of the velocities
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.Format = None
        """
        Specifies the format of the output file for the velocities.

        Available values:
            ATOMIC
                Write only the coordinates X,Y,Z without element symbols to a
                formatted file
            DCD
                Write the coordinates (no element labels) and the cell information to
                a binary file
            XMOL
                Mostly known as XYZ format, provides in a formatted file:
                element_symbol X Y Z
            XYZ
                Alias name for XMOL
        """
        self.EACH = _each76()
        self._name = "VELOCITIES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT'), ('Format', 'FORMAT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _xas_spectrum1(printable):
    """
    Controls the dumping of the CLS output files containing the absorption
    spectra
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each162()
        self._name = "XAS_SPECTRUM"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _moments1(printable):
    """
    Section controlling the calculation of MOMENTS. Note that the result
    in the periodic case might be defined modulo a certain period,
    determined by the lattice vectors. During MD, this can lead to jumps.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Periodic = None
        """
        Use Berry phase formula (PERIODIC=T) or simple operator (PERIODIC=F).
        The latter normally requires that the CELL is periodic NONE.
        """
        self.Reference = None
        """
        Define the reference point for the calculation of the electrostatic
        moment.

        Available values:
            COM
                Use Center of Mass
            COAC
                Use Center of Atomic Charges
            USER_DEFINED
                Use User Defined Point (Keyword:REF_POINT)
            ZERO
                Use Origin of Coordinate System
        """
        self.Reference_point = None
        """
        Fixed reference point for the calculations of the electrostatic
        moment.
        """
        self.Max_moment = None
        """
        Maximum moment to be calculated
        """
        self.Magnetic = None
        """
        Calculate also magnetic moments
        """
        self.EACH = _each208()
        self._name = "MOMENTS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Periodic', 'PERIODIC'), ('Reference', 'REFERENCE'), ('Reference_point', 'REFERENCE_POINT'), ('Max_moment', 'MAX_MOMENT'), ('Magnetic', 'MAGNETIC')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Ref(self):
        """
        See documentation for Reference
        """
        return self.Reference

    @property
    def Ref_point(self):
        """
        See documentation for Reference_point
        """
        return self.Reference_point

    @Ref.setter
    def Ref(self, value):
        self.Reference = value

    @Ref_point.setter
    def Ref_point(self, value):
        self.Reference_point = value



class _xyz_outerdiag4(printable):
    """
    Section to define the cross term (XA-XA(0))*(XB-XB(0))+(XA-XA(0))*(YB-
    YB(0)) or part of its components as a collective variable. The final
    term is given by the product  of the components of A with the
    components of B.
    """
    def __init__(self):
        self.Atoms = None
        """
        Specifies the index of the atoms/points A and B.
        """
        self.Component_a = None
        """
        Define the component of the position vector which will be used as a
        colvar for atom A.

        Available values:
            XYZ
            X
            Y
            Z
            XY
            XZ
            YZ
        """
        self.Component_b = None
        """
        Define the component of the position vector which will be used as a
        colvar for atom B.

        Available values:
            XYZ
            X
            Y
            Z
            XY
            XZ
            YZ
        """
        self.Pbc = None
        """
        Whether periodic boundary conditions should be applied on the atomic
        position before computing the colvar or not.
        """
        self.list_POINT = []
        self._name = "XYZ_OUTERDIAG"
        self._keywords = [('Atoms', 'ATOMS'), ('Component_a', 'COMPONENT_A'), ('Component_b', 'COMPONENT_B'), ('Pbc', 'PBC')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point68')]

    def add_POINT(self):
        new_section = _point68()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Points(self):
        """
        See documentation for Atoms
        """
        return self.Atoms

    @Points.setter
    def Points(self, value):
        self.Atoms = value



class _xyz_outerdiag1(printable):
    """
    Section to define the cross term (XA-XA(0))*(XB-XB(0))+(XA-XA(0))*(YB-
    YB(0)) or part of its components as a collective variable. The final
    term is given by the product  of the components of A with the
    components of B.
    """
    def __init__(self):
        self.Atoms = None
        """
        Specifies the index of the atoms/points A and B.
        """
        self.Component_a = None
        """
        Define the component of the position vector which will be used as a
        colvar for atom A.

        Available values:
            XYZ
            X
            Y
            Z
            XY
            XZ
            YZ
        """
        self.Component_b = None
        """
        Define the component of the position vector which will be used as a
        colvar for atom B.

        Available values:
            XYZ
            X
            Y
            Z
            XY
            XZ
            YZ
        """
        self.Pbc = None
        """
        Whether periodic boundary conditions should be applied on the atomic
        position before computing the colvar or not.
        """
        self.list_POINT = []
        self._name = "XYZ_OUTERDIAG"
        self._keywords = [('Atoms', 'ATOMS'), ('Component_a', 'COMPONENT_A'), ('Component_b', 'COMPONENT_B'), ('Pbc', 'PBC')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point14')]

    def add_POINT(self):
        new_section = _point14()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Points(self):
        """
        See documentation for Atoms
        """
        return self.Atoms

    @Points.setter
    def Points(self, value):
        self.Atoms = value



class _xyz_outerdiag2(printable):
    """
    Section to define the cross term (XA-XA(0))*(XB-XB(0))+(XA-XA(0))*(YB-
    YB(0)) or part of its components as a collective variable. The final
    term is given by the product  of the components of A with the
    components of B.
    """
    def __init__(self):
        self.Atoms = None
        """
        Specifies the index of the atoms/points A and B.
        """
        self.Component_a = None
        """
        Define the component of the position vector which will be used as a
        colvar for atom A.

        Available values:
            XYZ
            X
            Y
            Z
            XY
            XZ
            YZ
        """
        self.Component_b = None
        """
        Define the component of the position vector which will be used as a
        colvar for atom B.

        Available values:
            XYZ
            X
            Y
            Z
            XY
            XZ
            YZ
        """
        self.Pbc = None
        """
        Whether periodic boundary conditions should be applied on the atomic
        position before computing the colvar or not.
        """
        self.list_POINT = []
        self._name = "XYZ_OUTERDIAG"
        self._keywords = [('Atoms', 'ATOMS'), ('Component_a', 'COMPONENT_A'), ('Component_b', 'COMPONENT_B'), ('Pbc', 'PBC')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point32')]

    def add_POINT(self):
        new_section = _point32()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Points(self):
        """
        See documentation for Atoms
        """
        return self.Atoms

    @Points.setter
    def Points(self, value):
        self.Atoms = value



class _xyz_outerdiag3(printable):
    """
    Section to define the cross term (XA-XA(0))*(XB-XB(0))+(XA-XA(0))*(YB-
    YB(0)) or part of its components as a collective variable. The final
    term is given by the product  of the components of A with the
    components of B.
    """
    def __init__(self):
        self.Atoms = None
        """
        Specifies the index of the atoms/points A and B.
        """
        self.Component_a = None
        """
        Define the component of the position vector which will be used as a
        colvar for atom A.

        Available values:
            XYZ
            X
            Y
            Z
            XY
            XZ
            YZ
        """
        self.Component_b = None
        """
        Define the component of the position vector which will be used as a
        colvar for atom B.

        Available values:
            XYZ
            X
            Y
            Z
            XY
            XZ
            YZ
        """
        self.Pbc = None
        """
        Whether periodic boundary conditions should be applied on the atomic
        position before computing the colvar or not.
        """
        self.list_POINT = []
        self._name = "XYZ_OUTERDIAG"
        self._keywords = [('Atoms', 'ATOMS'), ('Component_a', 'COMPONENT_A'), ('Component_b', 'COMPONENT_B'), ('Pbc', 'PBC')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point50')]

    def add_POINT(self):
        new_section = _point50()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Points(self):
        """
        See documentation for Atoms
        """
        return self.Atoms

    @Points.setter
    def Points(self, value):
        self.Atoms = value



class _wavelet1(printable):
    """
    Sets up parameters of  wavelet based poisson solver.This solver allows
    for non-periodic (PERIODIC NONE) boundary conditions and slab-boundary
    conditions (but only PERIODIC XZ).It does not require very large unit
    cells, only that the density goes to zero on the faces of the cell.The
    use of PREFERRED_FFT_LIBRARY FFTSG is required
    """
    def __init__(self):
        self.Scf_type = None
        """
        Type of scaling function used in the wavelet approach, the total
        energy depends on this choice,and the convergence with respect to
        cutoff depends on the selected scaling functions.Possible values are
        8,14,16,20,24,30,40,50,60,100
        """
        self._name = "WAVELET"
        self._keywords = [('Scf_type', 'SCF_TYPE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _wavelet2(printable):
    """
    Sets up parameters of  wavelet based poisson solver.This solver allows
    for non-periodic (PERIODIC NONE) boundary conditions and slab-boundary
    conditions (but only PERIODIC XZ).It does not require very large unit
    cells, only that the density goes to zero on the faces of the cell.The
    use of PREFERRED_FFT_LIBRARY FFTSG is required
    """
    def __init__(self):
        self.Scf_type = None
        """
        Type of scaling function used in the wavelet approach, the total
        energy depends on this choice,and the convergence with respect to
        cutoff depends on the selected scaling functions.Possible values are
        8,14,16,20,24,30,40,50,60,100
        """
        self._name = "WAVELET"
        self._keywords = [('Scf_type', 'SCF_TYPE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _core_coord1(printable):
    """
    The core coordinates for the shell-model potentials xyz format with an
    additional column for the index of the corresponding particle
    """
    def __init__(self):
        self.Unit = None
        """
        Specify the unit of measurement for the coordinates in inputAll
        available CP2K units can be used.
        """
        self.Scaled = None
        """
        Specify if the coordinateds in input are scaled.
        """
        self.list_Default_keyword = []
        """
        The core coordinates in xyz format.
        """
        self._name = "CORE_COORD"
        self._keywords = [('Unit', 'UNIT'), ('Scaled', 'SCALED')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _move_mm_charge1(printable):
    """
    Specify information to move a classical charge before the QM/MM
    energies and forces evaluation
    """
    def __init__(self):
        self.Atom_index_1 = None
        """
        Specifies the index of the MM atom involved in the QM/MM link to be
        moved
        """
        self.Atom_index_2 = None
        """
        Specifies the index of the second atom defining the direction along
        which  the atom will be moved
        """
        self.Alpha = None
        """
        Specifies the scaling factor that defines the movement along the
        defined direction
        """
        self.Radius = None
        """
        Specifies the radius used for the QM/MM electrostatic coupling after
        movement
        """
        self.Corr_radius = None
        """
        Specifies the correction radius used for the QM/MM electrostatic
        coupling after movement
        """
        self._name = "MOVE_MM_CHARGE"
        self._keywords = [('Atom_index_1', 'ATOM_INDEX_1'), ('Atom_index_2', 'ATOM_INDEX_2'), ('Alpha', 'ALPHA'), ('Radius', 'RADIUS'), ('Corr_radius', 'CORR_RADIUS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Mm1(self):
        """
        See documentation for Atom_index_1
        """
        return self.Atom_index_1

    @property
    def Mm2(self):
        """
        See documentation for Atom_index_2
        """
        return self.Atom_index_2

    @Mm1.setter
    def Mm1(self, value):
        self.Atom_index_1 = value

    @Mm2.setter
    def Mm2(self, value):
        self.Atom_index_2 = value



class _move_mm_charge2(printable):
    """
    Specify information to move a classical charge before the QM/MM
    energies and forces evaluation
    """
    def __init__(self):
        self.Atom_index_1 = None
        """
        Specifies the index of the MM atom involved in the QM/MM link to be
        moved
        """
        self.Atom_index_2 = None
        """
        Specifies the index of the second atom defining the direction along
        which  the atom will be moved
        """
        self.Alpha = None
        """
        Specifies the scaling factor that defines the movement along the
        defined direction
        """
        self.Radius = None
        """
        Specifies the radius used for the QM/MM electrostatic coupling after
        movement
        """
        self.Corr_radius = None
        """
        Specifies the correction radius used for the QM/MM electrostatic
        coupling after movement
        """
        self._name = "MOVE_MM_CHARGE"
        self._keywords = [('Atom_index_1', 'ATOM_INDEX_1'), ('Atom_index_2', 'ATOM_INDEX_2'), ('Alpha', 'ALPHA'), ('Radius', 'RADIUS'), ('Corr_radius', 'CORR_RADIUS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Mm1(self):
        """
        See documentation for Atom_index_1
        """
        return self.Atom_index_1

    @property
    def Mm2(self):
        """
        See documentation for Atom_index_2
        """
        return self.Atom_index_2

    @Mm1.setter
    def Mm1(self, value):
        self.Atom_index_1 = value

    @Mm2.setter
    def Mm2(self, value):
        self.Atom_index_2 = value



class _move_mm_charge3(printable):
    """
    Specify information to move a classical charge before the QM/MM
    energies and forces evaluation
    """
    def __init__(self):
        self.Atom_index_1 = None
        """
        Specifies the index of the MM atom involved in the QM/MM link to be
        moved
        """
        self.Atom_index_2 = None
        """
        Specifies the index of the second atom defining the direction along
        which  the atom will be moved
        """
        self.Alpha = None
        """
        Specifies the scaling factor that defines the movement along the
        defined direction
        """
        self.Radius = None
        """
        Specifies the radius used for the QM/MM electrostatic coupling after
        movement
        """
        self.Corr_radius = None
        """
        Specifies the correction radius used for the QM/MM electrostatic
        coupling after movement
        """
        self._name = "MOVE_MM_CHARGE"
        self._keywords = [('Atom_index_1', 'ATOM_INDEX_1'), ('Atom_index_2', 'ATOM_INDEX_2'), ('Alpha', 'ALPHA'), ('Radius', 'RADIUS'), ('Corr_radius', 'CORR_RADIUS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Mm1(self):
        """
        See documentation for Atom_index_1
        """
        return self.Atom_index_1

    @property
    def Mm2(self):
        """
        See documentation for Atom_index_2
        """
        return self.Atom_index_2

    @Mm1.setter
    def Mm1(self, value):
        self.Atom_index_1 = value

    @Mm2.setter
    def Mm2(self, value):
        self.Atom_index_2 = value



class _shell_velocity1(printable):
    """
    The velocities of shells for shell-model potentials, in xyz format
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        The shell velocities in xyz format. The same order as the shell
        coordinate is assumed.
        """
        self._name = "SHELL_VELOCITY"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _sdensity1(printable):
    """
    Controls the output of the helium superfluid density
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each51()
        self._name = "SDENSITY"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _mapping1(printable):
    """
    Defines the mapping of atoms for the different force_eval with the
    mixed force_eval. The default is to have a mapping 1-1 between atom
    index (i.e. all force_eval share the same geometrical structure). The
    mapping is based on defining fragments and the mapping the  fragments
    between the several force_eval and the mixed force_eval
    """
    def __init__(self):
        self.list_FORCE_EVAL_MIXED = []
        self.list_FORCE_EVAL = []
        self._name = "MAPPING"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('FORCE_EVAL_MIXED', '_force_eval_mixed1'), ('FORCE_EVAL', '_force_eval1')]

    def add_FORCE_EVAL_MIXED(self):
        new_section = _force_eval_mixed1()
        self.list_FORCE_EVAL_MIXED.append(new_section)
        return new_section

    def add_FORCE_EVAL(self):
        new_section = _force_eval1()
        self.list_FORCE_EVAL.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _wannier_cubes1(printable):
    """
    Controls the printing of the wannier functions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Stride = None
        """
        The stride (X,Y,Z) used to write the cube file (larger values result
        in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1
        number valid for all components.
        """
        self.Cubes_lu_bounds = None
        """
        The lower and upper index of the states to be printed as cube
        """
        self.list_Cubes_list = []
        self.Append = None
        """
        append the cube files when they already exist
        """
        self.EACH = _each145()
        self._name = "WANNIER_CUBES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Stride', 'STRIDE'), ('Cubes_lu_bounds', 'CUBES_LU_BOUNDS'), ('Append', 'APPEND')]
        self._repeated_keywords = [('Cubes_list', 'CUBES_LIST')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def add_Cubes_list(self, value):
        self.list_Cubes_list.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Cubes_lu(self):
        """
        See documentation for Cubes_lu_bounds
        """
        return self.Cubes_lu_bounds

    @Cubes_lu.setter
    def Cubes_lu(self, value):
        self.Cubes_lu_bounds = value



class _stm1(printable):
    """
    Controls the printing of cubes for the generation of STM images.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Stride = None
        """
        The stride (X,Y,Z) used to write the cube file (larger values result
        in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1
        number valid for all components.
        """
        self.Nlumo = None
        """
        If the printkey is activated controls the number of additional lumos
        that are computed to be able to reproduce STM images obtained  from
        positive bias (imaging unoccupied states)
        """
        self.Bias = None
        """
        Bias energy for scanning tunneling microscopy (STM) image
        generation.Orbital densities are summed according to the bias
        energy.For negative values, states in the range ]EF+bias,EF] are
        summed,While positive values sum states in the range [EF,EF+bias[.If
        postive biases are used, sufficiently many unoccupied stated (see
        ADDED_MOS and NLUMO ) should be computed.
        """
        self.list_Th_torb = []
        self.Ref_energy = None
        """
        By default the reference energy is the Fermi energy. In order to
        compare with STS experiments, where specific energy ranges are
        addressed, here  one can set a different reference energy. The energy
        range is anyway controlled by the BIAS
        """
        self.Append = None
        """
        append the cube files when they already exist
        """
        self.EACH = _each187()
        self._name = "STM"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Stride', 'STRIDE'), ('Nlumo', 'NLUMO'), ('Bias', 'BIAS'), ('Ref_energy', 'REF_ENERGY'), ('Append', 'APPEND')]
        self._repeated_keywords = [('Th_torb', 'TH_TORB')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def add_Th_torb(self, value):
        self.list_Th_torb.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _wannier_cubes3(printable):
    """
    Controls the printing of the wannier functions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Stride = None
        """
        The stride (X,Y,Z) used to write the cube file (larger values result
        in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1
        number valid for all components.
        """
        self.Cubes_lu_bounds = None
        """
        The lower and upper index of the states to be printed as cube
        """
        self.list_Cubes_list = []
        self.Append = None
        """
        append the cube files when they already exist
        """
        self.EACH = _each166()
        self._name = "WANNIER_CUBES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Stride', 'STRIDE'), ('Cubes_lu_bounds', 'CUBES_LU_BOUNDS'), ('Append', 'APPEND')]
        self._repeated_keywords = [('Cubes_list', 'CUBES_LIST')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def add_Cubes_list(self, value):
        self.list_Cubes_list.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Cubes_lu(self):
        """
        See documentation for Cubes_lu_bounds
        """
        return self.Cubes_lu_bounds

    @Cubes_lu.setter
    def Cubes_lu(self, value):
        self.Cubes_lu_bounds = value



class _wannier_cubes2(printable):
    """
    Controls the printing of the wannier functions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Stride = None
        """
        The stride (X,Y,Z) used to write the cube file (larger values result
        in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1
        number valid for all components.
        """
        self.Cubes_lu_bounds = None
        """
        The lower and upper index of the states to be printed as cube
        """
        self.list_Cubes_list = []
        self.Append = None
        """
        append the cube files when they already exist
        """
        self.EACH = _each155()
        self._name = "WANNIER_CUBES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Stride', 'STRIDE'), ('Cubes_lu_bounds', 'CUBES_LU_BOUNDS'), ('Append', 'APPEND')]
        self._repeated_keywords = [('Cubes_list', 'CUBES_LIST')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def add_Cubes_list(self, value):
        self.list_Cubes_list.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Cubes_lu(self):
        """
        See documentation for Cubes_lu_bounds
        """
        return self.Cubes_lu_bounds

    @Cubes_lu.setter
    def Cubes_lu(self, value):
        self.Cubes_lu_bounds = value



class _wannier_cubes5(printable):
    """
    Controls the printing of the wannier functions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Stride = None
        """
        The stride (X,Y,Z) used to write the cube file (larger values result
        in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1
        number valid for all components.
        """
        self.Cubes_lu_bounds = None
        """
        The lower and upper index of the states to be printed as cube
        """
        self.list_Cubes_list = []
        self.Append = None
        """
        append the cube files when they already exist
        """
        self.EACH = _each287()
        self._name = "WANNIER_CUBES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Stride', 'STRIDE'), ('Cubes_lu_bounds', 'CUBES_LU_BOUNDS'), ('Append', 'APPEND')]
        self._repeated_keywords = [('Cubes_list', 'CUBES_LIST')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def add_Cubes_list(self, value):
        self.list_Cubes_list.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Cubes_lu(self):
        """
        See documentation for Cubes_lu_bounds
        """
        return self.Cubes_lu_bounds

    @Cubes_lu.setter
    def Cubes_lu(self, value):
        self.Cubes_lu_bounds = value



class _wannier_cubes4(printable):
    """
    Controls the printing of the wannier functions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Stride = None
        """
        The stride (X,Y,Z) used to write the cube file (larger values result
        in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1
        number valid for all components.
        """
        self.Cubes_lu_bounds = None
        """
        The lower and upper index of the states to be printed as cube
        """
        self.list_Cubes_list = []
        self.Append = None
        """
        append the cube files when they already exist
        """
        self.EACH = _each198()
        self._name = "WANNIER_CUBES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Stride', 'STRIDE'), ('Cubes_lu_bounds', 'CUBES_LU_BOUNDS'), ('Append', 'APPEND')]
        self._repeated_keywords = [('Cubes_list', 'CUBES_LIST')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def add_Cubes_list(self, value):
        self.list_Cubes_list.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Cubes_lu(self):
        """
        See documentation for Cubes_lu_bounds
        """
        return self.Cubes_lu_bounds

    @Cubes_lu.setter
    def Cubes_lu(self, value):
        self.Cubes_lu_bounds = value



class _temp_shell_kind1(printable):
    """
    Controls the output of the temperature of the shell-core motion
    computed separately for each kind
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each36()
        self._name = "TEMP_SHELL_KIND"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _wannier_spreads1(printable):
    """
    Controls the printing of the wannier functions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each147()
        self._name = "WANNIER_SPREADS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _wannier_spreads3(printable):
    """
    Controls the printing of the wannier functions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each168()
        self._name = "WANNIER_SPREADS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _wannier_spreads2(printable):
    """
    Controls the printing of the wannier functions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each157()
        self._name = "WANNIER_SPREADS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _wannier_spreads5(printable):
    """
    Controls the printing of the wannier functions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each289()
        self._name = "WANNIER_SPREADS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _wannier_spreads4(printable):
    """
    Controls the printing of the wannier functions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each200()
        self._name = "WANNIER_SPREADS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _forces2(printable):
    """
    Controls the output of the forces
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.Format = None
        """
        Specifies the format of the output file for the forces.

        Available values:
            ATOMIC
                Write only the coordinates X,Y,Z without element symbols to a
                formatted file
            DCD
                Write the coordinates (no element labels) and the cell information to
                a binary file
            XMOL
                Mostly known as XYZ format, provides in a formatted file:
                element_symbol X Y Z
            XYZ
                Alias name for XMOL
        """
        self.EACH = _each81()
        self._name = "FORCES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT'), ('Format', 'FORMAT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _efield_cube1(printable):
    """
    Controls the printing of cube files with electric  field generated by
    the total density (electrons+ions). It is  valid only for QS with GPW
    formalism .
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Stride = None
        """
        The stride (X,Y,Z) used to write the cube file (larger values result
        in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1
        number valid for all components.
        """
        self.Append = None
        """
        append the cube files when they already exist
        """
        self.EACH = _each195()
        self._name = "EFIELD_CUBE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Stride', 'STRIDE'), ('Append', 'APPEND')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _colvar_func_info4(printable):
    """
    Specify further data possibly used by colvars, depending on the
    starting geometry, for computing the functions value.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Colvar function data. The order is an internal order. So if you decide
        to edit/modify/add these values by hand you should know very well what
        you are doing.!
        """
        self._name = "COLVAR_FUNC_INFO"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _colvar_func_info1(printable):
    """
    Specify further data possibly used by colvars, depending on the
    starting geometry, for computing the functions value.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Colvar function data. The order is an internal order. So if you decide
        to edit/modify/add these values by hand you should know very well what
        you are doing.!
        """
        self._name = "COLVAR_FUNC_INFO"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _colvar_func_info2(printable):
    """
    Specify further data possibly used by colvars, depending on the
    starting geometry, for computing the functions value.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Colvar function data. The order is an internal order. So if you decide
        to edit/modify/add these values by hand you should know very well what
        you are doing.!
        """
        self._name = "COLVAR_FUNC_INFO"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _colvar_func_info3(printable):
    """
    Specify further data possibly used by colvars, depending on the
    starting geometry, for computing the functions value.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Colvar function data. The order is an internal order. So if you decide
        to edit/modify/add these values by hand you should know very well what
        you are doing.!
        """
        self._name = "COLVAR_FUNC_INFO"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _population4(printable):
    """
    Section to define the population of specie as a collective variable.
    """
    def __init__(self):
        self.list_Atoms_from = []
        self.list_Points_from = self.list_Atoms_from
        self.list_Atoms_to = []
        self.list_Points_to = self.list_Atoms_to
        self.list_Kinds_from = []
        self.list_Kinds_to = []
        self.R0 = None
        """
        Specify the R0 parameter in the coordination function.
        """
        self.Nn = None
        """
        Sets the value of the numerator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Nd = None
        """
        Sets the value of the denominator of the exponential factorin the
        coordination FUNCTION.
        """
        self.N0 = None
        """
        Specify the n0 parameter that sets the coordination of the species.
        """
        self.Sigma = None
        """
        Specify the gaussian width of used to build the population istogram.
        """
        self.list_POINT = []
        self._name = "POPULATION"
        self._keywords = [('R0', 'R0'), ('Nn', 'NN'), ('Nd', 'ND'), ('N0', 'N0'), ('Sigma', 'SIGMA')]
        self._repeated_keywords = [('Atoms_from', 'ATOMS_FROM'), ('Atoms_to', 'ATOMS_TO'), ('Kinds_from', 'KINDS_FROM'), ('Kinds_to', 'KINDS_TO')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point59')]

    def add_POINT(self):
        new_section = _point59()
        self.list_POINT.append(new_section)
        return new_section

    def add_Atoms_from(self, value):
        self.list_Atoms_from.append(value)

    def add_Atoms_to(self, value):
        self.list_Atoms_to.append(value)

    def add_Kinds_from(self, value):
        self.list_Kinds_from.append(value)

    def add_Kinds_to(self, value):
        self.list_Kinds_to.append(value)

    def add_Points_from(self, value):
        self.list_KINDS_TO.append(value)

    def add_Points_to(self, value):
        self.list_KINDS_TO.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def R_0(self):
        """
        See documentation for R0
        """
        return self.R0

    @property
    def Expon_numerator(self):
        """
        See documentation for Nn
        """
        return self.Nn

    @property
    def Expon_denominator(self):
        """
        See documentation for Nd
        """
        return self.Nd

    @property
    def N_0(self):
        """
        See documentation for N0
        """
        return self.N0

    @R_0.setter
    def R_0(self, value):
        self.R0 = value

    @Expon_numerator.setter
    def Expon_numerator(self, value):
        self.Nn = value

    @Expon_denominator.setter
    def Expon_denominator(self, value):
        self.Nd = value

    @N_0.setter
    def N_0(self, value):
        self.N0 = value



class _population2(printable):
    """
    Section to define the population of specie as a collective variable.
    """
    def __init__(self):
        self.list_Atoms_from = []
        self.list_Points_from = self.list_Atoms_from
        self.list_Atoms_to = []
        self.list_Points_to = self.list_Atoms_to
        self.list_Kinds_from = []
        self.list_Kinds_to = []
        self.R0 = None
        """
        Specify the R0 parameter in the coordination function.
        """
        self.Nn = None
        """
        Sets the value of the numerator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Nd = None
        """
        Sets the value of the denominator of the exponential factorin the
        coordination FUNCTION.
        """
        self.N0 = None
        """
        Specify the n0 parameter that sets the coordination of the species.
        """
        self.Sigma = None
        """
        Specify the gaussian width of used to build the population istogram.
        """
        self.list_POINT = []
        self._name = "POPULATION"
        self._keywords = [('R0', 'R0'), ('Nn', 'NN'), ('Nd', 'ND'), ('N0', 'N0'), ('Sigma', 'SIGMA')]
        self._repeated_keywords = [('Atoms_from', 'ATOMS_FROM'), ('Atoms_to', 'ATOMS_TO'), ('Kinds_from', 'KINDS_FROM'), ('Kinds_to', 'KINDS_TO')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point23')]

    def add_POINT(self):
        new_section = _point23()
        self.list_POINT.append(new_section)
        return new_section

    def add_Atoms_from(self, value):
        self.list_Atoms_from.append(value)

    def add_Atoms_to(self, value):
        self.list_Atoms_to.append(value)

    def add_Kinds_from(self, value):
        self.list_Kinds_from.append(value)

    def add_Kinds_to(self, value):
        self.list_Kinds_to.append(value)

    def add_Points_from(self, value):
        self.list_KINDS_TO.append(value)

    def add_Points_to(self, value):
        self.list_KINDS_TO.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def R_0(self):
        """
        See documentation for R0
        """
        return self.R0

    @property
    def Expon_numerator(self):
        """
        See documentation for Nn
        """
        return self.Nn

    @property
    def Expon_denominator(self):
        """
        See documentation for Nd
        """
        return self.Nd

    @property
    def N_0(self):
        """
        See documentation for N0
        """
        return self.N0

    @R_0.setter
    def R_0(self, value):
        self.R0 = value

    @Expon_numerator.setter
    def Expon_numerator(self, value):
        self.Nn = value

    @Expon_denominator.setter
    def Expon_denominator(self, value):
        self.Nd = value

    @N_0.setter
    def N_0(self, value):
        self.N0 = value



class _population3(printable):
    """
    Section to define the population of specie as a collective variable.
    """
    def __init__(self):
        self.list_Atoms_from = []
        self.list_Points_from = self.list_Atoms_from
        self.list_Atoms_to = []
        self.list_Points_to = self.list_Atoms_to
        self.list_Kinds_from = []
        self.list_Kinds_to = []
        self.R0 = None
        """
        Specify the R0 parameter in the coordination function.
        """
        self.Nn = None
        """
        Sets the value of the numerator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Nd = None
        """
        Sets the value of the denominator of the exponential factorin the
        coordination FUNCTION.
        """
        self.N0 = None
        """
        Specify the n0 parameter that sets the coordination of the species.
        """
        self.Sigma = None
        """
        Specify the gaussian width of used to build the population istogram.
        """
        self.list_POINT = []
        self._name = "POPULATION"
        self._keywords = [('R0', 'R0'), ('Nn', 'NN'), ('Nd', 'ND'), ('N0', 'N0'), ('Sigma', 'SIGMA')]
        self._repeated_keywords = [('Atoms_from', 'ATOMS_FROM'), ('Atoms_to', 'ATOMS_TO'), ('Kinds_from', 'KINDS_FROM'), ('Kinds_to', 'KINDS_TO')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point41')]

    def add_POINT(self):
        new_section = _point41()
        self.list_POINT.append(new_section)
        return new_section

    def add_Atoms_from(self, value):
        self.list_Atoms_from.append(value)

    def add_Atoms_to(self, value):
        self.list_Atoms_to.append(value)

    def add_Kinds_from(self, value):
        self.list_Kinds_from.append(value)

    def add_Kinds_to(self, value):
        self.list_Kinds_to.append(value)

    def add_Points_from(self, value):
        self.list_KINDS_TO.append(value)

    def add_Points_to(self, value):
        self.list_KINDS_TO.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def R_0(self):
        """
        See documentation for R0
        """
        return self.R0

    @property
    def Expon_numerator(self):
        """
        See documentation for Nn
        """
        return self.Nn

    @property
    def Expon_denominator(self):
        """
        See documentation for Nd
        """
        return self.Nd

    @property
    def N_0(self):
        """
        See documentation for N0
        """
        return self.N0

    @R_0.setter
    def R_0(self, value):
        self.R0 = value

    @Expon_numerator.setter
    def Expon_numerator(self, value):
        self.Nn = value

    @Expon_denominator.setter
    def Expon_denominator(self, value):
        self.Nd = value

    @N_0.setter
    def N_0(self, value):
        self.N0 = value



class _population1(printable):
    """
    Section to define the population of specie as a collective variable.
    """
    def __init__(self):
        self.list_Atoms_from = []
        self.list_Points_from = self.list_Atoms_from
        self.list_Atoms_to = []
        self.list_Points_to = self.list_Atoms_to
        self.list_Kinds_from = []
        self.list_Kinds_to = []
        self.R0 = None
        """
        Specify the R0 parameter in the coordination function.
        """
        self.Nn = None
        """
        Sets the value of the numerator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Nd = None
        """
        Sets the value of the denominator of the exponential factorin the
        coordination FUNCTION.
        """
        self.N0 = None
        """
        Specify the n0 parameter that sets the coordination of the species.
        """
        self.Sigma = None
        """
        Specify the gaussian width of used to build the population istogram.
        """
        self.list_POINT = []
        self._name = "POPULATION"
        self._keywords = [('R0', 'R0'), ('Nn', 'NN'), ('Nd', 'ND'), ('N0', 'N0'), ('Sigma', 'SIGMA')]
        self._repeated_keywords = [('Atoms_from', 'ATOMS_FROM'), ('Atoms_to', 'ATOMS_TO'), ('Kinds_from', 'KINDS_FROM'), ('Kinds_to', 'KINDS_TO')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point5')]

    def add_POINT(self):
        new_section = _point5()
        self.list_POINT.append(new_section)
        return new_section

    def add_Atoms_from(self, value):
        self.list_Atoms_from.append(value)

    def add_Atoms_to(self, value):
        self.list_Atoms_to.append(value)

    def add_Kinds_from(self, value):
        self.list_Kinds_from.append(value)

    def add_Kinds_to(self, value):
        self.list_Kinds_to.append(value)

    def add_Points_from(self, value):
        self.list_KINDS_TO.append(value)

    def add_Points_to(self, value):
        self.list_KINDS_TO.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def R_0(self):
        """
        See documentation for R0
        """
        return self.R0

    @property
    def Expon_numerator(self):
        """
        See documentation for Nn
        """
        return self.Nn

    @property
    def Expon_denominator(self):
        """
        See documentation for Nd
        """
        return self.Nd

    @property
    def N_0(self):
        """
        See documentation for N0
        """
        return self.N0

    @R_0.setter
    def R_0(self, value):
        self.R0 = value

    @Expon_numerator.setter
    def Expon_numerator(self, value):
        self.Nn = value

    @Expon_denominator.setter
    def Expon_denominator(self, value):
        self.Nd = value

    @N_0.setter
    def N_0(self, value):
        self.N0 = value



class _coulomb1(printable):
    """
    Setup parameters for the evaluation of the COULOMB term in SE
    calculations.
    """
    def __init__(self):
        self.Cutoff = None
        """
        Atomic Cutoff Radius Cutoff for the evaluation of the  Coulomb
        integrals. For non-periodic calculation the default value is exactly
        the full cell dimension, in order to evaluate all pair interactions.
        Instead, for periodic calculations the default numerical value is
        used.
        """
        self.Rc_taper = None
        """
        Atomic Cutoff Radius Cutoff for Tapering Coulomb integrals. If not
        specified it assumes the same value specified for the CUTOFF.
        """
        self.Rc_range = None
        """
        Range of cutoff switch function (tapering):
        0.5*(1-TANH((r-r0)/RC_RANGE)), where r0=2.0*RC_TAPER-20.0*RC_RANGE.
        """
        self._name = "COULOMB"
        self._keywords = [('Cutoff', 'CUTOFF'), ('Rc_taper', 'RC_TAPER'), ('Rc_range', 'RC_RANGE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _subsys1(printable):
    """
    a subsystem: coordinates, topology, molecules and cell
    """
    def __init__(self):
        self.RNG_INIT = _rng_init8()
        self.CELL = _cell4()
        self.COORD = _coord10()
        self.VELOCITY = _velocity10()
        self.list_KIND = []
        self.TOPOLOGY = _topology1()
        self.list_COLVAR = []
        self.MULTIPOLES = _multipoles3()
        self.SHELL_COORD = _shell_coord1()
        self.SHELL_VELOCITY = _shell_velocity1()
        self.CORE_COORD = _core_coord1()
        self.CORE_VELOCITY = _core_velocity1()
        self.PRINT = _print47()
        self._name = "SUBSYS"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('RNG_INIT', 'RNG_INIT'), ('CELL', 'CELL'), ('COORD', 'COORD'), ('VELOCITY', 'VELOCITY'), ('TOPOLOGY', 'TOPOLOGY'), ('MULTIPOLES', 'MULTIPOLES'), ('SHELL_COORD', 'SHELL_COORD'), ('SHELL_VELOCITY', 'SHELL_VELOCITY'), ('CORE_COORD', 'CORE_COORD'), ('CORE_VELOCITY', 'CORE_VELOCITY'), ('PRINT', 'PRINT')]
        self._repeated_subsections = [('KIND', '_kind1'), ('COLVAR', '_colvar5')]

    def add_KIND(self):
        new_section = _kind1()
        self.list_KIND.append(new_section)
        return new_section

    def add_COLVAR(self):
        new_section = _colvar5()
        self.list_COLVAR.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _thermostat_info1(printable):
    """
    Controls output information of the corresponding thermostat.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each18()
        self._name = "THERMOSTAT_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _thermostat_info2(printable):
    """
    Controls output information of the corresponding thermostat.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each22()
        self._name = "THERMOSTAT_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _thermostat_info3(printable):
    """
    Controls output information of the corresponding thermostat.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each25()
        self._name = "THERMOSTAT_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _ke_libxc4(printable):
    """
    To be used for KG runs. Uses kinetic energy functionals from LIBXC,
    see also http://www.tddft.org/programs/octopus/wiki/index.php/Libxc
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Functional = None
        """
        names of the functionals, see also
        http://www.tddft.org/programs/octopus/wiki/index.php/Libxc:manual .The
        precise list of available functionals depends on the version of libxc
        interfaced (currently 2.0.1).
        """
        self.Scale = None
        """
        scaling factors of the functionals
        """
        self.Parameters = None
        """
        parameters of the functionals
        """
        self._name = "KE_LIBXC"
        self._keywords = [('Functional', 'FUNCTIONAL'), ('Scale', 'SCALE'), ('Parameters', 'PARAMETERS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _ke_libxc2(printable):
    """
    To be used for KG runs. Uses kinetic energy functionals from LIBXC,
    see also http://www.tddft.org/programs/octopus/wiki/index.php/Libxc
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Functional = None
        """
        names of the functionals, see also
        http://www.tddft.org/programs/octopus/wiki/index.php/Libxc:manual .The
        precise list of available functionals depends on the version of libxc
        interfaced (currently 2.0.1).
        """
        self.Scale = None
        """
        scaling factors of the functionals
        """
        self.Parameters = None
        """
        parameters of the functionals
        """
        self._name = "KE_LIBXC"
        self._keywords = [('Functional', 'FUNCTIONAL'), ('Scale', 'SCALE'), ('Parameters', 'PARAMETERS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _ke_libxc3(printable):
    """
    To be used for KG runs. Uses kinetic energy functionals from LIBXC,
    see also http://www.tddft.org/programs/octopus/wiki/index.php/Libxc
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Functional = None
        """
        names of the functionals, see also
        http://www.tddft.org/programs/octopus/wiki/index.php/Libxc:manual .The
        precise list of available functionals depends on the version of libxc
        interfaced (currently 2.0.1).
        """
        self.Scale = None
        """
        scaling factors of the functionals
        """
        self.Parameters = None
        """
        parameters of the functionals
        """
        self._name = "KE_LIBXC"
        self._keywords = [('Functional', 'FUNCTIONAL'), ('Scale', 'SCALE'), ('Parameters', 'PARAMETERS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _ke_libxc1(printable):
    """
    To be used for KG runs. Uses kinetic energy functionals from LIBXC,
    see also http://www.tddft.org/programs/octopus/wiki/index.php/Libxc
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Functional = None
        """
        names of the functionals, see also
        http://www.tddft.org/programs/octopus/wiki/index.php/Libxc:manual .The
        precise list of available functionals depends on the version of libxc
        interfaced (currently 2.0.1).
        """
        self.Scale = None
        """
        scaling factors of the functionals
        """
        self.Parameters = None
        """
        parameters of the functionals
        """
        self._name = "KE_LIBXC"
        self._keywords = [('Functional', 'FUNCTIONAL'), ('Scale', 'SCALE'), ('Parameters', 'PARAMETERS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _cg3(printable):
    """
    Provides parameters to tune the conjugate gradient optimization
    """
    def __init__(self):
        self.Max_steep_steps = None
        """
        Maximum number of steepest descent steps before starting the conjugate
        gradients optimization.
        """
        self.Restart_limit = None
        """
        Cosine of the angle between two consecutive searching directions. If
        the angle during a CG optimization is less than the one corresponding
        to  to the RESTART_LIMIT the CG is reset and one step of steepest
        descent is  performed.
        """
        self.Fletcher_reeves = None
        """
        Uses FLETCHER-REEVES instead of POLAK-RIBIERE when using Conjugate
        Gradients
        """
        self.LINE_SEARCH = _line_search3()
        self._name = "CG"
        self._keywords = [('Max_steep_steps', 'MAX_STEEP_STEPS'), ('Restart_limit', 'RESTART_LIMIT'), ('Fletcher_reeves', 'FLETCHER_REEVES')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('LINE_SEARCH', 'LINE_SEARCH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _cg2(printable):
    """
    Provides parameters to tune the conjugate gradient optimization
    """
    def __init__(self):
        self.Max_steep_steps = None
        """
        Maximum number of steepest descent steps before starting the conjugate
        gradients optimization.
        """
        self.Restart_limit = None
        """
        Cosine of the angle between two consecutive searching directions. If
        the angle during a CG optimization is less than the one corresponding
        to  to the RESTART_LIMIT the CG is reset and one step of steepest
        descent is  performed.
        """
        self.Fletcher_reeves = None
        """
        Uses FLETCHER-REEVES instead of POLAK-RIBIERE when using Conjugate
        Gradients
        """
        self.LINE_SEARCH = _line_search2()
        self._name = "CG"
        self._keywords = [('Max_steep_steps', 'MAX_STEEP_STEPS'), ('Restart_limit', 'RESTART_LIMIT'), ('Fletcher_reeves', 'FLETCHER_REEVES')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('LINE_SEARCH', 'LINE_SEARCH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _cg1(printable):
    """
    Provides parameters to tune the conjugate gradient optimization
    """
    def __init__(self):
        self.Max_steep_steps = None
        """
        Maximum number of steepest descent steps before starting the conjugate
        gradients optimization.
        """
        self.Restart_limit = None
        """
        Cosine of the angle between two consecutive searching directions. If
        the angle during a CG optimization is less than the one corresponding
        to  to the RESTART_LIMIT the CG is reset and one step of steepest
        descent is  performed.
        """
        self.Fletcher_reeves = None
        """
        Uses FLETCHER-REEVES instead of POLAK-RIBIERE when using Conjugate
        Gradients
        """
        self.LINE_SEARCH = _line_search1()
        self._name = "CG"
        self._keywords = [('Max_steep_steps', 'MAX_STEEP_STEPS'), ('Restart_limit', 'RESTART_LIMIT'), ('Fletcher_reeves', 'FLETCHER_REEVES')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('LINE_SEARCH', 'LINE_SEARCH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _cg4(printable):
    """
    Provides parameters to tune the conjugate gradient optimization
    """
    def __init__(self):
        self.Max_steep_steps = None
        """
        Maximum number of steepest descent steps before starting the conjugate
        gradients optimization.
        """
        self.Restart_limit = None
        """
        Cosine of the angle between two consecutive searching directions. If
        the angle during a CG optimization is less than the one corresponding
        to  to the RESTART_LIMIT the CG is reset and one step of steepest
        descent is  performed.
        """
        self.Fletcher_reeves = None
        """
        Uses FLETCHER-REEVES instead of POLAK-RIBIERE when using Conjugate
        Gradients
        """
        self.LINE_SEARCH = _line_search4()
        self._name = "CG"
        self._keywords = [('Max_steep_steps', 'MAX_STEEP_STEPS'), ('Restart_limit', 'RESTART_LIMIT'), ('Fletcher_reeves', 'FLETCHER_REEVES')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('LINE_SEARCH', 'LINE_SEARCH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _saop1(printable):
    """
    Uses the SAOP potential
    """
    def __init__(self):
        self.Alpha = None
        """
        Value of the alpha parameter (default = 1.19).
        """
        self.Beta = None
        """
        Value of the beta parameter (default = 0.01).
        """
        self.K_rho = None
        """
        Value of the K_rho parameter (default = 0.42).
        """
        self._name = "SAOP"
        self._keywords = [('Alpha', 'ALPHA'), ('Beta', 'BETA'), ('K_rho', 'K_RHO')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _saop2(printable):
    """
    Uses the SAOP potential
    """
    def __init__(self):
        self.Alpha = None
        """
        Value of the alpha parameter (default = 1.19).
        """
        self.Beta = None
        """
        Value of the beta parameter (default = 0.01).
        """
        self.K_rho = None
        """
        Value of the K_rho parameter (default = 0.42).
        """
        self._name = "SAOP"
        self._keywords = [('Alpha', 'ALPHA'), ('Beta', 'BETA'), ('K_rho', 'K_RHO')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _saop3(printable):
    """
    Uses the SAOP potential
    """
    def __init__(self):
        self.Alpha = None
        """
        Value of the alpha parameter (default = 1.19).
        """
        self.Beta = None
        """
        Value of the beta parameter (default = 0.01).
        """
        self.K_rho = None
        """
        Value of the K_rho parameter (default = 0.42).
        """
        self._name = "SAOP"
        self._keywords = [('Alpha', 'ALPHA'), ('Beta', 'BETA'), ('K_rho', 'K_RHO')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _saop4(printable):
    """
    Uses the SAOP potential
    """
    def __init__(self):
        self.Alpha = None
        """
        Value of the alpha parameter (default = 1.19).
        """
        self.Beta = None
        """
        Value of the beta parameter (default = 0.01).
        """
        self.K_rho = None
        """
        Value of the K_rho parameter (default = 0.42).
        """
        self._name = "SAOP"
        self._keywords = [('Alpha', 'ALPHA'), ('Beta', 'BETA'), ('K_rho', 'K_RHO')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _curvy_steps1(printable):
    """
    Specifies the parameters of the linear scaling SCF routines
    """
    def __init__(self):
        self.Line_search = None
        """
        Line serch type used in the curvy_setp optimization.

        Available values:
            3POINT
                Performs a three point line search
            3POINT_2D
                Only for spin unrestricted calcualtions. Separate step sizes for alpha
                and beta spin using a fit to a 2D parabolic function
        """
        self.N_bch_history = None
        """
        Number of stored matrices in the Baker-Campbell-Hausdorff series.
        Reduces the BCH evaluation during line search but can be memory
        intense.
        """
        self.Min_hessian_shift = None
        """
        Minimal eigenvalue shift for the Hessian in the Newton iteration.
        Useful for small band gap systems (0.5-1.0 recommended).
        """
        self.Filter_factor = None
        """
        Allows to set a seperate EPS_FILTER in the newton iterations. The new
        EPS is EPS_FILTER*FILTER_FACTOR.
        """
        self.Filter_factor_scale = None
        """
        Allows for dynamic EPS_FILTER. Updates the filter factor every scf-
        newton step by FILTER_FACTOR=FILTER_FACTOR*FILTER_FACTOR_SCALE
        """
        self.Min_filter = None
        """
        Lowest EPS_FILTER in dynamic filtering. Given as multiple of
        EPS_FILTER: EPS_FILTER_MIN=EPS_FILTER*MIN_FILTER
        """
        self._name = "CURVY_STEPS"
        self._keywords = [('Line_search', 'LINE_SEARCH'), ('N_bch_history', 'N_BCH_HISTORY'), ('Min_hessian_shift', 'MIN_HESSIAN_SHIFT'), ('Filter_factor', 'FILTER_FACTOR'), ('Filter_factor_scale', 'FILTER_FACTOR_SCALE'), ('Min_filter', 'MIN_FILTER')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _m_sampling1(printable):
    """
    Permutation cycle length sampling settings
    """
    def __init__(self):
        self.M_value = None
        """
        Value of m treated in a special way
        """
        self.M_ratio = None
        """
        Probability ratio betw M-VALUE and other cycle lengths
        """
        self._name = "M-SAMPLING"
        self._keywords = [('M_value', 'M-VALUE'), ('M_ratio', 'M-RATIO')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _smear1(printable):
    """
    Define the smearing of the MO occupation numbers
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Controls the activation of smearing
        """
        self.Method = None
        """
        Smearing method to be applied

        Available values:
            FERMI_DIRAC
                Fermi-Dirac distribution defined by the keyword ELECTRONIC_TEMPERATURE
            ENERGY_WINDOW
                Energy window defined by the keyword WINDOW_SIZE
            LIST
                Use a fixed list of occupations
        """
        self.List = None
        """
        A list of fractional occupations to use. Must match the number of
        states and sum up to the correct number of electrons
        """
        self.Electronic_temperature = None
        """
        Electronic temperature in the case of Fermi-Dirac smearing
        """
        self.Eps_fermi_dirac = None
        """
        Accuracy checks on occupation numbers use this as a tolerance
        """
        self.Window_size = None
        """
        Size of the energy window centred at the Fermi level
        """
        self.Fixed_magnetic_moment = None
        """
        Imposed difference between the numbers of electrons of spin up and
        spin down: m = n(up) - n(down). A negative value (default) allows for
        a change of the magnetic moment. -1 specifically keeps an integer
        number of spin up and spin down electrons.
        """
        self._name = "SMEAR"
        self._keywords = [('Method', 'METHOD'), ('List', 'LIST'), ('Electronic_temperature', 'ELECTRONIC_TEMPERATURE'), ('Eps_fermi_dirac', 'EPS_FERMI_DIRAC'), ('Window_size', 'WINDOW_SIZE'), ('Fixed_magnetic_moment', 'FIXED_MAGNETIC_MOMENT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Elec_temp(self):
        """
        See documentation for Electronic_temperature
        """
        return self.Electronic_temperature

    @property
    def Telec(self):
        """
        See documentation for Electronic_temperature
        """
        return self.Electronic_temperature

    @Elec_temp.setter
    def Elec_temp(self, value):
        self.Electronic_temperature = value

    @Telec.setter
    def Telec(self, value):
        self.Electronic_temperature = value



class _fit_charge1(printable):
    """
    This section is used to print the density derived atomic point
    charges.The fit of the charges is controlled through the
    DENSITY_FITTING section
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Type_of_density = None
        """
        Specifies the type of density used for the fitting

        Available values:
            FULL
                Full density
            SPIN
                Spin density
        """
        self.EACH = _each334()
        self._name = "FIT_CHARGE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Type_of_density', 'TYPE_OF_DENSITY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _hydronium4(printable):
    """
    Section to define the formation of a hydronium as a collective
    variable.
    """
    def __init__(self):
        self.list_Oxygens = []
        self.list_Hydrogens = []
        self.Roo = None
        """
        Specify the ROO parameter in the coordination function.
        """
        self.Pno = None
        """
        Sets the value of the numerator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Qno = None
        """
        Sets the value of the denominator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Roh = None
        """
        Specify the ROH parameter in the coordination function.
        """
        self.Pnh = None
        """
        Sets the value of the numerator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Qnh = None
        """
        Sets the value of the denominator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Nh = None
        """
        Specify the NH parameter in the hydronium function.
        """
        self.P = None
        """
        Sets the value of the numerator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Q = None
        """
        Sets the value of the denominator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Lambda = None
        """
        Specify the LAMBDA parameter in the hydronium function.
        """
        self.Lambda = None
        """
        Specify the LAMBDA parameter in the hydronium function.
        """
        self.list_POINT = []
        self._name = "HYDRONIUM"
        self._keywords = [('Roo', 'ROO'), ('Pno', 'PNO'), ('Qno', 'QNO'), ('Roh', 'ROH'), ('Pnh', 'PNH'), ('Qnh', 'QNH'), ('Nh', 'NH'), ('P', 'P'), ('Q', 'Q'), ('Lambda', 'LAMBDA'), ('Lambda', 'LAMBDA')]
        self._repeated_keywords = [('Oxygens', 'OXYGENS'), ('Hydrogens', 'HYDROGENS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point66')]

    def add_POINT(self):
        new_section = _point66()
        self.list_POINT.append(new_section)
        return new_section

    def add_Oxygens(self, value):
        self.list_Oxygens.append(value)

    def add_Hydrogens(self, value):
        self.list_Hydrogens.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def R_oo(self):
        """
        See documentation for Roo
        """
        return self.Roo

    @property
    def Expon_numeratora(self):
        """
        See documentation for Pno
        """
        return self.Pno

    @property
    def Expon_denominatora(self):
        """
        See documentation for Qno
        """
        return self.Qno

    @property
    def R_oh(self):
        """
        See documentation for Roh
        """
        return self.Roh

    @property
    def Expon_numeratorb(self):
        """
        See documentation for Pnh
        """
        return self.Pnh

    @property
    def Expon_denominatorb(self):
        """
        See documentation for Qnh
        """
        return self.Qnh

    @property
    def Nhtest(self):
        """
        See documentation for Nh
        """
        return self.Nh

    @property
    def Expon_numerator(self):
        """
        See documentation for P
        """
        return self.P

    @property
    def Expon_denominator(self):
        """
        See documentation for Q
        """
        return self.Q

    @R_oo.setter
    def R_oo(self, value):
        self.Roo = value

    @Expon_numeratora.setter
    def Expon_numeratora(self, value):
        self.Pno = value

    @Expon_denominatora.setter
    def Expon_denominatora(self, value):
        self.Qno = value

    @R_oh.setter
    def R_oh(self, value):
        self.Roh = value

    @Expon_numeratorb.setter
    def Expon_numeratorb(self, value):
        self.Pnh = value

    @Expon_denominatorb.setter
    def Expon_denominatorb(self, value):
        self.Qnh = value

    @Nhtest.setter
    def Nhtest(self, value):
        self.Nh = value

    @Expon_numerator.setter
    def Expon_numerator(self, value):
        self.P = value

    @Expon_denominator.setter
    def Expon_denominator(self, value):
        self.Q = value



class _memory9(printable):
    """
    Sets up memory parameters for the storage of the ERI's if requested
    """
    def __init__(self):
        self.Eps_storage_scaling = None
        """
        Scaling factor to scale eps_schwarz. Storage threshold for compression
        will be EPS_SCHWARZ*EPS_STORAGE_SCALING.
        """
        self.Max_memory = None
        """
        Defines the maximum amount of memory [MB] to be consumed by the full
        HFX module. All temporary buffers and helper arrays are subtracted
        from this number. What remains will be used for storage of integrals.
        NOTE: This number is assumed to represent the memory available to one
        MPI process. When running a threaded version, cp2k automatically takes
        care of distributing the memory among all involved sub-processes.
        """
        self.Storage_location = None
        """
        Loaction where ERI's are stored if MAX_DISK_SPACE /=0 Expects a path
        to a directory.
        """
        self.Max_disk_space = None
        """
        Defines the maximum amount of disk space [MB] used to store
        precomputed compressed four-center integrals. If 0, nothing is stored
        to disk
        """
        self.Treat_forces_in_core = None
        """
        Determines whether the derivative ERI's should be stored to RAM or
        not. Only meaningful when performing Ehrenfest MD. Memory usage is
        defined via MAX_MEMORY, i.e. the memory is shared wit the energy
        ERI's.
        """
        self._name = "MEMORY"
        self._keywords = [('Eps_storage_scaling', 'EPS_STORAGE_SCALING'), ('Max_memory', 'MAX_MEMORY'), ('Storage_location', 'STORAGE_LOCATION'), ('Max_disk_space', 'MAX_DISK_SPACE'), ('Treat_forces_in_core', 'TREAT_FORCES_IN_CORE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Eps_storage(self):
        """
        See documentation for Eps_storage_scaling
        """
        return self.Eps_storage_scaling

    @Eps_storage.setter
    def Eps_storage(self, value):
        self.Eps_storage_scaling = value



class _hydronium1(printable):
    """
    Section to define the formation of a hydronium as a collective
    variable.
    """
    def __init__(self):
        self.list_Oxygens = []
        self.list_Hydrogens = []
        self.Roo = None
        """
        Specify the ROO parameter in the coordination function.
        """
        self.Pno = None
        """
        Sets the value of the numerator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Qno = None
        """
        Sets the value of the denominator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Roh = None
        """
        Specify the ROH parameter in the coordination function.
        """
        self.Pnh = None
        """
        Sets the value of the numerator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Qnh = None
        """
        Sets the value of the denominator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Nh = None
        """
        Specify the NH parameter in the hydronium function.
        """
        self.P = None
        """
        Sets the value of the numerator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Q = None
        """
        Sets the value of the denominator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Lambda = None
        """
        Specify the LAMBDA parameter in the hydronium function.
        """
        self.Lambda = None
        """
        Specify the LAMBDA parameter in the hydronium function.
        """
        self.list_POINT = []
        self._name = "HYDRONIUM"
        self._keywords = [('Roo', 'ROO'), ('Pno', 'PNO'), ('Qno', 'QNO'), ('Roh', 'ROH'), ('Pnh', 'PNH'), ('Qnh', 'QNH'), ('Nh', 'NH'), ('P', 'P'), ('Q', 'Q'), ('Lambda', 'LAMBDA'), ('Lambda', 'LAMBDA')]
        self._repeated_keywords = [('Oxygens', 'OXYGENS'), ('Hydrogens', 'HYDROGENS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point12')]

    def add_POINT(self):
        new_section = _point12()
        self.list_POINT.append(new_section)
        return new_section

    def add_Oxygens(self, value):
        self.list_Oxygens.append(value)

    def add_Hydrogens(self, value):
        self.list_Hydrogens.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def R_oo(self):
        """
        See documentation for Roo
        """
        return self.Roo

    @property
    def Expon_numeratora(self):
        """
        See documentation for Pno
        """
        return self.Pno

    @property
    def Expon_denominatora(self):
        """
        See documentation for Qno
        """
        return self.Qno

    @property
    def R_oh(self):
        """
        See documentation for Roh
        """
        return self.Roh

    @property
    def Expon_numeratorb(self):
        """
        See documentation for Pnh
        """
        return self.Pnh

    @property
    def Expon_denominatorb(self):
        """
        See documentation for Qnh
        """
        return self.Qnh

    @property
    def Nhtest(self):
        """
        See documentation for Nh
        """
        return self.Nh

    @property
    def Expon_numerator(self):
        """
        See documentation for P
        """
        return self.P

    @property
    def Expon_denominator(self):
        """
        See documentation for Q
        """
        return self.Q

    @R_oo.setter
    def R_oo(self, value):
        self.Roo = value

    @Expon_numeratora.setter
    def Expon_numeratora(self, value):
        self.Pno = value

    @Expon_denominatora.setter
    def Expon_denominatora(self, value):
        self.Qno = value

    @R_oh.setter
    def R_oh(self, value):
        self.Roh = value

    @Expon_numeratorb.setter
    def Expon_numeratorb(self, value):
        self.Pnh = value

    @Expon_denominatorb.setter
    def Expon_denominatorb(self, value):
        self.Qnh = value

    @Nhtest.setter
    def Nhtest(self, value):
        self.Nh = value

    @Expon_numerator.setter
    def Expon_numerator(self, value):
        self.P = value

    @Expon_denominator.setter
    def Expon_denominator(self, value):
        self.Q = value



class _hydronium3(printable):
    """
    Section to define the formation of a hydronium as a collective
    variable.
    """
    def __init__(self):
        self.list_Oxygens = []
        self.list_Hydrogens = []
        self.Roo = None
        """
        Specify the ROO parameter in the coordination function.
        """
        self.Pno = None
        """
        Sets the value of the numerator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Qno = None
        """
        Sets the value of the denominator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Roh = None
        """
        Specify the ROH parameter in the coordination function.
        """
        self.Pnh = None
        """
        Sets the value of the numerator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Qnh = None
        """
        Sets the value of the denominator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Nh = None
        """
        Specify the NH parameter in the hydronium function.
        """
        self.P = None
        """
        Sets the value of the numerator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Q = None
        """
        Sets the value of the denominator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Lambda = None
        """
        Specify the LAMBDA parameter in the hydronium function.
        """
        self.Lambda = None
        """
        Specify the LAMBDA parameter in the hydronium function.
        """
        self.list_POINT = []
        self._name = "HYDRONIUM"
        self._keywords = [('Roo', 'ROO'), ('Pno', 'PNO'), ('Qno', 'QNO'), ('Roh', 'ROH'), ('Pnh', 'PNH'), ('Qnh', 'QNH'), ('Nh', 'NH'), ('P', 'P'), ('Q', 'Q'), ('Lambda', 'LAMBDA'), ('Lambda', 'LAMBDA')]
        self._repeated_keywords = [('Oxygens', 'OXYGENS'), ('Hydrogens', 'HYDROGENS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point48')]

    def add_POINT(self):
        new_section = _point48()
        self.list_POINT.append(new_section)
        return new_section

    def add_Oxygens(self, value):
        self.list_Oxygens.append(value)

    def add_Hydrogens(self, value):
        self.list_Hydrogens.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def R_oo(self):
        """
        See documentation for Roo
        """
        return self.Roo

    @property
    def Expon_numeratora(self):
        """
        See documentation for Pno
        """
        return self.Pno

    @property
    def Expon_denominatora(self):
        """
        See documentation for Qno
        """
        return self.Qno

    @property
    def R_oh(self):
        """
        See documentation for Roh
        """
        return self.Roh

    @property
    def Expon_numeratorb(self):
        """
        See documentation for Pnh
        """
        return self.Pnh

    @property
    def Expon_denominatorb(self):
        """
        See documentation for Qnh
        """
        return self.Qnh

    @property
    def Nhtest(self):
        """
        See documentation for Nh
        """
        return self.Nh

    @property
    def Expon_numerator(self):
        """
        See documentation for P
        """
        return self.P

    @property
    def Expon_denominator(self):
        """
        See documentation for Q
        """
        return self.Q

    @R_oo.setter
    def R_oo(self, value):
        self.Roo = value

    @Expon_numeratora.setter
    def Expon_numeratora(self, value):
        self.Pno = value

    @Expon_denominatora.setter
    def Expon_denominatora(self, value):
        self.Qno = value

    @R_oh.setter
    def R_oh(self, value):
        self.Roh = value

    @Expon_numeratorb.setter
    def Expon_numeratorb(self, value):
        self.Pnh = value

    @Expon_denominatorb.setter
    def Expon_denominatorb(self, value):
        self.Qnh = value

    @Nhtest.setter
    def Nhtest(self, value):
        self.Nh = value

    @Expon_numerator.setter
    def Expon_numerator(self, value):
        self.P = value

    @Expon_denominator.setter
    def Expon_denominator(self, value):
        self.Q = value



class _hydronium2(printable):
    """
    Section to define the formation of a hydronium as a collective
    variable.
    """
    def __init__(self):
        self.list_Oxygens = []
        self.list_Hydrogens = []
        self.Roo = None
        """
        Specify the ROO parameter in the coordination function.
        """
        self.Pno = None
        """
        Sets the value of the numerator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Qno = None
        """
        Sets the value of the denominator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Roh = None
        """
        Specify the ROH parameter in the coordination function.
        """
        self.Pnh = None
        """
        Sets the value of the numerator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Qnh = None
        """
        Sets the value of the denominator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Nh = None
        """
        Specify the NH parameter in the hydronium function.
        """
        self.P = None
        """
        Sets the value of the numerator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Q = None
        """
        Sets the value of the denominator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Lambda = None
        """
        Specify the LAMBDA parameter in the hydronium function.
        """
        self.Lambda = None
        """
        Specify the LAMBDA parameter in the hydronium function.
        """
        self.list_POINT = []
        self._name = "HYDRONIUM"
        self._keywords = [('Roo', 'ROO'), ('Pno', 'PNO'), ('Qno', 'QNO'), ('Roh', 'ROH'), ('Pnh', 'PNH'), ('Qnh', 'QNH'), ('Nh', 'NH'), ('P', 'P'), ('Q', 'Q'), ('Lambda', 'LAMBDA'), ('Lambda', 'LAMBDA')]
        self._repeated_keywords = [('Oxygens', 'OXYGENS'), ('Hydrogens', 'HYDROGENS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point30')]

    def add_POINT(self):
        new_section = _point30()
        self.list_POINT.append(new_section)
        return new_section

    def add_Oxygens(self, value):
        self.list_Oxygens.append(value)

    def add_Hydrogens(self, value):
        self.list_Hydrogens.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def R_oo(self):
        """
        See documentation for Roo
        """
        return self.Roo

    @property
    def Expon_numeratora(self):
        """
        See documentation for Pno
        """
        return self.Pno

    @property
    def Expon_denominatora(self):
        """
        See documentation for Qno
        """
        return self.Qno

    @property
    def R_oh(self):
        """
        See documentation for Roh
        """
        return self.Roh

    @property
    def Expon_numeratorb(self):
        """
        See documentation for Pnh
        """
        return self.Pnh

    @property
    def Expon_denominatorb(self):
        """
        See documentation for Qnh
        """
        return self.Qnh

    @property
    def Nhtest(self):
        """
        See documentation for Nh
        """
        return self.Nh

    @property
    def Expon_numerator(self):
        """
        See documentation for P
        """
        return self.P

    @property
    def Expon_denominator(self):
        """
        See documentation for Q
        """
        return self.Q

    @R_oo.setter
    def R_oo(self, value):
        self.Roo = value

    @Expon_numeratora.setter
    def Expon_numeratora(self, value):
        self.Pno = value

    @Expon_denominatora.setter
    def Expon_denominatora(self, value):
        self.Qno = value

    @R_oh.setter
    def R_oh(self, value):
        self.Roh = value

    @Expon_numeratorb.setter
    def Expon_numeratorb(self, value):
        self.Pnh = value

    @Expon_denominatorb.setter
    def Expon_denominatorb(self, value):
        self.Qnh = value

    @Nhtest.setter
    def Nhtest(self, value):
        self.Nh = value

    @Expon_numerator.setter
    def Expon_numerator(self, value):
        self.P = value

    @Expon_denominator.setter
    def Expon_denominator(self, value):
        self.Q = value



class _density_fitting1(printable):
    """
    Setup parameters for density fitting (Bloechl charges or density
    derived  atomic point charges (DDAPC) charges)
    """
    def __init__(self):
        self.Num_gauss = None
        """
        Specifies the numbers of gaussian used to fit the QM density for each
        atomic site.
        """
        self.Pfactor = None
        """
        Specifies the progression factor for the gaussian exponent for each
        atomic site.
        """
        self.Min_radius = None
        """
        Specifies the smallest radius of the gaussian used in the fit. All
        other radius are obtained with the progression factor.
        """
        self.Radii = None
        """
        Specifies all the radius of the gaussian used in the fit for each
        atomic site. The use of this keyword disables all other keywords of
        this section.
        """
        self.Gcut = None
        """
        Cutoff for charge fit in G-space.
        """
        self.PROGRAM_RUN_INFO = _program_run_info24()
        self._name = "DENSITY_FITTING"
        self._keywords = [('Num_gauss', 'NUM_GAUSS'), ('Pfactor', 'PFACTOR'), ('Min_radius', 'MIN_RADIUS'), ('Radii', 'RADII'), ('Gcut', 'GCUT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each70(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _screening4(printable):
    """
    Sets up screening parameters if requested
    """
    def __init__(self):
        self.Eps_schwarz = None
        """
        Screens the near field part of the electronic repulsion integrals
        using the Schwarz inequality for the given threshold.
        """
        self.Eps_schwarz_forces = None
        """
        Screens the near field part of the electronic repulsion integrals
        using the Schwarz inequality for the given threshold. This will be
        approximately the accuracy of the forces,  and should normally be
        similar to EPS_SCF
        """
        self.Screen_p_forces = None
        """
        Screens the electronic repulsion integrals for the forces using the
        density matrix. This results in a significant speedup for large
        systems, but might require a somewhat tigher EPS_SCHWARZ_FORCES.
        """
        self.Screen_on_initial_p = None
        """
        Screen on an initial density matrix. For the first MD step this matrix
        must be provided by a Restart File.
        """
        self.P_screen_correction_factor = None
        """
        Recalculates integrals on the fly if the actual density matrix is
        larger by a given factor than the initial one. If the factor is set to
        0.0_dp, this feature is disbled.
        """
        self._name = "SCREENING"
        self._keywords = [('Eps_schwarz', 'EPS_SCHWARZ'), ('Eps_schwarz_forces', 'EPS_SCHWARZ_FORCES'), ('Screen_p_forces', 'SCREEN_P_FORCES'), ('Screen_on_initial_p', 'SCREEN_ON_INITIAL_P'), ('P_screen_correction_factor', 'P_SCREEN_CORRECTION_FACTOR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each71(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _angle_plane_plane2(printable):
    """
    This section defines the angle between two planes as a collective
    variables.
    """
    def __init__(self):
        self.list_PLANE = []
        self.list_POINT = []
        self._name = "ANGLE_PLANE_PLANE"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('PLANE', '_plane2'), ('POINT', '_point26')]

    def add_PLANE(self):
        new_section = _plane2()
        self.list_PLANE.append(new_section)
        return new_section

    def add_POINT(self):
        new_section = _point26()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _spawned_hills_scale1(printable):
    """
    The scales of the spawned hills during metadynamics.Used for RESTART.
    When a scale is zero in one or more directions, the Gaussian hill is
    assumed to be infinitely wide in those directions. The latter can be
    used to combine spawned hills from multiple 1D metadynamics runs in
    one multidimensional metadynamics run.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify the spawned hills
        """
        self._name = "SPAWNED_HILLS_SCALE"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _screening6(printable):
    """
    Sets up screening parameters if requested
    """
    def __init__(self):
        self.Eps_schwarz = None
        """
        Screens the near field part of the electronic repulsion integrals
        using the Schwarz inequality for the given threshold.
        """
        self.Eps_schwarz_forces = None
        """
        Screens the near field part of the electronic repulsion integrals
        using the Schwarz inequality for the given threshold. This will be
        approximately the accuracy of the forces,  and should normally be
        similar to EPS_SCF
        """
        self.Screen_p_forces = None
        """
        Screens the electronic repulsion integrals for the forces using the
        density matrix. This results in a significant speedup for large
        systems, but might require a somewhat tigher EPS_SCHWARZ_FORCES.
        """
        self.Screen_on_initial_p = None
        """
        Screen on an initial density matrix. For the first MD step this matrix
        must be provided by a Restart File.
        """
        self.P_screen_correction_factor = None
        """
        Recalculates integrals on the fly if the actual density matrix is
        larger by a given factor than the initial one. If the factor is set to
        0.0_dp, this feature is disbled.
        """
        self._name = "SCREENING"
        self._keywords = [('Eps_schwarz', 'EPS_SCHWARZ'), ('Eps_schwarz_forces', 'EPS_SCHWARZ_FORCES'), ('Screen_p_forces', 'SCREEN_P_FORCES'), ('Screen_on_initial_p', 'SCREEN_ON_INITIAL_P'), ('P_screen_correction_factor', 'P_SCREEN_CORRECTION_FACTOR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print_dftd3(printable):
    """
    Controls the printing of some info about DFTD contributions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each319()
        self._name = "PRINT_DFTD"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info13(printable):
    """
    Controls the printing of basic information during the run
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each106()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _screening3(printable):
    """
    Sets up screening parameters if requested
    """
    def __init__(self):
        self.Eps_schwarz = None
        """
        Screens the near field part of the electronic repulsion integrals
        using the Schwarz inequality for the given threshold.
        """
        self.Eps_schwarz_forces = None
        """
        Screens the near field part of the electronic repulsion integrals
        using the Schwarz inequality for the given threshold. This will be
        approximately the accuracy of the forces,  and should normally be
        similar to EPS_SCF
        """
        self.Screen_p_forces = None
        """
        Screens the electronic repulsion integrals for the forces using the
        density matrix. This results in a significant speedup for large
        systems, but might require a somewhat tigher EPS_SCHWARZ_FORCES.
        """
        self.Screen_on_initial_p = None
        """
        Screen on an initial density matrix. For the first MD step this matrix
        must be provided by a Restart File.
        """
        self.P_screen_correction_factor = None
        """
        Recalculates integrals on the fly if the actual density matrix is
        larger by a given factor than the initial one. If the factor is set to
        0.0_dp, this feature is disbled.
        """
        self._name = "SCREENING"
        self._keywords = [('Eps_schwarz', 'EPS_SCHWARZ'), ('Eps_schwarz_forces', 'EPS_SCHWARZ_FORCES'), ('Screen_p_forces', 'SCREEN_P_FORCES'), ('Screen_on_initial_p', 'SCREEN_ON_INITIAL_P'), ('P_screen_correction_factor', 'P_SCREEN_CORRECTION_FACTOR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print_dftd1(printable):
    """
    Controls the printing of some info about DFTD contributions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each124()
        self._name = "PRINT_DFTD"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each79(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _method1(printable):
    """
    Section of information on method to use.
    """
    def __init__(self):
        self.Method_type = None
        """
        Type of electronic structure method to be used

        Available values:
            KOHN-SHAM
            RKS
            UKS
            HARTREE-FOCK
            RHF
            UHF
            ROHF
        """
        self.Relativistic = None
        """
        Type of scalar relativistic method to be used

        Available values:
            OFF
            ZORA(MP)
            DKH(0)
            DKH(1)
            DKH(2)
            DKH(3)
            DKH(4)
            DKH(5)
        """
        self.XC = _xc4()
        self._name = "METHOD"
        self._keywords = [('Method_type', 'METHOD_TYPE'), ('Relativistic', 'RELATIVISTIC')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('XC', 'XC')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print_dftd4(printable):
    """
    Controls the printing of some info about DFTD contributions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each376()
        self._name = "PRINT_DFTD"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _pw_transfer1(printable):
    """
    Benchmark and test the pw_transfer routines.
    """
    def __init__(self):
        self.Grid = None
        """
        Specify the number of grid points (not all grid points are allowed)
        """
        self.N_loop = None
        """
        Number of pw_transfers (backward&forward) being timed
        """
        self.Pw_grid = None
        """
        What kind of PW_GRID should be employed

        Available values:
            SPHERICAL
                - not tested
            NS-FULLSPACE
                tested
            NS-HALFSPACE
                - not tested
        """
        self.Pw_grid_layout_all = None
        """
        loop overal all PW_GRID_LAYOUTs that are compatible with a given
        number of CPUs
        """
        self.Debug = None
        """
        Do the FFT in debug mode in all cases
        """
        self.Pw_grid_layout = None
        """
        Expert use only, leave the default...Can be used to set the
        distribution for ray-distributed FFT.
        """
        self.Pw_grid_blocked = None
        """
        Expert use only, leave the default...Can be used to set the
        distribution in g-space for the pw grids and their FFT.

        Available values:
            FREE
                CP2K will select the optimal value
            TRUE
                blocked
            FALSE
                not blocked
        """
        self._name = "PW_TRANSFER"
        self._keywords = [('Grid', 'GRID'), ('N_loop', 'N_LOOP'), ('Pw_grid', 'PW_GRID'), ('Pw_grid_layout_all', 'PW_GRID_LAYOUT_ALL'), ('Debug', 'DEBUG'), ('Pw_grid_layout', 'PW_GRID_LAYOUT'), ('Pw_grid_blocked', 'PW_GRID_BLOCKED')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _geo_opt1(printable):
    """
    This section sets the environment of the geometry optimizer.
    """
    def __init__(self):
        self.Type = None
        """
        Specify which kind of geometry optimization to perform

        Available values:
            MINIMIZATION
                Performs a geometry minimization.
            TRANSITION_STATE
                Performs a transition state optimization.
        """
        self.Optimizer = None
        """
        Specify which method to use to perform a geometry optimization.

        Available values:
            BFGS
                Most efficient minimizer, but only for 'small' systems, as it relies
                on diagonalization of a full Hessian matrix
            LBFGS
                Limit memory variant of the above, can also be applied to large
                systems, not as well fine-tuned
            CG
                conjugate gradients, robust minimizer (depending on the line search)
                also OK for large systems
        """
        self.Max_iter = None
        """
        Specifies the maximum number of geometry optimization steps. One step
        might imply several force evaluations for the CG and LBFGS optimizers.
        """
        self.Max_dr = None
        """
        Convergence criterium for the maximum geometry change between the
        current and the last optimizer iteration.
        """
        self.Max_force = None
        """
        Convergence criterium for the maximum force component of the current
        configuration.
        """
        self.Rms_dr = None
        """
        Convergence criterium for the root mean square (RMS) geometry change
        between the current and the last optimizer iteration.
        """
        self.Rms_force = None
        """
        Convergence criterium for the root mean square (RMS) force of the
        current configuration.
        """
        self.Step_start_val = None
        """
        The starting step value for the GEO_OPT module.
        """
        self.LBFGS = _lbfgs1()
        self.CG = _cg1()
        self.BFGS = _bfgs1()
        self.TRANSITION_STATE = _transition_state1()
        self.list_PRINT = []
        self._name = "GEO_OPT"
        self._keywords = [('Type', 'TYPE'), ('Optimizer', 'OPTIMIZER'), ('Max_iter', 'MAX_ITER'), ('Max_dr', 'MAX_DR'), ('Max_force', 'MAX_FORCE'), ('Rms_dr', 'RMS_DR'), ('Rms_force', 'RMS_FORCE'), ('Step_start_val', 'STEP_START_VAL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('LBFGS', 'LBFGS'), ('CG', 'CG'), ('BFGS', 'BFGS'), ('TRANSITION_STATE', 'TRANSITION_STATE')]
        self._repeated_subsections = [('PRINT', '_print3')]

    def add_PRINT(self):
        new_section = _print3()
        self.list_PRINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Minimizer(self):
        """
        See documentation for Optimizer
        """
        return self.Optimizer

    @Minimizer.setter
    def Minimizer(self, value):
        self.Optimizer = value



class _harris1(printable):
    """
    This section specifies the flags for the calculation of the harris
    functional
    """
    def __init__(self):
        self.Activate = None
        """
        Activates the harris functional.
        """
        self.Harris_energy = None
        """
        Overrides the QS Energy.
        """
        self._name = "HARRIS"
        self._keywords = [('Activate', 'ACTIVATE'), ('Harris_energy', 'HARRIS_ENERGY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _point65(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point64(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _each16(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each17(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _point61(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _each11(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _point63(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _each13(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _pbe3(printable):
    """
    Uses the PBE functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Parametrization = None
        """
        switches between the different parametrizations of the functional

        Available values:
            ORIG
                original PBE
            REVPBE
                revised PBE (revPBE)
            PBESOL
                PBE for solids and surfaces (PBEsol)
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Scale_c = None
        """
        scales the correlation part of the functional
        """
        self._name = "PBE"
        self._keywords = [('Parametrization', 'PARAMETRIZATION'), ('Scale_x', 'SCALE_X'), ('Scale_c', 'SCALE_C')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _pbe2(printable):
    """
    Uses the PBE functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Parametrization = None
        """
        switches between the different parametrizations of the functional

        Available values:
            ORIG
                original PBE
            REVPBE
                revised PBE (revPBE)
            PBESOL
                PBE for solids and surfaces (PBEsol)
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Scale_c = None
        """
        scales the correlation part of the functional
        """
        self._name = "PBE"
        self._keywords = [('Parametrization', 'PARAMETRIZATION'), ('Scale_x', 'SCALE_X'), ('Scale_c', 'SCALE_C')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _pbe1(printable):
    """
    Uses the PBE functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Parametrization = None
        """
        switches between the different parametrizations of the functional

        Available values:
            ORIG
                original PBE
            REVPBE
                revised PBE (revPBE)
            PBESOL
                PBE for solids and surfaces (PBEsol)
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Scale_c = None
        """
        scales the correlation part of the functional
        """
        self._name = "PBE"
        self._keywords = [('Parametrization', 'PARAMETRIZATION'), ('Scale_x', 'SCALE_X'), ('Scale_c', 'SCALE_C')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _point69(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _each19(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _reflective1(printable):
    """
    Parameters controlling the reflective wall
    """
    def __init__(self):
        self.Direction = None
        """
        Specify the direction of the wall.

        Available values:
            WALL_PLUS
                Wall extends from the position towards larger values of COLVAR
            WALL_MINUS
                Wall extends from the position towards smaller values of COLVAR
        """
        self._name = "REFLECTIVE"
        self._keywords = [('Direction', 'DIRECTION')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each252(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _becke88_lr_adiabatic4(printable):
    """
    Uses the Becke 88 longrange exchange functional in an adiabatic
    fashion
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Omega = None
        """
        Potential parameter in erf(omega*r)/r
        """
        self.Lambda = None
        """
        Defines the parameter of the adiabatic curve
        """
        self._name = "BECKE88_LR_ADIABATIC"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Omega', 'OMEGA'), ('Lambda', 'LAMBDA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _becke88_lr_adiabatic3(printable):
    """
    Uses the Becke 88 longrange exchange functional in an adiabatic
    fashion
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Omega = None
        """
        Potential parameter in erf(omega*r)/r
        """
        self.Lambda = None
        """
        Defines the parameter of the adiabatic curve
        """
        self._name = "BECKE88_LR_ADIABATIC"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Omega', 'OMEGA'), ('Lambda', 'LAMBDA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _becke88_lr_adiabatic2(printable):
    """
    Uses the Becke 88 longrange exchange functional in an adiabatic
    fashion
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Omega = None
        """
        Potential parameter in erf(omega*r)/r
        """
        self.Lambda = None
        """
        Defines the parameter of the adiabatic curve
        """
        self._name = "BECKE88_LR_ADIABATIC"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Omega', 'OMEGA'), ('Lambda', 'LAMBDA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _becke88_lr_adiabatic1(printable):
    """
    Uses the Becke 88 longrange exchange functional in an adiabatic
    fashion
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Omega = None
        """
        Potential parameter in erf(omega*r)/r
        """
        self.Lambda = None
        """
        Defines the parameter of the adiabatic curve
        """
        self._name = "BECKE88_LR_ADIABATIC"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Omega', 'OMEGA'), ('Lambda', 'LAMBDA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _qs1(printable):
    """
    parameters needed to set up the Quickstep framework
    """
    def __init__(self):
        self.Eps_default = None
        """
        Try setting all EPS_xxx to values leading to an energy correct up to
        EPS_DEFAULT
        """
        self.Eps_core_charge = None
        """
        Precision for mapping the core charges.Overrides EPS_DEFAULT/100.0
        value
        """
        self.Eps_gvg_rspace = None
        """
        Sets precision of the realspace KS matrix element integration.
        Overrides SQRT(EPS_DEFAULT) value
        """
        self.Eps_pgf_orb = None
        """
        Sets precision of the overlap matrix elements. Overrides
        SQRT(EPS_DEFAULT) value
        """
        self.Eps_kg_orb = None
        """
        Sets precision used in coloring the subsets. Overrides
        SQRT(EPS_DEFAULT) value
        """
        self.Eps_3c_reduce = None
        """
        GAPW: Factor to reduce the precision in the construction of the 3
        center lists for the calculation of the OCE coefficients.
        """
        self.Eps_ppl = None
        """
        Adjusts the precision for the local part of the pseudo potential.
        """
        self.Eps_ppnl = None
        """
        Sets precision of the non-local part of the pseudo potential.
        Overrides sqrt(EPS_DEFAULT) value
        """
        self.Eps_cpc = None
        """
        Sets precision of the GAPW projection. Overrides EPS_DEFAULT value
        """
        self.Eps_rho = None
        """
        Sets precision of the density mapping on the grids.Overrides
        EPS_DEFAULT value
        """
        self.Eps_rho_rspace = None
        """
        Sets precision of the density mapping in rspace.Overrides EPS_DEFAULT
        value..Overrides EPS_RHO value
        """
        self.Eps_rho_gspace = None
        """
        Sets precision of the density mapping in gspace.Overrides EPS_DEFAULT
        value..Overrides EPS_RHO value
        """
        self.Eps_filter_matrix = None
        """
        Sets the threshold for filtering matrix elements.
        """
        self.Epsfit = None
        """
        GAPW and LRIPAW: precision to give the extention of a hard gaussian
        """
        self.Epsiso = None
        """
        GAPW : precision to determine an isolated projector
        """
        self.Epssvd = None
        """
        GAPW : tolerance used in the singular value decomposition of the
        projector matrix
        """
        self.Epsrho0 = None
        """
        GAPW : precision to determine the range of V(rho0-rho0soft)
        """
        self.Alpha0_hard = None
        """
        GAPW and LRIPAW : Exponent for hard compensation charge
        """
        self.Force_paw = None
        """
        Use the GAPW scheme also for atoms with soft basis sets, i.e.  the
        local densities are computed even if hard and soft should be equal. If
        this keyword is not set to true, those atoms with soft basis sets are
        treated by a GPW scheme, i.e. the corresponding density contribution
        goes on the global grid and is expanded in PW.  This option nullifies
        the effect of the GPW_TYPE in the atomic KIND
        """
        self.Max_rad_local = None
        """
        GAPW : maximum radius of gaussian functions included in the generation
        of projectors
        """
        self.Scp = None
        """
        Introduce additional self-consistent polarization through additional
        response basis functions (read in through AUX_BASIS.
        """
        self.Ls_scf = None
        """
        Perform a linear scaling SCF
        """
        self.Kg_method = None
        """
        Use a Kim-Gordon-like scheme.
        """
        self.Map_consistent = None
        """
        Compute the exact derivative (Hks) of the energy with respect to the
        density matrix. This is slightly more expensive than using an
        approximate computation, but consistent mapping can improve the
        stability of the SCF procedure, especially for a tight EPS_SCF and a
        less tight EPS_DEFAULT.
        """
        self.Check_bcsr_code = None
        """
        Check the BCSR code on actual data, once per QS run.
        """
        self.Bcsr_code = None
        """
        Selects BCSR pathway.
        """
        self.Lmaxn1 = None
        """
        GAPW : max L number for espansion of the atomic densities in spherical
        gaussians
        """
        self.Lmaxn0 = None
        """
        GAPW : max L number for the expansion compensation densities in
        spherical gaussians
        """
        self.Laddn0 = None
        """
        GAPW : integer added to the max L of the basis set, used to determine
        the maximum value of L for the compensation charge density.
        """
        self.Quadrature = None
        """
        GAPW and LRIPAW: algorithm to construct the atomic radial grids

        Available values:
            GC_SIMPLE
                Gauss-Chebyshev
            GC_TRANSFORMED
                Trans_Gauss-Chebyshev
            GC_LOG
                LogTrans-Gauss-Chebyshev
        """
        self.Pw_grid = None
        """
        What kind of PW_GRID should be employed

        Available values:
            SPHERICAL
                - not tested
            NS-FULLSPACE
                tested
            NS-HALFSPACE
                - not tested
        """
        self.Pw_grid_layout = None
        """
        Force a particular real-space layout for the plane waves grids.
        Numbers <=0 mean that this dimension is free, incorrect layouts will
        be ignored. The default (/-1,-1/) causes CP2K to select a good value,
        i.e. plane distributed for large grids, more general distribution for
        small grids.
        """
        self.Pw_grid_blocked = None
        """
        Can be used to set the distribution in g-space for the pw grids and
        their FFT.

        Available values:
            FREE
                CP2K will select an appropriate value
            TRUE
                blocked
            FALSE
                not blocked
        """
        self.Extrapolation = None
        """
        Extrapolation strategy for the wavefunction during e.g. MD.PS and ASPC
        are recommended, see also EXTRAPOLATION_ORDER.

        Available values:
            USE_GUESS
                Use the method specified with SCF_GUESS, i.e. no extrapolation
            USE_PREV_P
                Use the previous density matrix
            USE_PREV_RHO_R
                Use the previous density in real space
            LINEAR_WF
                Linear extrapolation of the wavefunction
            LINEAR_P
                Linear extrapolation of the density matrix
            LINEAR_PS
                Linear extrapolation of the density matrix times the overlap matrix
            USE_PREV_WF
                Use the previous wavefunction
            PS
                Higher order extrapolation of the density matrix times the overlap
                matrix
            FROZEN
                Frozen ...
            ASPC
                Always stable predictor corrector, similar to PS, but going for MD
                stability instead of intial guess accuracy.
        """
        self.Extrapolation_order = None
        """
        Order for the PS or ASPC extrapolation (typically 2-4). Higher order
        might bring more accuracy, but comes, for large systems, also at some
        cost. In some cases, a high order extrapolation is not stable, and the
        order needs to be reduced.
        """
        self.Method = None
        """
        Specifies the electronic structure method that should be employed

        Available values:
            GAPW
                Gaussian and augmented plane waves method
            GAPW_XC
                Gaussian and augmented plane waves method only for XC
            GPW
                Gaussian and plane waves method
            LRIPAW
                Local resolution of identity projector augmented wave method
            MNDO
                MNDO semiempirical
            MNDOD
                MNDO-d semiempirical
            AM1
                AM1 semiempirical
            PM3
                PM3 semiempirical
            PM6
                PM6 semiempirical
            PDG
                PDG semiempirical
            RM1
                RM1 semiempirical
            PNNL
                PNNL semiempirical
            DFTB
                DFTB Density Functional based Tight-Binding
            OFGPW
                OFGPW Orbital-free GPW method
            SCPTB
                SCPTB Self-Consistent-Polarization Tight-Binding
        """
        self.Core_ppl = None
        """
        Specifies the method used to calculate the local pseudopotential
        contribution.

        Available values:
            ANALYTIC
                Analytic integration of integrals
            GRID
                Numerical integration on real space grid. Lumped together with core
                charge
        """
        self.DISTRIBUTION = _distribution1()
        self.DFTB = _dftb1()
        self.SCPTB = _scptb1()
        self.SE = _se1()
        self.MULLIKEN_RESTRAINT = _mulliken_restraint1()
        self.list_DDAPC_RESTRAINT = []
        self.BECKE_RESTRAINT = _becke_restraint1()
        self.S2_RESTRAINT = _s2_restraint1()
        self.HARRIS = _harris1()
        self._name = "QS"
        self._keywords = [('Eps_default', 'EPS_DEFAULT'), ('Eps_core_charge', 'EPS_CORE_CHARGE'), ('Eps_gvg_rspace', 'EPS_GVG_RSPACE'), ('Eps_pgf_orb', 'EPS_PGF_ORB'), ('Eps_kg_orb', 'EPS_KG_ORB'), ('Eps_3c_reduce', 'EPS_3C_REDUCE'), ('Eps_ppl', 'EPS_PPL'), ('Eps_ppnl', 'EPS_PPNL'), ('Eps_cpc', 'EPS_CPC'), ('Eps_rho', 'EPS_RHO'), ('Eps_rho_rspace', 'EPS_RHO_RSPACE'), ('Eps_rho_gspace', 'EPS_RHO_GSPACE'), ('Eps_filter_matrix', 'EPS_FILTER_MATRIX'), ('Epsfit', 'EPSFIT'), ('Epsiso', 'EPSISO'), ('Epssvd', 'EPSSVD'), ('Epsrho0', 'EPSRHO0'), ('Alpha0_hard', 'ALPHA0_HARD'), ('Force_paw', 'FORCE_PAW'), ('Max_rad_local', 'MAX_RAD_LOCAL'), ('Scp', 'SCP'), ('Ls_scf', 'LS_SCF'), ('Kg_method', 'KG_METHOD'), ('Map_consistent', 'MAP_CONSISTENT'), ('Check_bcsr_code', 'CHECK_BCSR_CODE'), ('Bcsr_code', 'BCSR_CODE'), ('Lmaxn1', 'LMAXN1'), ('Lmaxn0', 'LMAXN0'), ('Laddn0', 'LADDN0'), ('Quadrature', 'QUADRATURE'), ('Pw_grid', 'PW_GRID'), ('Pw_grid_layout', 'PW_GRID_LAYOUT'), ('Pw_grid_blocked', 'PW_GRID_BLOCKED'), ('Extrapolation', 'EXTRAPOLATION'), ('Extrapolation_order', 'EXTRAPOLATION_ORDER'), ('Method', 'METHOD'), ('Core_ppl', 'CORE_PPL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('DISTRIBUTION', 'DISTRIBUTION'), ('DFTB', 'DFTB'), ('SCPTB', 'SCPTB'), ('SE', 'SE'), ('MULLIKEN_RESTRAINT', 'MULLIKEN_RESTRAINT'), ('BECKE_RESTRAINT', 'BECKE_RESTRAINT'), ('S2_RESTRAINT', 'S2_RESTRAINT'), ('HARRIS', 'HARRIS')]
        self._repeated_subsections = [('DDAPC_RESTRAINT', '_ddapc_restraint1')]

    def add_DDAPC_RESTRAINT(self):
        new_section = _ddapc_restraint1()
        self.list_DDAPC_RESTRAINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Eps_gvg(self):
        """
        See documentation for Eps_gvg_rspace
        """
        return self.Eps_gvg_rspace

    @property
    def Eps_fit(self):
        """
        See documentation for Epsfit
        """
        return self.Epsfit

    @property
    def Eps_iso(self):
        """
        See documentation for Epsiso
        """
        return self.Epsiso

    @property
    def Eps_svd(self):
        """
        See documentation for Epssvd
        """
        return self.Epssvd

    @property
    def Epsvrho0(self):
        """
        See documentation for Epsrho0
        """
        return self.Epsrho0

    @property
    def Eps_vrho0(self):
        """
        See documentation for Epsrho0
        """
        return self.Epsrho0

    @property
    def Alpha0_h(self):
        """
        See documentation for Alpha0_hard
        """
        return self.Alpha0_hard

    @property
    def Alpha0(self):
        """
        See documentation for Alpha0_hard
        """
        return self.Alpha0_hard

    @property
    def Lmaxrho1(self):
        """
        See documentation for Lmaxn1
        """
        return self.Lmaxn1

    @property
    def Lmaxrho0(self):
        """
        See documentation for Lmaxn0
        """
        return self.Lmaxn0

    @property
    def Interpolation(self):
        """
        See documentation for Extrapolation
        """
        return self.Extrapolation

    @property
    def Wf_interpolation(self):
        """
        See documentation for Extrapolation
        """
        return self.Extrapolation

    @Eps_gvg.setter
    def Eps_gvg(self, value):
        self.Eps_gvg_rspace = value

    @Eps_fit.setter
    def Eps_fit(self, value):
        self.Epsfit = value

    @Eps_iso.setter
    def Eps_iso(self, value):
        self.Epsiso = value

    @Eps_svd.setter
    def Eps_svd(self, value):
        self.Epssvd = value

    @Epsvrho0.setter
    def Epsvrho0(self, value):
        self.Epsrho0 = value

    @Eps_vrho0.setter
    def Eps_vrho0(self, value):
        self.Epsrho0 = value

    @Alpha0_h.setter
    def Alpha0_h(self, value):
        self.Alpha0_hard = value

    @Alpha0.setter
    def Alpha0(self, value):
        self.Alpha0_hard = value

    @Lmaxrho1.setter
    def Lmaxrho1(self, value):
        self.Lmaxn1 = value

    @Lmaxrho0.setter
    def Lmaxrho0(self, value):
        self.Lmaxn0 = value

    @Interpolation.setter
    def Interpolation(self, value):
        self.Extrapolation = value

    @Wf_interpolation.setter
    def Wf_interpolation(self, value):
        self.Extrapolation = value



class _rs_grid3(printable):
    """
    Set options that influence how the realspace grids are being
    distributed in parallel runs.
    """
    def __init__(self):
        self.Distribution_type = None
        """
        Parallelization strategy.

        Available values:
            AUTOMATIC
                Use heuristic rules to decide between distributed and replicated
            DISTRIBUTED
                Force a distributed setup if possible
            REPLICATED
                Force a replicated setup
        """
        self.Distribution_layout = None
        """
        Specifies the number of slices in the x, y and z directions.-1
        specifies that any number of slices is OK.If a given distribution can
        not be satisfied, a replicated grid will result.Also see
        LOCK_DISTRIBUTION.
        """
        self.Max_distributed_level = None
        """
        If the multigrid-level of a grid is larger than the parameter, it will
        not be distributed in the automatic scheme.
        """
        self.Lock_distribution = None
        """
        Expert use only, only basic QS deals correctly with a non-default
        value.If the distribution is locked, a grid will have the same
        distribution asthe next finer multigrid (provided it is
        distributed).If unlocked, all grids can be distributed freely.
        """
        self.Memory_factor = None
        """
        A grid will only be distributed if the memory usage for that grid
        (including halo) is smaller than a replicated grid by this parameter.
        """
        self.Halo_reduction_factor = None
        """
        Can be used to reduce the halo of the distributed grid (experimental
        features).
        """
        self._name = "RS_GRID"
        self._keywords = [('Distribution_type', 'DISTRIBUTION_TYPE'), ('Distribution_layout', 'DISTRIBUTION_LAYOUT'), ('Max_distributed_level', 'MAX_DISTRIBUTED_LEVEL'), ('Lock_distribution', 'LOCK_DISTRIBUTION'), ('Memory_factor', 'MEMORY_FACTOR'), ('Halo_reduction_factor', 'HALO_REDUCTION_FACTOR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _quadrupole1(printable):
    """
    This section specifies that we will perform an SCF quadrupole
    calculation of the MM atoms. Needs KEYWORD POL_SCF in POISSON secton
    """
    def __init__(self):
        self.Atom = None
        """
        Defines the atomic kind of the scf quadrupole.
        """
        self.Cpol = None
        """
        Defines the isotropic polarizability of the MM atom.
        """
        self._name = "QUADRUPOLE"
        self._keywords = [('Atom', 'ATOM'), ('Cpol', 'CPOL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _basis2(printable):
    """
    Section used to specify a general basis set for QM calculations.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        CP2K Basis Set Standard Format
        """
        self._name = "BASIS"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _basis3(printable):
    """
    Section used to specify a general basis set for QM calculations.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        CP2K Basis Set Standard Format
        """
        self._name = "BASIS"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _basis1(printable):
    """
    Section used to specify a general basis set for QM calculations.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        CP2K Basis Set Standard Format
        """
        self._name = "BASIS"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _resp1(printable):
    """
    Requests a RESP fit of charges. When using a periodic Poisson solver
    and a periodic cell, the periodic RESP routines are used. If the
    Hartree potential matches with the one of an isolated system (i.e.
    isolated Poisson solver and big, nonperiodic cells), the nonperiodic
    RESP routines are automatically used. The subsections NONPERIODIC_SYS
    and PERIODIC_SYS do not request a nonperiodic or periodic solution,
    they only determine the sampling of the fitting points. All restraints
    are harmonic!
    """
    def __init__(self):
        self.Stride = None
        """
        The stride (X,Y,Z) used to write the cube file (larger values result
        in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1
        number valid for all components.
        """
        self.Integer_total_charge = None
        """
        Forces the total charge to be integer
        """
        self.Restrain_heavies_to_zero = None
        """
        Restrain non-hydrogen atoms to zero.
        """
        self.Restrain_heavies_strength = None
        """
        If defined, enforce the restraint of non-hydrogen atoms to zero. Its
        value is the strength of the restraint on the heavy atoms.
        """
        self.Width = None
        """
        Specifies the value of the width of the Gaussian charge distribution
        carried by each atom. Needs only to be specified when using a periodic
        Poisson solver.
        """
        self.list_CONSTRAINT = []
        self.list_RESTRAINT = []
        self.NONPERIODIC_SYS = _nonperiodic_sys1()
        self.list_PERIODIC_SYS = []
        self.PRINT = _print58()
        self._name = "RESP"
        self._keywords = [('Stride', 'STRIDE'), ('Integer_total_charge', 'INTEGER_TOTAL_CHARGE'), ('Restrain_heavies_to_zero', 'RESTRAIN_HEAVIES_TO_ZERO'), ('Restrain_heavies_strength', 'RESTRAIN_HEAVIES_STRENGTH'), ('Width', 'WIDTH')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('NONPERIODIC_SYS', 'NONPERIODIC_SYS'), ('PRINT', 'PRINT')]
        self._repeated_subsections = [('CONSTRAINT', '_constraint2'), ('RESTRAINT', '_restraint8'), ('PERIODIC_SYS', '_periodic_sys1')]

    def add_CONSTRAINT(self):
        new_section = _constraint2()
        self.list_CONSTRAINT.append(new_section)
        return new_section

    def add_RESTRAINT(self):
        new_section = _restraint8()
        self.list_RESTRAINT.append(new_section)
        return new_section

    def add_PERIODIC_SYS(self):
        new_section = _periodic_sys1()
        self.list_PERIODIC_SYS.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _point67(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _shell_forces1(printable):
    """
    controls the output of the forces on shells when shell-model is used
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.Format = None
        """
        Specifies the format of the output file for the forces on shells.

        Available values:
            ATOMIC
                Write only the coordinates X,Y,Z without element symbols to a
                formatted file
            DCD
                Write the coordinates (no element labels) and the cell information to
                a binary file
            XMOL
                Mostly known as XYZ format, provides in a formatted file:
                element_symbol X Y Z
            XYZ
                Alias name for XMOL
        """
        self.EACH = _each82()
        self._name = "SHELL_FORCES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT'), ('Format', 'FORMAT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _lda_hole_t_c_lr4(printable):
    """
    LDA exchange hole model in truncated coulomb potential
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Cutoff_radius = None
        """
        Defines cutoff for lower integration boundary
        """
        self._name = "LDA_HOLE_T_C_LR"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Cutoff_radius', 'CUTOFF_RADIUS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _lda_hole_t_c_lr1(printable):
    """
    LDA exchange hole model in truncated coulomb potential
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Cutoff_radius = None
        """
        Defines cutoff for lower integration boundary
        """
        self._name = "LDA_HOLE_T_C_LR"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Cutoff_radius', 'CUTOFF_RADIUS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _lda_hole_t_c_lr2(printable):
    """
    LDA exchange hole model in truncated coulomb potential
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Cutoff_radius = None
        """
        Defines cutoff for lower integration boundary
        """
        self._name = "LDA_HOLE_T_C_LR"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Cutoff_radius', 'CUTOFF_RADIUS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _lda_hole_t_c_lr3(printable):
    """
    LDA exchange hole model in truncated coulomb potential
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Cutoff_radius = None
        """
        Defines cutoff for lower integration boundary
        """
        self._name = "LDA_HOLE_T_C_LR"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Cutoff_radius', 'CUTOFF_RADIUS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _interpolator10(printable):
    """
    kind of interpolation used between the multigrids
    """
    def __init__(self):
        self.Kind = None
        """
        the interpolator to use

        Available values:
            PW
            SPLINE3_NOPBC
            SPLINE3
        """
        self.Safe_computation = None
        """
        if a non unrolled calculation is to be performed in parallel
        """
        self.Aint_precond = None
        """
        the approximate inverse to use to get the starting point for the
        linear solver of the spline3 methods

        Available values:
            COPY
            SPL3_NOPBC_AINT1
            SPL3_NOPBC_AINT2
            SPL3_NOPBC_PRECOND1
            SPL3_NOPBC_PRECOND2
            SPL3_NOPBC_PRECOND3
        """
        self.Precond = None
        """
        The preconditioner used for the linear solver of the spline3 methods

        Available values:
            COPY
            SPL3_NOPBC_AINT1
            SPL3_NOPBC_AINT2
            SPL3_NOPBC_PRECOND1
            SPL3_NOPBC_PRECOND2
            SPL3_NOPBC_PRECOND3
        """
        self.Eps_x = None
        """
        accuracy on the solution for spline3 the interpolators
        """
        self.Eps_r = None
        """
        accuracy on the residual for spline3 the interpolators
        """
        self.Max_iter = None
        """
        the maximum number of iterations
        """
        self.CONV_INFO = _conv_info10()
        self._name = "INTERPOLATOR"
        self._keywords = [('Kind', 'KIND'), ('Safe_computation', 'SAFE_COMPUTATION'), ('Aint_precond', 'AINT_PRECOND'), ('Precond', 'PRECOND'), ('Eps_x', 'EPS_X'), ('Eps_r', 'EPS_R'), ('Max_iter', 'MAX_ITER')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('CONV_INFO', 'CONV_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Maxiter(self):
        """
        See documentation for Max_iter
        """
        return self.Max_iter

    @Maxiter.setter
    def Maxiter(self, value):
        self.Max_iter = value



class _interpolator11(printable):
    """
    kind of interpolation used between the multigrids
    """
    def __init__(self):
        self.Kind = None
        """
        the interpolator to use

        Available values:
            PW
            SPLINE3_NOPBC
            SPLINE3
        """
        self.Safe_computation = None
        """
        if a non unrolled calculation is to be performed in parallel
        """
        self.Aint_precond = None
        """
        the approximate inverse to use to get the starting point for the
        linear solver of the spline3 methods

        Available values:
            COPY
            SPL3_NOPBC_AINT1
            SPL3_NOPBC_AINT2
            SPL3_NOPBC_PRECOND1
            SPL3_NOPBC_PRECOND2
            SPL3_NOPBC_PRECOND3
        """
        self.Precond = None
        """
        The preconditioner used for the linear solver of the spline3 methods

        Available values:
            COPY
            SPL3_NOPBC_AINT1
            SPL3_NOPBC_AINT2
            SPL3_NOPBC_PRECOND1
            SPL3_NOPBC_PRECOND2
            SPL3_NOPBC_PRECOND3
        """
        self.Eps_x = None
        """
        accuracy on the solution for spline3 the interpolators
        """
        self.Eps_r = None
        """
        accuracy on the residual for spline3 the interpolators
        """
        self.Max_iter = None
        """
        the maximum number of iterations
        """
        self.CONV_INFO = _conv_info11()
        self._name = "INTERPOLATOR"
        self._keywords = [('Kind', 'KIND'), ('Safe_computation', 'SAFE_COMPUTATION'), ('Aint_precond', 'AINT_PRECOND'), ('Precond', 'PRECOND'), ('Eps_x', 'EPS_X'), ('Eps_r', 'EPS_R'), ('Max_iter', 'MAX_ITER')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('CONV_INFO', 'CONV_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Maxiter(self):
        """
        See documentation for Max_iter
        """
        return self.Max_iter

    @Maxiter.setter
    def Maxiter(self, value):
        self.Max_iter = value



class _cell3(printable):
    """
    Input parameters needed to set up the CELL.
    """
    def __init__(self):
        self.A = None
        """
        Specify the Cartesian components for the cell vector A. This defines
        the first column of the h matrix.
        """
        self.B = None
        """
        Specify the Cartesian components for the cell vector B. This defines
        the second column of the h matrix.
        """
        self.C = None
        """
        Specify the Cartesian components for the cell vector C. This defines
        the third column of the h matrix.
        """
        self.Abc = None
        """
        Specify the lengths of the cell vectors A, B, and C, which defines the
        diagonal elements of h matrix for an orthorhombic cell. For non-
        orthorhombic cells it is possible either to specify the angles ALPHA,
        BETA, GAMMA via ALPHA_BETA_GAMMA keyword or alternatively use the
        keywords A, B, and C. The convention is that A lies along the X-axis,
        B is in the XY plane.
        """
        self.Alpha_beta_gamma = None
        """
        Specify the angles between the vectors A, B and C when using the ABC
        keyword. The convention is that A lies along the X-axis, B is in the
        XY plane. ALPHA is the angle between B and C, BETA is the angle
        between A and C and GAMMA the angle between A and B.
        """
        self.Cell_file_name = None
        """
        Possibility to read the cell from an external file
        """
        self.Cell_file_format = None
        """
        Specify the format of the cell file (if used)

        Available values:
            CP2K
                Cell info in the CP2K native format.
            XSC
                Cell info in the XSC format (NAMD)
        """
        self.Periodic = None
        """
        Specify the directions for which periodic boundary conditions (PBC)
        will be applied. Important notice: This applies to the generation of
        the pair lists as well as to the application of the PBCs to positions.
        See the POISSON section to specify the periodicity used for the
        electrostatics. Typically the settings should be the same.

        Available values:
            X
            Y
            Z
            XY
            XZ
            YZ
            XYZ
            NONE
        """
        self.Multiple_unit_cell = None
        """
        Specifies the numbers of repetition in space (X, Y, Z) of the defined
        cell, assuming it as a unit cell. This keyword affects only the CELL
        specification. The same keyword in SUBSYS%TOPOLOGY%MULTIPLE_UNIT_CELL
        should be modified in order to affect the coordinates specification.
        """
        self.Symmetry = None
        """
        Imposes an initial cell symmetry.

        Available values:
            NONE
                No cell symmetry
            TRICLINIC
                Triclinic (a ≠ b ≠ c ≠ a, α ≠ β ≠ γ ≠ α ≠ 90°)
            MONOCLINIC
                Monoclinic (a ≠ b ≠ c ≠ a, α = γ = 90°, β ≠ 90°)
            ORTHORHOMBIC
                Orthorhombic (a ≠ b ≠ c, α = β = γ = 90°)
            TETRAGONAL_AB
                Tetragonal (a = b ≠ c, α = β = γ = 90°)
            TETRAGONAL_AC
                Tetragonal (a = c ≠ b, α = β = γ = 90°)
            TETRAGONAL_BC
                Tetragonal (a ≠ b = c, α = β = γ = 90°)
            TETRAGONAL
                Tetragonal (alias for TETRAGONAL_AB)
            RHOMBOHEDRAL
                Rhombohedral (a = b = c, α = β = γ ≠ 90°)
            HEXAGONAL
                Hexagonal (a = b ≠ c, α = β = 90°, γ = 60°)
            CUBIC
                Cubic (a = b = c, α = β = γ = 90°)
        """
        self.CELL_REF = _cell_ref1()
        self._name = "CELL"
        self._keywords = [('A', 'A'), ('B', 'B'), ('C', 'C'), ('Abc', 'ABC'), ('Alpha_beta_gamma', 'ALPHA_BETA_GAMMA'), ('Cell_file_name', 'CELL_FILE_NAME'), ('Cell_file_format', 'CELL_FILE_FORMAT'), ('Periodic', 'PERIODIC'), ('Multiple_unit_cell', 'MULTIPLE_UNIT_CELL'), ('Symmetry', 'SYMMETRY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('CELL_REF', 'CELL_REF')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Angles(self):
        """
        See documentation for Alpha_beta_gamma
        """
        return self.Alpha_beta_gamma

    @Angles.setter
    def Angles(self, value):
        self.Alpha_beta_gamma = value



class _cell2(printable):
    """
    Controls the output of the simulation cell.For later analysis of the
    trajectory it is recommendable that thefrequency of printing is the
    same as the one used for the trajectory file
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each75()
        self._name = "CELL"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _cell1(printable):
    """
    Controls the printing of the cell eveytime a calculation using a new
    cell is started.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.EACH = _each15()
        self._name = "CELL"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _forcefield1(printable):
    """
    Section specifying information regarding how to set up properly a
    force_field for the classical calculations.
    """
    def __init__(self):
        self.Parmtype = None
        """
        Define the kind of torsion potential

        Available values:
            OFF
                Provides force field parameters through the input file
            CHM
                Provides force field parameters through an external file with CHARMM
                format
            G87
                Provides force field parameters through an external file with GROMOS
                87 format
            G96
                Provides force field parameters through an external file with GROMOS
                96 format
            AMBER
                Provides force field parameters through an external file with AMBER
                format (from v.8 on)
        """
        self.Parm_file_name = None
        """
        Specifies the filename that contains the parameters of the FF.
        """
        self.Vdw_scale14 = None
        """
        Scaling factor for the VDW 1-4
        """
        self.Ei_scale14 = None
        """
        Scaling factor for the electrostatics 1-4
        """
        self.Shift_cutoff = None
        """
        Add a constant energy shift to the real-space non-bonding interactions
        (both Van der Waals and electrostatic) such that the energy at the
        cutoff radius is zero. This makes the non-bonding interactions
        continuous at the cutoff.
        """
        self.Do_nonbonded = None
        """
        Controls the computation of all the real-sapce (short-range) nonbonded
        interactions. This also includes the real-space corrections for
        excluded or scaled 1-2, 1-3 and 1-4 interactions. When set to F, the
        neighborlists are not created and all interactions that depend on them
        are not computed.
        """
        self.Ignore_missing_critical_params = None
        """
        Do not abort when critical force-field parameters are missing. CP2K
        will run as if the terms containing the missing parameters are zero.
        """
        self.Multiple_potential = None
        """
        Enables the possibility to define NONBONDED and NONBONDED14 as a sum
        of different kinds of potential. Useful for piecewise defined
        potentials.
        """
        self.Zbl_scattering = None
        """
        A short range repulsive potential is added, to simulatecollisions and
        scattering.
        """
        self.list_SPLINE = []
        self.NONBONDED = _nonbonded1()
        self.NONBONDED14 = _nonbonded141()
        self.list_CHARGE = []
        self.CHARGES = _charges1()
        self.list_SHELL = []
        self.list_BOND = []
        self.list_BEND = []
        self.list_TORSION = []
        self.list_IMPROPER = []
        self.list_OPBEND = []
        self.list_DIPOLE = []
        self.list_QUADRUPOLE = []
        self._name = "FORCEFIELD"
        self._keywords = [('Parmtype', 'PARMTYPE'), ('Parm_file_name', 'PARM_FILE_NAME'), ('Vdw_scale14', 'VDW_SCALE14'), ('Ei_scale14', 'EI_SCALE14'), ('Shift_cutoff', 'SHIFT_CUTOFF'), ('Do_nonbonded', 'DO_NONBONDED'), ('Ignore_missing_critical_params', 'IGNORE_MISSING_CRITICAL_PARAMS'), ('Multiple_potential', 'MULTIPLE_POTENTIAL'), ('Zbl_scattering', 'ZBL_SCATTERING')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('NONBONDED', 'NONBONDED'), ('NONBONDED14', 'NONBONDED14'), ('CHARGES', 'CHARGES')]
        self._repeated_subsections = [('SPLINE', '_spline1'), ('CHARGE', '_charge5'), ('SHELL', '_shell2'), ('BOND', '_bond1'), ('BEND', '_bend1'), ('TORSION', '_torsion1'), ('IMPROPER', '_improper1'), ('OPBEND', '_opbend1'), ('DIPOLE', '_dipole2'), ('QUADRUPOLE', '_quadrupole1')]

    def add_SPLINE(self):
        new_section = _spline1()
        self.list_SPLINE.append(new_section)
        return new_section

    def add_CHARGE(self):
        new_section = _charge5()
        self.list_CHARGE.append(new_section)
        return new_section

    def add_SHELL(self):
        new_section = _shell2()
        self.list_SHELL.append(new_section)
        return new_section

    def add_BOND(self):
        new_section = _bond1()
        self.list_BOND.append(new_section)
        return new_section

    def add_BEND(self):
        new_section = _bend1()
        self.list_BEND.append(new_section)
        return new_section

    def add_TORSION(self):
        new_section = _torsion1()
        self.list_TORSION.append(new_section)
        return new_section

    def add_IMPROPER(self):
        new_section = _improper1()
        self.list_IMPROPER.append(new_section)
        return new_section

    def add_OPBEND(self):
        new_section = _opbend1()
        self.list_OPBEND.append(new_section)
        return new_section

    def add_DIPOLE(self):
        new_section = _dipole2()
        self.list_DIPOLE.append(new_section)
        return new_section

    def add_QUADRUPOLE(self):
        new_section = _quadrupole1()
        self.list_QUADRUPOLE.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _cell5(printable):
    """
    controls the output of the cell parameters
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.EACH = _each281()
        self._name = "CELL"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _cell4(printable):
    """
    Input parameters needed to set up the CELL.
    """
    def __init__(self):
        self.A = None
        """
        Specify the Cartesian components for the cell vector A. This defines
        the first column of the h matrix.
        """
        self.B = None
        """
        Specify the Cartesian components for the cell vector B. This defines
        the second column of the h matrix.
        """
        self.C = None
        """
        Specify the Cartesian components for the cell vector C. This defines
        the third column of the h matrix.
        """
        self.Abc = None
        """
        Specify the lengths of the cell vectors A, B, and C, which defines the
        diagonal elements of h matrix for an orthorhombic cell. For non-
        orthorhombic cells it is possible either to specify the angles ALPHA,
        BETA, GAMMA via ALPHA_BETA_GAMMA keyword or alternatively use the
        keywords A, B, and C. The convention is that A lies along the X-axis,
        B is in the XY plane.
        """
        self.Alpha_beta_gamma = None
        """
        Specify the angles between the vectors A, B and C when using the ABC
        keyword. The convention is that A lies along the X-axis, B is in the
        XY plane. ALPHA is the angle between B and C, BETA is the angle
        between A and C and GAMMA the angle between A and B.
        """
        self.Cell_file_name = None
        """
        Possibility to read the cell from an external file
        """
        self.Cell_file_format = None
        """
        Specify the format of the cell file (if used)

        Available values:
            CP2K
                Cell info in the CP2K native format.
            XSC
                Cell info in the XSC format (NAMD)
        """
        self.Periodic = None
        """
        Specify the directions for which periodic boundary conditions (PBC)
        will be applied. Important notice: This applies to the generation of
        the pair lists as well as to the application of the PBCs to positions.
        See the POISSON section to specify the periodicity used for the
        electrostatics. Typically the settings should be the same.

        Available values:
            X
            Y
            Z
            XY
            XZ
            YZ
            XYZ
            NONE
        """
        self.Multiple_unit_cell = None
        """
        Specifies the numbers of repetition in space (X, Y, Z) of the defined
        cell, assuming it as a unit cell. This keyword affects only the CELL
        specification. The same keyword in SUBSYS%TOPOLOGY%MULTIPLE_UNIT_CELL
        should be modified in order to affect the coordinates specification.
        """
        self.Symmetry = None
        """
        Imposes an initial cell symmetry.

        Available values:
            NONE
                No cell symmetry
            TRICLINIC
                Triclinic (a ≠ b ≠ c ≠ a, α ≠ β ≠ γ ≠ α ≠ 90°)
            MONOCLINIC
                Monoclinic (a ≠ b ≠ c ≠ a, α = γ = 90°, β ≠ 90°)
            ORTHORHOMBIC
                Orthorhombic (a ≠ b ≠ c, α = β = γ = 90°)
            TETRAGONAL_AB
                Tetragonal (a = b ≠ c, α = β = γ = 90°)
            TETRAGONAL_AC
                Tetragonal (a = c ≠ b, α = β = γ = 90°)
            TETRAGONAL_BC
                Tetragonal (a ≠ b = c, α = β = γ = 90°)
            TETRAGONAL
                Tetragonal (alias for TETRAGONAL_AB)
            RHOMBOHEDRAL
                Rhombohedral (a = b = c, α = β = γ ≠ 90°)
            HEXAGONAL
                Hexagonal (a = b ≠ c, α = β = 90°, γ = 60°)
            CUBIC
                Cubic (a = b = c, α = β = γ = 90°)
        """
        self.CELL_REF = _cell_ref2()
        self._name = "CELL"
        self._keywords = [('A', 'A'), ('B', 'B'), ('C', 'C'), ('Abc', 'ABC'), ('Alpha_beta_gamma', 'ALPHA_BETA_GAMMA'), ('Cell_file_name', 'CELL_FILE_NAME'), ('Cell_file_format', 'CELL_FILE_FORMAT'), ('Periodic', 'PERIODIC'), ('Multiple_unit_cell', 'MULTIPLE_UNIT_CELL'), ('Symmetry', 'SYMMETRY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('CELL_REF', 'CELL_REF')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Angles(self):
        """
        See documentation for Alpha_beta_gamma
        """
        return self.Alpha_beta_gamma

    @Angles.setter
    def Angles(self, value):
        self.Alpha_beta_gamma = value



class _diag_sub_scf2(printable):
    """
    Controls the printing of information on subspace diagonalization
    internal loop.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each101()
        self._name = "DIAG_SUB_SCF"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _diag_sub_scf1(printable):
    """
    Activation of self-consistenf subspace refinement by diagonalization
    of H by adjusting the occupation but keeping the MOS unchanged.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        controls the activation of inner SCF loop to refine occupations in MOS
        subspace
        """
        self.Max_iter = None
        """
        Maximum number of iterations for the SCF inner loop
        """
        self.Eps_ene = None
        """
        Required energy accuracy for convergence of subspace diagonalization
        """
        self.Eps_adapt_scf = None
        """
        Required density matrix accuracy as compared to current SCF
        convergence
        """
        self.Eps_skip_sub_diag = None
        """
        Level of convergence to be reached before starting the internal loop
        of subspace rotations. Above this threshold only the outer
        diagonalization method is used.  If negative the subspace rotation is
        started at the first iteration
        """
        self.MIXING = _mixing1()
        self._name = "DIAG_SUB_SCF"
        self._keywords = [('Max_iter', 'MAX_ITER'), ('Eps_ene', 'EPS_ENE'), ('Eps_adapt_scf', 'EPS_ADAPT_SCF'), ('Eps_skip_sub_diag', 'EPS_SKIP_SUB_DIAG')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('MIXING', 'MIXING')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _dump_pdb1(printable):
    """
    controls the dumping of the PDB at the starting geometry
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Charge_occup = None
        """
        Write the MM charges to the OCCUP field of the PDB file
        """
        self.Charge_beta = None
        """
        Write the MM charges to the BETA field of the PDB file
        """
        self.Charge_extended = None
        """
        Write the MM charges to the very last field of the PDB file (starting
        from column 81)
        """
        self.EACH = _each267()
        self._name = "DUMP_PDB"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Charge_occup', 'CHARGE_OCCUP'), ('Charge_beta', 'CHARGE_BETA'), ('Charge_extended', 'CHARGE_EXTENDED')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Charge_o(self):
        """
        See documentation for Charge_occup
        """
        return self.Charge_occup

    @property
    def Charge_b(self):
        """
        See documentation for Charge_beta
        """
        return self.Charge_beta

    @Charge_o.setter
    def Charge_o(self, value):
        self.Charge_occup = value

    @Charge_b.setter
    def Charge_b(self, value):
        self.Charge_beta = value



class _cell_opt1(printable):
    """
    This section sets the environment for the optimization of the
    simulation cell. Two possible schemes are available: (1) Zero
    temperature optimization;  (2) Finite temperature optimization.
    """
    def __init__(self):
        self.Optimizer = None
        """
        Specify which method to use to perform a geometry optimization.

        Available values:
            BFGS
                Most efficient minimizer, but only for 'small' systems, as it relies
                on diagonalization of a full Hessian matrix
            LBFGS
                Limit memory variant of the above, can also be applied to large
                systems, not as well fine-tuned
            CG
                conjugate gradients, robust minimizer (depending on the line search)
                also OK for large systems
        """
        self.Max_iter = None
        """
        Specifies the maximum number of geometry optimization steps. One step
        might imply several force evaluations for the CG and LBFGS optimizers.
        """
        self.Max_dr = None
        """
        Convergence criterium for the maximum geometry change between the
        current and the last optimizer iteration.
        """
        self.Max_force = None
        """
        Convergence criterium for the maximum force component of the current
        configuration.
        """
        self.Rms_dr = None
        """
        Convergence criterium for the root mean square (RMS) geometry change
        between the current and the last optimizer iteration.
        """
        self.Rms_force = None
        """
        Convergence criterium for the root mean square (RMS) force of the
        current configuration.
        """
        self.Step_start_val = None
        """
        The starting step value for the CELL_OPT module.
        """
        self.Type = None
        """
        Specify which kind of method to use for the optimization of the
        simulation cell

        Available values:
            GEO_OPT
                Performs a geometry optimization (the GEO_OPT section must be defined)
                between cell optimization steps.  The stress tensor is computed at the
                optimized geometry.
            MD
                Performs a molecular dynamics run (the MD section needs must defined)
                for computing the stress tensor  used for the cell optimization.
            DIRECT_CELL_OPT
                Performs a geometry and cell optimization at the same time. The stress
                tensor is computed at every step
        """
        self.External_pressure = None
        """
        Specifies the external pressure (1 value or the full 9 components of
        the pressure tensor) applied during the cell optimization.
        """
        self.Keep_angles = None
        """
        Keep angles between the cell vectors constant, but allow the lenghts
        of the cell vectors to change independently. For example, a cubic cell
        might become orthorhombic, but not triclinic.
        """
        self.Keep_symmetry = None
        """
        Keep the requested initial cell symmetry (e.g. during a cell
        optimisation). See cell section for how to impose a cell symmetry.
        """
        self.Pressure_tolerance = None
        """
        Specifies the Pressure tolerance (compared to the external pressure)
        to achieve during the cell optimization.
        """
        self.LBFGS = _lbfgs3()
        self.CG = _cg3()
        self.BFGS = _bfgs3()
        self.list_PRINT = []
        self._name = "CELL_OPT"
        self._keywords = [('Optimizer', 'OPTIMIZER'), ('Max_iter', 'MAX_ITER'), ('Max_dr', 'MAX_DR'), ('Max_force', 'MAX_FORCE'), ('Rms_dr', 'RMS_DR'), ('Rms_force', 'RMS_FORCE'), ('Step_start_val', 'STEP_START_VAL'), ('Type', 'TYPE'), ('External_pressure', 'EXTERNAL_PRESSURE'), ('Keep_angles', 'KEEP_ANGLES'), ('Keep_symmetry', 'KEEP_SYMMETRY'), ('Pressure_tolerance', 'PRESSURE_TOLERANCE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('LBFGS', 'LBFGS'), ('CG', 'CG'), ('BFGS', 'BFGS')]
        self._repeated_subsections = [('PRINT', '_print4')]

    def add_PRINT(self):
        new_section = _print4()
        self.list_PRINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Minimizer(self):
        """
        See documentation for Optimizer
        """
        return self.Optimizer

    @Minimizer.setter
    def Minimizer(self, value):
        self.Optimizer = value



class _buck4ranges1(printable):
    """
    This section specifies the input parameters for Buckingham 4 ranges
    potential type.Functional form: (r<r1) V(r) = A* EXP(-B*r); (r1<r<r2)
    V(r) = SUM_n POLY1(n)*R^n;(r2<r<r3) V(r) = SUM_n POLY2(n)*R^n; (r>r3)
    V(r) = -C/r^6
    """
    def __init__(self):
        self.Atoms = None
        """
        Defines the atomic kind involved in the nonbond potential
        """
        self.A = None
        """
        Defines the A parameter of the Buckingham potential
        """
        self.B = None
        """
        Defines the B parameter of the Buckingham potential
        """
        self.C = None
        """
        Defines the C parameter of the Buckingham  potential
        """
        self.R1 = None
        """
        Defines the upper bound of the first range
        """
        self.R2 = None
        """
        Defines the upper bound of the second range
        """
        self.R3 = None
        """
        Defines the upper bound of the third range
        """
        self.list_Poly1 = []
        self.list_Poly2 = []
        self.Rcut = None
        """
        Defines the cutoff parameter of the Buckingham potential
        """
        self.Rmin = None
        """
        Defines the lower bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self.Rmax = None
        """
        Defines the upper bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self._name = "BUCK4RANGES"
        self._keywords = [('Atoms', 'ATOMS'), ('A', 'A'), ('B', 'B'), ('C', 'C'), ('R1', 'R1'), ('R2', 'R2'), ('R3', 'R3'), ('Rcut', 'RCUT'), ('Rmin', 'RMIN'), ('Rmax', 'RMAX')]
        self._repeated_keywords = [('Poly1', 'POLY1'), ('Poly2', 'POLY2')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Poly1(self, value):
        self.list_Poly1.append(value)

    def add_Poly2(self, value):
        self.list_Poly2.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _geminal1(printable):
    """
    Section used to specify a geminal basis set for QM calculations.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        CP2K Basis Set Standard Format
        """
        self._name = "GEMINAL"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _each196(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each197(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each194(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each195(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each192(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each193(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each190(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each191(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each198(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each199(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _xalpha3(printable):
    """
    Uses the XALPHA (SLATER) functional.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Xa = None
        """
        Value of the xa parameter (this does not change the exponent, just the
        mixing)
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self._name = "XALPHA"
        self._keywords = [('Xa', 'XA'), ('Scale_x', 'SCALE_X')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each282(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each283(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each280(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each281(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each286(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each287(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each284(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _mo_orthonormality1(printable):
    """
    Controls the printing relative to the orthonormality of MOs (CT S C).
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each95()
        self._name = "MO_ORTHONORMALITY"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each288(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each289(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _constrain_exponents1(printable):
    """
    specicifies contraints for the exponents to be fitted. Only a single
    constraint can be applied to an exponent
    """
    def __init__(self):
        self.Use_exp = None
        """
        Defines the exponent to be constraint. The two integers indicate the
        set number and i'th exponent. The value -1 can be used to mark all
        sets/expoenents in a set.
        """
        self.Boundaries = None
        """
        Defines the boundaries to which the optimization is restricted. First
        value is the lower bound, second value is the upper bound.
        """
        self.Max_var_fraction = None
        """
        Defines the maximum fractionr by which the exponent is allowed to
        vary. e.g. 0.5 allows the exp to vary by 0.5*exp in both directions.
        """
        self._name = "CONSTRAIN_EXPONENTS"
        self._keywords = [('Use_exp', 'USE_EXP'), ('Boundaries', 'BOUNDARIES'), ('Max_var_fraction', 'MAX_VAR_FRACTION')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _coord_var1(printable):
    """
    Controls the printing of the variance of the coordination number.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each263()
        self._name = "COORD_VAR"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _reaction_path1(printable):
    """
    Section defining a one dimensional reaction path in an Q-dimensional
    space of colvars. Constraining this colvar, allows to sample the space
    orthogonal to the reaction path, both in the Q-dimensional colvar and
    3N-Q remaining coordinates. For the details of the function see cited
    literature.
    """
    def __init__(self):
        self.Distances_rmsd = None
        """

        """
        self.Rmsd = None
        """

        """
        self.Subset_type = None
        """
        Define the subsytem used to compute the RMSD

        Available values:
            ALL
            LIST
        """
        self.Align_frames = None
        """
        Whether the reference frames should be aligned to minimize the RMSD
        """
        self.list_Atoms = []
        self.list_Function = []
        self.Variable = None
        """
        Specifies the name of the variable that parametrises the FUNCTION
        defining the reaction path.
        """
        self.Lambda = None
        """
        Specifies the exponent of the Gaussian used in the integral
        representation of the colvar.The shape of the space orthogonal to the
        reaction path is defined by this choice. In the limit of large values,
        it is given by the plane orthogonal to the path.In practice, modest
        values are required for stable numerical integration.
        """
        self.Step_size = None
        """
        Step size in the numerical integration, a few thousand points are
        common, and the proper number also depends on LAMBDA.
        """
        self.Range = None
        """
        The range of VARIABLE used for the parametrisation.
        """
        self.list_COLVAR = []
        self.list_FRAME = []
        self.MAP = _map1()
        self._name = "REACTION_PATH"
        self._keywords = [('Distances_rmsd', 'DISTANCES_RMSD'), ('Rmsd', 'RMSD'), ('Subset_type', 'SUBSET_TYPE'), ('Align_frames', 'ALIGN_FRAMES'), ('Variable', 'VARIABLE'), ('Lambda', 'LAMBDA'), ('Step_size', 'STEP_SIZE'), ('Range', 'RANGE')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Function', 'FUNCTION')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('MAP', 'MAP')]
        self._repeated_subsections = [('COLVAR', '_colvar2'), ('FRAME', '_frame3')]

    def add_COLVAR(self):
        new_section = _colvar2()
        self.list_COLVAR.append(new_section)
        return new_section

    def add_FRAME(self):
        new_section = _frame3()
        self.list_FRAME.append(new_section)
        return new_section

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Function(self, value):
        self.list_Function.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _each268(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each269(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _pp_basis1(printable):
    """
    Section of basis set information for pseudopotential calculations.
    """
    def __init__(self):
        self.Basis_type = None
        """
        Basis set type

        Available values:
            GAUSSIAN
            GEOMETRICAL_GTO
            CONTRACTED_GTO
            SLATER
            NUMERICAL
        """
        self.Num_gto = None
        """
        Number of Gaussian type functions for s, p, d, ...
        """
        self.Num_slater = None
        """
        Number of Slater type functions for s, p, d, ...
        """
        self.Start_index = None
        """
        Starting index for Geometrical Basis sets
        """
        self.S_exponents = None
        """
        Exponents for s functions
        """
        self.P_exponents = None
        """
        Exponents for p functions
        """
        self.D_exponents = None
        """
        Exponents for d functions
        """
        self.F_exponents = None
        """
        Exponents for f functions
        """
        self.S_quantum_numbers = None
        """
        Main quantum numbers for s functions
        """
        self.P_quantum_numbers = None
        """
        Main quantum numbers for p functions
        """
        self.D_quantum_numbers = None
        """
        Main quantum numbers for d functions
        """
        self.F_quantum_numbers = None
        """
        Main quantum numbers for f functions
        """
        self.Geometrical_factor = None
        """
        Geometrical basis: factor C in a*C^k
        """
        self.Geo_start_value = None
        """
        Geometrical basis: starting value a in a*C^k
        """
        self.Basis_set_file_name = None
        """
        Name of the basis set file, may include a path
        """
        self.Basis_set = None
        """
        The contracted Gaussian basis set
        """
        self.Quadrature = None
        """
        Algorithm to construct the atomic radial grids

        Available values:
            GC_SIMPLE
            GC_TRANSFORMED
            GC_LOG
        """
        self.Grid_points = None
        """
        Number of radial grid points
        """
        self.Eps_eigenvalue = None
        """
        Cutoff of overlap matrix eigenvalues included into basis
        """
        self.BASIS = _basis3()
        self._name = "PP_BASIS"
        self._keywords = [('Basis_type', 'BASIS_TYPE'), ('Num_gto', 'NUM_GTO'), ('Num_slater', 'NUM_SLATER'), ('Start_index', 'START_INDEX'), ('S_exponents', 'S_EXPONENTS'), ('P_exponents', 'P_EXPONENTS'), ('D_exponents', 'D_EXPONENTS'), ('F_exponents', 'F_EXPONENTS'), ('S_quantum_numbers', 'S_QUANTUM_NUMBERS'), ('P_quantum_numbers', 'P_QUANTUM_NUMBERS'), ('D_quantum_numbers', 'D_QUANTUM_NUMBERS'), ('F_quantum_numbers', 'F_QUANTUM_NUMBERS'), ('Geometrical_factor', 'GEOMETRICAL_FACTOR'), ('Geo_start_value', 'GEO_START_VALUE'), ('Basis_set_file_name', 'BASIS_SET_FILE_NAME'), ('Basis_set', 'BASIS_SET'), ('Quadrature', 'QUADRATURE'), ('Grid_points', 'GRID_POINTS'), ('Eps_eigenvalue', 'EPS_EIGENVALUE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('BASIS', 'BASIS')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Orbital_basis_set(self):
        """
        See documentation for Basis_set
        """
        return self.Basis_set

    @property
    def Orb_basis(self):
        """
        See documentation for Basis_set
        """
        return self.Basis_set

    @Orbital_basis_set.setter
    def Orbital_basis_set(self, value):
        self.Basis_set = value

    @Orb_basis.setter
    def Orb_basis(self, value):
        self.Basis_set = value



class _each260(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each261(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each262(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each263(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each264(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each265(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each266(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each267(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _g_tensor1(printable):
    """
    Controls the printing of the g tensor
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Gapw_max_alpha = None
        """
        Maximum alpha of GTH potentials allowed on the soft grids
        """
        self.Soo_rho_hard = None
        """
        Whether or not to include the atomic parts of the density in the SOO
        part of the g tensor
        """
        self.EACH = _each307()
        self.XC = _xc3()
        self._name = "G_TENSOR"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Gapw_max_alpha', 'GAPW_MAX_ALPHA'), ('Soo_rho_hard', 'SOO_RHO_HARD')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH'), ('XC', 'XC')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _elf_cube1(printable):
    """
    Controls printing of cube files with the electron localization
    function (ELF). Note that the value of ELF is defined between 0 and 1:
    Pauli kinetic energy density normalized  by the kinetic energy density
    of a uniform el. gas of same density.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Stride = None
        """
        The stride (X,Y,Z) used to write the cube file (larger values result
        in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1
        number valid for all components.
        """
        self.Append = None
        """
        append the cube files when they already exist
        """
        self.Density_cutoff = None
        """

        """
        self.EACH = _each196()
        self._name = "ELF_CUBE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Stride', 'STRIDE'), ('Append', 'APPEND'), ('Density_cutoff', 'DENSITY_CUTOFF')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _colvar_restart1(printable):
    """
    Specify restart position only for COLVAR restraints.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        The restarting values for COLVAR restraints. The order is an internal
        order. So if you decide to modify these values by hand first think
        what you're doing!
        """
        self._name = "COLVAR_RESTART"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _lyp_adiabatic1(printable):
    """
    Uses the LYP correlation functional in an adiabatic fashion
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Lambda = None
        """
        Defines the parameter of the adiabatic curve.
        """
        self._name = "LYP_ADIABATIC"
        self._keywords = [('Lambda', 'LAMBDA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _lyp_adiabatic2(printable):
    """
    Uses the LYP correlation functional in an adiabatic fashion
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Lambda = None
        """
        Defines the parameter of the adiabatic curve.
        """
        self._name = "LYP_ADIABATIC"
        self._keywords = [('Lambda', 'LAMBDA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _lyp_adiabatic3(printable):
    """
    Uses the LYP correlation functional in an adiabatic fashion
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Lambda = None
        """
        Defines the parameter of the adiabatic curve.
        """
        self._name = "LYP_ADIABATIC"
        self._keywords = [('Lambda', 'LAMBDA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _lyp_adiabatic4(printable):
    """
    Uses the LYP correlation functional in an adiabatic fashion
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Lambda = None
        """
        Defines the parameter of the adiabatic curve.
        """
        self._name = "LYP_ADIABATIC"
        self._keywords = [('Lambda', 'LAMBDA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _dipole1(printable):
    """
    Controls the printing of dipole information. Requires the DIPOLE
    calculation be active for all subforce_eval.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each90()
        self._name = "DIPOLE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _dipole2(printable):
    """
    This section specifies that we will perform an SCF dipole calculation
    of the MM atoms. Needs KEYWORD POL_SCF in POISSON secton
    """
    def __init__(self):
        self.Atom = None
        """
        Defines the atomic kind of the scf dipole.
        """
        self.Apol = None
        """
        Defines the isotropic polarizability of the MM atom.
        """
        self.list_DAMPING = []
        self._name = "DIPOLE"
        self._keywords = [('Atom', 'ATOM'), ('Apol', 'APOL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('DAMPING', '_damping1')]

    def add_DAMPING(self):
        new_section = _damping1()
        self.list_DAMPING.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _dipole3(printable):
    """
    Section controlling the calculation of DIPOLE. Note that the result in
    the periodic case might be defined modulo a certain period, determined
    by the lattice vectors. During MD, this can lead to jumps.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Periodic = None
        """
        Use Berry phase formula (PERIODIC=T) or simple operator (PERIODIC=F).
        The latter normally requires that the CELL is periodic NONE.
        """
        self.Reference = None
        """
        Define the reference point for the calculation of the electrostatic
        moment.

        Available values:
            COM
                Use Center of Mass
            COAC
                Use Center of Atomic Charges
            USER_DEFINED
                Use User Defined Point (Keyword:REF_POINT)
            ZERO
                Use Origin of Coordinate System
        """
        self.Reference_point = None
        """
        Fixed reference point for the calculations of the electrostatic
        moment.
        """
        self.EACH = _each224()
        self._name = "DIPOLE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Periodic', 'PERIODIC'), ('Reference', 'REFERENCE'), ('Reference_point', 'REFERENCE_POINT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Ref(self):
        """
        See documentation for Reference
        """
        return self.Reference

    @property
    def Ref_point(self):
        """
        See documentation for Reference_point
        """
        return self.Reference_point

    @Ref.setter
    def Ref(self, value):
        self.Reference = value

    @Ref_point.setter
    def Ref_point(self, value):
        self.Reference_point = value



class _run_info1(printable):
    """
    Prints various informations on the progress of the ep calculation
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Lin_solv = None
        """
        print the linear solver progress
        """
        self.EACH = _each256()
        self._name = "RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Lin_solv', 'LIN_SOLV')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _distribution1(printable):
    """
    can be used used to tune the parallel distribution of the data
    """
    def __init__(self):
        self.Cost_model = None
        """
        The cost model that needs to be minimized

        Available values:
            BLOCK_COUNT
                the number of blocks
            BLOCK_SURFACE
                the number of blocks weighted by the number elements per block
            BLOCK_LMAX
                the number of blocks weighted by the sum of the lmax
        """
        self.Num2d_molecular_distribution = None
        """
        Distribute the atoms so that atoms belonging to a given molecule are
        on the same CPU for the 2D distribution. This might give rise to a
        worse distribution but reduces memory needs of finding the optimal
        distribution.
        """
        self.Skip_optimization = None
        """
        Do not optimize the distribution, go for something very simple. Might
        be useful if the optimization, which scales quadratically in system
        size, is too expensive.
        """
        self.Basic_optimization = None
        """
        Creates a distribution based on a few heuristics using only minimal
        memory and CPU time.
        """
        self.Basic_spatial_optimization = None
        """
        Creates a distribution with spatial info, using only minimal memory
        and CPU time.
        """
        self.Symmetric = None
        """
        Take the symmetry of the distribution_2d into account.
        """
        self._2D_MC = _num2d_mc1()
        self._name = "DISTRIBUTION"
        self._keywords = [('Cost_model', 'COST_MODEL'), ('Num2d_molecular_distribution', '2D_MOLECULAR_DISTRIBUTION'), ('Skip_optimization', 'SKIP_OPTIMIZATION'), ('Basic_optimization', 'BASIC_OPTIMIZATION'), ('Basic_spatial_optimization', 'BASIC_SPATIAL_OPTIMIZATION'), ('Symmetric', 'SYMMETRIC')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('_2D_MC', '2D_MC')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _distribution2(printable):
    """
    Controls the printing of the distribution of molecules, atoms, ...
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each339()
        self._name = "DISTRIBUTION"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _thermostat1(printable):
    """
    Specify thermostat type and parameters controlling the thermostat.
    """
    def __init__(self):
        self.Type = None
        """
        Specify the thermostat used for the constant temperature ensembles.

        Available values:
            SAME_AS_PARTICLE
                Use the same kind of thermostat used for particles.
            NOSE
                Uses the Nose-Hoover thermostat.
            CSVR
                Uses the canonical sampling through velocity rescaling.
        """
        self.NOSE = _nose1()
        self.CSVR = _csvr1()
        self.GLE = _gle1()
        self.AD_LANGEVIN = _ad_langevin1()
        self.PRINT = _print6()
        self._name = "THERMOSTAT"
        self._keywords = [('Type', 'TYPE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('NOSE', 'NOSE'), ('CSVR', 'CSVR'), ('GLE', 'GLE'), ('AD_LANGEVIN', 'AD_LANGEVIN'), ('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _thermostat2(printable):
    """
    Specify thermostat type and parameters controlling the thermostat.
    """
    def __init__(self):
        self.Type = None
        """
        Specify the thermostat used for the constant temperature ensembles.

        Available values:
            NOSE
                Uses the Nose-Hoover thermostat.
            CSVR
                Uses the canonical sampling through velocity rescaling.
            GLE
                Uses GLE thermostat
            AD_LANGEVIN
                Uses adaptive-Langevin thermostat
        """
        self.Region = None
        """
        Determines the region each thermostat is attached to.

        Available values:
            GLOBAL
            MOLECULE
            MASSIVE
            DEFINED
            NONE
        """
        self.list_DEFINE_REGION = []
        self.NOSE = _nose2()
        self.CSVR = _csvr2()
        self.GLE = _gle2()
        self.AD_LANGEVIN = _ad_langevin2()
        self.PRINT = _print8()
        self._name = "THERMOSTAT"
        self._keywords = [('Type', 'TYPE'), ('Region', 'REGION')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('NOSE', 'NOSE'), ('CSVR', 'CSVR'), ('GLE', 'GLE'), ('AD_LANGEVIN', 'AD_LANGEVIN'), ('PRINT', 'PRINT')]
        self._repeated_subsections = [('DEFINE_REGION', '_define_region1')]

    def add_DEFINE_REGION(self):
        new_section = _define_region1()
        self.list_DEFINE_REGION.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _thermostat3(printable):
    """
    Specify thermostat type and parameters controlling the thermostat.
    """
    def __init__(self):
        self.Type = None
        """
        Specify the thermostat used for the constant temperature ensembles.

        Available values:
            NOSE
                Uses the Nose-Hoover thermostat.
            CSVR
                Uses the canonical sampling through velocity rescaling.
            GLE
                Uses GLE thermostat
            AD_LANGEVIN
                Uses adaptive-Langevin thermostat
        """
        self.Region = None
        """
        Determines the region each thermostat is attached to.

        Available values:
            GLOBAL
            MOLECULE
            MASSIVE
            DEFINED
            NONE
        """
        self.list_DEFINE_REGION = []
        self.NOSE = _nose3()
        self.CSVR = _csvr3()
        self.GLE = _gle3()
        self.AD_LANGEVIN = _ad_langevin3()
        self.PRINT = _print9()
        self._name = "THERMOSTAT"
        self._keywords = [('Type', 'TYPE'), ('Region', 'REGION')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('NOSE', 'NOSE'), ('CSVR', 'CSVR'), ('GLE', 'GLE'), ('AD_LANGEVIN', 'AD_LANGEVIN'), ('PRINT', 'PRINT')]
        self._repeated_subsections = [('DEFINE_REGION', '_define_region2')]

    def add_DEFINE_REGION(self):
        new_section = _define_region2()
        self.list_DEFINE_REGION.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _ddapc_restraint_b1(printable):
    """
    Use DDAPC charges in a restraint (check code for details), section can
    be repeated, but only one constraint is possible at the moment.
    """
    def __init__(self):
        self.Strength = None
        """
        force constant of the restraint
        """
        self.Type_of_density = None
        """
        Specifies the type of density used for the fitting

        Available values:
            FULL
                Full density
            SPIN
                Spin density
        """
        self.Target = None
        """
        target value of the restraint
        """
        self.Atoms = None
        """
        Specifies the list of atoms that is summed in the restraint
        """
        self.Coeff = None
        """
        Defines the the coefficient of the atom in the atom list (default is
        one), currently DDAPC only
        """
        self.Functional_form = None
        """
        Specifies the functional form of the term added

        Available values:
            RESTRAINT
                Harmonic potential: s*(q-t)**2
            CONSTRAINT
                Constraint form: s*(q-t)
        """
        self.PROGRAM_RUN_INFO = _program_run_info44()
        self._name = "DDAPC_RESTRAINT_B"
        self._keywords = [('Strength', 'STRENGTH'), ('Type_of_density', 'TYPE_OF_DENSITY'), ('Target', 'TARGET'), ('Atoms', 'ATOMS'), ('Coeff', 'COEFF'), ('Functional_form', 'FUNCTIONAL_FORM')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _qmmm_matrix1(printable):
    """
    Controls the printing of the QMMM 1 electron Hamiltonian Matrix for
    methods like semiempirical and DFTB
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each244()
        self._name = "QMMM_MATRIX"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _ff_info1(printable):
    """
    Controls the printing of information in the forcefield settings
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Spline_info = None
        """
        if the printkey is active prints information regarding the splines
        used in the nonbonded interactions
        """
        self.Spline_data = None
        """
        if the printkey is active prints on separated files the splined
        function together with the reference one. Useful to check the spline
        behavior.
        """
        self.EACH = _each231()
        self._name = "FF_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Spline_info', 'SPLINE_INFO'), ('Spline_data', 'SPLINE_DATA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _conv_info11(printable):
    """
    if convergence information about the linear solver of the spline
    methods should be printed
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each321()
        self._name = "CONV_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _conv_info10(printable):
    """
    if convergence information about the linear solver of the spline
    methods should be printed
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each305()
        self._name = "CONV_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _chebyshev1(printable):
    """
    Specifies the parameters needed for the chebyshev expansion based
    properties.
    """
    def __init__(self):
        self.N_chebyshev = None
        """
        Order of the polynomial expansion.
        """
        self.DOS = _dos1()
        self.PRINT_SPECIFIC_E_DENSITY_CUBE = _print_specific_e_density_cube1()
        self._name = "CHEBYSHEV"
        self._keywords = [('N_chebyshev', 'N_CHEBYSHEV')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('DOS', 'DOS'), ('PRINT_SPECIFIC_E_DENSITY_CUBE', 'PRINT_SPECIFIC_E_DENSITY_CUBE')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each21(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each20(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each23(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each22(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each25(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each24(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each27(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each26(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each29(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each28(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _pint1(printable):
    """
    The section that controls a path integral run
    """
    def __init__(self):
        self.P = None
        """
        Specify number beads to use
        """
        self.Proc_per_replica = None
        """
        Specify number of processors to use for each replica
        """
        self.Num_steps = None
        """
        Number of steps (if MAX_STEP is not explicitly given the program will
        perform this number of steps)
        """
        self.Max_step = None
        """
        Maximum step number (the program will stop if ITERATION >= MAX_STEP
        even if NUM_STEPS has not been reached)
        """
        self.Iteration = None
        """
        Specify the iteration number from which it should be counted
        """
        self.Temp = None
        """
        The temperature you want to simulate
        """
        self.T_tol = None
        """
        threshold for the oscillations of the temperature excedeed which the
        temperature is rescaled. 0 means no rescaling.
        """
        self.Dt = None
        """
        timestep (might be subdivised in nrespa subtimesteps
        """
        self.Nrespa = None
        """
        number of respa steps for the bead for each md step
        """
        self.Transformation = None
        """
        Specifies the coordinate transformation to use

        Available values:
            NORMAL
            STAGE
        """
        self.Fix_centroid_pos = None
        """
        Propagate all DOF but the centroid - useful for equilibration of the
        non-centroid modes (activated only if TRANSFORMATION==NORMAL)
        """
        self.NORMALMODE = _normalmode1()
        self.STAGING = _staging1()
        self.BEADS = _beads1()
        self.NOSE = _nose6()
        self.GLE = _gle4()
        self.INIT = _init1()
        self.HELIUM = _helium1()
        self.PRINT = _print15()
        self._name = "PINT"
        self._keywords = [('P', 'P'), ('Proc_per_replica', 'PROC_PER_REPLICA'), ('Num_steps', 'NUM_STEPS'), ('Max_step', 'MAX_STEP'), ('Iteration', 'ITERATION'), ('Temp', 'TEMP'), ('T_tol', 'T_TOL'), ('Dt', 'DT'), ('Nrespa', 'NRESPA'), ('Transformation', 'TRANSFORMATION'), ('Fix_centroid_pos', 'FIX_CENTROID_POS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('NORMALMODE', 'NORMALMODE'), ('STAGING', 'STAGING'), ('BEADS', 'BEADS'), ('NOSE', 'NOSE'), ('GLE', 'GLE'), ('INIT', 'INIT'), ('HELIUM', 'HELIUM'), ('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Temp_to(self):
        """
        See documentation for T_tol
        """
        return self.T_tol

    @Temp_to.setter
    def Temp_to(self, value):
        self.T_tol = value



class _displaced_atom1(printable):
    """
    Controls the output of index and dislacement of atoms that moved away
    from the initial position of more than agiven distance (see
    msd%disp_tol)
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each30()
        self._name = "DISPLACED_ATOM"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _hcth4(printable):
    """
    Uses the HCTH class of functionals
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Parameter_set = None
        """
        Which version of the parameters should be used

        Available values:
            93
            120
            147
            407
        """
        self._name = "HCTH"
        self._keywords = [('Parameter_set', 'PARAMETER_SET')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _hcth2(printable):
    """
    Uses the HCTH class of functionals
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Parameter_set = None
        """
        Which version of the parameters should be used

        Available values:
            93
            120
            147
            407
        """
        self._name = "HCTH"
        self._keywords = [('Parameter_set', 'PARAMETER_SET')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _hcth3(printable):
    """
    Uses the HCTH class of functionals
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Parameter_set = None
        """
        Which version of the parameters should be used

        Available values:
            93
            120
            147
            407
        """
        self._name = "HCTH"
        self._keywords = [('Parameter_set', 'PARAMETER_SET')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _hcth1(printable):
    """
    Uses the HCTH class of functionals
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Parameter_set = None
        """
        Which version of the parameters should be used

        Available values:
            93
            120
            147
            407
        """
        self._name = "HCTH"
        self._keywords = [('Parameter_set', 'PARAMETER_SET')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _fixed_atoms1(printable):
    """
    This section is used to constraint the overall atomic position
    (X,Y,Z). In case a restraint is specified the value of the TARGET is
    considered to be the value of the coordinates at the beginning of the
    run or alternatively the corresponding value in the section:
    FIX_ATOM_RESTART.
    """
    def __init__(self):
        self.Components_to_fix = None
        """
        Specify which components (X,Y,Z or combinations) of the atoms
        specified in the sectionwill be constrained/restrained.

        Available values:
            X
                Fix only X component
            Y
                Fix only Y component
            Z
                Fix only Z component
            XY
                Fix X-Y components
            XZ
                Fix X-Z components
            YZ
                Fix Y-Z components
            XYZ
                Fix the full components of the atomic position.
        """
        self.list_List = []
        self.list_Molname = []
        self.list_Segname = self.list_Molname
        self.Mm_subsys = None
        """
        In a QM/MM run all  MM atoms are fixed according to the argument.

        Available values:
            NONE
                fix nothing
            ATOMIC
                only the MM atoms itself
            MOLECULAR
                the full molecule/residue that contains a MM atom (i.e. some QM atoms
                might be fixed as well)
        """
        self.Qm_subsys = None
        """
        In a QM/MM run all QM atoms are fixed according to the argument.

        Available values:
            NONE
                fix nothing
            ATOMIC
                only the QM atoms itself
            MOLECULAR
                the full molecule/residue that contains a QM atom (i.e. some MM atoms
                might be fixed as well)
        """
        self.Exclude_qm = None
        """
        Does not apply the constraint to the QM region within a QM/MM
        calculation. This keyword is active only together with MOLNAME
        """
        self.Exclude_mm = None
        """
        Does not apply the constraint to the MM region within a QM/MM
        calculation. This keyword is active only together with MOLNAME
        """
        self.RESTRAINT = _restraint6()
        self._name = "FIXED_ATOMS"
        self._keywords = [('Components_to_fix', 'COMPONENTS_TO_FIX'), ('Mm_subsys', 'MM_SUBSYS'), ('Qm_subsys', 'QM_SUBSYS'), ('Exclude_qm', 'EXCLUDE_QM'), ('Exclude_mm', 'EXCLUDE_MM')]
        self._repeated_keywords = [('List', 'LIST'), ('Molname', 'MOLNAME')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('RESTRAINT', 'RESTRAINT')]
        self._repeated_subsections = []

    def add_List(self, value):
        self.list_List.append(value)

    def add_Molname(self, value):
        self.list_Molname.append(value)

    def add_Segname(self, value):
        self.list_MOLNAME.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Protein(self):
        """
        See documentation for Mm_subsys
        """
        return self.Mm_subsys

    @Protein.setter
    def Protein(self, value):
        self.Mm_subsys = value



class _forces4(printable):
    """
    Controls the printing of the forces after each force evaluation
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Ndigits = None
        """
        Specifies the number of digits used for the printing of the forces
        """
        self.EACH = _each336()
        self._name = "FORCES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Ndigits', 'NDIGITS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _forces1(printable):
    """
    Controls the output of the helium forces on the solute
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each58()
        self._name = "FORCES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _cascade1(printable):
    """
    Defines the parameters for the setup of a cascade simulation.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Controls the activation of the CASCADE section.
        """
        self.Energy = None
        """
        Total energy transferred to the system during the cascade event.
        """
        self.ATOM_LIST = _atom_list1()
        self._name = "CASCADE"
        self._keywords = [('Energy', 'ENERGY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('ATOM_LIST', 'ATOM_LIST')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _forces3(printable):
    """
    Controls the printing of the EIP forces.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each261()
        self._name = "FORCES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _alchemical_change1(printable):
    """
    Controls the calculation of delta free energies with the alchemical
    change method.
    """
    def __init__(self):
        self.Parameter = None
        """
        Defines the perturbing parameter of the alchemical change
        tranformation
        """
        self.Weighting_function = None
        """
        Specifies the weighting function (umbrella potential, part of the
        mixing function)
        """
        self.Eps_conv = None
        """
        Set the relative tolerance for the convergence of the free energy
        derivative
        """
        self.Nequil_steps = None
        """
        Set the number of equilibration steps, skipped to compute averages
        """
        self._name = "ALCHEMICAL_CHANGE"
        self._keywords = [('Parameter', 'PARAMETER'), ('Weighting_function', 'WEIGHTING_FUNCTION'), ('Eps_conv', 'EPS_CONV'), ('Nequil_steps', 'NEQUIL_STEPS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _periodic4(printable):
    """
    Sets up periodic boundary condition parameters if requested
    """
    def __init__(self):
        self.Number_of_shells = None
        """
        Number of shells taken into account for periodicity. By default, cp2k
        tries to automatically evaluate this number. This algorithm might be
        to conservative, resulting in some overhead. You can try to adjust
        this number in order to make a calculation cheaper.
        """
        self._name = "PERIODIC"
        self._keywords = [('Number_of_shells', 'NUMBER_OF_SHELLS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _hills1(printable):
    """
    Controls the printing of HILLS summary information during
    metadynamics. The file contains: instantaneous colvar value, width of
    the spawned gaussian and height of the gaussian. According the value
    of  the EACH keyword this file may not be synchronized with the COLVAR
    file.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each44()
        self._name = "HILLS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _compare_energies1(printable):
    """
    A comparison of energies between fit and reference
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each345()
        self._name = "COMPARE_ENERGIES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _atom1(printable):
    """
    Section handling input for atomic calculations.
    """
    def __init__(self):
        self.Atomic_number = None
        """
        Specify the atomic number
        """
        self.Element = None
        """
        Specify the element to be calculated
        """
        self.Run_type = None
        """
        Type of run that you want to perform
        [ENERGY,BASIS_OPTIMIZATION,PSEUDOPOTENTIAL_OPTIMIZATION,,...]

        Available values:
            NONE
            ENERGY
            BASIS_OPTIMIZATION
            PSEUDOPOTENTIAL_OPTIMIZATION
        """
        self.Coulomb_integrals = None
        """
        Method to calculate Coulomb integrals

        Available values:
            ANALYTIC
            SEMI_ANALYTIC
            NUMERIC
        """
        self.Exchange_integrals = None
        """
        Method to calculate Exchange integrals

        Available values:
            ANALYTIC
            SEMI_ANALYTIC
            NUMERIC
        """
        self.Core = None
        """
        Specifies the core electrons for a pseudopotential
        """
        self.list_Electron_configuration = []
        self.Max_angular_momentum = None
        """
        Specifies the largest angular momentum calculated [0-3]
        """
        self.Calculate_states = None
        """
        Specifies the number of states calculated per l value
        """
        self.PRINT = _print63()
        self.AE_BASIS = _ae_basis1()
        self.PP_BASIS = _pp_basis1()
        self.list_METHOD = []
        self.OPTIMIZATION = _optimization2()
        self.POTENTIAL = _potential4()
        self.POWELL = _powell2()
        self._name = "ATOM"
        self._keywords = [('Atomic_number', 'ATOMIC_NUMBER'), ('Element', 'ELEMENT'), ('Run_type', 'RUN_TYPE'), ('Coulomb_integrals', 'COULOMB_INTEGRALS'), ('Exchange_integrals', 'EXCHANGE_INTEGRALS'), ('Core', 'CORE'), ('Max_angular_momentum', 'MAX_ANGULAR_MOMENTUM'), ('Calculate_states', 'CALCULATE_STATES')]
        self._repeated_keywords = [('Electron_configuration', 'ELECTRON_CONFIGURATION')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT', 'PRINT'), ('AE_BASIS', 'AE_BASIS'), ('PP_BASIS', 'PP_BASIS'), ('OPTIMIZATION', 'OPTIMIZATION'), ('POTENTIAL', 'POTENTIAL'), ('POWELL', 'POWELL')]
        self._repeated_subsections = [('METHOD', '_method1')]

    def add_METHOD(self):
        new_section = _method1()
        self.list_METHOD.append(new_section)
        return new_section

    def add_Electron_configuration(self, value):
        self.list_Electron_configuration.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _enforce_occupation1(printable):
    """
    Enforce and control a special (initial) orbital occupation. Note, this
    feature works only for the methods MULLIKEN and LOWDIN. It should only
    be used to prepare an initial configuration. An inadequate parameter
    choice can easily inhibit SCF convergence.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Controls the activation of the ENFORCE_OCCUPATION section
        """
        self.Orbitals = None
        """
        Select orbitals and occupation order. An input of 1 to 2*L+1 integer
        values in the range -L to L defining the M values of the spherical
        orbitals is expected.
        """
        self.Eps_scf = None
        """
        The occupation constraint is enforced until this threshold value for
        the SCF convergence criterion is reached
        """
        self.Max_scf = None
        """
        The occupation constraint is applied for this number of initial SCF
        iterations
        """
        self.Smear = None
        """
        The occupation constraint is applied with smearing
        """
        self._name = "ENFORCE_OCCUPATION"
        self._keywords = [('Orbitals', 'ORBITALS'), ('Eps_scf', 'EPS_SCF'), ('Max_scf', 'MAX_SCF'), ('Smear', 'SMEAR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def M(self):
        """
        See documentation for Orbitals
        """
        return self.Orbitals

    @M.setter
    def M(self, value):
        self.Orbitals = value



class _num2pnt3(printable):
    """
    Provides parameters to tune the line search for the two point based
    line search.
    """
    def __init__(self):
        self.Max_allowed_step = None
        """
        Max allowed value for the line search step.
        """
        self.Linmin_grad_only = None
        """
        Use only the gradient, not the energy for line minimizations (e.g. in
        conjugate gradients).
        """
        self._name = "2PNT"
        self._keywords = [('Max_allowed_step', 'MAX_ALLOWED_STEP'), ('Linmin_grad_only', 'LINMIN_GRAD_ONLY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _num2pnt1(printable):
    """
    Provides parameters to tune the line search for the two point based
    line search.
    """
    def __init__(self):
        self.Max_allowed_step = None
        """
        Max allowed value for the line search step.
        """
        self.Linmin_grad_only = None
        """
        Use only the gradient, not the energy for line minimizations (e.g. in
        conjugate gradients).
        """
        self._name = "2PNT"
        self._keywords = [('Max_allowed_step', 'MAX_ALLOWED_STEP'), ('Linmin_grad_only', 'LINMIN_GRAD_ONLY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _num2pnt4(printable):
    """
    Provides parameters to tune the line search for the two point based
    line search.
    """
    def __init__(self):
        self.Max_allowed_step = None
        """
        Max allowed value for the line search step.
        """
        self.Linmin_grad_only = None
        """
        Use only the gradient, not the energy for line minimizations (e.g. in
        conjugate gradients).
        """
        self._name = "2PNT"
        self._keywords = [('Max_allowed_step', 'MAX_ALLOWED_STEP'), ('Linmin_grad_only', 'LINMIN_GRAD_ONLY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _force_mixing_labels1(printable):
    """
    Controls the output of the force mixing (FORCE_EVAL&QMMM&FORCE_MIXING)
    labels
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Format = None
        """
        Specifies the format of the output file for the force mixing labels.

        Available values:
            ATOMIC
                Write only the coordinates X,Y,Z without element symbols to a
                formatted file
            DCD
                Write the coordinates (no element labels) and the cell information to
                a binary file
            XMOL
                Mostly known as XYZ format, provides in a formatted file:
                element_symbol X Y Z
            XYZ
                Alias name for XMOL
        """
        self.EACH = _each80()
        self._name = "FORCE_MIXING_LABELS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Format', 'FORMAT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _constraint2(printable):
    """
    specifies a linear constraint on the fitted charges.This can be used
    to give equal values to equivalent atoms.sum over atom_list c_i * q_i
    = t
    """
    def __init__(self):
        self.Target = None
        """
        the target value for the constraint
        """
        self.Equal_charges = None
        """
        All atoms in ATOM_LIST are constrained to have the same charges. When
        using this keyword, TARGET and ATOM_COEF do not need to be set and
        will be ignored. Instead of using this keyword, the constraint section
        could be repeated.
        """
        self.list_Atom_list = []
        self.Atom_coef = None
        """
        Defines the coefficient of the atom in this linear constraint
        """
        self._name = "CONSTRAINT"
        self._keywords = [('Target', 'TARGET'), ('Equal_charges', 'EQUAL_CHARGES'), ('Atom_coef', 'ATOM_COEF')]
        self._repeated_keywords = [('Atom_list', 'ATOM_LIST')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atom_list(self, value):
        self.list_Atom_list.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _constraint1(printable):
    """
    Section specifying information regarding how to impose constraints on
    the system.
    """
    def __init__(self):
        self.Shake_tolerance = None
        """
        Set the tolerance for the shake/rattle constraint algorithm.
        """
        self.Roll_tolerance = None
        """
        Set the tolerance for the roll constraint algorithm.
        """
        self.Constraint_init = None
        """
        Apply constraints to the initial position and velocities. Default is
        to apply constraints only after the first MD step.
        """
        self.HBONDS = _hbonds1()
        self.list_G3X3 = []
        self.list_G4X6 = []
        self.list_VIRTUAL_SITE = []
        self.list_COLLECTIVE = []
        self.list_FIXED_ATOMS = []
        self.FIX_ATOM_RESTART = _fix_atom_restart1()
        self.COLVAR_RESTART = _colvar_restart1()
        self.CONSTRAINT_INFO = _constraint_info1()
        self.LAGRANGE_MULTIPLIERS = _lagrange_multipliers1()
        self._name = "CONSTRAINT"
        self._keywords = [('Shake_tolerance', 'SHAKE_TOLERANCE'), ('Roll_tolerance', 'ROLL_TOLERANCE'), ('Constraint_init', 'CONSTRAINT_INIT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('HBONDS', 'HBONDS'), ('FIX_ATOM_RESTART', 'FIX_ATOM_RESTART'), ('COLVAR_RESTART', 'COLVAR_RESTART'), ('CONSTRAINT_INFO', 'CONSTRAINT_INFO'), ('LAGRANGE_MULTIPLIERS', 'LAGRANGE_MULTIPLIERS')]
        self._repeated_subsections = [('G3X3', '_g3x31'), ('G4X6', '_g4x61'), ('VIRTUAL_SITE', '_virtual_site1'), ('COLLECTIVE', '_collective1'), ('FIXED_ATOMS', '_fixed_atoms1')]

    def add_G3X3(self):
        new_section = _g3x31()
        self.list_G3X3.append(new_section)
        return new_section

    def add_G4X6(self):
        new_section = _g4x61()
        self.list_G4X6.append(new_section)
        return new_section

    def add_VIRTUAL_SITE(self):
        new_section = _virtual_site1()
        self.list_VIRTUAL_SITE.append(new_section)
        return new_section

    def add_COLLECTIVE(self):
        new_section = _collective1()
        self.list_COLLECTIVE.append(new_section)
        return new_section

    def add_FIXED_ATOMS(self):
        new_section = _fixed_atoms1()
        self.list_FIXED_ATOMS.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Shake_tol(self):
        """
        See documentation for Shake_tolerance
        """
        return self.Shake_tolerance

    @property
    def Shake(self):
        """
        See documentation for Shake_tolerance
        """
        return self.Shake_tolerance

    @property
    def Roll_tol(self):
        """
        See documentation for Roll_tolerance
        """
        return self.Roll_tolerance

    @property
    def Roll(self):
        """
        See documentation for Roll_tolerance
        """
        return self.Roll_tolerance

    @Shake_tol.setter
    def Shake_tol(self, value):
        self.Shake_tolerance = value

    @Shake.setter
    def Shake(self, value):
        self.Shake_tolerance = value

    @Roll_tol.setter
    def Roll_tol(self, value):
        self.Roll_tolerance = value

    @Roll.setter
    def Roll(self, value):
        self.Roll_tolerance = value



class _tddfpt1(printable):
    """
    parameters needed to set up the Time Dependent Density Functional PT
    """
    def __init__(self):
        self.Max_kv = None
        """
         maximal number of Krylov space vectors
        """
        self.Restarts = None
        """
         maximal number subspace search restarts
        """
        self.Nev = None
        """
         number of excitations to calculate
        """
        self.Nlumo = None
        """
         number of additional unoccupied orbitals
        """
        self.Nreortho = None
        """
         number of reorthogonalization steps
        """
        self.Kernel = None
        """
        compute the kernel (debug purpose only)
        """
        self.Lsd_singlets = None
        """
        compute singlets using lsd vxc kernel
        """
        self.Invert_s = None
        """
        use the inverse of the overlap matrix
        """
        self.Preconditioner = None
        """
        use the preconditioner (only for Davidson)
        """
        self.Res_etype = None
        """
        (singlets/triplets) for restricted calculation

        Available values:
            S
            SINGLET
            SINGLETS
            T
            TRIPLET
            TRIPLETS
        """
        self.Diag_method = None
        """
        Diagonalization method used in tddfpt

        Available values:
            DAVIDSON
            LANCZOS
        """
        self.Oe_corr = None
        """
        Which type of orbital eigenvalue correction to use\n(to yield better
        HOMO-LUMO energies)

        Available values:
            NONE
            LB
            LB_ALPHA
            LB94
            GLLB
            GLB
            SAOP
            SIC
        """
        self.Convergence = None
        """
        The convergence of the eigenvalues
        """
        self.XC = _xc1()
        self.SIC = _sic1()
        self._name = "TDDFPT"
        self._keywords = [('Max_kv', 'MAX_KV'), ('Restarts', 'RESTARTS'), ('Nev', 'NEV'), ('Nlumo', 'NLUMO'), ('Nreortho', 'NREORTHO'), ('Kernel', 'KERNEL'), ('Lsd_singlets', 'LSD_SINGLETS'), ('Invert_s', 'INVERT_S'), ('Preconditioner', 'PRECONDITIONER'), ('Res_etype', 'RES_ETYPE'), ('Diag_method', 'DIAG_METHOD'), ('Oe_corr', 'OE_CORR'), ('Convergence', 'CONVERGENCE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('XC', 'XC'), ('SIC', 'SIC')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Max_vectors(self):
        """
        See documentation for Max_kv
        """
        return self.Max_kv

    @property
    def N_restarts(self):
        """
        See documentation for Restarts
        """
        return self.Restarts

    @property
    def N_ev(self):
        """
        See documentation for Nev
        """
        return self.Nev

    @property
    def Ev(self):
        """
        See documentation for Nev
        """
        return self.Nev

    @property
    def N_reortho(self):
        """
        See documentation for Nreortho
        """
        return self.Nreortho

    @property
    def Reortho(self):
        """
        See documentation for Nreortho
        """
        return self.Nreortho

    @property
    def Reorthogonalitazions(self):
        """
        See documentation for Nreortho
        """
        return self.Nreortho

    @property
    def Do_kernel(self):
        """
        See documentation for Kernel
        """
        return self.Kernel

    @property
    def Invert_overlap(self):
        """
        See documentation for Invert_s
        """
        return self.Invert_s

    @property
    def Precond(self):
        """
        See documentation for Preconditioner
        """
        return self.Preconditioner

    @property
    def Restricted_excitations_type(self):
        """
        See documentation for Res_etype
        """
        return self.Res_etype

    @property
    def Res_e_type(self):
        """
        See documentation for Res_etype
        """
        return self.Res_etype

    @property
    def Diagonalization_method(self):
        """
        See documentation for Diag_method
        """
        return self.Diag_method

    @property
    def Method(self):
        """
        See documentation for Diag_method
        """
        return self.Diag_method

    @property
    def Orbital_eigenvalues_correction(self):
        """
        See documentation for Oe_corr
        """
        return self.Oe_corr

    @property
    def Conv(self):
        """
        See documentation for Convergence
        """
        return self.Convergence

    @Max_vectors.setter
    def Max_vectors(self, value):
        self.Max_kv = value

    @N_restarts.setter
    def N_restarts(self, value):
        self.Restarts = value

    @N_ev.setter
    def N_ev(self, value):
        self.Nev = value

    @Ev.setter
    def Ev(self, value):
        self.Nev = value

    @N_reortho.setter
    def N_reortho(self, value):
        self.Nreortho = value

    @Reortho.setter
    def Reortho(self, value):
        self.Nreortho = value

    @Reorthogonalitazions.setter
    def Reorthogonalitazions(self, value):
        self.Nreortho = value

    @Do_kernel.setter
    def Do_kernel(self, value):
        self.Kernel = value

    @Invert_overlap.setter
    def Invert_overlap(self, value):
        self.Invert_s = value

    @Precond.setter
    def Precond(self, value):
        self.Preconditioner = value

    @Restricted_excitations_type.setter
    def Restricted_excitations_type(self, value):
        self.Res_etype = value

    @Res_e_type.setter
    def Res_e_type(self, value):
        self.Res_etype = value

    @Diagonalization_method.setter
    def Diagonalization_method(self, value):
        self.Diag_method = value

    @Method.setter
    def Method(self, value):
        self.Diag_method = value

    @Orbital_eigenvalues_correction.setter
    def Orbital_eigenvalues_correction(self, value):
        self.Oe_corr = value

    @Conv.setter
    def Conv(self, value):
        self.Convergence = value



class _qmmm_link_info1(printable):
    """
    Print all information on QM/MM links
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each251()
        self._name = "QMMM_LINK_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _torsions1(printable):
    """
    Defines new torsions
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Four integer indexes per line defining the new torsion Indexes must be
        relative to the full system and not to the single molecules
        """
        self._name = "TORSIONS"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _mixing3(printable):
    """
    Define type and parameters for mixingprocedures to be applied to the
    density matrix. Normally, only one type of mixing method should be
    accepted. The mixing procedures activated by this section are only
    active for diagonalization methods, i.e. not with minimization methods
    based on OT.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Controls the activation of the mixing procedure
        """
        self.Method = None
        """
        Mixing method to be applied

        Available values:
            NONE
                No mixing is applied
            DIRECT_P_MIXING
                Direct mixing of new and old density matrices
            KERKER_MIXING
                Mixing of the potential in reciprocal space using the Kerker damping
            PULAY_MIXING
                Pulay mixing
            BROYDEN_MIXING
                Broyden mixing
            BROYDEN_MIXING_NEW
                Broyden mixing second version
            MULTISECANT_MIXING
                Multisecant scheme for mixing
        """
        self.Alpha = None
        """
        Fraction of new density to be included
        """
        self.Beta = None
        """
        Denominator parameter in Kerker damping introduced to suppress charge
        sloshing: rho_mix(g) =rho_in(g) + alpha*g^2/(g^2 +
        beta^2)*(rho_out(g)-rho_in(g))
        """
        self.Pulay_alpha = None
        """
        Fraction of new density to be added to the Pulay expansion
        """
        self.Pulay_beta = None
        """
        Fraction of residual contribution to be added to Pulay expansion
        """
        self.Nmixing = None
        """
        Minimal number of density mixing (should be greater than 0),before
        starting DIIS
        """
        self.Nbuffer = None
        """
        Number of previous steps stored for the actual mixing scheme
        """
        self.Broy_w0 = None
        """
         w0 parameter used in Broyden mixing
        """
        self.Broy_wref = None
        """

        """
        self.Broy_wmax = None
        """

        """
        self.Regularization = None
        """
        Regularization parameter to stabilize the inversion of the residual
        matrix {Yn^t Yn} in the multisecant mixing scheme (noise)
        """
        self.Max_step = None
        """
        Upper bound for the magnitude of the unpredicted step size in the
        update by the multisecant mixing scheme
        """
        self.R_factor = None
        """
        Control factor for the magnitude of the unpredicted step size in the
        update by the multisecant mixing scheme
        """
        self.Nskip = None
        """
        Number of initial iteration for which the mixing is skipped
        """
        self.N_simple_mix = None
        """
        Number of kerker damping iterations before starting other mixing
        procedures
        """
        self.Kerker_min = None
        """
        Minimal Kerker damping factor: MAX(g^2/(g^2 + beta^2),KERKER_MIN)
        """
        self.Max_gvec_exp = None
        """
        Restricts the G-space mixing to lower part of G-vector spectrum, up to
        a G0, by assigning the exponent of the Gaussian that can be
        represented by vectors smaller than G0 within a certain accuracy.
        """
        self._name = "MIXING"
        self._keywords = [('Method', 'METHOD'), ('Alpha', 'ALPHA'), ('Beta', 'BETA'), ('Pulay_alpha', 'PULAY_ALPHA'), ('Pulay_beta', 'PULAY_BETA'), ('Nmixing', 'NMIXING'), ('Nbuffer', 'NBUFFER'), ('Broy_w0', 'BROY_W0'), ('Broy_wref', 'BROY_WREF'), ('Broy_wmax', 'BROY_WMAX'), ('Regularization', 'REGULARIZATION'), ('Max_step', 'MAX_STEP'), ('R_factor', 'R_FACTOR'), ('Nskip', 'NSKIP'), ('N_simple_mix', 'N_SIMPLE_MIX'), ('Kerker_min', 'KERKER_MIN'), ('Max_gvec_exp', 'MAX_GVEC_EXP')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Npulay(self):
        """
        See documentation for Nbuffer
        """
        return self.Nbuffer

    @property
    def Nbroyden(self):
        """
        See documentation for Nbuffer
        """
        return self.Nbuffer

    @property
    def Nmultisecant(self):
        """
        See documentation for Nbuffer
        """
        return self.Nbuffer

    @property
    def Nskip_mixing(self):
        """
        See documentation for Nskip
        """
        return self.Nskip

    @property
    def Nsimplemix(self):
        """
        See documentation for N_simple_mix
        """
        return self.N_simple_mix

    @Npulay.setter
    def Npulay(self, value):
        self.Nbuffer = value

    @Nbroyden.setter
    def Nbroyden(self, value):
        self.Nbuffer = value

    @Nmultisecant.setter
    def Nmultisecant(self, value):
        self.Nbuffer = value

    @Nskip_mixing.setter
    def Nskip_mixing(self, value):
        self.Nskip = value

    @Nsimplemix.setter
    def Nsimplemix(self, value):
        self.N_simple_mix = value



class _mixing2(printable):
    """
    Define type and parameters for mixingprocedures to be applied to the
    density matrix. Normally, only one type of mixing method should be
    accepted. The mixing procedures activated by this section are only
    active for diagonalization methods, i.e. not with minimization methods
    based on OT.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Controls the activation of the mixing procedure
        """
        self.Method = None
        """
        Mixing method to be applied

        Available values:
            NONE
                No mixing is applied
            DIRECT_P_MIXING
                Direct mixing of new and old density matrices
            KERKER_MIXING
                Mixing of the potential in reciprocal space using the Kerker damping
            PULAY_MIXING
                Pulay mixing
            BROYDEN_MIXING
                Broyden mixing
            BROYDEN_MIXING_NEW
                Broyden mixing second version
            MULTISECANT_MIXING
                Multisecant scheme for mixing
        """
        self.Alpha = None
        """
        Fraction of new density to be included
        """
        self.Beta = None
        """
        Denominator parameter in Kerker damping introduced to suppress charge
        sloshing: rho_mix(g) =rho_in(g) + alpha*g^2/(g^2 +
        beta^2)*(rho_out(g)-rho_in(g))
        """
        self.Pulay_alpha = None
        """
        Fraction of new density to be added to the Pulay expansion
        """
        self.Pulay_beta = None
        """
        Fraction of residual contribution to be added to Pulay expansion
        """
        self.Nmixing = None
        """
        Minimal number of density mixing (should be greater than 0),before
        starting DIIS
        """
        self.Nbuffer = None
        """
        Number of previous steps stored for the actual mixing scheme
        """
        self.Broy_w0 = None
        """
         w0 parameter used in Broyden mixing
        """
        self.Broy_wref = None
        """

        """
        self.Broy_wmax = None
        """

        """
        self.Regularization = None
        """
        Regularization parameter to stabilize the inversion of the residual
        matrix {Yn^t Yn} in the multisecant mixing scheme (noise)
        """
        self.Max_step = None
        """
        Upper bound for the magnitude of the unpredicted step size in the
        update by the multisecant mixing scheme
        """
        self.R_factor = None
        """
        Control factor for the magnitude of the unpredicted step size in the
        update by the multisecant mixing scheme
        """
        self.Nskip = None
        """
        Number of initial iteration for which the mixing is skipped
        """
        self.N_simple_mix = None
        """
        Number of kerker damping iterations before starting other mixing
        procedures
        """
        self.Kerker_min = None
        """
        Minimal Kerker damping factor: MAX(g^2/(g^2 + beta^2),KERKER_MIN)
        """
        self.Max_gvec_exp = None
        """
        Restricts the G-space mixing to lower part of G-vector spectrum, up to
        a G0, by assigning the exponent of the Gaussian that can be
        represented by vectors smaller than G0 within a certain accuracy.
        """
        self._name = "MIXING"
        self._keywords = [('Method', 'METHOD'), ('Alpha', 'ALPHA'), ('Beta', 'BETA'), ('Pulay_alpha', 'PULAY_ALPHA'), ('Pulay_beta', 'PULAY_BETA'), ('Nmixing', 'NMIXING'), ('Nbuffer', 'NBUFFER'), ('Broy_w0', 'BROY_W0'), ('Broy_wref', 'BROY_WREF'), ('Broy_wmax', 'BROY_WMAX'), ('Regularization', 'REGULARIZATION'), ('Max_step', 'MAX_STEP'), ('R_factor', 'R_FACTOR'), ('Nskip', 'NSKIP'), ('N_simple_mix', 'N_SIMPLE_MIX'), ('Kerker_min', 'KERKER_MIN'), ('Max_gvec_exp', 'MAX_GVEC_EXP')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Npulay(self):
        """
        See documentation for Nbuffer
        """
        return self.Nbuffer

    @property
    def Nbroyden(self):
        """
        See documentation for Nbuffer
        """
        return self.Nbuffer

    @property
    def Nmultisecant(self):
        """
        See documentation for Nbuffer
        """
        return self.Nbuffer

    @property
    def Nskip_mixing(self):
        """
        See documentation for Nskip
        """
        return self.Nskip

    @property
    def Nsimplemix(self):
        """
        See documentation for N_simple_mix
        """
        return self.N_simple_mix

    @Npulay.setter
    def Npulay(self, value):
        self.Nbuffer = value

    @Nbroyden.setter
    def Nbroyden(self, value):
        self.Nbuffer = value

    @Nmultisecant.setter
    def Nmultisecant(self, value):
        self.Nbuffer = value

    @Nskip_mixing.setter
    def Nskip_mixing(self, value):
        self.Nskip = value

    @Nsimplemix.setter
    def Nsimplemix(self, value):
        self.N_simple_mix = value



class _mixing1(printable):
    """
    Define type and parameters for mixingprocedures to be applied to the
    density matrix. Normally, only one type of mixing method should be
    accepted. The mixing procedures activated by this section are only
    active for diagonalization methods, i.e. not with minimization methods
    based on OT.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Controls the activation of the mixing procedure
        """
        self.Method = None
        """
        Mixing method to be applied

        Available values:
            NONE
                No mixing is applied
            DIRECT_P_MIXING
                Direct mixing of new and old density matrices
            KERKER_MIXING
                Mixing of the potential in reciprocal space using the Kerker damping
            PULAY_MIXING
                Pulay mixing
            BROYDEN_MIXING
                Broyden mixing
            BROYDEN_MIXING_NEW
                Broyden mixing second version
            MULTISECANT_MIXING
                Multisecant scheme for mixing
        """
        self.Alpha = None
        """
        Fraction of new density to be included
        """
        self.Beta = None
        """
        Denominator parameter in Kerker damping introduced to suppress charge
        sloshing: rho_mix(g) =rho_in(g) + alpha*g^2/(g^2 +
        beta^2)*(rho_out(g)-rho_in(g))
        """
        self.Pulay_alpha = None
        """
        Fraction of new density to be added to the Pulay expansion
        """
        self.Pulay_beta = None
        """
        Fraction of residual contribution to be added to Pulay expansion
        """
        self.Nmixing = None
        """
        Minimal number of density mixing (should be greater than 0),before
        starting DIIS
        """
        self.Nbuffer = None
        """
        Number of previous steps stored for the actual mixing scheme
        """
        self.Broy_w0 = None
        """
         w0 parameter used in Broyden mixing
        """
        self.Broy_wref = None
        """

        """
        self.Broy_wmax = None
        """

        """
        self.Regularization = None
        """
        Regularization parameter to stabilize the inversion of the residual
        matrix {Yn^t Yn} in the multisecant mixing scheme (noise)
        """
        self.Max_step = None
        """
        Upper bound for the magnitude of the unpredicted step size in the
        update by the multisecant mixing scheme
        """
        self.R_factor = None
        """
        Control factor for the magnitude of the unpredicted step size in the
        update by the multisecant mixing scheme
        """
        self.Nskip = None
        """
        Number of initial iteration for which the mixing is skipped
        """
        self.N_simple_mix = None
        """
        Number of kerker damping iterations before starting other mixing
        procedures
        """
        self.Kerker_min = None
        """
        Minimal Kerker damping factor: MAX(g^2/(g^2 + beta^2),KERKER_MIN)
        """
        self.Max_gvec_exp = None
        """
        Restricts the G-space mixing to lower part of G-vector spectrum, up to
        a G0, by assigning the exponent of the Gaussian that can be
        represented by vectors smaller than G0 within a certain accuracy.
        """
        self._name = "MIXING"
        self._keywords = [('Method', 'METHOD'), ('Alpha', 'ALPHA'), ('Beta', 'BETA'), ('Pulay_alpha', 'PULAY_ALPHA'), ('Pulay_beta', 'PULAY_BETA'), ('Nmixing', 'NMIXING'), ('Nbuffer', 'NBUFFER'), ('Broy_w0', 'BROY_W0'), ('Broy_wref', 'BROY_WREF'), ('Broy_wmax', 'BROY_WMAX'), ('Regularization', 'REGULARIZATION'), ('Max_step', 'MAX_STEP'), ('R_factor', 'R_FACTOR'), ('Nskip', 'NSKIP'), ('N_simple_mix', 'N_SIMPLE_MIX'), ('Kerker_min', 'KERKER_MIN'), ('Max_gvec_exp', 'MAX_GVEC_EXP')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Npulay(self):
        """
        See documentation for Nbuffer
        """
        return self.Nbuffer

    @property
    def Nbroyden(self):
        """
        See documentation for Nbuffer
        """
        return self.Nbuffer

    @property
    def Nmultisecant(self):
        """
        See documentation for Nbuffer
        """
        return self.Nbuffer

    @property
    def Nskip_mixing(self):
        """
        See documentation for Nskip
        """
        return self.Nskip

    @property
    def Nsimplemix(self):
        """
        See documentation for N_simple_mix
        """
        return self.N_simple_mix

    @Npulay.setter
    def Npulay(self, value):
        self.Nbuffer = value

    @Nbroyden.setter
    def Nbroyden(self, value):
        self.Nbuffer = value

    @Nmultisecant.setter
    def Nmultisecant(self, value):
        self.Nbuffer = value

    @Nskip_mixing.setter
    def Nskip_mixing(self, value):
        self.Nskip = value

    @Nsimplemix.setter
    def Nsimplemix(self, value):
        self.N_simple_mix = value



class _parameter1(printable):
    """
    Information on where to find DFTB parameters
    """
    def __init__(self):
        self.list_Sk_file = []
        self.Param_file_path = None
        """
        Specify the directory with the DFTB parameter files
        """
        self.Param_file_name = None
        """
        Specify file that contains the SK_FILE names
        """
        self.Uff_force_field = None
        """
        Name of file with UFF parameters
        """
        self._name = "PARAMETER"
        self._keywords = [('Param_file_path', 'PARAM_FILE_PATH'), ('Param_file_name', 'PARAM_FILE_NAME'), ('Uff_force_field', 'UFF_FORCE_FIELD')]
        self._repeated_keywords = [('Sk_file', 'SK_FILE')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Sk_file(self, value):
        self.list_Sk_file.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _optimize_band1(printable):
    """
    Specify the optimization method for the band
    """
    def __init__(self):
        self.Opt_type = None
        """
        Specifies the type optimizer used for the band

        Available values:
            MD
                Molecular Dynamics based Optimizer
            DIIS
                Coupled Steepest Descent / DIIS
        """
        self.Optimize_end_points = None
        """
        Performs also an optimization of the end points of the band.
        """
        self.MD = _md2()
        self.DIIS = _diis1()
        self._name = "OPTIMIZE_BAND"
        self._keywords = [('Opt_type', 'OPT_TYPE'), ('Optimize_end_points', 'OPTIMIZE_END_POINTS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('MD', 'MD'), ('DIIS', 'DIIS')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _ao_matrices1(printable):
    """
    Controls the printing of the ao (i.e. contracted gaussian) matrices
    (debug).
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Core_hamiltonian = None
        """
        If the printkey is activated controls the printing of the hamiltonian
        matrix
        """
        self.Density = None
        """
        If the printkey is activated controls the printing of the density (P)
        matrix
        """
        self.Kinetic_energy = None
        """
        If the printkey is activated controls the printing of the kinetic
        energy matrix
        """
        self.Kohn_sham_matrix = None
        """
        If the printkey is activated controls the printing of the kohn-sham
        matrix
        """
        self.Matrix_vxc = None
        """
        If the printkey is activated compute and print the matrix of the
        exchange and correlation potential.Only the GGA part for GPW is
        printed
        """
        self.Ortho = None
        """
        If the printkey is activated controls the printing of the
        orthogonalization matrix
        """
        self.Overlap = None
        """
        If the printkey is activated controls the printing of the overlap
        matrix
        """
        self.Fermi_contact = None
        """
        If the printkey is activated controls the printing of the Fermi
        contact matrix
        """
        self.Pso = None
        """
        If the printkey is activated controls the printing of the paramagnetic
        spin-orbit matrices
        """
        self.Efg = None
        """
        If the printkey is activated controls the printing of the electric
        field gradient matrices
        """
        self.Potential_energy = None
        """
        If the printkey is activated controls the printing of the potential
        energy matrix
        """
        self.Oce_hard = None
        """
        If the printkey is activated controls the printing of the OCE HARD
        matrix
        """
        self.Oce_soft = None
        """
        If the printkey is activated controls the printing of the OCE SOFT
        matrix
        """
        self.W_matrix = None
        """
        If the printkey is activated controls the printing of the w matrix
        """
        self.W_matrix_aux_fit = None
        """
        If the printkey is activated controls the printing of the w matrix
        """
        self.Derivatives = None
        """
        If the printkey is activated controls the printing of derivatives (for
        the matrixes that support this)
        """
        self.EACH = _each184()
        self._name = "AO_MATRICES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Core_hamiltonian', 'CORE_HAMILTONIAN'), ('Density', 'DENSITY'), ('Kinetic_energy', 'KINETIC_ENERGY'), ('Kohn_sham_matrix', 'KOHN_SHAM_MATRIX'), ('Matrix_vxc', 'MATRIX_VXC'), ('Ortho', 'ORTHO'), ('Overlap', 'OVERLAP'), ('Fermi_contact', 'FERMI_CONTACT'), ('Pso', 'PSO'), ('Efg', 'EFG'), ('Potential_energy', 'POTENTIAL_ENERGY'), ('Oce_hard', 'OCE_HARD'), ('Oce_soft', 'OCE_SOFT'), ('W_matrix', 'W_MATRIX'), ('W_matrix_aux_fit', 'W_MATRIX_AUX_FIT'), ('Derivatives', 'DERIVATIVES')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _mp2_info4(printable):
    """
    Controls the printing basic info about MP2 method
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each370()
        self._name = "MP2_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _mp2_info1(printable):
    """
    Controls the printing basic info about MP2 method
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each118()
        self._name = "MP2_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _mp2_info3(printable):
    """
    Controls the printing basic info about MP2 method
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each313()
        self._name = "MP2_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _mp2_info2(printable):
    """
    Controls the printing basic info about MP2 method
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each131()
        self._name = "MP2_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _conv_info7(printable):
    """
    if convergence information about the linear solver of the spline
    methods should be printed
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each239()
        self._name = "CONV_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _conv_info6(printable):
    """
    if convergence information about the linear solver of the spline
    methods should be printed
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each237()
        self._name = "CONV_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _conv_info5(printable):
    """
    if convergence information about the linear solver of the spline
    methods should be printed
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each234()
        self._name = "CONV_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _conv_info4(printable):
    """
    if convergence information about the linear solver of the spline
    methods should be printed
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each218()
        self._name = "CONV_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _conv_info3(printable):
    """
    if convergence information about the linear solver of the spline
    methods should be printed
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each213()
        self._name = "CONV_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _conv_info2(printable):
    """
    if convergence information about the linear solver of the spline
    methods should be printed
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each138()
        self._name = "CONV_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _conv_info1(printable):
    """
    if convergence information about the linear solver of the spline
    methods should be printed
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each125()
        self._name = "CONV_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _conv_info9(printable):
    """
    if convergence information about the linear solver of the spline
    methods should be printed
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each303()
        self._name = "CONV_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _conv_info8(printable):
    """
    if convergence information about the linear solver of the spline
    methods should be printed
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each299()
        self._name = "CONV_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _coord11(printable):
    """
    The positions for RMSD used for restart
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify positions of the system
        """
        self._name = "COORD"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _bond_rotation2(printable):
    """
    Section to define the rotation of a bond/line with respect toanother
    bond/line
    """
    def __init__(self):
        self.P1_bond1 = None
        """
        Specifies the index of atom/point defining the first pointof the first
        bond/line.
        """
        self.P2_bond1 = None
        """
        Specifies the index of atom/point defining the second pointof the
        first bond/line.
        """
        self.P1_bond2 = None
        """
        Specifies the index of atom/point defining the first pointof the
        second bond/line.
        """
        self.P2_bond2 = None
        """
        Specifies the index of atom/point defining the second pointof the
        second bond/line.
        """
        self.list_POINT = []
        self._name = "BOND_ROTATION"
        self._keywords = [('P1_bond1', 'P1_BOND1'), ('P2_bond1', 'P2_BOND1'), ('P1_bond2', 'P1_BOND2'), ('P2_bond2', 'P2_BOND2')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point27')]

    def add_POINT(self):
        new_section = _point27()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _ae_basis1(printable):
    """
    Section of basis set information for all-electron calculations.
    """
    def __init__(self):
        self.Basis_type = None
        """
        Basis set type

        Available values:
            GAUSSIAN
            GEOMETRICAL_GTO
            CONTRACTED_GTO
            SLATER
            NUMERICAL
        """
        self.Num_gto = None
        """
        Number of Gaussian type functions for s, p, d, ...
        """
        self.Num_slater = None
        """
        Number of Slater type functions for s, p, d, ...
        """
        self.Start_index = None
        """
        Starting index for Geometrical Basis sets
        """
        self.S_exponents = None
        """
        Exponents for s functions
        """
        self.P_exponents = None
        """
        Exponents for p functions
        """
        self.D_exponents = None
        """
        Exponents for d functions
        """
        self.F_exponents = None
        """
        Exponents for f functions
        """
        self.S_quantum_numbers = None
        """
        Main quantum numbers for s functions
        """
        self.P_quantum_numbers = None
        """
        Main quantum numbers for p functions
        """
        self.D_quantum_numbers = None
        """
        Main quantum numbers for d functions
        """
        self.F_quantum_numbers = None
        """
        Main quantum numbers for f functions
        """
        self.Geometrical_factor = None
        """
        Geometrical basis: factor C in a*C^k
        """
        self.Geo_start_value = None
        """
        Geometrical basis: starting value a in a*C^k
        """
        self.Basis_set_file_name = None
        """
        Name of the basis set file, may include a path
        """
        self.Basis_set = None
        """
        The contracted Gaussian basis set
        """
        self.Quadrature = None
        """
        Algorithm to construct the atomic radial grids

        Available values:
            GC_SIMPLE
            GC_TRANSFORMED
            GC_LOG
        """
        self.Grid_points = None
        """
        Number of radial grid points
        """
        self.Eps_eigenvalue = None
        """
        Cutoff of overlap matrix eigenvalues included into basis
        """
        self.BASIS = _basis2()
        self._name = "AE_BASIS"
        self._keywords = [('Basis_type', 'BASIS_TYPE'), ('Num_gto', 'NUM_GTO'), ('Num_slater', 'NUM_SLATER'), ('Start_index', 'START_INDEX'), ('S_exponents', 'S_EXPONENTS'), ('P_exponents', 'P_EXPONENTS'), ('D_exponents', 'D_EXPONENTS'), ('F_exponents', 'F_EXPONENTS'), ('S_quantum_numbers', 'S_QUANTUM_NUMBERS'), ('P_quantum_numbers', 'P_QUANTUM_NUMBERS'), ('D_quantum_numbers', 'D_QUANTUM_NUMBERS'), ('F_quantum_numbers', 'F_QUANTUM_NUMBERS'), ('Geometrical_factor', 'GEOMETRICAL_FACTOR'), ('Geo_start_value', 'GEO_START_VALUE'), ('Basis_set_file_name', 'BASIS_SET_FILE_NAME'), ('Basis_set', 'BASIS_SET'), ('Quadrature', 'QUADRATURE'), ('Grid_points', 'GRID_POINTS'), ('Eps_eigenvalue', 'EPS_EIGENVALUE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('BASIS', 'BASIS')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Orbital_basis_set(self):
        """
        See documentation for Basis_set
        """
        return self.Basis_set

    @property
    def Orb_basis(self):
        """
        See documentation for Basis_set
        """
        return self.Basis_set

    @Orbital_basis_set.setter
    def Orbital_basis_set(self, value):
        self.Basis_set = value

    @Orb_basis.setter
    def Orb_basis(self, value):
        self.Basis_set = value



class _coord10(printable):
    """
    The coordinates for simple systems (like the QM ones) xyz format by
    default. More complex systems should be given with an external pdb
    file.
    """
    def __init__(self):
        self.Unit = None
        """
        Specify the unit of measurement for the coordinates in inputAll
        available CP2K units can be used.
        """
        self.Scaled = None
        """
        Specify if the coordinateds in input are scaled.
        """
        self.list_Default_keyword = []
        """
        ATOM_KIND  X  Y  Z  <MOLNAME>. MOLNAME is optional. If not provided
        the molecule name is internally created. All other fields after
        MOLNAME are simply ignored.
        """
        self._name = "COORD"
        self._keywords = [('Unit', 'UNIT'), ('Scaled', 'SCALED')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _sphere1(printable):
    """
    Treats the implicit solvent environment like a sphere
    """
    def __init__(self):
        self.Radius = None
        """
        Value of the spherical cavity in the dielectric medium
        """
        self.CENTER = _center1()
        self._name = "SPHERE"
        self._keywords = [('Radius', 'RADIUS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('CENTER', 'CENTER')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each295(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each294(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each297(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each296(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each291(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each290(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each293(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each292(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each299(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each298(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _loc_restart4(printable):
    """
    Controls the printing of restart file for localized MOS
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each201()
        self._name = "LOC_RESTART"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _loc_restart5(printable):
    """
    Controls the printing of restart file for localized MOS
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each290()
        self._name = "LOC_RESTART"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _wall1(printable):
    """
    Controls the activation of walls on COLVAR during a metadynamic run.
    """
    def __init__(self):
        self.Type = None
        """
        Specify the type of wall

        Available values:
            REFLECTIVE
                Reflective wall. Colvar velocity is inverted when the colvar is beyond
                the wall position.
            QUADRATIC
                Applies a quadratic potential at the wall position.
            QUARTIC
                Applies a quartic potential at the wall position.
            GAUSSIAN
                Applies a gaussian potential at the wall position.
            NONE
                No walls are applied.
        """
        self.Position = None
        """
        Specify the value of the colvar for the wall position
        """
        self.REFLECTIVE = _reflective1()
        self.QUADRATIC = _quadratic1()
        self.QUARTIC = _quartic1()
        self.GAUSSIAN = _gaussian1()
        self._name = "WALL"
        self._keywords = [('Type', 'TYPE'), ('Position', 'POSITION')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('REFLECTIVE', 'REFLECTIVE'), ('QUADRATIC', 'QUADRATIC'), ('QUARTIC', 'QUARTIC'), ('GAUSSIAN', 'GAUSSIAN')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _loc_restart1(printable):
    """
    Controls the printing of restart file for localized MOS
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each148()
        self._name = "LOC_RESTART"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _loc_restart2(printable):
    """
    Controls the printing of restart file for localized MOS
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each158()
        self._name = "LOC_RESTART"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _loc_restart3(printable):
    """
    Controls the printing of restart file for localized MOS
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each169()
        self._name = "LOC_RESTART"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _xc_grid4(printable):
    """
    The xc parameters used when calculating the xc on the grid
    """
    def __init__(self):
        self.Xc_smooth_rho = None
        """
        The density smoothing used for the xc calculation

        Available values:
            NONE
            NN50
            NN10
            SPLINE2
            NN6
            SPLINE3
            NN4
        """
        self.Xc_deriv = None
        """
        The method used to compute the derivatives

        Available values:
            PW
            SPLINE3
            SPLINE2
            NN50_SMOOTH
            NN10_SMOOTH
            SPLINE2_SMOOTH
            NN6_SMOOTH
            SPLINE3_SMOOTH
            NN4_SMOOTH
            COLLOCATE
        """
        self.Use_finer_grid = None
        """
        Uses a finer grid only to calculate the xc
        """
        self._name = "XC_GRID"
        self._keywords = [('Xc_smooth_rho', 'XC_SMOOTH_RHO'), ('Xc_deriv', 'XC_DERIV'), ('Use_finer_grid', 'USE_FINER_GRID')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each279(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each278(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _xc_grid1(printable):
    """
    The xc parameters used when calculating the xc on the grid
    """
    def __init__(self):
        self.Xc_smooth_rho = None
        """
        The density smoothing used for the xc calculation

        Available values:
            NONE
            NN50
            NN10
            SPLINE2
            NN6
            SPLINE3
            NN4
        """
        self.Xc_deriv = None
        """
        The method used to compute the derivatives

        Available values:
            PW
            SPLINE3
            SPLINE2
            NN50_SMOOTH
            NN10_SMOOTH
            SPLINE2_SMOOTH
            NN6_SMOOTH
            SPLINE3_SMOOTH
            NN4_SMOOTH
            COLLOCATE
        """
        self.Use_finer_grid = None
        """
        Uses a finer grid only to calculate the xc
        """
        self._name = "XC_GRID"
        self._keywords = [('Xc_smooth_rho', 'XC_SMOOTH_RHO'), ('Xc_deriv', 'XC_DERIV'), ('Use_finer_grid', 'USE_FINER_GRID')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _xc_grid2(printable):
    """
    The xc parameters used when calculating the xc on the grid
    """
    def __init__(self):
        self.Xc_smooth_rho = None
        """
        The density smoothing used for the xc calculation

        Available values:
            NONE
            NN50
            NN10
            SPLINE2
            NN6
            SPLINE3
            NN4
        """
        self.Xc_deriv = None
        """
        The method used to compute the derivatives

        Available values:
            PW
            SPLINE3
            SPLINE2
            NN50_SMOOTH
            NN10_SMOOTH
            SPLINE2_SMOOTH
            NN6_SMOOTH
            SPLINE3_SMOOTH
            NN4_SMOOTH
            COLLOCATE
        """
        self.Use_finer_grid = None
        """
        Uses a finer grid only to calculate the xc
        """
        self._name = "XC_GRID"
        self._keywords = [('Xc_smooth_rho', 'XC_SMOOTH_RHO'), ('Xc_deriv', 'XC_DERIV'), ('Use_finer_grid', 'USE_FINER_GRID')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _xc_grid3(printable):
    """
    The xc parameters used when calculating the xc on the grid
    """
    def __init__(self):
        self.Xc_smooth_rho = None
        """
        The density smoothing used for the xc calculation

        Available values:
            NONE
            NN50
            NN10
            SPLINE2
            NN6
            SPLINE3
            NN4
        """
        self.Xc_deriv = None
        """
        The method used to compute the derivatives

        Available values:
            PW
            SPLINE3
            SPLINE2
            NN50_SMOOTH
            NN10_SMOOTH
            SPLINE2_SMOOTH
            NN6_SMOOTH
            SPLINE3_SMOOTH
            NN4_SMOOTH
            COLLOCATE
        """
        self.Use_finer_grid = None
        """
        Uses a finer grid only to calculate the xc
        """
        self._name = "XC_GRID"
        self._keywords = [('Xc_smooth_rho', 'XC_SMOOTH_RHO'), ('Xc_deriv', 'XC_DERIV'), ('Use_finer_grid', 'USE_FINER_GRID')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each273(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _total_dipole4(printable):
    """
    Section controlling the calculation of TOTAL_DIPOLE. Note that the
    result in the periodic case might be defined modulo a certain period,
    determined by the lattice vectors. During MD, this can lead to jumps.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Periodic = None
        """
        Use Berry phase formula (PERIODIC=T) or simple operator (PERIODIC=F).
        The latter normally requires that the CELL is periodic NONE.
        """
        self.Reference = None
        """
        Define the reference point for the calculation of the electrostatic
        moment.

        Available values:
            COM
                Use Center of Mass
            COAC
                Use Center of Atomic Charges
            USER_DEFINED
                Use User Defined Point (Keyword:REF_POINT)
            ZERO
                Use Origin of Coordinate System
        """
        self.Reference_point = None
        """
        Fixed reference point for the calculations of the electrostatic
        moment.
        """
        self.EACH = _each291()
        self._name = "TOTAL_DIPOLE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Periodic', 'PERIODIC'), ('Reference', 'REFERENCE'), ('Reference_point', 'REFERENCE_POINT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Ref(self):
        """
        See documentation for Reference
        """
        return self.Reference

    @property
    def Ref_point(self):
        """
        See documentation for Reference_point
        """
        return self.Reference_point

    @Ref.setter
    def Ref(self, value):
        self.Reference = value

    @Ref_point.setter
    def Ref_point(self, value):
        self.Reference_point = value



class _each271(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each270(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each277(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each276(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _total_dipole3(printable):
    """
    Section controlling the calculation of TOTAL_DIPOLE. Note that the
    result in the periodic case might be defined modulo a certain period,
    determined by the lattice vectors. During MD, this can lead to jumps.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Periodic = None
        """
        Use Berry phase formula (PERIODIC=T) or simple operator (PERIODIC=F).
        The latter normally requires that the CELL is periodic NONE.
        """
        self.Reference = None
        """
        Define the reference point for the calculation of the electrostatic
        moment.

        Available values:
            COM
                Use Center of Mass
            COAC
                Use Center of Atomic Charges
            USER_DEFINED
                Use User Defined Point (Keyword:REF_POINT)
            ZERO
                Use Origin of Coordinate System
        """
        self.Reference_point = None
        """
        Fixed reference point for the calculations of the electrostatic
        moment.
        """
        self.EACH = _each202()
        self._name = "TOTAL_DIPOLE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Periodic', 'PERIODIC'), ('Reference', 'REFERENCE'), ('Reference_point', 'REFERENCE_POINT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Ref(self):
        """
        See documentation for Reference
        """
        return self.Reference

    @property
    def Ref_point(self):
        """
        See documentation for Reference_point
        """
        return self.Reference_point

    @Ref.setter
    def Ref(self, value):
        self.Reference = value

    @Ref_point.setter
    def Ref_point(self, value):
        self.Reference_point = value



class _each274(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _pgf1(printable):
    """
    Controls the printing of the gaussian expansion basis set of the
    electrostatic potential
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each241()
        self._name = "PGF"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _derivatives1(printable):
    """
    Print all derivatives after the DFT calculation
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Ndigits = None
        """
        Specify the number of digits used to print derivatives
        """
        self.EACH = _each181()
        self._name = "DERIVATIVES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Ndigits', 'NDIGITS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _derivatives2(printable):
    """
    Controls the printing of derivatives.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each222()
        self._name = "DERIVATIVES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _derivatives3(printable):
    """
    Print all derivatives after QM/MM calculation
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each249()
        self._name = "DERIVATIVES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each189(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each188(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each181(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each180(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each183(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each182(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each185(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _wf_correlation2(printable):
    """
    Sets up the Wavefunction-based Correlation parameters if requested
    """
    def __init__(self):
        self.Method = None
        """
        Which method should be used to compute the MP2 energy

        Available values:
            NONE
                Skip MP2 calculation
            DIRECT_CANONICAL
                Use the direct mp2 canonical approach
            MP2_GPW
                Use the GPW approach to MP2
            RI_MP2_GPW
                Use the GPW approach to RI-MP2
            RI_RPA_GPW
                Use the GPW approach to RI-RPA
            RI_SOS_LAPLACE
                Use the GPW approach to RI-SOS-Laplace-MP2
        """
        self.Memory = None
        """
        Maximum allowed total memory usage during MP2 methods [Mb].
        """
        self.Scale_s = None
        """
        Scaling factor of the singlet energy component (opposite spin, OS).
        """
        self.Scale_t = None
        """
        Scaling factor of the triplet energy component (same spin, SS).
        """
        self.Group_size = None
        """
        Group size used in the computation of the integrals. Default is to use
        all processors (GROUP_SIZE=-1).A smaller group size (for example the
        node size), might a better choice if the actual MP2 time is large
        compared to integral computation time. This is usually the case if the
        total number of processors is not too large.
        """
        self.Row_block = None
        """
        Size of the row block used in the SCALAPACK block cyclic data
        distribution.Default is (ROW_BLOCK=-1) is automatic. A proper choice
        can speedup the parallel matrix multiplication in the case of RI-RPA
        and RI-SOS-MP2-Laplace.
        """
        self.Col_block = None
        """
        Size of the column block used in the SCALAPACK block cyclic data
        distribution.Default is (COL_BLOCK=-1) is automatic. A proper choice
        can speedup the parallel matrix multiplication in the case of RI-RPA
        and RI-SOS-MP2-Laplace.
        """
        self.Calc_cond_num = None
        """
        Calculate the condition number of the (P|Q) matrix for the RI methods.
        """
        self.MP2_INFO = _mp2_info2()
        self.DIRECT_CANONICAL = _direct_canonical2()
        self.WFC_GPW = _wfc_gpw2()
        self.RI_MP2 = _ri_mp22()
        self.RI_RPA = _ri_rpa2()
        self.RI_LAPLACE = _ri_laplace2()
        self.INTERACTION_POTENTIAL = _interaction_potential6()
        self._name = "WF_CORRELATION"
        self._keywords = [('Method', 'METHOD'), ('Memory', 'MEMORY'), ('Scale_s', 'SCALE_S'), ('Scale_t', 'SCALE_T'), ('Group_size', 'GROUP_SIZE'), ('Row_block', 'ROW_BLOCK'), ('Col_block', 'COL_BLOCK'), ('Calc_cond_num', 'CALC_COND_NUM')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('MP2_INFO', 'MP2_INFO'), ('DIRECT_CANONICAL', 'DIRECT_CANONICAL'), ('WFC_GPW', 'WFC_GPW'), ('RI_MP2', 'RI_MP2'), ('RI_RPA', 'RI_RPA'), ('RI_LAPLACE', 'RI_LAPLACE'), ('INTERACTION_POTENTIAL', 'INTERACTION_POTENTIAL')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Number_proc(self):
        """
        See documentation for Group_size
        """
        return self.Group_size

    @property
    def Row_block_size(self):
        """
        See documentation for Row_block
        """
        return self.Row_block

    @property
    def Col_block_size(self):
        """
        See documentation for Col_block
        """
        return self.Col_block

    @property
    def Calc_condition_number(self):
        """
        See documentation for Calc_cond_num
        """
        return self.Calc_cond_num

    @Number_proc.setter
    def Number_proc(self, value):
        self.Group_size = value

    @Row_block_size.setter
    def Row_block_size(self, value):
        self.Row_block = value

    @Col_block_size.setter
    def Col_block_size(self, value):
        self.Col_block = value

    @Calc_condition_number.setter
    def Calc_condition_number(self, value):
        self.Calc_cond_num = value



class _wf_correlation1(printable):
    """
    Sets up the Wavefunction-based Correlation parameters if requested
    """
    def __init__(self):
        self.Method = None
        """
        Which method should be used to compute the MP2 energy

        Available values:
            NONE
                Skip MP2 calculation
            DIRECT_CANONICAL
                Use the direct mp2 canonical approach
            MP2_GPW
                Use the GPW approach to MP2
            RI_MP2_GPW
                Use the GPW approach to RI-MP2
            RI_RPA_GPW
                Use the GPW approach to RI-RPA
            RI_SOS_LAPLACE
                Use the GPW approach to RI-SOS-Laplace-MP2
        """
        self.Memory = None
        """
        Maximum allowed total memory usage during MP2 methods [Mb].
        """
        self.Scale_s = None
        """
        Scaling factor of the singlet energy component (opposite spin, OS).
        """
        self.Scale_t = None
        """
        Scaling factor of the triplet energy component (same spin, SS).
        """
        self.Group_size = None
        """
        Group size used in the computation of the integrals. Default is to use
        all processors (GROUP_SIZE=-1).A smaller group size (for example the
        node size), might a better choice if the actual MP2 time is large
        compared to integral computation time. This is usually the case if the
        total number of processors is not too large.
        """
        self.Row_block = None
        """
        Size of the row block used in the SCALAPACK block cyclic data
        distribution.Default is (ROW_BLOCK=-1) is automatic. A proper choice
        can speedup the parallel matrix multiplication in the case of RI-RPA
        and RI-SOS-MP2-Laplace.
        """
        self.Col_block = None
        """
        Size of the column block used in the SCALAPACK block cyclic data
        distribution.Default is (COL_BLOCK=-1) is automatic. A proper choice
        can speedup the parallel matrix multiplication in the case of RI-RPA
        and RI-SOS-MP2-Laplace.
        """
        self.Calc_cond_num = None
        """
        Calculate the condition number of the (P|Q) matrix for the RI methods.
        """
        self.MP2_INFO = _mp2_info1()
        self.DIRECT_CANONICAL = _direct_canonical1()
        self.WFC_GPW = _wfc_gpw1()
        self.RI_MP2 = _ri_mp21()
        self.RI_RPA = _ri_rpa1()
        self.RI_LAPLACE = _ri_laplace1()
        self.INTERACTION_POTENTIAL = _interaction_potential3()
        self._name = "WF_CORRELATION"
        self._keywords = [('Method', 'METHOD'), ('Memory', 'MEMORY'), ('Scale_s', 'SCALE_S'), ('Scale_t', 'SCALE_T'), ('Group_size', 'GROUP_SIZE'), ('Row_block', 'ROW_BLOCK'), ('Col_block', 'COL_BLOCK'), ('Calc_cond_num', 'CALC_COND_NUM')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('MP2_INFO', 'MP2_INFO'), ('DIRECT_CANONICAL', 'DIRECT_CANONICAL'), ('WFC_GPW', 'WFC_GPW'), ('RI_MP2', 'RI_MP2'), ('RI_RPA', 'RI_RPA'), ('RI_LAPLACE', 'RI_LAPLACE'), ('INTERACTION_POTENTIAL', 'INTERACTION_POTENTIAL')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Number_proc(self):
        """
        See documentation for Group_size
        """
        return self.Group_size

    @property
    def Row_block_size(self):
        """
        See documentation for Row_block
        """
        return self.Row_block

    @property
    def Col_block_size(self):
        """
        See documentation for Col_block
        """
        return self.Col_block

    @property
    def Calc_condition_number(self):
        """
        See documentation for Calc_cond_num
        """
        return self.Calc_cond_num

    @Number_proc.setter
    def Number_proc(self, value):
        self.Group_size = value

    @Row_block_size.setter
    def Row_block_size(self, value):
        self.Row_block = value

    @Col_block_size.setter
    def Col_block_size(self, value):
        self.Col_block = value

    @Calc_condition_number.setter
    def Calc_condition_number(self, value):
        self.Calc_cond_num = value



class _each186(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _localization1(printable):
    """
    Collects all printing options related to the Wannier centers and
    properties computed with Wannier centers.
    """
    def __init__(self):
        self.WANNIER_CUBES = _wannier_cubes4()
        self.WANNIER_CENTERS = _wannier_centers4()
        self.WANNIER_SPREADS = _wannier_spreads4()
        self.LOC_RESTART = _loc_restart4()
        self.TOTAL_DIPOLE = _total_dipole3()
        self.MOLECULAR_DIPOLES = _molecular_dipoles3()
        self.MOLECULAR_STATES = _molecular_states3()
        self.WANNIER_STATES = _wannier_states3()
        self._name = "LOCALIZATION"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('WANNIER_CUBES', 'WANNIER_CUBES'), ('WANNIER_CENTERS', 'WANNIER_CENTERS'), ('WANNIER_SPREADS', 'WANNIER_SPREADS'), ('LOC_RESTART', 'LOC_RESTART'), ('TOTAL_DIPOLE', 'TOTAL_DIPOLE'), ('MOLECULAR_DIPOLES', 'MOLECULAR_DIPOLES'), ('MOLECULAR_STATES', 'MOLECULAR_STATES'), ('WANNIER_STATES', 'WANNIER_STATES')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _basis_set1(printable):
    """
    Controls the printing of the basis sets
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each356()
        self._name = "BASIS_SET"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _mulliken1(printable):
    """
    Controls the printing of the Mulliken (spin) population analysis
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Print_gop = None
        """
        Print the gross orbital populations (GOP) in addition to the gross
        atomic populations (GAP) and net charges
        """
        self.Print_all = None
        """
        Print all information including the full net AO and overlap population
        matrix
        """
        self.EACH = _each209()
        self._name = "MULLIKEN"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Print_gop', 'PRINT_GOP'), ('Print_all', 'PRINT_ALL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _angles1(printable):
    """
    Defines new angles
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Three integer indexes per line defining the new angle Indexes must be
        relative to the full system and not to the single molecules
        """
        self._name = "ANGLES"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _spawned_hills_height1(printable):
    """
    The height of the spawned hills during metadynamics.Used for RESTART.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify the spawned hills
        """
        self._name = "SPAWNED_HILLS_HEIGHT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _ga1(printable):
    """
    Sets up memory parameters for the storage of the integrals
    """
    def __init__(self):
        self.Ncells = None
        """
        Defines the number of linked cells for the neighbor list. Default
        value is number of processors
        """
        self._name = "GA"
        self._keywords = [('Ncells', 'NCELLS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _ext_restart1(printable):
    """
    Section for external restart, specifies an external input file where
    to take positions,...
    """
    def __init__(self):
        self.Restart_file_name = None
        """
        Specifies the name of restart file (or any other input file) to be
        read. Only fields relevant to a restart will be used (unless switched
        off with the keywords in this section)
        """
        self.Binary_restart_file_name = None
        """
        Specifies the name of an additional restart file from which selected
        input sections are read in binary format (see SPLIT_RESTART_FILE).
        """
        self.Restart_default = None
        """
        This keyword controls the default value for all possible  restartable
        keywords, unless explicitly defined. For example setting this keyword
        to .FALSE. does not restart any quantity. If, at the  same time, one
        keyword is set to .TRUE. only that quantity will be restarted.
        """
        self.Restart_counters = None
        """
        Restarts the counters in MD schemes
        """
        self.Restart_pos = None
        """
        Takes the positions from the external file
        """
        self.Restart_vel = None
        """
        Takes the velocities from the external file
        """
        self.Restart_randomg = None
        """
        Restarts the random number generator from the external file
        """
        self.Restart_shell_pos = None
        """
        Takes the positions of the shells from the external file (only if
        shell-model)
        """
        self.Restart_core_pos = None
        """
        Takes the positions of the cores from the external file (only if
        shell-model)
        """
        self.Restart_optimize_input_variables = None
        """
        Restart with the optimize input variables
        """
        self.Restart_shell_velocity = None
        """
        Takes the velocities of the shells from the external file (only if
        shell-model)
        """
        self.Restart_core_velocity = None
        """
        Takes the velocities of the shells from the external file (only if
        shell-model)
        """
        self.Restart_barostat = None
        """
        Restarts the barostat from the external file
        """
        self.Restart_barostat_thermostat = None
        """
        Restarts the barostat thermostat from the external file
        """
        self.Restart_shell_thermostat = None
        """
        Restarts the shell thermostat from the external file
        """
        self.Restart_thermostat = None
        """
        Restarts the nose thermostats of the particles from the EXTERNAL file
        """
        self.Restart_cell = None
        """
        Restarts the cell (and cell_ref) from the EXTERNAL file
        """
        self.Restart_metadynamics = None
        """
        Restarts hills from a previous metadynamics run from the EXTERNAL file
        """
        self.Restart_walkers = None
        """
        Restarts walkers informations from a previous metadynamics run from
        the EXTERNAL file
        """
        self.Restart_band = None
        """
        Restarts positions and velocities of the Band.
        """
        self.Restart_qmmm = None
        """
        Restarts the following specific QMMM info: translation vectors.
        """
        self.Restart_constraint = None
        """
        Restarts constraint section. It's necessary when doing restraint
        calculation to have a perfect energy conservation. For constraints
        only it's use is optional.
        """
        self.Restart_bsse = None
        """
        Restarts information for BSSE calculations.
        """
        self.Restart_dimer = None
        """
        Restarts information for DIMER geometry optimizations.
        """
        self.Restart_averages = None
        """
        Restarts information for AVERAGES.
        """
        self.Restart_rtp = None
        """
        Restarts information for REAL TIME PROPAGATION and EHRENFEST DYNAMICS.
        """
        self.list_Custom_path = []
        self.Restart_pint_pos = None
        """
        Restart bead positions from PINT%BEADS%COORD.
        """
        self.Restart_pint_vel = None
        """
        Restart bead velocities from PINT%BEADS%VELOCITY.
        """
        self.Restart_pint_nose = None
        """
        Restart Nose thermostat for beads from PINT%NOSE.
        """
        self.Restart_pint_gle = None
        """
        Restart GLE thermostat for beads from PINT%GLE.
        """
        self.Restart_helium_pos = None
        """
        Restart helium positions from PINT%HELIUM%COORD.
        """
        self.Restart_helium_permutation = None
        """
        Restart helium permutation state from PINT%HELIUM%PERM.
        """
        self.Restart_helium_force = None
        """
        Restart helium forces exerted on the solute from PINT%HELIUM%FORCE.
        """
        self.Restart_helium_rng = None
        """
        Restarts helium random number generators from PINT%HELIUM%RNG_STATE.
        """
        self.Restart_helium_densities = None
        """
        Restarts helium density distributions from PINT%HELIUM%RHO.
        """
        self._name = "EXT_RESTART"
        self._keywords = [('Restart_file_name', 'RESTART_FILE_NAME'), ('Binary_restart_file_name', 'BINARY_RESTART_FILE_NAME'), ('Restart_default', 'RESTART_DEFAULT'), ('Restart_counters', 'RESTART_COUNTERS'), ('Restart_pos', 'RESTART_POS'), ('Restart_vel', 'RESTART_VEL'), ('Restart_randomg', 'RESTART_RANDOMG'), ('Restart_shell_pos', 'RESTART_SHELL_POS'), ('Restart_core_pos', 'RESTART_CORE_POS'), ('Restart_optimize_input_variables', 'RESTART_OPTIMIZE_INPUT_VARIABLES'), ('Restart_shell_velocity', 'RESTART_SHELL_VELOCITY'), ('Restart_core_velocity', 'RESTART_CORE_VELOCITY'), ('Restart_barostat', 'RESTART_BAROSTAT'), ('Restart_barostat_thermostat', 'RESTART_BAROSTAT_THERMOSTAT'), ('Restart_shell_thermostat', 'RESTART_SHELL_THERMOSTAT'), ('Restart_thermostat', 'RESTART_THERMOSTAT'), ('Restart_cell', 'RESTART_CELL'), ('Restart_metadynamics', 'RESTART_METADYNAMICS'), ('Restart_walkers', 'RESTART_WALKERS'), ('Restart_band', 'RESTART_BAND'), ('Restart_qmmm', 'RESTART_QMMM'), ('Restart_constraint', 'RESTART_CONSTRAINT'), ('Restart_bsse', 'RESTART_BSSE'), ('Restart_dimer', 'RESTART_DIMER'), ('Restart_averages', 'RESTART_AVERAGES'), ('Restart_rtp', 'RESTART_RTP'), ('Restart_pint_pos', 'RESTART_PINT_POS'), ('Restart_pint_vel', 'RESTART_PINT_VEL'), ('Restart_pint_nose', 'RESTART_PINT_NOSE'), ('Restart_pint_gle', 'RESTART_PINT_GLE'), ('Restart_helium_pos', 'RESTART_HELIUM_POS'), ('Restart_helium_permutation', 'RESTART_HELIUM_PERMUTATION'), ('Restart_helium_force', 'RESTART_HELIUM_FORCE'), ('Restart_helium_rng', 'RESTART_HELIUM_RNG'), ('Restart_helium_densities', 'RESTART_HELIUM_DENSITIES')]
        self._repeated_keywords = [('Custom_path', 'CUSTOM_PATH')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Custom_path(self, value):
        self.list_Custom_path.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def External_file(self):
        """
        See documentation for Restart_file_name
        """
        return self.Restart_file_name

    @property
    def Binary_restart_file(self):
        """
        See documentation for Binary_restart_file_name
        """
        return self.Binary_restart_file_name

    @External_file.setter
    def External_file(self, value):
        self.Restart_file_name = value

    @Binary_restart_file.setter
    def Binary_restart_file(self, value):
        self.Binary_restart_file_name = value



class _genpot4(printable):
    """
    This section specifies the input parameters for a generic potential
    type.A functional form is specified. Mathematical Operators recognized
    are +, -, *, /, ** or alternatively ^, whereas symbols for brackets
    must be (). The function parser recognizes the (single argument)
    Fortran 90 intrinsic functions abs, exp, log10, log, sqrt, sinh, cosh,
    tanh, sin, cos, tan, asin, acos, atan. Parsing for INTRINSIC functions
    is CASE INsensitive.
    """
    def __init__(self):
        self.Atoms = None
        """
        Defines the atomic kind involved in the generic potential
        """
        self.Function = None
        """
        Specifies the functional form in mathematical notation.
        """
        self.Variables = None
        """
        Defines the variable of the functional form.
        """
        self.list_Parameters = []
        self.list_Values = []
        self.list_Units = []
        self.Rcut = None
        """
        Defines the cutoff parameter of the generic potential
        """
        self.Rmin = None
        """
        Defines the lower bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self.Rmax = None
        """
        Defines the upper bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self._name = "GENPOT"
        self._keywords = [('Atoms', 'ATOMS'), ('Function', 'FUNCTION'), ('Variables', 'VARIABLES'), ('Rcut', 'RCUT'), ('Rmin', 'RMIN'), ('Rmax', 'RMAX')]
        self._repeated_keywords = [('Parameters', 'PARAMETERS'), ('Values', 'VALUES'), ('Units', 'UNITS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Parameters(self, value):
        self.list_Parameters.append(value)

    def add_Values(self, value):
        self.list_Values.append(value)

    def add_Units(self, value):
        self.list_Units.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _powell1(printable):
    """
    Section defines basic parameters for Powell optimization
    """
    def __init__(self):
        self.Accuracy = None
        """
        Final accuracy requested in optimization (RHOEND)
        """
        self.Step_size = None
        """
        Initial step size for search algorithm (RHOBEG)
        """
        self.Max_fun = None
        """
        Maximum number of function evaluations
        """
        self.Weight_pot_virtual = None
        """
        Weight for virtual states in pseudopotential optimization
        """
        self.Weight_pot_semicore = None
        """
        Weight for semi core states in pseudopotential optimization
        """
        self.Weight_pot_valence = None
        """
        Weight for valence states in pseudopotential optimization
        """
        self.Weight_pot_node = None
        """
        Weight for node mismatch in pseudopotential optimization
        """
        self.Weight_electron_configuration = None
        """
        Weight for different electronic states in optimization
        """
        self.Weight_method = None
        """
        Weight for different methods in optimization
        """
        self.Target_pot_virtual = None
        """
        Target accuracy for virtual state eigenvalues in pseudopotential
        optimization
        """
        self.Target_pot_valence = None
        """
        Target accuracy for valence state eigenvalues in pseudopotential
        optimization
        """
        self.Target_pot_semicore = None
        """
        Target accuracy for semicore state eigenvalues in pseudopotential
        optimization
        """
        self.Weight_psir0 = None
        """
        Weight for the wavefunctions at r=0 (only occupied states)
        """
        self.Rcov_multiplication = None
        """
        Multiply Rcov integration limit for charge conservation
        """
        self._name = "POWELL"
        self._keywords = [('Accuracy', 'ACCURACY'), ('Step_size', 'STEP_SIZE'), ('Max_fun', 'MAX_FUN'), ('Weight_pot_virtual', 'WEIGHT_POT_VIRTUAL'), ('Weight_pot_semicore', 'WEIGHT_POT_SEMICORE'), ('Weight_pot_valence', 'WEIGHT_POT_VALENCE'), ('Weight_pot_node', 'WEIGHT_POT_NODE'), ('Weight_electron_configuration', 'WEIGHT_ELECTRON_CONFIGURATION'), ('Weight_method', 'WEIGHT_METHOD'), ('Target_pot_virtual', 'TARGET_POT_VIRTUAL'), ('Target_pot_valence', 'TARGET_POT_VALENCE'), ('Target_pot_semicore', 'TARGET_POT_SEMICORE'), ('Weight_psir0', 'WEIGHT_PSIR0'), ('Rcov_multiplication', 'RCOV_MULTIPLICATION')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _powell2(printable):
    """
    Section defines basic parameters for Powell optimization
    """
    def __init__(self):
        self.Accuracy = None
        """
        Final accuracy requested in optimization (RHOEND)
        """
        self.Step_size = None
        """
        Initial step size for search algorithm (RHOBEG)
        """
        self.Max_fun = None
        """
        Maximum number of function evaluations
        """
        self.Weight_pot_virtual = None
        """
        Weight for virtual states in pseudopotential optimization
        """
        self.Weight_pot_semicore = None
        """
        Weight for semi core states in pseudopotential optimization
        """
        self.Weight_pot_valence = None
        """
        Weight for valence states in pseudopotential optimization
        """
        self.Weight_pot_node = None
        """
        Weight for node mismatch in pseudopotential optimization
        """
        self.Weight_electron_configuration = None
        """
        Weight for different electronic states in optimization
        """
        self.Weight_method = None
        """
        Weight for different methods in optimization
        """
        self.Target_pot_virtual = None
        """
        Target accuracy for virtual state eigenvalues in pseudopotential
        optimization
        """
        self.Target_pot_valence = None
        """
        Target accuracy for valence state eigenvalues in pseudopotential
        optimization
        """
        self.Target_pot_semicore = None
        """
        Target accuracy for semicore state eigenvalues in pseudopotential
        optimization
        """
        self.Weight_psir0 = None
        """
        Weight for the wavefunctions at r=0 (only occupied states)
        """
        self.Rcov_multiplication = None
        """
        Multiply Rcov integration limit for charge conservation
        """
        self._name = "POWELL"
        self._keywords = [('Accuracy', 'ACCURACY'), ('Step_size', 'STEP_SIZE'), ('Max_fun', 'MAX_FUN'), ('Weight_pot_virtual', 'WEIGHT_POT_VIRTUAL'), ('Weight_pot_semicore', 'WEIGHT_POT_SEMICORE'), ('Weight_pot_valence', 'WEIGHT_POT_VALENCE'), ('Weight_pot_node', 'WEIGHT_POT_NODE'), ('Weight_electron_configuration', 'WEIGHT_ELECTRON_CONFIGURATION'), ('Weight_method', 'WEIGHT_METHOD'), ('Target_pot_virtual', 'TARGET_POT_VIRTUAL'), ('Target_pot_valence', 'TARGET_POT_VALENCE'), ('Target_pot_semicore', 'TARGET_POT_SEMICORE'), ('Weight_psir0', 'WEIGHT_PSIR0'), ('Rcov_multiplication', 'RCOV_MULTIPLICATION')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _genpot1(printable):
    """
    This section specifies the input parameters for a generic potential
    type.A functional form is specified. Mathematical Operators recognized
    are +, -, *, /, ** or alternatively ^, whereas symbols for brackets
    must be (). The function parser recognizes the (single argument)
    Fortran 90 intrinsic functions abs, exp, log10, log, sqrt, sinh, cosh,
    tanh, sin, cos, tan, asin, acos, atan. Parsing for INTRINSIC functions
    is CASE INsensitive.
    """
    def __init__(self):
        self.Atoms = None
        """
        Defines the atomic kind involved in the generic potential
        """
        self.Function = None
        """
        Specifies the functional form in mathematical notation.
        """
        self.Variables = None
        """
        Defines the variable of the functional form.
        """
        self.list_Parameters = []
        self.list_Values = []
        self.list_Units = []
        self.Rcut = None
        """
        Defines the cutoff parameter of the generic potential
        """
        self.Rmin = None
        """
        Defines the lower bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self.Rmax = None
        """
        Defines the upper bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self._name = "GENPOT"
        self._keywords = [('Atoms', 'ATOMS'), ('Function', 'FUNCTION'), ('Variables', 'VARIABLES'), ('Rcut', 'RCUT'), ('Rmin', 'RMIN'), ('Rmax', 'RMAX')]
        self._repeated_keywords = [('Parameters', 'PARAMETERS'), ('Values', 'VALUES'), ('Units', 'UNITS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Parameters(self, value):
        self.list_Parameters.append(value)

    def add_Values(self, value):
        self.list_Values.append(value)

    def add_Units(self, value):
        self.list_Units.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _genpot2(printable):
    """
    This section specifies the input parameters for a generic potential
    type.A functional form is specified. Mathematical Operators recognized
    are +, -, *, /, ** or alternatively ^, whereas symbols for brackets
    must be (). The function parser recognizes the (single argument)
    Fortran 90 intrinsic functions abs, exp, log10, log, sqrt, sinh, cosh,
    tanh, sin, cos, tan, asin, acos, atan. Parsing for INTRINSIC functions
    is CASE INsensitive.
    """
    def __init__(self):
        self.Atoms = None
        """
        Defines the atomic kind involved in the generic potential
        """
        self.Function = None
        """
        Specifies the functional form in mathematical notation.
        """
        self.Variables = None
        """
        Defines the variable of the functional form.
        """
        self.list_Parameters = []
        self.list_Values = []
        self.list_Units = []
        self.Rcut = None
        """
        Defines the cutoff parameter of the generic potential
        """
        self.Rmin = None
        """
        Defines the lower bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self.Rmax = None
        """
        Defines the upper bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self._name = "GENPOT"
        self._keywords = [('Atoms', 'ATOMS'), ('Function', 'FUNCTION'), ('Variables', 'VARIABLES'), ('Rcut', 'RCUT'), ('Rmin', 'RMIN'), ('Rmax', 'RMAX')]
        self._repeated_keywords = [('Parameters', 'PARAMETERS'), ('Values', 'VALUES'), ('Units', 'UNITS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Parameters(self, value):
        self.list_Parameters.append(value)

    def add_Values(self, value):
        self.list_Values.append(value)

    def add_Units(self, value):
        self.list_Units.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _genpot3(printable):
    """
    This section specifies the input parameters for a generic potential
    type.A functional form is specified. Mathematical Operators recognized
    are +, -, *, /, ** or alternatively ^, whereas symbols for brackets
    must be (). The function parser recognizes the (single argument)
    Fortran 90 intrinsic functions abs, exp, log10, log, sqrt, sinh, cosh,
    tanh, sin, cos, tan, asin, acos, atan. Parsing for INTRINSIC functions
    is CASE INsensitive.
    """
    def __init__(self):
        self.Atoms = None
        """
        Defines the atomic kind involved in the generic potential
        """
        self.Function = None
        """
        Specifies the functional form in mathematical notation.
        """
        self.Variables = None
        """
        Defines the variable of the functional form.
        """
        self.list_Parameters = []
        self.list_Values = []
        self.list_Units = []
        self.Rcut = None
        """
        Defines the cutoff parameter of the generic potential
        """
        self.Rmin = None
        """
        Defines the lower bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self.Rmax = None
        """
        Defines the upper bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self._name = "GENPOT"
        self._keywords = [('Atoms', 'ATOMS'), ('Function', 'FUNCTION'), ('Variables', 'VARIABLES'), ('Rcut', 'RCUT'), ('Rmin', 'RMIN'), ('Rmax', 'RMAX')]
        self._repeated_keywords = [('Parameters', 'PARAMETERS'), ('Values', 'VALUES'), ('Units', 'UNITS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Parameters(self, value):
        self.list_Parameters.append(value)

    def add_Values(self, value):
        self.list_Values.append(value)

    def add_Units(self, value):
        self.list_Units.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _lennard_jones4(printable):
    """
    This section specifies the input parameters for LENNARD-JONES
    potential type.Functional form: V(r) = 4.0 * EPSILON *
    [(SIGMA/r)^12-(SIGMA/r)^6].
    """
    def __init__(self):
        self.Atoms = None
        """
        Defines the atomic kind involved in the nonbond potential
        """
        self.Epsilon = None
        """
        Defines the EPSILON parameter of the LJ potential
        """
        self.Sigma = None
        """
        Defines the SIGMA parameter of the LJ potential
        """
        self.Rcut = None
        """
        Defines the cutoff parameter of the LJ potential
        """
        self.Rmin = None
        """
        Defines the lower bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self.Rmax = None
        """
        Defines the upper bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self._name = "LENNARD-JONES"
        self._keywords = [('Atoms', 'ATOMS'), ('Epsilon', 'EPSILON'), ('Sigma', 'SIGMA'), ('Rcut', 'RCUT'), ('Rmin', 'RMIN'), ('Rmax', 'RMAX')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _lennard_jones1(printable):
    """
    This section specifies the input parameters for LENNARD-JONES
    potential type.Functional form: V(r) = 4.0 * EPSILON *
    [(SIGMA/r)^12-(SIGMA/r)^6].
    """
    def __init__(self):
        self.Atoms = None
        """
        Defines the atomic kind involved in the nonbond potential
        """
        self.Epsilon = None
        """
        Defines the EPSILON parameter of the LJ potential
        """
        self.Sigma = None
        """
        Defines the SIGMA parameter of the LJ potential
        """
        self.Rcut = None
        """
        Defines the cutoff parameter of the LJ potential
        """
        self.Rmin = None
        """
        Defines the lower bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self.Rmax = None
        """
        Defines the upper bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self._name = "LENNARD-JONES"
        self._keywords = [('Atoms', 'ATOMS'), ('Epsilon', 'EPSILON'), ('Sigma', 'SIGMA'), ('Rcut', 'RCUT'), ('Rmin', 'RMIN'), ('Rmax', 'RMAX')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _lennard_jones2(printable):
    """
    This section specifies the input parameters for LENNARD-JONES
    potential type.Functional form: V(r) = 4.0 * EPSILON *
    [(SIGMA/r)^12-(SIGMA/r)^6].
    """
    def __init__(self):
        self.Atoms = None
        """
        Defines the atomic kind involved in the nonbond potential
        """
        self.Epsilon = None
        """
        Defines the EPSILON parameter of the LJ potential
        """
        self.Sigma = None
        """
        Defines the SIGMA parameter of the LJ potential
        """
        self.Rcut = None
        """
        Defines the cutoff parameter of the LJ potential
        """
        self.Rmin = None
        """
        Defines the lower bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self.Rmax = None
        """
        Defines the upper bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self._name = "LENNARD-JONES"
        self._keywords = [('Atoms', 'ATOMS'), ('Epsilon', 'EPSILON'), ('Sigma', 'SIGMA'), ('Rcut', 'RCUT'), ('Rmin', 'RMIN'), ('Rmax', 'RMAX')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _lennard_jones3(printable):
    """
    This section specifies the input parameters for LENNARD-JONES
    potential type.Functional form: V(r) = 4.0 * EPSILON *
    [(SIGMA/r)^12-(SIGMA/r)^6].
    """
    def __init__(self):
        self.Atoms = None
        """
        Defines the atomic kind involved in the nonbond potential
        """
        self.Epsilon = None
        """
        Defines the EPSILON parameter of the LJ potential
        """
        self.Sigma = None
        """
        Defines the SIGMA parameter of the LJ potential
        """
        self.Rcut = None
        """
        Defines the cutoff parameter of the LJ potential
        """
        self.Rmin = None
        """
        Defines the lower bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self.Rmax = None
        """
        Defines the upper bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self._name = "LENNARD-JONES"
        self._keywords = [('Atoms', 'ATOMS'), ('Epsilon', 'EPSILON'), ('Sigma', 'SIGMA'), ('Rcut', 'RCUT'), ('Rmin', 'RMIN'), ('Rmax', 'RMAX')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _coefficients1(printable):
    """
    Controls the printing of coefficients during an MD run.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each38()
        self._name = "COEFFICIENTS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _kg_method1(printable):
    """
    Specifies the parameters for a Kim-Gordon-like partitioning into
    molecular subunits
    """
    def __init__(self):
        self.Coloring_method = None
        """
        Which algorithm to use for coloring.

        Available values:
            DSATUR
                Maximum degree of saturation, relatively accurate
            GREEDY
                Greedy, fast coloring, less accurate
        """
        self.PRINT = _print19()
        self._name = "KG_METHOD"
        self._keywords = [('Coloring_method', 'COLORING_METHOD')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _rng_init3(printable):
    """
    Information to initialize the parallel random number generator streams
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify an initial RNG stream
        """
        self._name = "RNG_INIT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _rng_init2(printable):
    """
    Information to initialize the parallel random number generator streams
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify an initial RNG stream
        """
        self._name = "RNG_INIT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _rng_init1(printable):
    """
    Information to initialize the parallel random number generator streams
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify an initial RNG stream
        """
        self._name = "RNG_INIT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _rng_init7(printable):
    """
    Information to initialize the parallel random number generator streams
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify an initial RNG stream
        """
        self._name = "RNG_INIT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _rng_init6(printable):
    """
    Information to initialize the parallel random number generator streams
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify an initial RNG stream
        """
        self._name = "RNG_INIT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _rng_init5(printable):
    """
    Information to initialize the parallel random number generator streams
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify an initial RNG stream
        """
        self._name = "RNG_INIT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _rng_init4(printable):
    """
    Information to initialize the parallel random number generator streams
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify an initial RNG stream
        """
        self._name = "RNG_INIT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _image_charge1(printable):
    """
    Inclusion of polarization effects within the image charge approach for
    systems where QM molecules are physisorbed on e.g. metal surfaces
    described by MM. QM box size has to be equal to MM box size.
    """
    def __init__(self):
        self.list_Mm_atom_list = []
        self.Width = None
        """
        Specifies the value of the width of the (induced) Gaussian charge
        distribution carried by each MM atom.
        """
        self.Ext_potential = None
        """
        External potential applied to the metal electrode
        """
        self.Determ_coeff = None
        """
        Specifies how the coefficients are determined.

        Available values:
            CALC_MATRIX
                Calculates image matrix and solves linear set of equations
            ITERATIVE
                Uses an iterative scheme to calculate the coefficients
        """
        self.Restart_image_matrix = None
        """
        Restart the image matrix. Useful when calculating coefficients
        iteratively (the image matrix is used as preconditioner in that case)
        """
        self.Image_restart_file_name = None
        """
        File name where to read the image matrix used as preconditioner in the
        iterative scheme
        """
        self._name = "IMAGE_CHARGE"
        self._keywords = [('Width', 'WIDTH'), ('Ext_potential', 'EXT_POTENTIAL'), ('Determ_coeff', 'DETERM_COEFF'), ('Restart_image_matrix', 'RESTART_IMAGE_MATRIX'), ('Image_restart_file_name', 'IMAGE_RESTART_FILE_NAME')]
        self._repeated_keywords = [('Mm_atom_list', 'MM_ATOM_LIST')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Mm_atom_list(self, value):
        self.list_Mm_atom_list.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _rng_init8(printable):
    """
    Information to initialize the parallel random number generator streams
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify an initial RNG stream
        """
        self._name = "RNG_INIT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _each355(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _check_spline4(printable):
    """
    Controls the checking of the G-space term Spline Interpolation.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each238()
        self._name = "CHECK_SPLINE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _check_spline3(printable):
    """
    Controls the checking of the G-space term Spline Interpolation.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each235()
        self._name = "CHECK_SPLINE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _check_spline2(printable):
    """
    Controls the checking of the G-space term Spline Interpolation.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each219()
        self._name = "CHECK_SPLINE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _check_spline1(printable):
    """
    Controls the checking of the G-space term Spline Interpolation.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each139()
        self._name = "CHECK_SPLINE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _torsion6(printable):
    """
    Section to define the torsion as a collective variables.
    """
    def __init__(self):
        self.Atoms = None
        """
        Specifies the indexes of atoms/points defining the torsion.
        """
        self.list_POINT = []
        self._name = "TORSION"
        self._keywords = [('Atoms', 'ATOMS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point57')]

    def add_POINT(self):
        new_section = _point57()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Points(self):
        """
        See documentation for Atoms
        """
        return self.Atoms

    @Points.setter
    def Points(self, value):
        self.Atoms = value



class _torsion4(printable):
    """
    Section to define the torsion as a collective variables.
    """
    def __init__(self):
        self.Atoms = None
        """
        Specifies the indexes of atoms/points defining the torsion.
        """
        self.list_POINT = []
        self._name = "TORSION"
        self._keywords = [('Atoms', 'ATOMS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point21')]

    def add_POINT(self):
        new_section = _point21()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Points(self):
        """
        See documentation for Atoms
        """
        return self.Atoms

    @Points.setter
    def Points(self, value):
        self.Atoms = value



class _torsion5(printable):
    """
    Section to define the torsion as a collective variables.
    """
    def __init__(self):
        self.Atoms = None
        """
        Specifies the indexes of atoms/points defining the torsion.
        """
        self.list_POINT = []
        self._name = "TORSION"
        self._keywords = [('Atoms', 'ATOMS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point39')]

    def add_POINT(self):
        new_section = _point39()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Points(self):
        """
        See documentation for Atoms
        """
        return self.Atoms

    @Points.setter
    def Points(self, value):
        self.Atoms = value



class _torsion2(printable):
    """
    Section used to add/remove torsion in the connectivity. Useful for
    systems with a complex connectivity, difficult to find out
    automatically.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        controls the activation of the bond

        Available values:
            ADD
            REMOVE
        """
        self.list_Atoms = []
        self._name = "TORSION"
        self._keywords = []
        self._repeated_keywords = [('Atoms', 'ATOMS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _torsion3(printable):
    """
    Section to define the torsion as a collective variables.
    """
    def __init__(self):
        self.Atoms = None
        """
        Specifies the indexes of atoms/points defining the torsion.
        """
        self.list_POINT = []
        self._name = "TORSION"
        self._keywords = [('Atoms', 'ATOMS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point3')]

    def add_POINT(self):
        new_section = _point3()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Points(self):
        """
        See documentation for Atoms
        """
        return self.Atoms

    @Points.setter
    def Points(self, value):
        self.Atoms = value



class _each38(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _torsion1(printable):
    """
    Specifies the torsion potential of the MM system.
    """
    def __init__(self):
        self.Atoms = None
        """
        Defines the atomic kinds involved in the tors.
        """
        self.Kind = None
        """
        Define the kind of torsion potential

        Available values:
            CHARMM
                Functional Form (CHARMM|G87|G96|AMBER): K * [ 1 +  cos[M*PHI - PHI0]]
            G87
                Functional Form (CHARMM|G87|G96|AMBER): K * [ 1 +  cos[M*PHI - PHI0]]
            G96
                Functional Form (CHARMM|G87|G96|AMBER): K * [ 1 +  cos[M*PHI - PHI0]]
            AMBER
                Functional Form (CHARMM|G87|G96|AMBER): K * [ 1 +  cos[M*PHI - PHI0]]
        """
        self.K = None
        """
        Defines the force constant of the potential
        """
        self.Phi0 = None
        """
        Defines the phase of the potential.
        """
        self.M = None
        """
        Defines the multiplicity of the potential.
        """
        self._name = "TORSION"
        self._keywords = [('Atoms', 'ATOMS'), ('Kind', 'KIND'), ('K', 'K'), ('Phi0', 'PHI0'), ('M', 'M')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each36(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each37(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each34(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each35(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each32(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each33(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each30(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each31(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print19(printable):
    """
    Print section
    """
    def __init__(self):
        self.NEIGHBOR_LISTS = _neighbor_lists1()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('NEIGHBOR_LISTS', 'NEIGHBOR_LISTS')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print18(printable):
    """
    printing of information during the scf
    """
    def __init__(self):
        self.RESTART = _restart6()
        self.RESTART_HISTORY = _restart_history2()
        self.ITERATION_INFO = _iteration_info1()
        self.PROGRAM_RUN_INFO = _program_run_info12()
        self.MO_ORTHONORMALITY = _mo_orthonormality1()
        self.MO_MAGNITUDE = _mo_magnitude1()
        self.DETAILED_ENERGY = _detailed_energy1()
        self.DIIS_INFO = _diis_info2()
        self.TOTAL_DENSITIES = _total_densities1()
        self.LANCZOS = _lanczos1()
        self.DIAG_SUB_SCF = _diag_sub_scf2()
        self.DAVIDSON = _davidson2()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('RESTART', 'RESTART'), ('RESTART_HISTORY', 'RESTART_HISTORY'), ('ITERATION_INFO', 'ITERATION_INFO'), ('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('MO_ORTHONORMALITY', 'MO_ORTHONORMALITY'), ('MO_MAGNITUDE', 'MO_MAGNITUDE'), ('DETAILED_ENERGY', 'DETAILED_ENERGY'), ('DIIS_INFO', 'DIIS_INFO'), ('TOTAL_DENSITIES', 'TOTAL_DENSITIES'), ('LANCZOS', 'LANCZOS'), ('DIAG_SUB_SCF', 'DIAG_SUB_SCF'), ('DAVIDSON', 'DAVIDSON')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print13(printable):
    """
    Controls the printing properties during an metadynamics run
    """
    def __init__(self):
        self.PROGRAM_RUN_INFO = _program_run_info9()
        self.TEMPERATURE_COLVAR = _temperature_colvar1()
        self.COLVAR = _colvar1()
        self.HILLS = _hills1()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('TEMPERATURE_COLVAR', 'TEMPERATURE_COLVAR'), ('COLVAR', 'COLVAR'), ('HILLS', 'HILLS')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print12(printable):
    """
    Controls the printing properties during an MD run
    """
    def __init__(self):
        self.Force_last = None
        """
        Print the output and restart file if walltime is reached or if an
        external EXIT command is given. It still requires the keyword LAST to
        be present for the specific print key (in case the last step should
        not match with the print_key iteration number).
        """
        self.ENERGY = _energy5()
        self.SHELL_ENERGY = _shell_energy1()
        self.TEMP_KIND = _temp_kind1()
        self.TEMP_SHELL_KIND = _temp_shell_kind1()
        self.CENTER_OF_MASS = _center_of_mass1()
        self.COEFFICIENTS = _coefficients1()
        self.ROTATIONAL_INFO = _rotational_info2()
        self.PROGRAM_RUN_INFO = _program_run_info8()
        self._name = "PRINT"
        self._keywords = [('Force_last', 'FORCE_LAST')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('ENERGY', 'ENERGY'), ('SHELL_ENERGY', 'SHELL_ENERGY'), ('TEMP_KIND', 'TEMP_KIND'), ('TEMP_SHELL_KIND', 'TEMP_SHELL_KIND'), ('CENTER_OF_MASS', 'CENTER_OF_MASS'), ('COEFFICIENTS', 'COEFFICIENTS'), ('ROTATIONAL_INFO', 'ROTATIONAL_INFO'), ('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print11(printable):
    """
    Collects all print_keys for thermal_regions
    """
    def __init__(self):
        self.TEMPERATURE = _temperature4()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('TEMPERATURE', 'TEMPERATURE')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print10(printable):
    """
    The section that controls the output of a reftraj run
    """
    def __init__(self):
        self.MSD_KIND = _msd_kind1()
        self.MSD_MOLECULE = _msd_molecule1()
        self.DISPLACED_ATOM = _displaced_atom1()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('MSD_KIND', 'MSD_KIND'), ('MSD_MOLECULE', 'MSD_MOLECULE'), ('DISPLACED_ATOM', 'DISPLACED_ATOM')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print17(printable):
    """
    Section of possible print options in MIXED env.
    """
    def __init__(self):
        self.PROGRAM_RUN_INFO = _program_run_info11()
        self.DIPOLE = _dipole1()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('DIPOLE', 'DIPOLE')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print16(printable):
    """
    Controls the printing properties during an MD run
    """
    def __init__(self):
        self.TRAJECTORY = _trajectory1()
        self.SHELL_TRAJECTORY = _shell_trajectory1()
        self.CORE_TRAJECTORY = _core_trajectory1()
        self.CELL = _cell2()
        self.VELOCITIES = _velocities1()
        self.SHELL_VELOCITIES = _shell_velocities1()
        self.CORE_VELOCITIES = _core_velocities1()
        self.STRUCTURE_DATA = _structure_data1()
        self.FORCE_MIXING_LABELS = _force_mixing_labels1()
        self.FORCES = _forces2()
        self.SHELL_FORCES = _shell_forces1()
        self.CORE_FORCES = _core_forces1()
        self.MIXED_ENERGIES = _mixed_energies1()
        self.STRESS = _stress1()
        self.RESTART = _restart5()
        self.RESTART_HISTORY = _restart_history1()
        self.TRANSLATION_VECTOR = _translation_vector1()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('TRAJECTORY', 'TRAJECTORY'), ('SHELL_TRAJECTORY', 'SHELL_TRAJECTORY'), ('CORE_TRAJECTORY', 'CORE_TRAJECTORY'), ('CELL', 'CELL'), ('VELOCITIES', 'VELOCITIES'), ('SHELL_VELOCITIES', 'SHELL_VELOCITIES'), ('CORE_VELOCITIES', 'CORE_VELOCITIES'), ('STRUCTURE_DATA', 'STRUCTURE_DATA'), ('FORCE_MIXING_LABELS', 'FORCE_MIXING_LABELS'), ('FORCES', 'FORCES'), ('SHELL_FORCES', 'SHELL_FORCES'), ('CORE_FORCES', 'CORE_FORCES'), ('MIXED_ENERGIES', 'MIXED_ENERGIES'), ('STRESS', 'STRESS'), ('RESTART', 'RESTART'), ('RESTART_HISTORY', 'RESTART_HISTORY'), ('TRANSLATION_VECTOR', 'TRANSLATION_VECTOR')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print15(printable):
    """
    Controls the path integral-specific output
    """
    def __init__(self):
        self.ENERGY = _energy7()
        self.CENTROID_POS = _centroid_pos1()
        self.CENTROID_VEL = _centroid_vel1()
        self.CENTROID_GYR = _centroid_gyr1()
        self.COM = _com1()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('ENERGY', 'ENERGY'), ('CENTROID_POS', 'CENTROID_POS'), ('CENTROID_VEL', 'CENTROID_VEL'), ('CENTROID_GYR', 'CENTROID_GYR'), ('COM', 'COM')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print14(printable):
    """
    The section that controls the output of the helium code
    """
    def __init__(self):
        self.ENERGY = _energy6()
        self.SDENSITY = _sdensity1()
        self.COORDINATES = _coordinates1()
        self.RDF = _rdf2()
        self.RHO = _rho2()
        self.PLENGTH = _plength1()
        self.ACCEPTS = _accepts1()
        self.PERM = _perm2()
        self.FORCES = _forces1()
        self.FORCES_INST = _forces_inst1()
        self.WNUMBER = _wnumber1()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('ENERGY', 'ENERGY'), ('SDENSITY', 'SDENSITY'), ('COORDINATES', 'COORDINATES'), ('RDF', 'RDF'), ('RHO', 'RHO'), ('PLENGTH', 'PLENGTH'), ('ACCEPTS', 'ACCEPTS'), ('PERM', 'PERM'), ('FORCES', 'FORCES'), ('FORCES_INST', 'FORCES_INST'), ('WNUMBER', 'WNUMBER')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _siepmann1(printable):
    """
    This section specifies the input parameters for the Siepmann-Sprik
    potential type. Consist of 4 terms: T1+T2+T3+T4. The terms
    T1=A/rij^alpha and T2=-C/rij^6 have to be given via the GENPOT
    section. The terms T3+T4 are obtained from the SIEPMANN section.
    """
    def __init__(self):
        self.Atoms = None
        """
        Defines the atomic kind involved in the nonbond potential
        """
        self.B = None
        """
        Defines the B parameter of Siepmann potential
        """
        self.D = None
        """
        Defines the D parameter of Siepmann potential
        """
        self.E = None
        """
        Defines the E parameter of Siepmann potential
        """
        self.F = None
        """
        Defines the F parameter of Siepmann potential
        """
        self.Beta = None
        """
        Defines the beta parameter of Siepmann potential
        """
        self.Rcut = None
        """
        Defines the cutoff parameter of Siepmann potential
        """
        self._name = "SIEPMANN"
        self._keywords = [('Atoms', 'ATOMS'), ('B', 'B'), ('D', 'D'), ('E', 'E'), ('F', 'F'), ('Beta', 'BETA'), ('Rcut', 'RCUT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _s1(printable):
    """
    The s variable for GLE used for restart
    """
    def __init__(self):
        self.Default_keyword = None
        """
        Specify s variable for GLE thermostat
        """
        self._name = "S"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _s3(printable):
    """
    The s variable for GLE used for restart
    """
    def __init__(self):
        self.Default_keyword = None
        """
        Specify s variable for GLE thermostat
        """
        self._name = "S"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _s2(printable):
    """
    The s variable for GLE used for restart
    """
    def __init__(self):
        self.Default_keyword = None
        """
        Specify s variable for GLE thermostat
        """
        self._name = "S"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _response_function_cubes3(printable):
    """
    Controls the printing of the response functions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Stride = None
        """
        The stride (X,Y,Z) used to write the cube file (larger values result
        in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1
        number valid for all components.
        """
        self.Cubes_lu_bounds = None
        """
        The lower and upper index of the states to be printed as cube
        """
        self.list_Cubes_list = []
        self.Append = None
        """
        append the cube files when they already exist
        """
        self.EACH = _each320()
        self._name = "RESPONSE_FUNCTION_CUBES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Stride', 'STRIDE'), ('Cubes_lu_bounds', 'CUBES_LU_BOUNDS'), ('Append', 'APPEND')]
        self._repeated_keywords = [('Cubes_list', 'CUBES_LIST')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def add_Cubes_list(self, value):
        self.list_Cubes_list.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Cubes_lu(self):
        """
        See documentation for Cubes_lu_bounds
        """
        return self.Cubes_lu_bounds

    @Cubes_lu.setter
    def Cubes_lu(self, value):
        self.Cubes_lu_bounds = value



class _response_function_cubes2(printable):
    """
    Controls the printing of the response functions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Stride = None
        """
        The stride (X,Y,Z) used to write the cube file (larger values result
        in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1
        number valid for all components.
        """
        self.Cubes_lu_bounds = None
        """
        The lower and upper index of the states to be printed as cube
        """
        self.list_Cubes_list = []
        self.Append = None
        """
        append the cube files when they already exist
        """
        self.EACH = _each300()
        self._name = "RESPONSE_FUNCTION_CUBES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Stride', 'STRIDE'), ('Cubes_lu_bounds', 'CUBES_LU_BOUNDS'), ('Append', 'APPEND')]
        self._repeated_keywords = [('Cubes_list', 'CUBES_LIST')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def add_Cubes_list(self, value):
        self.list_Cubes_list.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Cubes_lu(self):
        """
        See documentation for Cubes_lu_bounds
        """
        return self.Cubes_lu_bounds

    @Cubes_lu.setter
    def Cubes_lu(self, value):
        self.Cubes_lu_bounds = value



class _response_function_cubes1(printable):
    """
    Controls the printing of the response functions (not working yet).
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Stride = None
        """
        The stride (X,Y,Z) used to write the cube file (larger values result
        in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1
        number valid for all components (not working yet).
        """
        self.Cubes_lu_bounds = None
        """
        The lower and upper index of the states to be printed as cube (not
        working yet).
        """
        self.list_Cubes_list = []
        self.Append = None
        """
        append the cube files when they already exist
        """
        self.EACH = _each298()
        self._name = "RESPONSE_FUNCTION_CUBES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Stride', 'STRIDE'), ('Cubes_lu_bounds', 'CUBES_LU_BOUNDS'), ('Append', 'APPEND')]
        self._repeated_keywords = [('Cubes_list', 'CUBES_LIST')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def add_Cubes_list(self, value):
        self.list_Cubes_list.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Cubes_lu(self):
        """
        See documentation for Cubes_lu_bounds
        """
        return self.Cubes_lu_bounds

    @Cubes_lu.setter
    def Cubes_lu(self, value):
        self.Cubes_lu_bounds = value



class _xas1(printable):
    """
    Sets the method of choice to calculate core-level excitation spectra.
    The occupied states from  which we calculate the excitation should be
    specified. Localization of the orbitals may be useful.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        controls the activation of core-level spectroscopy simulations
        """
        self.Method = None
        """
        Method to be used to calculate core-level excitation spectra

        Available values:
            NONE
                No core electron spectroscopy
            TP_HH
                Transition potential half-hole
            TP_FH
                Transition potential full-hole
            TP_VAL
                Hole in homo for X-ray emission only
            TP_XHH
                Transition potential excited half-hole
            TP_XFH
                Transition potential excited full-hole
            DSCF
                DSCF calculations to compute the first (core)excited state
        """
        self.Xes_core = None
        """
        occupation of the core state in XES calculation by TP_VAL.The homo is
        emptied by the same amount
        """
        self.Dipole_form = None
        """
        Type of integral to get the oscillator strengths in the diipole
        approximation

        Available values:
            LENGTH
                Length form <i|e r |j>
            VELOCITY
                Velocity form <i|d/dr|j>
        """
        self.Scf_optimizer = None
        """
        Optimization algorithm: diagonalization or OT

        Available values:
            DEFAULT
                same as in std SCF
            GENERAL
                diagonalization
        """
        self.Maxstep = None
        """
        Max # of steps in the cls-scf for one excitation
        """
        self.Convergence = None
        """
        Convergence criterion for the xas-scf
        """
        self.Eps_diis = None
        """
        treshold on the convergence to start using DIAG/DIIS for the cls-scfif
        default, the scf_control value is used
        """
        self.State_type = None
        """
        Type of the orbitas that are excited for the xas spectra calculation

        Available values:
            1S
                1s orbitals
            2S
                2s orbitals
            2P
                2p orbitals
        """
        self.State_search = None
        """
        # of states where to look for the one to be excited
        """
        self.list_Atoms_list = []
        self.list_At_list = self.list_Atoms_list
        self.Added_mos = None
        """
        Number of additional MOS added spin up only
        """
        self.Max_iter_added = None
        """
        maximum number of iteration in calculation of added orbitals
        """
        self.Eps_added = None
        """
        target accuracy incalculation of the added orbitals
        """
        self.Ngauss = None
        """
        Number of gto's for the expansion of the stoof the type given by
        STATE_TYPE
        """
        self.Restart = None
        """
        Restart the excited state if the restart file exists
        """
        self.Wfn_restart_file_name = None
        """
        Root of the file names where to read the MOS fromwhich to restart the
        calculation of the core level excited states
        """
        self.LOCALIZE = _localize1()
        self.PRINT = _print31()
        self.MIXING = _mixing3()
        self.SMEAR = _smear2()
        self._name = "XAS"
        self._keywords = [('Method', 'METHOD'), ('Xes_core', 'XES_CORE'), ('Dipole_form', 'DIPOLE_FORM'), ('Scf_optimizer', 'SCF_OPTIMIZER'), ('Maxstep', 'MAXSTEP'), ('Convergence', 'CONVERGENCE'), ('Eps_diis', 'EPS_DIIS'), ('State_type', 'STATE_TYPE'), ('State_search', 'STATE_SEARCH'), ('Added_mos', 'ADDED_MOS'), ('Max_iter_added', 'MAX_ITER_ADDED'), ('Eps_added', 'EPS_ADDED'), ('Ngauss', 'NGAUSS'), ('Restart', 'RESTART'), ('Wfn_restart_file_name', 'WFN_RESTART_FILE_NAME')]
        self._repeated_keywords = [('Atoms_list', 'ATOMS_LIST')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('LOCALIZE', 'LOCALIZE'), ('PRINT', 'PRINT'), ('MIXING', 'MIXING'), ('SMEAR', 'SMEAR')]
        self._repeated_subsections = []

    def add_Atoms_list(self, value):
        self.list_Atoms_list.append(value)

    def add_At_list(self, value):
        self.list_ATOMS_LIST.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Xas_method(self):
        """
        See documentation for Method
        """
        return self.Method

    @property
    def Dip_form(self):
        """
        See documentation for Dipole_form
        """
        return self.Dipole_form

    @property
    def Conv(self):
        """
        See documentation for Convergence
        """
        return self.Convergence

    @property
    def Type(self):
        """
        See documentation for State_type
        """
        return self.State_type

    @property
    def Restart_file_name(self):
        """
        See documentation for Wfn_restart_file_name
        """
        return self.Wfn_restart_file_name

    @Xas_method.setter
    def Xas_method(self, value):
        self.Method = value

    @Dip_form.setter
    def Dip_form(self, value):
        self.Dipole_form = value

    @Conv.setter
    def Conv(self, value):
        self.Convergence = value

    @Type.setter
    def Type(self, value):
        self.State_type = value

    @Restart_file_name.setter
    def Restart_file_name(self, value):
        self.Wfn_restart_file_name = value



class _program_run_info10(printable):
    """
    Controls the printing basic info about the BAND run
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Initial_configuration_info = None
        """
        Print information for the setup of the initial configuration.
        """
        self.EACH = _each67()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Initial_configuration_info', 'INITIAL_CONFIGURATION_INFO')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _libxc2(printable):
    """
    Uses functionals from LIBXC, see also
    http://www.tddft.org/programs/octopus/wiki/index.php/Libxc
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Functional = None
        """
        names of the functionals, see also
        http://www.tddft.org/programs/octopus/wiki/index.php/Libxc:manual .The
        precise list of available functionals depends on the version of libxc
        interfaced (currently 2.0.1).
        """
        self.Scale = None
        """
        scaling factors of the functionals
        """
        self.Parameters = None
        """
        parameters of the functionals
        """
        self._name = "LIBXC"
        self._keywords = [('Functional', 'FUNCTIONAL'), ('Scale', 'SCALE'), ('Parameters', 'PARAMETERS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _libxc3(printable):
    """
    Uses functionals from LIBXC, see also
    http://www.tddft.org/programs/octopus/wiki/index.php/Libxc
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Functional = None
        """
        names of the functionals, see also
        http://www.tddft.org/programs/octopus/wiki/index.php/Libxc:manual .The
        precise list of available functionals depends on the version of libxc
        interfaced (currently 2.0.1).
        """
        self.Scale = None
        """
        scaling factors of the functionals
        """
        self.Parameters = None
        """
        parameters of the functionals
        """
        self._name = "LIBXC"
        self._keywords = [('Functional', 'FUNCTIONAL'), ('Scale', 'SCALE'), ('Parameters', 'PARAMETERS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _libxc1(printable):
    """
    Uses functionals from LIBXC, see also
    http://www.tddft.org/programs/octopus/wiki/index.php/Libxc
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Functional = None
        """
        names of the functionals, see also
        http://www.tddft.org/programs/octopus/wiki/index.php/Libxc:manual .The
        precise list of available functionals depends on the version of libxc
        interfaced (currently 2.0.1).
        """
        self.Scale = None
        """
        scaling factors of the functionals
        """
        self.Parameters = None
        """
        parameters of the functionals
        """
        self._name = "LIBXC"
        self._keywords = [('Functional', 'FUNCTIONAL'), ('Scale', 'SCALE'), ('Parameters', 'PARAMETERS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _libxc4(printable):
    """
    Uses functionals from LIBXC, see also
    http://www.tddft.org/programs/octopus/wiki/index.php/Libxc
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Functional = None
        """
        names of the functionals, see also
        http://www.tddft.org/programs/octopus/wiki/index.php/Libxc:manual .The
        precise list of available functionals depends on the version of libxc
        interfaced (currently 2.0.1).
        """
        self.Scale = None
        """
        scaling factors of the functionals
        """
        self.Parameters = None
        """
        parameters of the functionals
        """
        self._name = "LIBXC"
        self._keywords = [('Functional', 'FUNCTIONAL'), ('Scale', 'SCALE'), ('Parameters', 'PARAMETERS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _periodic_sys1(printable):
    """
    Specifies the parameter for sampling the RESP fitting points for
    periodic systems, i.e. systems that involve surfaces. This section can
    only be used with periodic  Poisson solver and cell. To see, which
    grid points were used, switch on COORD_FIT_POINTS in the PRINT
    section.
    """
    def __init__(self):
        self.list_Atom_list = []
        self.Range = None
        """
        Range where the fitting points are sampled. A range of 3 to 5
        Angstroms means that the fitting points are sampled in the region of 3
        to 5 Angstroms above the surface which is defined by atom indexes
        given in ATOM_LIST.
        """
        self.Length = None
        """
        Length of the sampling box, i.e. a box of this length and the height
        specified by RANGE is defined above each surface atom given in
        ATOM_LIST. The grid points in the boxes are accepted as fitting point.
        Should be in the range of the nearest neighbour distance (a bit larger
        to be on the safe side). Allows for a refined sampling of grid points
        in case of corrugated surfaces.
        """
        self.Surf_direction = None
        """
        Specifies what above the surface means. Defines the direction.

        Available values:
            X
                surface layers are piled up in x-direction
            Y
                surface layers are piled up in y-direction
            Z
                surface layers are piled up in z-direction
            -X
                surface layers are piled up in -x-direction
            -Y
                surface layers are piled up in -y-direction
            -Z
                surface layers are piled up in -z-direction
        """
        self._name = "PERIODIC_SYS"
        self._keywords = [('Range', 'RANGE'), ('Length', 'LENGTH'), ('Surf_direction', 'SURF_DIRECTION')]
        self._repeated_keywords = [('Atom_list', 'ATOM_LIST')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atom_list(self, value):
        self.list_Atom_list.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _print7(printable):
    """
    Collects all print_keys for barostat
    """
    def __init__(self):
        self.ENERGY = _energy2()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('ENERGY', 'ENERGY')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print6(printable):
    """
    Collects all print_keys for thermostat
    """
    def __init__(self):
        self.THERMOSTAT_INFO = _thermostat_info1()
        self.TEMPERATURE = _temperature1()
        self.ENERGY = _energy1()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('THERMOSTAT_INFO', 'THERMOSTAT_INFO'), ('TEMPERATURE', 'TEMPERATURE'), ('ENERGY', 'ENERGY')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print5(printable):
    """
    Controls the printing properties during a shell-core optimization
    procedure
    """
    def __init__(self):
        self.PROGRAM_RUN_INFO = _program_run_info7()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print4(printable):
    """
    Controls the printing properties during a geometry optimization run
    """
    def __init__(self):
        self.PROGRAM_RUN_INFO = _program_run_info6()
        self.CELL = _cell1()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('CELL', 'CELL')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print3(printable):
    """
    Controls the printing properties during a geometry optimization run
    """
    def __init__(self):
        self.PROGRAM_RUN_INFO = _program_run_info5()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print2(printable):
    """
    Controls the printing properties during the dimer rotation
    optimization run
    """
    def __init__(self):
        self.PROGRAM_RUN_INFO = _program_run_info4()
        self.ROTATIONAL_INFO = _rotational_info1()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('ROTATIONAL_INFO', 'ROTATIONAL_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print1(printable):
    """
    controls the printing of physical and mathematical constants
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Basic_data_types = None
        """
        Controls the printing of the basic data types.
        """
        self.Physcon = None
        """
        if the printkey is active prints the physical constants
        """
        self.Spherical_harmonics = None
        """
        if the printkey is active prints the spherical harmonics
        """
        self.Rng_matrices = None
        """
        Prints the transformation matrices used by the  random number
        generator
        """
        self.Rng_check = None
        """
        Performs a check of the global (pseudo)random number generator (RNG)
        and prints the result
        """
        self.Global_gaussian_rng = None
        """
        Prints the initial status of the global Gaussian (pseudo)random number
        stream which is mostly used for the velocity initialization
        """
        self.Hpm = None
        """
        if the keyword is active controls the printing of the hpm info (if
        linked as external library, on IBM only)
        """
        self.EACH = _each4()
        self._name = "PRINT"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Basic_data_types', 'BASIC_DATA_TYPES'), ('Physcon', 'PHYSCON'), ('Spherical_harmonics', 'SPHERICAL_HARMONICS'), ('Rng_matrices', 'RNG_MATRICES'), ('Rng_check', 'RNG_CHECK'), ('Global_gaussian_rng', 'GLOBAL_GAUSSIAN_RNG'), ('Hpm', 'HPM')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each54(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print9(printable):
    """
    Collects all print_keys for thermostat
    """
    def __init__(self):
        self.THERMOSTAT_INFO = _thermostat_info3()
        self.TEMPERATURE = _temperature3()
        self.ENERGY = _energy4()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('THERMOSTAT_INFO', 'THERMOSTAT_INFO'), ('TEMPERATURE', 'TEMPERATURE'), ('ENERGY', 'ENERGY')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print8(printable):
    """
    Collects all print_keys for thermostat
    """
    def __init__(self):
        self.THERMOSTAT_INFO = _thermostat_info2()
        self.TEMPERATURE = _temperature2()
        self.ENERGY = _energy3()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('THERMOSTAT_INFO', 'THERMOSTAT_INFO'), ('TEMPERATURE', 'TEMPERATURE'), ('ENERGY', 'ENERGY')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each56(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each272(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _energies_var1(printable):
    """
    Controls the printing of the variance of the EIP energies.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each260()
        self._name = "ENERGIES_VAR"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _total_dipole1(printable):
    """
    Section controlling the calculation of TOTAL_DIPOLE. Note that the
    result in the periodic case might be defined modulo a certain period,
    determined by the lattice vectors. During MD, this can lead to jumps.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Periodic = None
        """
        Use Berry phase formula (PERIODIC=T) or simple operator (PERIODIC=F).
        The latter normally requires that the CELL is periodic NONE.
        """
        self.Reference = None
        """
        Define the reference point for the calculation of the electrostatic
        moment.

        Available values:
            COM
                Use Center of Mass
            COAC
                Use Center of Atomic Charges
            USER_DEFINED
                Use User Defined Point (Keyword:REF_POINT)
            ZERO
                Use Origin of Coordinate System
        """
        self.Reference_point = None
        """
        Fixed reference point for the calculations of the electrostatic
        moment.
        """
        self.EACH = _each149()
        self._name = "TOTAL_DIPOLE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Periodic', 'PERIODIC'), ('Reference', 'REFERENCE'), ('Reference_point', 'REFERENCE_POINT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Ref(self):
        """
        See documentation for Reference
        """
        return self.Reference

    @property
    def Ref_point(self):
        """
        See documentation for Reference_point
        """
        return self.Reference_point

    @Ref.setter
    def Ref(self, value):
        self.Reference = value

    @Ref_point.setter
    def Ref_point(self, value):
        self.Reference_point = value



class _spl_coeffs1(printable):
    """
    outputs a cube with the coefficents calculated for the spline
    interpolation
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each240()
        self._name = "SPL_COEFFS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each275(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _gaussian_env1(printable):
    """
    parameters for a gaussian envelop
    """
    def __init__(self):
        self.T0 = None
        """
        Center of the gaussian envelop (maximum of the gaussian)
        """
        self.Sigma = None
        """
        Width of the gaussian
        """
        self._name = "GAUSSIAN_ENV"
        self._keywords = [('T0', 'T0'), ('Sigma', 'SIGMA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _total_dipole2(printable):
    """
    Section controlling the calculation of TOTAL_DIPOLE. Note that the
    result in the periodic case might be defined modulo a certain period,
    determined by the lattice vectors. During MD, this can lead to jumps.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Periodic = None
        """
        Use Berry phase formula (PERIODIC=T) or simple operator (PERIODIC=F).
        The latter normally requires that the CELL is periodic NONE.
        """
        self.Reference = None
        """
        Define the reference point for the calculation of the electrostatic
        moment.

        Available values:
            COM
                Use Center of Mass
            COAC
                Use Center of Atomic Charges
            USER_DEFINED
                Use User Defined Point (Keyword:REF_POINT)
            ZERO
                Use Origin of Coordinate System
        """
        self.Reference_point = None
        """
        Fixed reference point for the calculations of the electrostatic
        moment.
        """
        self.EACH = _each170()
        self._name = "TOTAL_DIPOLE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Periodic', 'PERIODIC'), ('Reference', 'REFERENCE'), ('Reference_point', 'REFERENCE_POINT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Ref(self):
        """
        See documentation for Reference
        """
        return self.Reference

    @property
    def Ref_point(self):
        """
        See documentation for Reference_point
        """
        return self.Reference_point

    @Ref.setter
    def Ref(self, value):
        self.Reference = value

    @Ref_point.setter
    def Ref_point(self, value):
        self.Reference_point = value



class _potential4(printable):
    """
    Section of information on potential.
    """
    def __init__(self):
        self.Confinement = None
        """
        Definition of confinement potential
        """
        self.Pseudo_type = None
        """
        Pseudopotential type

        Available values:
            NONE
            GTH
        """
        self.Potential_file_name = None
        """
        Name of the pseudo potential file, may include a path
        """
        self.Potential_name = None
        """
        The name of the pseudopotential for the defined kind.
        """
        self.GTH_POTENTIAL = _gth_potential1()
        self._name = "POTENTIAL"
        self._keywords = [('Confinement', 'CONFINEMENT'), ('Pseudo_type', 'PSEUDO_TYPE'), ('Potential_file_name', 'POTENTIAL_FILE_NAME'), ('Potential_name', 'POTENTIAL_NAME')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('GTH_POTENTIAL', 'GTH_POTENTIAL')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Pot_name(self):
        """
        See documentation for Potential_name
        """
        return self.Potential_name

    @Pot_name.setter
    def Pot_name(self, value):
        self.Potential_name = value



class _potential2(printable):
    """
    Section used to specify Potentials.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        CP2K Pseudo Potential Standard Format (GTH, ALL or KG)
        """
        self._name = "POTENTIAL"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _potential3(printable):
    """
    Controls the printing of the potentials
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each357()
        self._name = "POTENTIAL"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _potential1(printable):
    """
    Controls the printing of the QMMM  potential
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Stride = None
        """
        The stride (X,Y,Z) used to write the cube file (larger values result
        in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1
        number valid for all components.
        """
        self.EACH = _each242()
        self._name = "POTENTIAL"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Stride', 'STRIDE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _derived_basis_sets1(printable):
    """
    This section can be used to create subsets of a basis  which will be
    fitted at the same time. This is especially useful if connected bsis
    sets e.g. TZVP, DZVP, SZV should be fitted.
    """
    def __init__(self):
        self.Reference_set = None
        """
        Specifies the reference basis ID which is used as template to create
        the new set. The original basis has ID 0. All follwing sets are
        counted in order as specified in the Input. The decriptors always
        assume the structure of the input basis set.
        """
        self.list_Remove_contraction = []
        self.list_Remove_set = []
        self._name = "DERIVED_BASIS_SETS"
        self._keywords = [('Reference_set', 'REFERENCE_SET')]
        self._repeated_keywords = [('Remove_contraction', 'REMOVE_CONTRACTION'), ('Remove_set', 'REMOVE_SET')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Remove_contraction(self, value):
        self.list_Remove_contraction.append(value)

    def add_Remove_set(self, value):
        self.list_Remove_set.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _ri_laplace1(printable):
    """
    Parameters influencing the RI-SOS-MP2-Laplace method
    """
    def __init__(self):
        self.Quadrature_points = None
        """
        Number of quadrature points for the numerical integration in the RI-
        SOS-MP2-Laplace method.
        """
        self.Size_integ_group = None
        """
        Group size for the integration in the Laplace method, that is the
        number of processes involved in the computation of each integration
        point. SIZE_INTEG_GROUP has to be a multiple of GROUP_SIZE in the
        WF_CORRELATION section. The default (-1) is automatic.
        """
        self._name = "RI_LAPLACE"
        self._keywords = [('Quadrature_points', 'QUADRATURE_POINTS'), ('Size_integ_group', 'SIZE_INTEG_GROUP')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Laplace_num_quad_points(self):
        """
        See documentation for Quadrature_points
        """
        return self.Quadrature_points

    @property
    def Laplace_group_size(self):
        """
        See documentation for Size_integ_group
        """
        return self.Size_integ_group

    @Laplace_num_quad_points.setter
    def Laplace_num_quad_points(self, value):
        self.Quadrature_points = value

    @Laplace_group_size.setter
    def Laplace_group_size(self, value):
        self.Size_integ_group = value



class _ri_laplace3(printable):
    """
    Parameters influencing the RI-SOS-MP2-Laplace method
    """
    def __init__(self):
        self.Quadrature_points = None
        """
        Number of quadrature points for the numerical integration in the RI-
        SOS-MP2-Laplace method.
        """
        self.Size_integ_group = None
        """
        Group size for the integration in the Laplace method, that is the
        number of processes involved in the computation of each integration
        point. SIZE_INTEG_GROUP has to be a multiple of GROUP_SIZE in the
        WF_CORRELATION section. The default (-1) is automatic.
        """
        self._name = "RI_LAPLACE"
        self._keywords = [('Quadrature_points', 'QUADRATURE_POINTS'), ('Size_integ_group', 'SIZE_INTEG_GROUP')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Laplace_num_quad_points(self):
        """
        See documentation for Quadrature_points
        """
        return self.Quadrature_points

    @property
    def Laplace_group_size(self):
        """
        See documentation for Size_integ_group
        """
        return self.Size_integ_group

    @Laplace_num_quad_points.setter
    def Laplace_num_quad_points(self, value):
        self.Quadrature_points = value

    @Laplace_group_size.setter
    def Laplace_group_size(self, value):
        self.Size_integ_group = value



class _ri_laplace2(printable):
    """
    Parameters influencing the RI-SOS-MP2-Laplace method
    """
    def __init__(self):
        self.Quadrature_points = None
        """
        Number of quadrature points for the numerical integration in the RI-
        SOS-MP2-Laplace method.
        """
        self.Size_integ_group = None
        """
        Group size for the integration in the Laplace method, that is the
        number of processes involved in the computation of each integration
        point. SIZE_INTEG_GROUP has to be a multiple of GROUP_SIZE in the
        WF_CORRELATION section. The default (-1) is automatic.
        """
        self._name = "RI_LAPLACE"
        self._keywords = [('Quadrature_points', 'QUADRATURE_POINTS'), ('Size_integ_group', 'SIZE_INTEG_GROUP')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Laplace_num_quad_points(self):
        """
        See documentation for Quadrature_points
        """
        return self.Quadrature_points

    @property
    def Laplace_group_size(self):
        """
        See documentation for Size_integ_group
        """
        return self.Size_integ_group

    @Laplace_num_quad_points.setter
    def Laplace_num_quad_points(self, value):
        self.Quadrature_points = value

    @Laplace_group_size.setter
    def Laplace_group_size(self, value):
        self.Size_integ_group = value



class _ri_laplace4(printable):
    """
    Parameters influencing the RI-SOS-MP2-Laplace method
    """
    def __init__(self):
        self.Quadrature_points = None
        """
        Number of quadrature points for the numerical integration in the RI-
        SOS-MP2-Laplace method.
        """
        self.Size_integ_group = None
        """
        Group size for the integration in the Laplace method, that is the
        number of processes involved in the computation of each integration
        point. SIZE_INTEG_GROUP has to be a multiple of GROUP_SIZE in the
        WF_CORRELATION section. The default (-1) is automatic.
        """
        self._name = "RI_LAPLACE"
        self._keywords = [('Quadrature_points', 'QUADRATURE_POINTS'), ('Size_integ_group', 'SIZE_INTEG_GROUP')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Laplace_num_quad_points(self):
        """
        See documentation for Quadrature_points
        """
        return self.Quadrature_points

    @property
    def Laplace_group_size(self):
        """
        See documentation for Size_integ_group
        """
        return self.Size_integ_group

    @Laplace_num_quad_points.setter
    def Laplace_num_quad_points(self, value):
        self.Quadrature_points = value

    @Laplace_group_size.setter
    def Laplace_group_size(self, value):
        self.Size_integ_group = value



class _block_density_matrix_method1(printable):
    """
    Parameters needed to set wavefunction fitting
    """
    def __init__(self):
        self.Basis_projection = None
        """
        Defines usage of auxiliary basis set

        Available values:
            ON
                Use auxiliary basis
            OFF
                Use primary basis
        """
        self.Purification = None
        """
        Method that shall be used for Purification

        Available values:
            OFF
                Do not apply any purification
            FULL
                Apply full McWeeny purification via general Cauchy representation
            BLOCKED
                Apply blocked McWeeny purification via general Cauchy representation
        """
        self.list_BLOCK = []
        self._name = "BLOCK_DENSITY_MATRIX_METHOD"
        self._keywords = [('Basis_projection', 'BASIS_PROJECTION'), ('Purification', 'PURIFICATION')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('BLOCK', '_block1')]

    def add_BLOCK(self):
        new_section = _block1()
        self.list_BLOCK.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _ext_lagrange_ss1(printable):
    """
    Colvar Theta within an extended Lagrangian formalism.Used for RESTART.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specified the theta
        """
        self._name = "EXT_LAGRANGE_SS"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _neighbor_lists4(printable):
    """
    Controls the printing of the neighbor lists
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.Sab_orb = None
        """
        Activates the printing of the orbital orbital neighbor lists, i.e. the
        overlap neighbor lists
        """
        self.Sab_aux_fit = None
        """
        Activates the printing of the orbital orbital neighbor lists
        wavefunction fitting basis, i.e. the overlap neighbor lists
        """
        self.Sab_aux_fit_vs_orb = None
        """
        Activates the printing of the orbital orbital mixed neighbor lists of
        wavefunction fitting basis, and the orbital basis, i.e. the overlap
        neighbor lists
        """
        self.Sab_scp = None
        """
        Activates the printing of the vdW SCP neighbor lists
        """
        self.Sab_vdw = None
        """
        Activates the printing of the vdW neighbor lists (from DFT, DFTB, SE),
        i.e. the dispersion neighbor lists
        """
        self.Sab_cn = None
        """
        Activates the printing of the neighbor lists used for coordination
        numbers in vdW DFT-D3
        """
        self.Sac_ae = None
        """
        Activates the printing of the orbital nuclear attraction neighbor
        lists (erfc potential)
        """
        self.Sac_ppl = None
        """
        Activates the printing of the orbital GTH-PPL neighbor lists (local
        part of the Goedecker-Teter-Hutter pseudo potentials)
        """
        self.Sap_ppnl = None
        """
        Activates the printing of the orbital GTH-PPNL neighbor lists (non-
        local part of theGoedecker-Teter-Hutter pseudo potentials)
        """
        self.Sap_oce = None
        """
        Activates the printing of the orbital PAW-projector neighbor lists
        (only GAPW)
        """
        self.Sab_se = None
        """
        Activates the printing of the two-center neighbor lists for Coulomb
        type interactions in NDDO
        """
        self.Sab_lrc = None
        """
        Activates the printing of the long-range SE correction neighbor lists
        (only when doing long-range SE with integral scheme KDSO and KDSO-d)
        """
        self.Sab_tbe = None
        """
        Activates the printing of the DFTB Ewald neighbor lists
        """
        self.Sab_core = None
        """
        Activates the printing of core interaction neighbor lists
        """
        self.Soo_list = None
        """
        Activates the printing of RI orbital-orbital neighbor lists
        """
        self.Sip_list = None
        """
        Activates the printing of RI basis-projector interaction neighbor
        lists
        """
        self.EACH = _each182()
        self._name = "NEIGHBOR_LISTS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT'), ('Sab_orb', 'SAB_ORB'), ('Sab_aux_fit', 'SAB_AUX_FIT'), ('Sab_aux_fit_vs_orb', 'SAB_AUX_FIT_VS_ORB'), ('Sab_scp', 'SAB_SCP'), ('Sab_vdw', 'SAB_VDW'), ('Sab_cn', 'SAB_CN'), ('Sac_ae', 'SAC_AE'), ('Sac_ppl', 'SAC_PPL'), ('Sap_ppnl', 'SAP_PPNL'), ('Sap_oce', 'SAP_OCE'), ('Sab_se', 'SAB_SE'), ('Sab_lrc', 'SAB_LRC'), ('Sab_tbe', 'SAB_TBE'), ('Sab_core', 'SAB_CORE'), ('Soo_list', 'SOO_LIST'), ('Sip_list', 'SIP_LIST')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _quartic1(printable):
    """
    Parameters controlling the quartic wall
    """
    def __init__(self):
        self.Direction = None
        """
        Specify the direction of the wall.

        Available values:
            WALL_PLUS
                Wall extends from the position towards larger values of COLVAR
            WALL_MINUS
                Wall extends from the position towards smaller values of COLVAR
        """
        self.K = None
        """
        Specify the value of the quartic potential constant:
        K*(CV-(POS+/-(1/K^(1/4))))^4
        """
        self._name = "QUARTIC"
        self._keywords = [('Direction', 'DIRECTION'), ('K', 'K')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _restraint1(printable):
    """
    Activate and specify information on restraint instead of constraint
    """
    def __init__(self):
        self.K = None
        """
        Specifies the force constant for the harmonic restraint. The
        functional form for the restraint is: K*(X-TARGET)^2.
        """
        self._name = "RESTRAINT"
        self._keywords = [('K', 'K')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _restraint2(printable):
    """
    Activate and specify information on restraint instead of constraint
    """
    def __init__(self):
        self.K = None
        """
        Specifies the force constant for the harmonic restraint. The
        functional form for the restraint is: K*(X-TARGET)^2.
        """
        self._name = "RESTRAINT"
        self._keywords = [('K', 'K')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _restraint3(printable):
    """
    Activate and specify information on restraint instead of constraint
    """
    def __init__(self):
        self.K = None
        """
        Specifies the force constant for the harmonic restraint. The
        functional form for the restraint is: K*(X-TARGET)^2.
        """
        self._name = "RESTRAINT"
        self._keywords = [('K', 'K')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _xwpbe2(printable):
    """
    Uses the short range PBE functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Scale_x0 = None
        """
        scales the exchange part of the original hole PBE-functional
        """
        self.Omega = None
        """
        screening parameter
        """
        self._name = "XWPBE"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Scale_x0', 'SCALE_X0'), ('Omega', 'OMEGA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _restraint5(printable):
    """
    Activate and specify information on restraint instead of constraint
    """
    def __init__(self):
        self.K = None
        """
        Specifies the force constant for the harmonic restraint. The
        functional form for the restraint is: K*(X-TARGET)^2.
        """
        self._name = "RESTRAINT"
        self._keywords = [('K', 'K')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _restraint6(printable):
    """
    Activate and specify information on restraint instead of constraint
    """
    def __init__(self):
        self.K = None
        """
        Specifies the force constant for the harmonic restraint. The
        functional form for the restraint is: K*(X-TARGET)^2.
        """
        self._name = "RESTRAINT"
        self._keywords = [('K', 'K')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _xwpbe1(printable):
    """
    Uses the short range PBE functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Scale_x0 = None
        """
        scales the exchange part of the original hole PBE-functional
        """
        self.Omega = None
        """
        screening parameter
        """
        self._name = "XWPBE"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Scale_x0', 'SCALE_X0'), ('Omega', 'OMEGA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _restraint8(printable):
    """
    specifies a restraint on the fitted charges.This can be used to
    restrain values to zero.s*(sum over atom_list q_i - t)**2
    """
    def __init__(self):
        self.Target = None
        """
        the target value for the restraint
        """
        self.Strength = None
        """
        the target value for the constraint
        """
        self.list_Atom_list = []
        self.Atom_coef = None
        """
        Defines the coefficient of the atom in this linear restraint. If
        given, the restraint will be: s*(sum over atom_list c_i * q_i - t)**2
        """
        self._name = "RESTRAINT"
        self._keywords = [('Target', 'TARGET'), ('Strength', 'STRENGTH'), ('Atom_coef', 'ATOM_COEF')]
        self._repeated_keywords = [('Atom_list', 'ATOM_LIST')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atom_list(self, value):
        self.list_Atom_list.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _wc3(printable):
    """
    Section to define the hbond wannier centre as a collective variables.
    """
    def __init__(self):
        self.Rcut = None
        """
        Parameter used for computing the cutoff radius for searching the
        wannier centres around an atom
        """
        self.list_Atoms = []
        self.list_Points = self.list_Atoms
        self.list_POINT = []
        self._name = "WC"
        self._keywords = [('Rcut', 'RCUT')]
        self._repeated_keywords = [('Atoms', 'ATOMS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point51')]

    def add_POINT(self):
        new_section = _point51()
        self.list_POINT.append(new_section)
        return new_section

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Points(self, value):
        self.list_ATOMS.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _wc2(printable):
    """
    Section to define the hbond wannier centre as a collective variables.
    """
    def __init__(self):
        self.Rcut = None
        """
        Parameter used for computing the cutoff radius for searching the
        wannier centres around an atom
        """
        self.list_Atoms = []
        self.list_Points = self.list_Atoms
        self.list_POINT = []
        self._name = "WC"
        self._keywords = [('Rcut', 'RCUT')]
        self._repeated_keywords = [('Atoms', 'ATOMS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point33')]

    def add_POINT(self):
        new_section = _point33()
        self.list_POINT.append(new_section)
        return new_section

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Points(self, value):
        self.list_ATOMS.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _wc1(printable):
    """
    Section to define the hbond wannier centre as a collective variables.
    """
    def __init__(self):
        self.Rcut = None
        """
        Parameter used for computing the cutoff radius for searching the
        wannier centres around an atom
        """
        self.list_Atoms = []
        self.list_Points = self.list_Atoms
        self.list_POINT = []
        self._name = "WC"
        self._keywords = [('Rcut', 'RCUT')]
        self._repeated_keywords = [('Atoms', 'ATOMS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point15')]

    def add_POINT(self):
        new_section = _point15()
        self.list_POINT.append(new_section)
        return new_section

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Points(self, value):
        self.list_ATOMS.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _wc4(printable):
    """
    Section to define the hbond wannier centre as a collective variables.
    """
    def __init__(self):
        self.Rcut = None
        """
        Parameter used for computing the cutoff radius for searching the
        wannier centres around an atom
        """
        self.list_Atoms = []
        self.list_Points = self.list_Atoms
        self.list_POINT = []
        self._name = "WC"
        self._keywords = [('Rcut', 'RCUT')]
        self._repeated_keywords = [('Atoms', 'ATOMS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point69')]

    def add_POINT(self):
        new_section = _point69()
        self.list_POINT.append(new_section)
        return new_section

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Points(self, value):
        self.list_ATOMS.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _molecules1(printable):
    """
    controls the output of information on the molecules
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each284()
        self._name = "MOLECULES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _neighbor_lists1(printable):
    """
    Controls the printing of the neighbor lists.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.Sab_orb_full = None
        """
        Activates the printing of the full orbital orbital neighbor lists.
        """
        self.Sab_orb_molecular = None
        """
        Activates the printing of the orbital orbital neighbor lists for
        molecular subsets.
        """
        self.EACH = _each105()
        self._name = "NEIGHBOR_LISTS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT'), ('Sab_orb_full', 'SAB_ORB_FULL'), ('Sab_orb_molecular', 'SAB_ORB_MOLECULAR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _shell_trajectory1(printable):
    """
    Controls the output of the trajectory of shells when the shell-model
    is used
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.Format = None
        """
        Specifies the format of the output file for the trajectory of shells.

        Available values:
            ATOMIC
                Write only the coordinates X,Y,Z without element symbols to a
                formatted file
            DCD
                Write the coordinates (no element labels) and the cell information to
                a binary file
            PDB
                Write the atomic information in PDB format to a formatted file
            XMOL
                Mostly known as XYZ format, provides in a formatted file:
                element_symbol X Y Z
            XYZ
                Alias name for XMOL
        """
        self.Charge_occup = None
        """
        Write the MM charges to the OCCUP field of the PDB file
        """
        self.Charge_beta = None
        """
        Write the MM charges to the BETA field of the PDB file
        """
        self.Charge_extended = None
        """
        Write the MM charges to the very last field of the PDB file (starting
        from column 81)
        """
        self.EACH = _each73()
        self._name = "SHELL_TRAJECTORY"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT'), ('Format', 'FORMAT'), ('Charge_occup', 'CHARGE_OCCUP'), ('Charge_beta', 'CHARGE_BETA'), ('Charge_extended', 'CHARGE_EXTENDED')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Charge_o(self):
        """
        See documentation for Charge_occup
        """
        return self.Charge_occup

    @property
    def Charge_b(self):
        """
        See documentation for Charge_beta
        """
        return self.Charge_beta

    @Charge_o.setter
    def Charge_o(self, value):
        self.Charge_occup = value

    @Charge_b.setter
    def Charge_b(self, value):
        self.Charge_beta = value



class _rdf1(printable):
    """
    Radial distribution function generation settings
    """
    def __init__(self):
        self.Maxr = None
        """
        Maximum RDF range, defaults to unit cell size
        """
        self.Nbin = None
        """
        Number of bins
        """
        self._name = "RDF"
        self._keywords = [('Maxr', 'MAXR'), ('Nbin', 'NBIN')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _neighbor_lists9(printable):
    """
    Activates the printing of the neighbor lists used for generating the
    connectivity.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.EACH = _each269()
        self._name = "NEIGHBOR_LISTS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _neighbor_lists8(printable):
    """
    This section specifies the input parameters for the construction of
    neighbor lists.
    """
    def __init__(self):
        self.Verlet_skin = None
        """
        Defines the Verlet Skin for the generation of the neighbor lists
        """
        self.Neighbor_lists_from_scratch = None
        """
        This keyword enables the building of the neighbouring list from
        scratch.
        """
        self.Geo_check = None
        """
        This keyword enables the check that two atoms are never below the
        minimum value used to construct the splines during the construction of
        the neighbouring list. Disabling this keyword avoids CP2K to abort in
        case two atoms are below the minimum  value of the radius used to
        generate the splines.
        """
        self._name = "NEIGHBOR_LISTS"
        self._keywords = [('Verlet_skin', 'VERLET_SKIN'), ('Neighbor_lists_from_scratch', 'NEIGHBOR_LISTS_FROM_SCRATCH'), ('Geo_check', 'GEO_CHECK')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each248(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each249(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _neighbor_lists5(printable):
    """
    This section specifies the input parameters for the construction of
    neighbor lists.
    """
    def __init__(self):
        self.Verlet_skin = None
        """
        Defines the Verlet Skin for the generation of the neighbor lists
        """
        self.Neighbor_lists_from_scratch = None
        """
        This keyword enables the building of the neighbouring list from
        scratch.
        """
        self.Geo_check = None
        """
        This keyword enables the check that two atoms are never below the
        minimum value used to construct the splines during the construction of
        the neighbouring list. Disabling this keyword avoids CP2K to abort in
        case two atoms are below the minimum  value of the radius used to
        generate the splines.
        """
        self._name = "NEIGHBOR_LISTS"
        self._keywords = [('Verlet_skin', 'VERLET_SKIN'), ('Neighbor_lists_from_scratch', 'NEIGHBOR_LISTS_FROM_SCRATCH'), ('Geo_check', 'GEO_CHECK')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each247(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each244(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each245(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each242(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each243(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each240(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each241(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _averages1(printable):
    """
    Controls the calculation of the averages during an MD run.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Controls the calculations of the averages.
        """
        self.Acquisition_start_time = None
        """
        Setup up the simulation time when the acquisition process to compute
        averages is started.
        """
        self.Average_colvar = None
        """
        Switch for computing the averages of COLVARs.
        """
        self.PRINT_AVERAGES = _print_averages1()
        self.RESTART_AVERAGES = _restart_averages1()
        self._name = "AVERAGES"
        self._keywords = [('Acquisition_start_time', 'ACQUISITION_START_TIME'), ('Average_colvar', 'AVERAGE_COLVAR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT_AVERAGES', 'PRINT_AVERAGES'), ('RESTART_AVERAGES', 'RESTART_AVERAGES')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _wf_correlation4(printable):
    """
    Sets up the Wavefunction-based Correlation parameters if requested
    """
    def __init__(self):
        self.Method = None
        """
        Which method should be used to compute the MP2 energy

        Available values:
            NONE
                Skip MP2 calculation
            DIRECT_CANONICAL
                Use the direct mp2 canonical approach
            MP2_GPW
                Use the GPW approach to MP2
            RI_MP2_GPW
                Use the GPW approach to RI-MP2
            RI_RPA_GPW
                Use the GPW approach to RI-RPA
            RI_SOS_LAPLACE
                Use the GPW approach to RI-SOS-Laplace-MP2
        """
        self.Memory = None
        """
        Maximum allowed total memory usage during MP2 methods [Mb].
        """
        self.Scale_s = None
        """
        Scaling factor of the singlet energy component (opposite spin, OS).
        """
        self.Scale_t = None
        """
        Scaling factor of the triplet energy component (same spin, SS).
        """
        self.Group_size = None
        """
        Group size used in the computation of the integrals. Default is to use
        all processors (GROUP_SIZE=-1).A smaller group size (for example the
        node size), might a better choice if the actual MP2 time is large
        compared to integral computation time. This is usually the case if the
        total number of processors is not too large.
        """
        self.Row_block = None
        """
        Size of the row block used in the SCALAPACK block cyclic data
        distribution.Default is (ROW_BLOCK=-1) is automatic. A proper choice
        can speedup the parallel matrix multiplication in the case of RI-RPA
        and RI-SOS-MP2-Laplace.
        """
        self.Col_block = None
        """
        Size of the column block used in the SCALAPACK block cyclic data
        distribution.Default is (COL_BLOCK=-1) is automatic. A proper choice
        can speedup the parallel matrix multiplication in the case of RI-RPA
        and RI-SOS-MP2-Laplace.
        """
        self.Calc_cond_num = None
        """
        Calculate the condition number of the (P|Q) matrix for the RI methods.
        """
        self.MP2_INFO = _mp2_info4()
        self.DIRECT_CANONICAL = _direct_canonical4()
        self.WFC_GPW = _wfc_gpw4()
        self.RI_MP2 = _ri_mp24()
        self.RI_RPA = _ri_rpa4()
        self.RI_LAPLACE = _ri_laplace4()
        self.INTERACTION_POTENTIAL = _interaction_potential12()
        self._name = "WF_CORRELATION"
        self._keywords = [('Method', 'METHOD'), ('Memory', 'MEMORY'), ('Scale_s', 'SCALE_S'), ('Scale_t', 'SCALE_T'), ('Group_size', 'GROUP_SIZE'), ('Row_block', 'ROW_BLOCK'), ('Col_block', 'COL_BLOCK'), ('Calc_cond_num', 'CALC_COND_NUM')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('MP2_INFO', 'MP2_INFO'), ('DIRECT_CANONICAL', 'DIRECT_CANONICAL'), ('WFC_GPW', 'WFC_GPW'), ('RI_MP2', 'RI_MP2'), ('RI_RPA', 'RI_RPA'), ('RI_LAPLACE', 'RI_LAPLACE'), ('INTERACTION_POTENTIAL', 'INTERACTION_POTENTIAL')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Number_proc(self):
        """
        See documentation for Group_size
        """
        return self.Group_size

    @property
    def Row_block_size(self):
        """
        See documentation for Row_block
        """
        return self.Row_block

    @property
    def Col_block_size(self):
        """
        See documentation for Col_block
        """
        return self.Col_block

    @property
    def Calc_condition_number(self):
        """
        See documentation for Calc_cond_num
        """
        return self.Calc_cond_num

    @Number_proc.setter
    def Number_proc(self, value):
        self.Group_size = value

    @Row_block_size.setter
    def Row_block_size(self, value):
        self.Row_block = value

    @Col_block_size.setter
    def Col_block_size(self, value):
        self.Col_block = value

    @Calc_condition_number.setter
    def Calc_condition_number(self, value):
        self.Calc_cond_num = value



class _wf_correlation3(printable):
    """
    Sets up the Wavefunction-based Correlation parameters if requested
    """
    def __init__(self):
        self.Method = None
        """
        Which method should be used to compute the MP2 energy

        Available values:
            NONE
                Skip MP2 calculation
            DIRECT_CANONICAL
                Use the direct mp2 canonical approach
            MP2_GPW
                Use the GPW approach to MP2
            RI_MP2_GPW
                Use the GPW approach to RI-MP2
            RI_RPA_GPW
                Use the GPW approach to RI-RPA
            RI_SOS_LAPLACE
                Use the GPW approach to RI-SOS-Laplace-MP2
        """
        self.Memory = None
        """
        Maximum allowed total memory usage during MP2 methods [Mb].
        """
        self.Scale_s = None
        """
        Scaling factor of the singlet energy component (opposite spin, OS).
        """
        self.Scale_t = None
        """
        Scaling factor of the triplet energy component (same spin, SS).
        """
        self.Group_size = None
        """
        Group size used in the computation of the integrals. Default is to use
        all processors (GROUP_SIZE=-1).A smaller group size (for example the
        node size), might a better choice if the actual MP2 time is large
        compared to integral computation time. This is usually the case if the
        total number of processors is not too large.
        """
        self.Row_block = None
        """
        Size of the row block used in the SCALAPACK block cyclic data
        distribution.Default is (ROW_BLOCK=-1) is automatic. A proper choice
        can speedup the parallel matrix multiplication in the case of RI-RPA
        and RI-SOS-MP2-Laplace.
        """
        self.Col_block = None
        """
        Size of the column block used in the SCALAPACK block cyclic data
        distribution.Default is (COL_BLOCK=-1) is automatic. A proper choice
        can speedup the parallel matrix multiplication in the case of RI-RPA
        and RI-SOS-MP2-Laplace.
        """
        self.Calc_cond_num = None
        """
        Calculate the condition number of the (P|Q) matrix for the RI methods.
        """
        self.MP2_INFO = _mp2_info3()
        self.DIRECT_CANONICAL = _direct_canonical3()
        self.WFC_GPW = _wfc_gpw3()
        self.RI_MP2 = _ri_mp23()
        self.RI_RPA = _ri_rpa3()
        self.RI_LAPLACE = _ri_laplace3()
        self.INTERACTION_POTENTIAL = _interaction_potential9()
        self._name = "WF_CORRELATION"
        self._keywords = [('Method', 'METHOD'), ('Memory', 'MEMORY'), ('Scale_s', 'SCALE_S'), ('Scale_t', 'SCALE_T'), ('Group_size', 'GROUP_SIZE'), ('Row_block', 'ROW_BLOCK'), ('Col_block', 'COL_BLOCK'), ('Calc_cond_num', 'CALC_COND_NUM')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('MP2_INFO', 'MP2_INFO'), ('DIRECT_CANONICAL', 'DIRECT_CANONICAL'), ('WFC_GPW', 'WFC_GPW'), ('RI_MP2', 'RI_MP2'), ('RI_RPA', 'RI_RPA'), ('RI_LAPLACE', 'RI_LAPLACE'), ('INTERACTION_POTENTIAL', 'INTERACTION_POTENTIAL')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Number_proc(self):
        """
        See documentation for Group_size
        """
        return self.Group_size

    @property
    def Row_block_size(self):
        """
        See documentation for Row_block
        """
        return self.Row_block

    @property
    def Col_block_size(self):
        """
        See documentation for Col_block
        """
        return self.Col_block

    @property
    def Calc_condition_number(self):
        """
        See documentation for Calc_cond_num
        """
        return self.Calc_cond_num

    @Number_proc.setter
    def Number_proc(self, value):
        self.Group_size = value

    @Row_block_size.setter
    def Row_block_size(self, value):
        self.Row_block = value

    @Col_block_size.setter
    def Col_block_size(self, value):
        self.Col_block = value

    @Calc_condition_number.setter
    def Calc_condition_number(self, value):
        self.Calc_cond_num = value



class _each184(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each187(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _tpss1(printable):
    """
    Uses the TPSS functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Scale_c = None
        """
        scales the correlation part of the functional
        """
        self._name = "TPSS"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Scale_c', 'SCALE_C')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _tpss3(printable):
    """
    Uses the TPSS functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Scale_c = None
        """
        scales the correlation part of the functional
        """
        self._name = "TPSS"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Scale_c', 'SCALE_C')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _tpss2(printable):
    """
    Uses the TPSS functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Scale_c = None
        """
        scales the correlation part of the functional
        """
        self._name = "TPSS"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Scale_c', 'SCALE_C')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _tpss4(printable):
    """
    Uses the TPSS functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Scale_c = None
        """
        scales the correlation part of the functional
        """
        self._name = "TPSS"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Scale_c', 'SCALE_C')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _stress_tensor1(printable):
    """
    Controls the printing of the stress tensor
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Ndigits = None
        """
        Specifies the number of digits used for the printing of the stress
        tensor
        """
        self.EACH = _each342()
        self._name = "STRESS_TENSOR"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Ndigits', 'NDIGITS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print46(printable):
    """
    Controls the printing of the colvar specifications
    """
    def __init__(self):
        self.PROGRAM_RUN_INFO = _program_run_info38()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _exclude_vdw_list1(printable):
    """
    Speficy bonds (via atom kinds) for fine tuning of 1-2 exclusion lists.
    If this section is not present the 1-2 exclusion is applied to all
    bond kinds. When this section is present the 1-2 exclusion is applied
    ONLY to the bonds defined herein. This section allows ONLY fine tuning
    of 1-2 interactions.
    """
    def __init__(self):
        self.Bond = None
        """
        Specify the atom kinds involved in the bond for which 1-2 exclusion
        holds.
        """
        self._name = "EXCLUDE_VDW_LIST"
        self._keywords = [('Bond', 'BOND')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _outer_scf1(printable):
    """
    parameters controlling the outer SCF loop
    """
    def __init__(self):
        self.Section_parameters = None
        """
        controls the activation of the outer SCF loop
        """
        self.Type = None
        """
        Specifies which kind of outer SCF should be employed

        Available values:
            DDAPC_CONSTRAINT
                Enforce a constraint on the DDAPC, requires the corresponding section
            S2_CONSTRAINT
                Enforce a constraint on the S2, requires the corresponding section
            BECKE_CONSTRAINT
                Enforce a constraint on the Becke weight population,requires the
                corresponding section
            SCP
                Enforce outer loop optimization for SCP, requires the corresponding
                metod (-DFT or -NDDO)
            NONE
                Do nothing in the outer loop, useful for resetting the inner loop,
        """
        self.Optimizer = None
        """
        Method used to bring the outer loop to a stationary point

        Available values:
            SD
                Takes steps in the direction of the gradient, multiplied by step_size
            DIIS
                Uses a Direct Inversion in the Iterative Subspace method
            NONE
                Do nothing, useful only with the none type
            BISECT
                Bisection on the gradient, useful for difficult one dimensional cases
        """
        self.Bisect_trust_count = None
        """
        Maximum number of times the same point will be used in bisection, a
        small number guards against the effect of wrongly converged states.
        """
        self.Eps_scf = None
        """
        The target gradient of the outer scf variables. Notice that the
        EPS_SCF of the inner loop also determines the value that can be
        reached in the outer loop, typically EPS_SCF of the outer loop must be
        smaller than EPS_SCF of the inner loop.
        """
        self.Diis_buffer_length = None
        """
        Maximum number of DIIS vectors used
        """
        self.Extrapolation_order = None
        """
        Number of past states used in the extrapolation of the variables
        during e.g. MD
        """
        self.Max_scf = None
        """
        The maximum number of outer loops
        """
        self.Step_size = None
        """
        The initial step_size used in the optimizer (currently steepest
        descent).Note that in cases where a sadle point is sought for
        (DDAPC_CONSTRAINT), this can be negative
        """
        self._name = "OUTER_SCF"
        self._keywords = [('Type', 'TYPE'), ('Optimizer', 'OPTIMIZER'), ('Bisect_trust_count', 'BISECT_TRUST_COUNT'), ('Eps_scf', 'EPS_SCF'), ('Diis_buffer_length', 'DIIS_BUFFER_LENGTH'), ('Extrapolation_order', 'EXTRAPOLATION_ORDER'), ('Max_scf', 'MAX_SCF'), ('Step_size', 'STEP_SIZE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _dump_psf1(printable):
    """
    controls the dumping of the PSF connectivity
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each268()
        self._name = "DUMP_PSF"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _point44(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _cs13(printable):
    """
    Uses the CS1 functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self._name = "CS1"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _cs12(printable):
    """
    Uses the CS1 functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self._name = "CS1"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _cs11(printable):
    """
    Uses the CS1 functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self._name = "CS1"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _training_files1(printable):
    """
    specicifies the location in which the files necessary for fitting
    procedure are located. Each Training set needs a reptition of this
    section.
    """
    def __init__(self):
        self.Directory = None
        """
        the directory in which the files are placed
        """
        self.Input_file_name = None
        """
        the filename of the input file used to run the original calcuation
        """
        self._name = "TRAINING_FILES"
        self._keywords = [('Directory', 'DIRECTORY'), ('Input_file_name', 'INPUT_FILE_NAME')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _cs14(printable):
    """
    Uses the CS1 functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self._name = "CS1"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _optimize_basis1(printable):
    """
    describes a basis optimization job, in which an ADMM like approach is
    used to find the best exponents and/or coefficients to match a given
    training set.
    """
    def __init__(self):
        self.Basis_template_file = None
        """
        Name of the basis set file, containing the structure of the new basis
        set
        """
        self.Basis_work_file = None
        """
        Name of the basis set file which is created to be read as initial
        guess
        """
        self.Basis_output_file = None
        """
        Name of the basis set file containing the optimized basis
        """
        self.Write_frequency = None
        """
        Frequency at which the intermediate results should be written
        """
        self.Use_condition_number = None
        """
        Determines whether condition number should be part of optimization or
        not
        """
        self.list_Basis_combinations = []
        self.list_Residuum_weight = []
        self.list_Condition_weight = []
        self.list_Group_partition = []
        self.list_FIT_KIND = []
        self.list_TRAINING_FILES = []
        self.OPTIMIZATION = _optimization1()
        self._name = "OPTIMIZE_BASIS"
        self._keywords = [('Basis_template_file', 'BASIS_TEMPLATE_FILE'), ('Basis_work_file', 'BASIS_WORK_FILE'), ('Basis_output_file', 'BASIS_OUTPUT_FILE'), ('Write_frequency', 'WRITE_FREQUENCY'), ('Use_condition_number', 'USE_CONDITION_NUMBER')]
        self._repeated_keywords = [('Basis_combinations', 'BASIS_COMBINATIONS'), ('Residuum_weight', 'RESIDUUM_WEIGHT'), ('Condition_weight', 'CONDITION_WEIGHT'), ('Group_partition', 'GROUP_PARTITION')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('OPTIMIZATION', 'OPTIMIZATION')]
        self._repeated_subsections = [('FIT_KIND', '_fit_kind1'), ('TRAINING_FILES', '_training_files1')]

    def add_FIT_KIND(self):
        new_section = _fit_kind1()
        self.list_FIT_KIND.append(new_section)
        return new_section

    def add_TRAINING_FILES(self):
        new_section = _training_files1()
        self.list_TRAINING_FILES.append(new_section)
        return new_section

    def add_Basis_combinations(self, value):
        self.list_Basis_combinations.append(value)

    def add_Residuum_weight(self, value):
        self.list_Residuum_weight.append(value)

    def add_Condition_weight(self, value):
        self.list_Condition_weight.append(value)

    def add_Group_partition(self, value):
        self.list_Group_partition.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _print41(printable):
    """
    Section of possible print options in BSSE code.
    """
    def __init__(self):
        self.PROGRAM_RUN_INFO = _program_run_info34()
        self.RESTART = _restart9()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('RESTART', 'RESTART')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _metadyn1(printable):
    """
    This section sets parameters to set up a calculation of metadynamics.
    """
    def __init__(self):
        self.Use_plumed = None
        """
        Specify whether to use plumed as an external metadynamics driver.
        """
        self.Plumed_input_file = None
        """
        Specify the file name of the external plumed input file
        """
        self.Min_nt_hills = None
        """
        Specify the minimum MD step interval between spawning two hills. If
        specified, it must be >= than NT_HILLS. In case MIN_DISP is used, if
        MIN_DISP is satisfied before MIN_NT_HILLS MD steps have been
        performed, the MD will continue without any spawning until
        MIN_NT_HILLS is reached. The default value has the net effect of
        skipping this check.
        """
        self.Nt_hills = None
        """
        Specify the maximum MD step interval between spawning two hills. When
        negative, no new hills are spawned and only the hills read from
        SPAWNED_HILLS_* are in effect. The latteris useful when one wants to
        add a custom constant bias potential.
        """
        self.Temperature = None
        """
        If a Lagrangian scheme is used the temperature for the collective
        variables is specified.
        """
        self.Min_disp = None
        """
        Minimum displacement between hills before placing a new hill.
        """
        self.Old_hill_number = None
        """
        Index of the last hill spawned for this walker.Needed to calculate
        MIN_DISP
        """
        self.Old_hill_step = None
        """
        Timestep of the last hill spawned for this walker.Needed to calculate
        MIN_DISP
        """
        self.Hill_tail_cutoff = None
        """
        By setting this variable larger than 0 the tail of the Gaussian hill
        is damped to zero faster. The Gaussian function is multiplied by a
        cutoff function that becomes active at |x-X0|>HILL_TAIL_CUTOFF*SCALE,
        where X0 is the location of the Gaussian and SCALE is the width of the
        Gaussian. For more than one METAVAR X0 and SCALE are METAVAR-
        dependent.  (1-(|x-X0|/HILL_TAIL_CUTOFF*SCALE)^P_EXP)/(1-(|x-X0|/HILL_
        TAIL_CUTOFF*SCALE)^Q_EXP)
        """
        self.P_exponent = None
        """
        Exponent at the numerator of the cutoff function to damp the tail of
        the Gaussian.
        """
        self.Q_exponent = None
        """
        Exponent at the denominator of the cutoff function to damp the tail of
        the Gaussian.
        """
        self.Slow_growth = None
        """
        Let the last hill grow slowly over NT_HILLS.
        """
        self.Temp_tol = None
        """
        If a Lagrangian scheme is used the temperature tolerance for the
        collective variables is specified.
        """
        self.Langevin = None
        """
        If a Lagrangian scheme is used the eq. motion of the COLVARS are
        integrated with a LANGEVIN scheme.
        """
        self.Ww = None
        """
        Specifies the height of the gaussian to spawn. Default 0.1 .
        """
        self.Do_hills = None
        """
        This keyword enables the spawning of the hills. Default .FALSE.
        """
        self.Well_tempered = None
        """
        This keyword enables Well-tempered metadynamics. Default .FALSE.
        """
        self.Delta_t = None
        """
        If Well-tempered metaD is used, the temperature parameter must be
        specified.
        """
        self.Wtgamma = None
        """
        If Well-tempered metaD is used, the gamma parameter must be specified
        if not DELTA_T.
        """
        self.Lagrange = None
        """
        Specifies whether an extended-lagrangian should be used. Default
        .FALSE.
        """
        self.Step_start_val = None
        """
        The starting step value for metadynamics
        """
        self.Nhills_start_val = None
        """
        The starting value of previously spawned hills
        """
        self.Colvar_avg_temperature_restart = None
        """
        COLVAR average temperature. Only for restarting purposes.
        """
        self.Tamcsteps = None
        """
        Number of sampling points for z
        """
        self.Timestep = None
        """
        The length of an integration step for colvars (TAMC only)
        """
        self.list_METAVAR = []
        self.MULTIPLE_WALKERS = _multiple_walkers1()
        self.list_PRINT = []
        self.SPAWNED_HILLS_POS = _spawned_hills_pos1()
        self.SPAWNED_HILLS_SCALE = _spawned_hills_scale1()
        self.SPAWNED_HILLS_HEIGHT = _spawned_hills_height1()
        self.SPAWNED_HILLS_INVDT = _spawned_hills_invdt1()
        self.EXT_LAGRANGE_SS0 = _ext_lagrange_ss01()
        self.EXT_LAGRANGE_VVP = _ext_lagrange_vvp1()
        self.EXT_LAGRANGE_SS = _ext_lagrange_ss1()
        self.EXT_LAGRANGE_FS = _ext_lagrange_fs1()
        self._name = "METADYN"
        self._keywords = [('Use_plumed', 'USE_PLUMED'), ('Plumed_input_file', 'PLUMED_INPUT_FILE'), ('Min_nt_hills', 'MIN_NT_HILLS'), ('Nt_hills', 'NT_HILLS'), ('Temperature', 'TEMPERATURE'), ('Min_disp', 'MIN_DISP'), ('Old_hill_number', 'OLD_HILL_NUMBER'), ('Old_hill_step', 'OLD_HILL_STEP'), ('Hill_tail_cutoff', 'HILL_TAIL_CUTOFF'), ('P_exponent', 'P_EXPONENT'), ('Q_exponent', 'Q_EXPONENT'), ('Slow_growth', 'SLOW_GROWTH'), ('Temp_tol', 'TEMP_TOL'), ('Langevin', 'LANGEVIN'), ('Ww', 'WW'), ('Do_hills', 'DO_HILLS'), ('Well_tempered', 'WELL_TEMPERED'), ('Delta_t', 'DELTA_T'), ('Wtgamma', 'WTGAMMA'), ('Lagrange', 'LAGRANGE'), ('Step_start_val', 'STEP_START_VAL'), ('Nhills_start_val', 'NHILLS_START_VAL'), ('Colvar_avg_temperature_restart', 'COLVAR_AVG_TEMPERATURE_RESTART'), ('Tamcsteps', 'TAMCSTEPS'), ('Timestep', 'TIMESTEP')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('MULTIPLE_WALKERS', 'MULTIPLE_WALKERS'), ('SPAWNED_HILLS_POS', 'SPAWNED_HILLS_POS'), ('SPAWNED_HILLS_SCALE', 'SPAWNED_HILLS_SCALE'), ('SPAWNED_HILLS_HEIGHT', 'SPAWNED_HILLS_HEIGHT'), ('SPAWNED_HILLS_INVDT', 'SPAWNED_HILLS_INVDT'), ('EXT_LAGRANGE_SS0', 'EXT_LAGRANGE_SS0'), ('EXT_LAGRANGE_VVP', 'EXT_LAGRANGE_VVP'), ('EXT_LAGRANGE_SS', 'EXT_LAGRANGE_SS'), ('EXT_LAGRANGE_FS', 'EXT_LAGRANGE_FS')]
        self._repeated_subsections = [('METAVAR', '_metavar1'), ('PRINT', '_print13')]

    def add_METAVAR(self):
        new_section = _metavar1()
        self.list_METAVAR.append(new_section)
        return new_section

    def add_PRINT(self):
        new_section = _print13()
        self.list_PRINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _point54(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _print42(printable):
    """
    Section of possible print options in GENERATE code.
    """
    def __init__(self):
        self.NEIGHBOR_LISTS = _neighbor_lists9()
        self.SUBCELL = _subcell5()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('NEIGHBOR_LISTS', 'NEIGHBOR_LISTS'), ('SUBCELL', 'SUBCELL')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _exchange1(printable):
    """
    Setup parameters for the evaluation of the EXCHANGE and  core
    Hamiltonian terms in SE calculations.
    """
    def __init__(self):
        self.Cutoff = None
        """
        Atomic Cutoff Radius Cutoff for the evaluation of the Exchange
        integrals. For non-periodic calculation the default value is exactly
        the full cell dimension, in order to evaluate all pair interactions.
        Instead, for periodic calculations the default is the minimum value
        between 1/4 of the cell dimension and the value specified in input
        (either explicitly defined or the default numerical value).
        """
        self.Rc_taper = None
        """
        Atomic Cutoff Radius Cutoff for Tapering Exchange integrals. If not
        specified it assumes the same value specified for the CUTOFF.
        """
        self.Rc_range = None
        """
        Range of cutoff switch function (tapering):
        0.5*(1-TANH((r-r0)/RC_RANGE)), where r0=2.0*RC_TAPER-20.0*RC_RANGE.
        """
        self._name = "EXCHANGE"
        self._keywords = [('Cutoff', 'CUTOFF'), ('Rc_taper', 'RC_TAPER'), ('Rc_range', 'RC_RANGE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each337(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info23(printable):
    """
    Controls the printing basic info about the method
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each142()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info22(printable):
    """
    controls the printing of ewald setup
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each141()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info21(printable):
    """
    Controls the printing of basic information during the run
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each140()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info20(printable):
    """
    Controls the printing of information on the HFX RI approximation
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each134()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info27(printable):
    """
    Controls the printing basic info about the method
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each165()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info26(printable):
    """
    Controls the printing of basic iteration information in CLS
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each160()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info25(printable):
    """
    Controls the printing basic info about the method
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each144()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info24(printable):
    """
    Controls the printing of basic information during the run
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Condition_number = None
        """
        Prints information regarding the condition numbers of the A matrix (to
        be inverted)
        """
        self.EACH = _each143()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Condition_number', 'CONDITION_NUMBER')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info29(printable):
    """
    Controls the printing of basic information during the run
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each220()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info28(printable):
    """
    Controls the printing within real time propagation and Eherenfest
    dynamics
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each176()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each49(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each48(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each43(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each42(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each41(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each40(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each47(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each46(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each45(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each44(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print28(printable):
    """
    Print results of a HFX RI calculation
    """
    def __init__(self):
        self.PROGRAM_RUN_INFO = _program_run_info20()
        self.GEMINAL_BASIS = _geminal_basis4()
        self.CHARGE = _charge4()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('GEMINAL_BASIS', 'GEMINAL_BASIS'), ('CHARGE', 'CHARGE')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print29(printable):
    """
    Controls printing of Ewald properties
    """
    def __init__(self):
        self.PROGRAM_RUN_INFO = _program_run_info22()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print26(printable):
    """
    Print results of a HFX RI calculation
    """
    def __init__(self):
        self.PROGRAM_RUN_INFO = _program_run_info19()
        self.GEMINAL_BASIS = _geminal_basis3()
        self.CHARGE = _charge3()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('GEMINAL_BASIS', 'GEMINAL_BASIS'), ('CHARGE', 'CHARGE')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print27(printable):
    """
    Controls the printing of info about load balance
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Load_balance_info = None
        """
        Activates the printing of load balance information
        """
        self.EACH = _each133()
        self._name = "PRINT"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Load_balance_info', 'LOAD_BALANCE_INFO')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print24(printable):
    """
    Print results of a HFX RI calculation
    """
    def __init__(self):
        self.PROGRAM_RUN_INFO = _program_run_info18()
        self.GEMINAL_BASIS = _geminal_basis2()
        self.CHARGE = _charge2()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('GEMINAL_BASIS', 'GEMINAL_BASIS'), ('CHARGE', 'CHARGE')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print25(printable):
    """
    Controls the printing of info about load balance
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Load_balance_info = None
        """
        Activates the printing of load balance information
        """
        self.EACH = _each127()
        self._name = "PRINT"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Load_balance_info', 'LOAD_BALANCE_INFO')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print22(printable):
    """
    Print results of a HFX RI calculation
    """
    def __init__(self):
        self.PROGRAM_RUN_INFO = _program_run_info17()
        self.GEMINAL_BASIS = _geminal_basis1()
        self.CHARGE = _charge1()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('GEMINAL_BASIS', 'GEMINAL_BASIS'), ('CHARGE', 'CHARGE')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print23(printable):
    """
    Controls the printing of info about load balance
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Load_balance_info = None
        """
        Activates the printing of load balance information
        """
        self.EACH = _each120()
        self._name = "PRINT"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Load_balance_info', 'LOAD_BALANCE_INFO')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print20(printable):
    """
    Section of possible print options in SE code.
    """
    def __init__(self):
        self.NEIGHBOR_LISTS = _neighbor_lists3()
        self.SUBCELL = _subcell1()
        self.EWALD_INFO = _ewald_info1()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('NEIGHBOR_LISTS', 'NEIGHBOR_LISTS'), ('SUBCELL', 'SUBCELL'), ('EWALD_INFO', 'EWALD_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print21(printable):
    """
    Controls the printing of info about load balance
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Load_balance_info = None
        """
        Activates the printing of load balance information
        """
        self.EACH = _each114()
        self._name = "PRINT"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Load_balance_info', 'LOAD_BALANCE_INFO')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _optimization2(printable):
    """
    Section of information on optimization thresholds and algorithms.
    """
    def __init__(self):
        self.Max_iter = None
        """
        Maximum number of iterations for optimization
        """
        self.Eps_scf = None
        """
        Convergence criterion for SCF
        """
        self.Damping = None
        """
        Damping parameter for extrapolation method
        """
        self.Eps_diis = None
        """
        Starting DIIS method at convergence to EPS_DIIS
        """
        self.N_diis = None
        """
        Maximum number of DIIS vectors
        """
        self._name = "OPTIMIZATION"
        self._keywords = [('Max_iter', 'MAX_ITER'), ('Eps_scf', 'EPS_SCF'), ('Damping', 'DAMPING'), ('Eps_diis', 'EPS_DIIS'), ('N_diis', 'N_DIIS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _optimization1(printable):
    """
    sets the parameters for optimizition, output frequency and restarts
    """
    def __init__(self):
        self.Accuracy = None
        """
        Final accuracy requested in optimization (RHOEND)
        """
        self.Step_size = None
        """
        Initial step size for search algorithm (RHOBEG)
        """
        self.Max_fun = None
        """
        Maximum number of function evaluations
        """
        self._name = "OPTIMIZATION"
        self._keywords = [('Accuracy', 'ACCURACY'), ('Step_size', 'STEP_SIZE'), ('Max_fun', 'MAX_FUN')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _debug1(printable):
    """
    Section to setup parameters for debug runs.
    """
    def __init__(self):
        self.Debug_forces = None
        """
        Enables  the debug of the forces.
        """
        self.Debug_stress_tensor = None
        """
        Enables the debug of the stress tensor
        """
        self.Dx = None
        """
         Setup the DX parameter to evaluate numerical derivatives
        """
        self.PROGRAM_RUN_INFO = _program_run_info3()
        self._name = "DEBUG"
        self._keywords = [('Debug_forces', 'DEBUG_FORCES'), ('Debug_stress_tensor', 'DEBUG_STRESS_TENSOR'), ('Dx', 'DX')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _xgga2(printable):
    """
    Uses one of the XGGA functionals (optimized versions of some of these
    functionals might be available outside this section).
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Functional = None
        """
        Which one of the XGGA functionals should be used

        Available values:
            BECKE88X
            PW86X
            PW91X
            PBEX
            REV_PBEX
            OPTX
            EV93
        """
        self._name = "XGGA"
        self._keywords = [('Functional', 'FUNCTIONAL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _xgga3(printable):
    """
    Uses one of the XGGA functionals (optimized versions of some of these
    functionals might be available outside this section).
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Functional = None
        """
        Which one of the XGGA functionals should be used

        Available values:
            BECKE88X
            PW86X
            PW91X
            PBEX
            REV_PBEX
            OPTX
            EV93
        """
        self._name = "XGGA"
        self._keywords = [('Functional', 'FUNCTIONAL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _xgga1(printable):
    """
    Uses one of the XGGA functionals (optimized versions of some of these
    functionals might be available outside this section).
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Functional = None
        """
        Which one of the XGGA functionals should be used

        Available values:
            BECKE88X
            PW86X
            PW91X
            PBEX
            REV_PBEX
            OPTX
            EV93
        """
        self._name = "XGGA"
        self._keywords = [('Functional', 'FUNCTIONAL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _xgga4(printable):
    """
    Uses one of the XGGA functionals (optimized versions of some of these
    functionals might be available outside this section).
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Functional = None
        """
        Which one of the XGGA functionals should be used

        Available values:
            BECKE88X
            PW86X
            PW91X
            PBEX
            REV_PBEX
            OPTX
            EV93
        """
        self._name = "XGGA"
        self._keywords = [('Functional', 'FUNCTIONAL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _mm_potential1(printable):
    """
    Controls the printing of the MM unidimensional potential on file
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each243()
        self._name = "MM_POTENTIAL"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _pbe_hole_t_c_lr2(printable):
    """
    PBE exchange hole model in trucanted coulomb potential
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Cutoff_radius = None
        """
        Defines cutoff for lower integration boundary
        """
        self._name = "PBE_HOLE_T_C_LR"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Cutoff_radius', 'CUTOFF_RADIUS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _qs_derivatives1(printable):
    """
    Print QM derivatives after QS calculation
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each252()
        self._name = "QS_DERIVATIVES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _pbe_hole_t_c_lr1(printable):
    """
    PBE exchange hole model in trucanted coulomb potential
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Cutoff_radius = None
        """
        Defines cutoff for lower integration boundary
        """
        self._name = "PBE_HOLE_T_C_LR"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Cutoff_radius', 'CUTOFF_RADIUS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _v_hartree_cube1(printable):
    """
    Controls the printing of a cube file with eletrostatic  potential
    generated by the total density (electrons+ions). It is  valid only for
    QS with GPW formalism .
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Stride = None
        """
        The stride (X,Y,Z) used to write the cube file (larger values result
        in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1
        number valid for all components.
        """
        self.Append = None
        """
        append the cube files when they already exist
        """
        self.EACH = _each194()
        self._name = "V_HARTREE_CUBE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Stride', 'STRIDE'), ('Append', 'APPEND')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _pbe_hole_t_c_lr4(printable):
    """
    PBE exchange hole model in trucanted coulomb potential
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Cutoff_radius = None
        """
        Defines cutoff for lower integration boundary
        """
        self._name = "PBE_HOLE_T_C_LR"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Cutoff_radius', 'CUTOFF_RADIUS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _plength1(printable):
    """
    Controls the output of the helium permutation length
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each55()
        self._name = "PLENGTH"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _fix_atom_restart1(printable):
    """
    Specify restart position only for FIXED_ATOMS restraints.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        The restarting position of fixed atoms for restraints. The order is an
        internal order. So if you decide to modify these values by hand first
        think what you're doing!
        """
        self._name = "FIX_ATOM_RESTART"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _xray_diffraction_spectrum1(printable):
    """
    Calculate and print the coherent X-ray diffraction spectrum
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Q_max = None
        """
        Maximum Q value calculated for the spectrum
        """
        self.EACH = _each211()
        self._name = "XRAY_DIFFRACTION_SPECTRUM"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Q_max', 'Q_MAX')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Q_maximum(self):
        """
        See documentation for Q_max
        """
        return self.Q_max

    @Q_maximum.setter
    def Q_maximum(self, value):
        self.Q_max = value



class _bonds1(printable):
    """
    Defines new bonds
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Two integer indexes per line defining the new bond. Indexes must be
        relative to the full system and not to the single molecules
        """
        self._name = "BONDS"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _image_charge_info1(printable):
    """
    Prints image charge coefficients and detailed energy info
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each253()
        self._name = "IMAGE_CHARGE_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _pw924(printable):
    """
    Uses the PerdewWang correlation functional.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale = None
        """
        Scaling of the energy functional
        """
        self.Parametrization = None
        """
        Which one of parametrizations should be used

        Available values:
            ORIGINAL
            DMC
            VMC
        """
        self._name = "PW92"
        self._keywords = [('Scale', 'SCALE'), ('Parametrization', 'PARAMETRIZATION')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _pw921(printable):
    """
    Uses the PerdewWang correlation functional.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale = None
        """
        Scaling of the energy functional
        """
        self.Parametrization = None
        """
        Which one of parametrizations should be used

        Available values:
            ORIGINAL
            DMC
            VMC
        """
        self._name = "PW92"
        self._keywords = [('Scale', 'SCALE'), ('Parametrization', 'PARAMETRIZATION')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _pw923(printable):
    """
    Uses the PerdewWang correlation functional.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale = None
        """
        Scaling of the energy functional
        """
        self.Parametrization = None
        """
        Which one of parametrizations should be used

        Available values:
            ORIGINAL
            DMC
            VMC
        """
        self._name = "PW92"
        self._keywords = [('Scale', 'SCALE'), ('Parametrization', 'PARAMETRIZATION')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _pw922(printable):
    """
    Uses the PerdewWang correlation functional.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale = None
        """
        Scaling of the energy functional
        """
        self.Parametrization = None
        """
        Which one of parametrizations should be used

        Available values:
            ORIGINAL
            DMC
            VMC
        """
        self._name = "PW92"
        self._keywords = [('Scale', 'SCALE'), ('Parametrization', 'PARAMETRIZATION')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _ramp_env1(printable):
    """
    Parameters for an trapeziodal envelop
    """
    def __init__(self):
        self.Start_step_in = None
        """
        Step when the electric field starts to be applied
        """
        self.End_step_in = None
        """
        Step when the field reaches the full strength
        """
        self.Start_step_out = None
        """
        Step when the field starts to vanish
        """
        self.End_step_out = None
        """
        Step when the field disappears
        """
        self._name = "RAMP_ENV"
        self._keywords = [('Start_step_in', 'START_STEP_IN'), ('End_step_in', 'END_STEP_IN'), ('Start_step_out', 'START_STEP_OUT'), ('End_step_out', 'END_STEP_OUT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _shell2(printable):
    """
    This section specifies the parameters for shell-model potentials
    """
    def __init__(self):
        self.Section_parameters = None
        """
        The kind for which the shell potential parameters are given
        """
        self.Core_charge = None
        """
        Partial charge assigned to the core (electron charge units)
        """
        self.Shell_charge = None
        """
        Partial charge assigned to the shell (electron charge units)
        """
        self.Mass_fraction = None
        """
        Fraction of the mass of the atom to be assigned to the shell
        """
        self.K2_spring = None
        """
        Force constant k2 of the spring potential 1/2*k2*r^2 + 1/24*k4*r^4
        binding a core-shell pair when a core-shell potential is employed.
        """
        self.K4_spring = None
        """
        Force constant k4 of the spring potential 1/2*k2*r^2 + 1/24*k4*r^4
        binding a core-shell pair when a core-shell potential is employed. By
        default a harmonic spring potential is used, i.e. k4 is zero.
        """
        self.Max_distance = None
        """
        Assign a maximum elongation of the spring, if negative no limit is
        imposed
        """
        self.Shell_cutoff = None
        """
        Define a screening function to exclude some neighbors  of the shell
        when electrostatic interaction are considered, if negative no
        screening is operated
        """
        self._name = "SHELL"
        self._keywords = [('Core_charge', 'CORE_CHARGE'), ('Shell_charge', 'SHELL_CHARGE'), ('Mass_fraction', 'MASS_FRACTION'), ('K2_spring', 'K2_SPRING'), ('K4_spring', 'K4_SPRING'), ('Max_distance', 'MAX_DISTANCE'), ('Shell_cutoff', 'SHELL_CUTOFF')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Core(self):
        """
        See documentation for Core_charge
        """
        return self.Core_charge

    @property
    def Shell(self):
        """
        See documentation for Shell_charge
        """
        return self.Shell_charge

    @property
    def Mass(self):
        """
        See documentation for Mass_fraction
        """
        return self.Mass_fraction

    @property
    def K2(self):
        """
        See documentation for K2_spring
        """
        return self.K2_spring

    @property
    def Spring(self):
        """
        See documentation for K2_spring
        """
        return self.K2_spring

    @property
    def K4(self):
        """
        See documentation for K4_spring
        """
        return self.K4_spring

    @Core.setter
    def Core(self, value):
        self.Core_charge = value

    @Shell.setter
    def Shell(self, value):
        self.Shell_charge = value

    @Mass.setter
    def Mass(self, value):
        self.Mass_fraction = value

    @K2.setter
    def K2(self, value):
        self.K2_spring = value

    @Spring.setter
    def Spring(self, value):
        self.K2_spring = value

    @K4.setter
    def K4(self, value):
        self.K4_spring = value



class _shell1(printable):
    """
    Parameters of shell model in adiabatic dynamics.
    """
    def __init__(self):
        self.Temperature = None
        """
        Temperature in K used to control the internal velocities of the core-
        shell motion
        """
        self.Temp_tol = None
        """
        Maximum accepted temperature deviation from the expected value, for
        the internal core-shell motion.If 0, no rescaling is performed
        """
        self.Nose_particle = None
        """
        If nvt or npt, the core and shell velocities are controlled by the
        same thermostat used for the particle. This might favour heat exchange
        and additional rescaling of the internal core-shell velocity is needed
        (TEMP_TOL)
        """
        self.Displacement_shell_tol = None
        """
        This keyword sets a maximum variation of the shell core distance in
        each Cartesian direction.The maximum internal core-shell velocity is
        evaluated and if it is too large to remainwithin the assigned limit,
        the time step is rescaled accordingly,and the first half step of the
        velocity verlet is repeated.
        """
        self.THERMOSTAT = _thermostat3()
        self._name = "SHELL"
        self._keywords = [('Temperature', 'TEMPERATURE'), ('Temp_tol', 'TEMP_TOL'), ('Nose_particle', 'NOSE_PARTICLE'), ('Displacement_shell_tol', 'DISPLACEMENT_SHELL_TOL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('THERMOSTAT', 'THERMOSTAT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _external_potential2(printable):
    """
    Section controlling the presence of an electrostatic external
    potential dependent on the atomic positions (X,Y,Z)
    """
    def __init__(self):
        self.Function = None
        """
        Specifies the functional form in mathematical notation. Variables must
        be the atomic coordinates (X,Y,Z) of the grid.
        """
        self.list_Parameters = []
        self.list_Values = []
        self.list_Units = []
        self.Static = None
        """
        Specifies the external potential as STATIC or time dependent. At the
        moment only static potentials are implemented.
        """
        self.Dx = None
        """
        Parameter used for computing the derivative with the Ridders method.
        """
        self.Error_limit = None
        """
        Checks that the error in computing the derivative is not larger than
        the value set. In case prints a warning message.
        """
        self._name = "EXTERNAL_POTENTIAL"
        self._keywords = [('Function', 'FUNCTION'), ('Static', 'STATIC'), ('Dx', 'DX'), ('Error_limit', 'ERROR_LIMIT')]
        self._repeated_keywords = [('Parameters', 'PARAMETERS'), ('Values', 'VALUES'), ('Units', 'UNITS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Parameters(self, value):
        self.list_Parameters.append(value)

    def add_Values(self, value):
        self.list_Values.append(value)

    def add_Units(self, value):
        self.list_Units.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _external_potential1(printable):
    """
    Section controlling the presence of an external potential dependent
    on the atomic positions (X,Y,Z)
    """
    def __init__(self):
        self.list_Atoms_list = []
        self.Function = None
        """
        Specifies the functional form in mathematical notation. Variables must
        be the atomic coordinates (X,Y,Z).
        """
        self.list_Parameters = []
        self.list_Values = []
        self.list_Units = []
        self.Dx = None
        """
        Parameter used for computing the derivative with the Ridders method.
        """
        self.Error_limit = None
        """
        Checks that the error in computing the derivative is not larger than
        the value set. In case prints a warning message.
        """
        self._name = "EXTERNAL_POTENTIAL"
        self._keywords = [('Function', 'FUNCTION'), ('Dx', 'DX'), ('Error_limit', 'ERROR_LIMIT')]
        self._repeated_keywords = [('Atoms_list', 'ATOMS_LIST'), ('Parameters', 'PARAMETERS'), ('Values', 'VALUES'), ('Units', 'UNITS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms_list(self, value):
        self.list_Atoms_list.append(value)

    def add_Parameters(self, value):
        self.list_Parameters.append(value)

    def add_Values(self, value):
        self.list_Values.append(value)

    def add_Units(self, value):
        self.list_Units.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _fit_kind1(printable):
    """
    specicifies the atomic kinds to be fitted and the basis sets
    associated with the kind.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        The name of the kind described in this section.
        """
        self.Basis_set = None
        """
        The name of the basis set for the kind. Has to be specified in
        BASIS_TEMPLATE_FILE.
        """
        self.Initial_degrees_of_freedom = None
        """
        Specifies the initial degrees of freedom in the basis
        optimization.This can be used to make further specifications easier

        Available values:
            ALL
                Set all parameters in the basis to be variable.
            NONE
                Set all parameters in the basis to be fixed.
            COEFFICIENTS
                Set all coefficients in the basis set to be variable.
            EXPONENTS
                Set all exponents in the basis to be variable.
        """
        self.list_Switch_coeff_state = []
        self.list_Switch_contraction_state = []
        self.list_Switch_exp_state = []
        self.list_Switch_set_state = []
        self.list_CONSTRAIN_EXPONENTS = []
        self.list_DERIVED_BASIS_SETS = []
        self._name = "FIT_KIND"
        self._keywords = [('Basis_set', 'BASIS_SET'), ('Initial_degrees_of_freedom', 'INITIAL_DEGREES_OF_FREEDOM')]
        self._repeated_keywords = [('Switch_coeff_state', 'SWITCH_COEFF_STATE'), ('Switch_contraction_state', 'SWITCH_CONTRACTION_STATE'), ('Switch_exp_state', 'SWITCH_EXP_STATE'), ('Switch_set_state', 'SWITCH_SET_STATE')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('CONSTRAIN_EXPONENTS', '_constrain_exponents1'), ('DERIVED_BASIS_SETS', '_derived_basis_sets1')]

    def add_CONSTRAIN_EXPONENTS(self):
        new_section = _constrain_exponents1()
        self.list_CONSTRAIN_EXPONENTS.append(new_section)
        return new_section

    def add_DERIVED_BASIS_SETS(self):
        new_section = _derived_basis_sets1()
        self.list_DERIVED_BASIS_SETS.append(new_section)
        return new_section

    def add_Switch_coeff_state(self, value):
        self.list_Switch_coeff_state.append(value)

    def add_Switch_contraction_state(self, value):
        self.list_Switch_contraction_state.append(value)

    def add_Switch_exp_state(self, value):
        self.list_Switch_exp_state.append(value)

    def add_Switch_set_state(self, value):
        self.list_Switch_set_state.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _farming1(printable):
    """
    describes a farming job, in which multiple inputs are executed
    """
    def __init__(self):
        self.Master_slave = None
        """
        If a master-slave setup should be employed, in which one process is
        used to distribute the tasks. This is most useful to load-balance if
        not all jobs have the same length, and a lot of CPUs/groups are
        availabe.
        """
        self.Ngroups = None
        """
        Gives the preferred number of working groups.
        """
        self.Group_size = None
        """
        Gives the preferred size of a working group, groups will always be
        equal or larger than this size.
        """
        self.Group_partition = None
        """
        gives the exact number of processors for each group.
        """
        self.Max_jobs_per_group = None
        """
        maximum number of jobs executed per group
        """
        self.Cycle = None
        """
        If farming should process all jobs in a cyclic way, stopping only if
        MAX_JOBS_PER_GROUP is exceeded.
        """
        self.Wait_time = None
        """
        Time to wait [s] for a new task if no task is currently available,
        make this zero if no clock is available
        """
        self.Do_restart = None
        """
        Restart a farming job (and should pick up where the previous left off)
        """
        self.Restart_file_name = None
        """
        Name of the restart file to use for restarting a FARMING run. If not
        specified the name is determined from PROJECT name.
        """
        self.list_JOB = []
        self.PROGRAM_RUN_INFO = _program_run_info50()
        self.RESTART = _restart11()
        self._name = "FARMING"
        self._keywords = [('Master_slave', 'MASTER_SLAVE'), ('Ngroups', 'NGROUPS'), ('Group_size', 'GROUP_SIZE'), ('Group_partition', 'GROUP_PARTITION'), ('Max_jobs_per_group', 'MAX_JOBS_PER_GROUP'), ('Cycle', 'CYCLE'), ('Wait_time', 'WAIT_TIME'), ('Do_restart', 'DO_RESTART'), ('Restart_file_name', 'RESTART_FILE_NAME')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('RESTART', 'RESTART')]
        self._repeated_subsections = [('JOB', '_job1')]

    def add_JOB(self):
        new_section = _job1()
        self.list_JOB.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Ngroup(self):
        """
        See documentation for Ngroups
        """
        return self.Ngroups

    @property
    def Max_jobs(self):
        """
        See documentation for Max_jobs_per_group
        """
        return self.Max_jobs_per_group

    @Ngroup.setter
    def Ngroup(self, value):
        self.Ngroups = value

    @Max_jobs.setter
    def Max_jobs(self, value):
        self.Max_jobs_per_group = value



class _dftb1(printable):
    """
    Parameters needed to set up the DFTB methods
    """
    def __init__(self):
        self.Self_consistent = None
        """
        Use self_consistent method
        """
        self.Orthogonal_basis = None
        """
        Assume orthogonal basis set
        """
        self.Do_ewald = None
        """
        Use Ewald type method instead of direct sum for Coulomb interaction
        """
        self.Dispersion = None
        """
        Use dispersion correction
        """
        self.Hb_sr_gamma = None
        """
        Uses a modified version for the GAMMA within the SCC-DFTB scheme,
        specifically tuned for hydrogen bonds.
        """
        self.Eps_disp = None
        """
        Define accuracy of dispersion interaction
        """
        self.PARAMETER = _parameter1()
        self._name = "DFTB"
        self._keywords = [('Self_consistent', 'SELF_CONSISTENT'), ('Orthogonal_basis', 'ORTHOGONAL_BASIS'), ('Do_ewald', 'DO_EWALD'), ('Dispersion', 'DISPERSION'), ('Hb_sr_gamma', 'HB_SR_GAMMA'), ('Eps_disp', 'EPS_DISP')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PARAMETER', 'PARAMETER')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _langevin1(printable):
    """
    Controls the set of parameters to run a Langevin MD
    """
    def __init__(self):
        self.Gamma = None
        """
        Gamma parameter for the Langevin dynamics (LD)
        """
        self.Noisy_gamma = None
        """
        Imaginary Langevin Friction term for LD with noisy forces.
        """
        self.Shadow_gamma = None
        """
        Shadow Langevin Friction term for LD with noisy forces in order to
        adjust Noisy_Gamma.
        """
        self._name = "LANGEVIN"
        self._keywords = [('Gamma', 'GAMMA'), ('Noisy_gamma', 'NOISY_GAMMA'), ('Shadow_gamma', 'SHADOW_GAMMA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Noisygamma(self):
        """
        See documentation for Noisy_gamma
        """
        return self.Noisy_gamma

    @property
    def Shadowgamma(self):
        """
        See documentation for Shadow_gamma
        """
        return self.Shadow_gamma

    @Noisygamma.setter
    def Noisygamma(self, value):
        self.Noisy_gamma = value

    @Shadowgamma.setter
    def Shadowgamma(self, value):
        self.Shadow_gamma = value



class _restart_history2(printable):
    """
    Dumps unique MO restart files during the run keeping all of them.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Backup_copies = None
        """
        Specifies the maximum index of backup copies.
        """
        self.EACH = _each92()
        self._name = "RESTART_HISTORY"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Backup_copies', 'BACKUP_COPIES')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _restart_history3(printable):
    """
    Dumps unique MO restart files during the run keeping all of them.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Backup_copies = None
        """
        Specifies the maximum index of backup copies.
        """
        self.EACH = _each178()
        self._name = "RESTART_HISTORY"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Backup_copies', 'BACKUP_COPIES')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _restart_history1(printable):
    """
    Dumps unique restart files during the run keeping all of them.Most
    useful if recovery is needed at a later point.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each87()
        self._name = "RESTART_HISTORY"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _pz813(printable):
    """
    Uses the PZ functional.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Parametrization = None
        """
        Which one of parametrizations should be used

        Available values:
            ORIGINAL
            DMC
            VMC
        """
        self.Scale_c = None
        """
        scales the correlation part of the functional
        """
        self._name = "PZ81"
        self._keywords = [('Parametrization', 'PARAMETRIZATION'), ('Scale_c', 'SCALE_C')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _qm_non_adaptive1(printable):
    """
    List of atoms always in QM region, non-adaptively
    """
    def __init__(self):
        self.list_QM_KIND = []
        self._name = "QM_NON_ADAPTIVE"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('QM_KIND', '_qm_kind1')]

    def add_QM_KIND(self):
        new_section = _qm_kind1()
        self.list_QM_KIND.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _epr1(printable):
    """
    The g tensor is calculated by DFPT
    """
    def __init__(self):
        self.Section_parameters = None
        """
        controls the activation of the epr calculation
        """
        self.Restart_epr = None
        """
        Restart the EPR calculation from a previous run (NOT WORKING)
        """
        self.PRINT = _print56()
        self.INTERPOLATOR = _interpolator11()
        self._name = "EPR"
        self._keywords = [('Restart_epr', 'RESTART_EPR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT', 'PRINT'), ('INTERPOLATOR', 'INTERPOLATOR')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _image_charge_restart1(printable):
    """
    Controls the printing of the restart file for the image matrix when
    using the iterative scheme
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each254()
        self._name = "IMAGE_CHARGE_RESTART"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _walkers_file_name1(printable):
    """
    Specify the basename for the NUMBER_OF_WALKERS files used to
    communicate between the walkers. Absolute path can be input as well
    together with the filename. One file will be created for each spawned
    hill.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specified the communication filename for each walker.
        """
        self._name = "WALKERS_FILE_NAME"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _cell_ref1(printable):
    """
    Input parameters needed to set up the CELL_REF.
    """
    def __init__(self):
        self.A = None
        """
        Specify the Cartesian components for the cell vector A. This defines
        the first column of the h matrix.
        """
        self.B = None
        """
        Specify the Cartesian components for the cell vector B. This defines
        the second column of the h matrix.
        """
        self.C = None
        """
        Specify the Cartesian components for the cell vector C. This defines
        the third column of the h matrix.
        """
        self.Abc = None
        """
        Specify the lengths of the cell vectors A, B, and C, which defines the
        diagonal elements of h matrix for an orthorhombic cell. For non-
        orthorhombic cells it is possible either to specify the angles ALPHA,
        BETA, GAMMA via ALPHA_BETA_GAMMA keyword or alternatively use the
        keywords A, B, and C. The convention is that A lies along the X-axis,
        B is in the XY plane.
        """
        self.Alpha_beta_gamma = None
        """
        Specify the angles between the vectors A, B and C when using the ABC
        keyword. The convention is that A lies along the X-axis, B is in the
        XY plane. ALPHA is the angle between B and C, BETA is the angle
        between A and C and GAMMA the angle between A and B.
        """
        self.Cell_file_name = None
        """
        Possibility to read the cell from an external file
        """
        self.Cell_file_format = None
        """
        Specify the format of the cell file (if used)

        Available values:
            CP2K
                Cell info in the CP2K native format.
            XSC
                Cell info in the XSC format (NAMD)
        """
        self.Periodic = None
        """
        Specify the directions for which periodic boundary conditions (PBC)
        will be applied. Important notice: This applies to the generation of
        the pair lists as well as to the application of the PBCs to positions.
        See the POISSON section to specify the periodicity used for the
        electrostatics. Typically the settings should be the same.

        Available values:
            X
            Y
            Z
            XY
            XZ
            YZ
            XYZ
            NONE
        """
        self.Multiple_unit_cell = None
        """
        Specifies the numbers of repetition in space (X, Y, Z) of the defined
        cell, assuming it as a unit cell. This keyword affects only the CELL
        specification. The same keyword in SUBSYS%TOPOLOGY%MULTIPLE_UNIT_CELL
        should be modified in order to affect the coordinates specification.
        """
        self.Symmetry = None
        """
        Imposes an initial cell symmetry.

        Available values:
            NONE
                No cell symmetry
            TRICLINIC
                Triclinic (a ≠ b ≠ c ≠ a, α ≠ β ≠ γ ≠ α ≠ 90°)
            MONOCLINIC
                Monoclinic (a ≠ b ≠ c ≠ a, α = γ = 90°, β ≠ 90°)
            ORTHORHOMBIC
                Orthorhombic (a ≠ b ≠ c, α = β = γ = 90°)
            TETRAGONAL_AB
                Tetragonal (a = b ≠ c, α = β = γ = 90°)
            TETRAGONAL_AC
                Tetragonal (a = c ≠ b, α = β = γ = 90°)
            TETRAGONAL_BC
                Tetragonal (a ≠ b = c, α = β = γ = 90°)
            TETRAGONAL
                Tetragonal (alias for TETRAGONAL_AB)
            RHOMBOHEDRAL
                Rhombohedral (a = b = c, α = β = γ ≠ 90°)
            HEXAGONAL
                Hexagonal (a = b ≠ c, α = β = 90°, γ = 60°)
            CUBIC
                Cubic (a = b = c, α = β = γ = 90°)
        """
        self._name = "CELL_REF"
        self._keywords = [('A', 'A'), ('B', 'B'), ('C', 'C'), ('Abc', 'ABC'), ('Alpha_beta_gamma', 'ALPHA_BETA_GAMMA'), ('Cell_file_name', 'CELL_FILE_NAME'), ('Cell_file_format', 'CELL_FILE_FORMAT'), ('Periodic', 'PERIODIC'), ('Multiple_unit_cell', 'MULTIPLE_UNIT_CELL'), ('Symmetry', 'SYMMETRY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Angles(self):
        """
        See documentation for Alpha_beta_gamma
        """
        return self.Alpha_beta_gamma

    @Angles.setter
    def Angles(self, value):
        self.Alpha_beta_gamma = value



class _cell_ref2(printable):
    """
    Input parameters needed to set up the CELL_REF.
    """
    def __init__(self):
        self.A = None
        """
        Specify the Cartesian components for the cell vector A. This defines
        the first column of the h matrix.
        """
        self.B = None
        """
        Specify the Cartesian components for the cell vector B. This defines
        the second column of the h matrix.
        """
        self.C = None
        """
        Specify the Cartesian components for the cell vector C. This defines
        the third column of the h matrix.
        """
        self.Abc = None
        """
        Specify the lengths of the cell vectors A, B, and C, which defines the
        diagonal elements of h matrix for an orthorhombic cell. For non-
        orthorhombic cells it is possible either to specify the angles ALPHA,
        BETA, GAMMA via ALPHA_BETA_GAMMA keyword or alternatively use the
        keywords A, B, and C. The convention is that A lies along the X-axis,
        B is in the XY plane.
        """
        self.Alpha_beta_gamma = None
        """
        Specify the angles between the vectors A, B and C when using the ABC
        keyword. The convention is that A lies along the X-axis, B is in the
        XY plane. ALPHA is the angle between B and C, BETA is the angle
        between A and C and GAMMA the angle between A and B.
        """
        self.Cell_file_name = None
        """
        Possibility to read the cell from an external file
        """
        self.Cell_file_format = None
        """
        Specify the format of the cell file (if used)

        Available values:
            CP2K
                Cell info in the CP2K native format.
            XSC
                Cell info in the XSC format (NAMD)
        """
        self.Periodic = None
        """
        Specify the directions for which periodic boundary conditions (PBC)
        will be applied. Important notice: This applies to the generation of
        the pair lists as well as to the application of the PBCs to positions.
        See the POISSON section to specify the periodicity used for the
        electrostatics. Typically the settings should be the same.

        Available values:
            X
            Y
            Z
            XY
            XZ
            YZ
            XYZ
            NONE
        """
        self.Multiple_unit_cell = None
        """
        Specifies the numbers of repetition in space (X, Y, Z) of the defined
        cell, assuming it as a unit cell. This keyword affects only the CELL
        specification. The same keyword in SUBSYS%TOPOLOGY%MULTIPLE_UNIT_CELL
        should be modified in order to affect the coordinates specification.
        """
        self.Symmetry = None
        """
        Imposes an initial cell symmetry.

        Available values:
            NONE
                No cell symmetry
            TRICLINIC
                Triclinic (a ≠ b ≠ c ≠ a, α ≠ β ≠ γ ≠ α ≠ 90°)
            MONOCLINIC
                Monoclinic (a ≠ b ≠ c ≠ a, α = γ = 90°, β ≠ 90°)
            ORTHORHOMBIC
                Orthorhombic (a ≠ b ≠ c, α = β = γ = 90°)
            TETRAGONAL_AB
                Tetragonal (a = b ≠ c, α = β = γ = 90°)
            TETRAGONAL_AC
                Tetragonal (a = c ≠ b, α = β = γ = 90°)
            TETRAGONAL_BC
                Tetragonal (a ≠ b = c, α = β = γ = 90°)
            TETRAGONAL
                Tetragonal (alias for TETRAGONAL_AB)
            RHOMBOHEDRAL
                Rhombohedral (a = b = c, α = β = γ ≠ 90°)
            HEXAGONAL
                Hexagonal (a = b ≠ c, α = β = 90°, γ = 60°)
            CUBIC
                Cubic (a = b = c, α = β = γ = 90°)
        """
        self._name = "CELL_REF"
        self._keywords = [('A', 'A'), ('B', 'B'), ('C', 'C'), ('Abc', 'ABC'), ('Alpha_beta_gamma', 'ALPHA_BETA_GAMMA'), ('Cell_file_name', 'CELL_FILE_NAME'), ('Cell_file_format', 'CELL_FILE_FORMAT'), ('Periodic', 'PERIODIC'), ('Multiple_unit_cell', 'MULTIPLE_UNIT_CELL'), ('Symmetry', 'SYMMETRY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Angles(self):
        """
        See documentation for Alpha_beta_gamma
        """
        return self.Alpha_beta_gamma

    @Angles.setter
    def Angles(self, value):
        self.Alpha_beta_gamma = value



class _normalmode1(printable):
    """
    Controls the normal mode transformation
    """
    def __init__(self):
        self.Q_centroid = None
        """
        Value of the thermostat mass of centroid degree of freedom
        """
        self.Q_bead = None
        """
        Value of the thermostat mass of non-centroid degrees of freedom
        """
        self.Modefactor = None
        """
        mass scale factor for non-centroid degrees of freedom
        """
        self._name = "NORMALMODE"
        self._keywords = [('Q_centroid', 'Q_CENTROID'), ('Q_bead', 'Q_BEAD'), ('Modefactor', 'MODEFACTOR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each251(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each250(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each253(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _centroid_pos1(printable):
    """
    Controls the output of the centroid's position
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.Format = None
        """
        Output file format for the positions of centroid

        Available values:
            ATOMIC
                Write only the coordinates X,Y,Z without element symbols to a
                formatted file
            DCD
                Write the coordinates (no element labels) and the cell information to
                a binary file
            PDB
                Write the atomic information in PDB format to a formatted file
            XMOL
                Mostly known as XYZ format, provides in a formatted file:
                element_symbol X Y Z
            XYZ
                Alias name for XMOL
        """
        self.Charge_occup = None
        """
        Write the MM charges to the OCCUP field of the PDB file
        """
        self.Charge_beta = None
        """
        Write the MM charges to the BETA field of the PDB file
        """
        self.Charge_extended = None
        """
        Write the MM charges to the very last field of the PDB file (starting
        from column 81)
        """
        self.EACH = _each62()
        self._name = "CENTROID_POS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT'), ('Format', 'FORMAT'), ('Charge_occup', 'CHARGE_OCCUP'), ('Charge_beta', 'CHARGE_BETA'), ('Charge_extended', 'CHARGE_EXTENDED')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Charge_o(self):
        """
        See documentation for Charge_occup
        """
        return self.Charge_occup

    @property
    def Charge_b(self):
        """
        See documentation for Charge_beta
        """
        return self.Charge_beta

    @Charge_o.setter
    def Charge_o(self, value):
        self.Charge_occup = value

    @Charge_b.setter
    def Charge_b(self, value):
        self.Charge_beta = value



class _each255(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each254(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each257(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each256(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each259(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each258(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _rescale_forces1(printable):
    """
    Section controlling the rescaling of forces. Useful when starting from
    quite bad geometries with unphysically large forces.
    """
    def __init__(self):
        self.Max_force = None
        """
        Specify the Maximum Values of the force. If the force of one atom
        exceed this value it's rescaled to the MAX_FORCE value.
        """
        self._name = "RESCALE_FORCES"
        self._keywords = [('Max_force', 'MAX_FORCE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _subcell4(printable):
    """
    Activates the printing of the subcells used for thegeneration of
    neighbor lists.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.EACH = _each232()
        self._name = "SUBCELL"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _subcell5(printable):
    """
    Activates the printing of the subcells used for thegeneration of
    neighbor lists for connectivity.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each270()
        self._name = "SUBCELL"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _subcell1(printable):
    """
    Activates the printing of the subcells used for thegeneration of
    neighbor lists for periodic SE.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each109()
        self._name = "SUBCELL"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _subcell2(printable):
    """
    Activates the printing of the subcells used for thegeneration of
    neighbor lists.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.EACH = _each183()
        self._name = "SUBCELL"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _subcell3(printable):
    """
    Activates the printing of the subcells used for thegeneration of
    neighbor lists.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each227()
        self._name = "SUBCELL"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _auxiliary_density_matrix_method1(printable):
    """
    Parameters needed to set wavefunction fitting
    """
    def __init__(self):
        self.Method = None
        """
        Method that shall be used for wavefunction fitting. Use
        BASIS_PROJECTION for MD.

        Available values:
            BASIS_PROJECTION
                Construct auxiliary density matrix from auxiliary basis
            BLOCK_DENSITY_MATRIX
                Construct auxiliary density from a blocked Fock matrix
        """
        self.Admm_purification_method = None
        """
        Method that shall be used for wavefunction fitting. Use MO_DIAG for
        MD.

        Available values:
            NONE
                Do not apply any purification
            CAUCHY
                Apply McWeeny purification via general Cauchy representation
            CAUCHY_SUBSPACE
                Apply McWeeny purification via Cauchy representation in occupied
                subspace
            MO_DIAG
                Calculate MO derivatives via Cauchy representation by diagonalization
            MO_NO_DIAG
                Calculate MO derivatives via Cauchy representation by inversion
        """
        self.BLOCK_DENSITY_MATRIX_METHOD = _block_density_matrix_method1()
        self._name = "AUXILIARY_DENSITY_MATRIX_METHOD"
        self._keywords = [('Method', 'METHOD'), ('Admm_purification_method', 'ADMM_PURIFICATION_METHOD')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('BLOCK_DENSITY_MATRIX_METHOD', 'BLOCK_DENSITY_MATRIX_METHOD')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _bond2(printable):
    """
    Section used to add/remove  bonds in the connectivity. Useful for
    systems with a complex connectivity, difficult to find out
    automatically.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        controls the activation of the bond

        Available values:
            ADD
            REMOVE
        """
        self.list_Atoms = []
        self._name = "BOND"
        self._keywords = []
        self._repeated_keywords = [('Atoms', 'ATOMS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _bond1(printable):
    """
    Specifies the bond potential
    """
    def __init__(self):
        self.Atoms = None
        """
        Defines the atomic kinds involved in the bond.
        """
        self.Kind = None
        """
        Define the kind of Bondpotential.

        Available values:
            HARMONIC
                Functional Form (HARMONIC|G87): 1/2*K*(R-R0)^2
            CHARMM
                Functional Form (CHARMM|AMBER): K*(R-R0)^2
            AMBER
                Functional Form (CHARMM|AMBER): K*(R-R0)^2
            G87
                Functional Form (HARMONIC|G87): 1/2*K*(R-R0)^2
            G96
                Functional Form (G96): 1/4*K*(R-R0)^2
            QUARTIC
                Functional Form (QUARTIC):
                (1/2*K1+[1/3*K2+1/4*K3*|R-R0|]*|R-R0|)(R-R0)^2
            MORSE
                Functional Form (MORSE): K1*[(1-exp(-K2*(R-R0)))^2-1])
            CUBIC
                Functional Form (CUBIC): K*(R-R0)^2*(1+cs*(R-R0)+7/12*(cs^2*(R-R0)^2))
            FUES
                Functional Form (FUES): 1/2*K*R0^2*(1+R0/R*(R0/R-2))
        """
        self.K = None
        """
        Defines the force constant of the potential. For QUARTIC potentials
        three numbers are expected.
        """
        self.Cs = None
        """
        Defines the cubic stretch term.
        """
        self.R0 = None
        """
        Defines the equilibrium distance.
        """
        self._name = "BOND"
        self._keywords = [('Atoms', 'ATOMS'), ('Kind', 'KIND'), ('K', 'K'), ('Cs', 'CS'), ('R0', 'R0')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _mm1(printable):
    """
    This section contains all information to run a MM calculation.
    """
    def __init__(self):
        self.FORCEFIELD = _forcefield1()
        self.NEIGHBOR_LISTS = _neighbor_lists5()
        self.POISSON = _poisson2()
        self.PRINT = _print36()
        self._name = "MM"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('FORCEFIELD', 'FORCEFIELD'), ('NEIGHBOR_LISTS', 'NEIGHBOR_LISTS'), ('POISSON', 'POISSON'), ('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _poisson1(printable):
    """
    Sets up the poisson resolutor.
    """
    def __init__(self):
        self.Poisson_solver = None
        """
        Specify which kind of solver to use to solve the Poisson equation.

        Available values:
            PERIODIC
            ANALYTIC
            MT
            MULTIPOLE
            WAVELET
        """
        self.Periodic = None
        """
        Specify the directions on wich apply PBC. Important notice,  this only
        applies to the electrostatics. See the CELL section to specify the
        periodicity used for e.g. the pair lists. Typically the settings
        should be the same.

        Available values:
            X
            Y
            Z
            XY
            XZ
            YZ
            XYZ
            NONE
        """
        self.MT = _mt1()
        self.WAVELET = _wavelet1()
        self.MULTIPOLE = _multipole1()
        self.EWALD = _ewald1()
        self._name = "POISSON"
        self._keywords = [('Poisson_solver', 'POISSON_SOLVER'), ('Periodic', 'PERIODIC')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('MT', 'MT'), ('WAVELET', 'WAVELET'), ('MULTIPOLE', 'MULTIPOLE'), ('EWALD', 'EWALD')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Poisson(self):
        """
        See documentation for Poisson_solver
        """
        return self.Poisson_solver

    @property
    def Psolver(self):
        """
        See documentation for Poisson_solver
        """
        return self.Poisson_solver

    @Poisson.setter
    def Poisson(self, value):
        self.Poisson_solver = value

    @Psolver.setter
    def Psolver(self, value):
        self.Poisson_solver = value



class _poisson2(printable):
    """
    Sets up the poisson resolutor.
    """
    def __init__(self):
        self.Poisson_solver = None
        """
        Specify which kind of solver to use to solve the Poisson equation.

        Available values:
            PERIODIC
            ANALYTIC
            MT
            MULTIPOLE
            WAVELET
        """
        self.Periodic = None
        """
        Specify the directions on wich apply PBC. Important notice,  this only
        applies to the electrostatics. See the CELL section to specify the
        periodicity used for e.g. the pair lists. Typically the settings
        should be the same.

        Available values:
            X
            Y
            Z
            XY
            XZ
            YZ
            XYZ
            NONE
        """
        self.MT = _mt2()
        self.WAVELET = _wavelet2()
        self.MULTIPOLE = _multipole2()
        self.EWALD = _ewald2()
        self._name = "POISSON"
        self._keywords = [('Poisson_solver', 'POISSON_SOLVER'), ('Periodic', 'PERIODIC')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('MT', 'MT'), ('WAVELET', 'WAVELET'), ('MULTIPOLE', 'MULTIPOLE'), ('EWALD', 'EWALD')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Poisson(self):
        """
        See documentation for Poisson_solver
        """
        return self.Poisson_solver

    @property
    def Psolver(self):
        """
        See documentation for Poisson_solver
        """
        return self.Poisson_solver

    @Poisson.setter
    def Poisson(self, value):
        self.Poisson_solver = value

    @Psolver.setter
    def Psolver(self, value):
        self.Poisson_solver = value



class _bmhftd1(printable):
    """
    This section specifies the input parameters for BMHFTD potential
    type.Functional form: V(r) = A*exp(-B*r) - f_6*(r)C/r^6 -
    f_8(r)*D/r^8.where f_order(r)=1-exp(-BD * r) * \sum_{k=0}^order (BD *
    r)^k / k! .(Tang-Toennies damping function)No values available inside
    cp2k.
    """
    def __init__(self):
        self.Atoms = None
        """
        Defines the atomic kind involved in the BMHFTD nonbond potential
        """
        self.Map_atoms = None
        """
        Defines the kinds for which internally is defined the BMHFTD nonbond
        potential at the moment no species included.
        """
        self.Rcut = None
        """
        Defines the cutoff parameter of the BMHFTD potential
        """
        self.A = None
        """
        Defines the A parameter of the dispersion-damped Fumi-Tosi Potential
        """
        self.B = None
        """
        Defines the B parameter of the dispersion-damped Fumi-Tosi Potential
        """
        self.C = None
        """
        Defines the C parameter of the dispersion-damped Fumi-Tosi Potential
        """
        self.D = None
        """
        Defines the D parameter of the dispersion-damped Fumi-Tosi Potential
        """
        self.Bd = None
        """
        Defines the BD parameter of the dispersion-damped Fumi-Tosi Potential
        """
        self.Order = None
        """
        Defines the order for this damping.
        """
        self.Rmin = None
        """
        Defines the lower bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self.Rmax = None
        """
        Defines the upper bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self._name = "BMHFTD"
        self._keywords = [('Atoms', 'ATOMS'), ('Map_atoms', 'MAP_ATOMS'), ('Rcut', 'RCUT'), ('A', 'A'), ('B', 'B'), ('C', 'C'), ('D', 'D'), ('Bd', 'BD'), ('Order', 'ORDER'), ('Rmin', 'RMIN'), ('Rmax', 'RMAX')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _kind1(printable):
    """
    The description of the kind of the atoms (mostly for QM)
    """
    def __init__(self):
        self.Section_parameters = None
        """
        The name of the kind described in this section.
        """
        self.Aux_basis_set = None
        """
        The auxliliary basis set (GTO type)
        """
        self.Ri_aux_basis_set = None
        """
        The RI auxliliary basis set used in WF_CORRELATION (GTO type)
        """
        self.Aux_basis_normalization = None
        """
        The normalization of the auxliliary basis set

        Available values:
            NONE
            NO
            WFN
            WAVEFUNCTION
            FUNCTION
            DENS
            DENSITY
            SQUARE
            UNDEFINED
        """
        self.Lri_basis_set = None
        """
        The local resolution of identity basis set (GTO type)
        """
        self.Aux_fit_basis_set = None
        """
        The auxliliary basis set (GTO type) for auxiliary density matrix
        method
        """
        self.Aux_basis_fit_normalization = None
        """
        The normalization of the basis set for auxiliary density matrix method

        Available values:
            NONE
            NO
            WFN
            WAVEFUNCTION
            FUNCTION
            DENS
            DENSITY
            SQUARE
            UNDEFINED
        """
        self.Basis_set = None
        """
        The primary Gaussian basis set (NONE implies no basis used, meaningful
        with GHOST)
        """
        self.Geminal_basis_set = None
        """
        The Geminal Gaussian basis set to be used in HF exchange fitting
        """
        self.Elec_conf = None
        """
        Specifies the electronic configration used in construction the atomic
        initial guess (see the pseudo potential file for the default values.
        """
        self.Basis_normalization = None
        """
        The normalization of the auxliliary basis set

        Available values:
            NONE
            NO
            WFN
            WAVEFUNCTION
            FUNCTION
            DENS
            DENSITY
            SQUARE
            UNDEFINED
        """
        self.Core_correction = None
        """
        Corrects the effective nuclear charge
        """
        self.Element = None
        """
        The element of the actual kind (if not given it is inferred from the
        kind name)
        """
        self.Mass = None
        """
        The mass of the atom (if negative or non present it is inferred from
        the element symbol)
        """
        self.Potential = None
        """
        The name of the pseudopotential for the defined kind.
        """
        self.Hard_exp_radius = None
        """
        The region where the hard density is supposed to be confined(GAPW)(in
        Bohr, default is 1.2 for H and 1.512 otherwise)
        """
        self.Max_rad_local = None
        """
        Max radius for the basis functions used to generate the local
        projectors in GAPW [Bohr]
        """
        self.Rho0_exp_radius = None
        """
        the radius which defines the atomic region where the hard compensation
        density is confined.should be less than HARD_EXP_RADIUS (GAPW)(Bohr,
        default equals HARD_EXP_RADIUS)
        """
        self.Lebedev_grid = None
        """
        The number of points for the angular part of the local grid (GAPW)
        """
        self.Radial_grid = None
        """
        The number of points for the radial part of the local grid (GAPW)
        """
        self.Alpha_scp = None
        """
        The polarizability for scalar-isotropic polarization using SCP with
        FIST as the driver
        """
        self.I_scp = None
        """
        The dispersion parameter for scalar-isotropic polarization using SCP
        with FIST as the driver
        """
        self.Mm_radius = None
        """
        Defines the radius of the electrostatic multipole of the atom in Fist.
        This radius applies to the charge, the dipole and the quadrupole. When
        zero, the atom is treated as a point multipole, otherwise it is
        treated as a Gaussian charge distribution with the given radius:
        p(x,y,z)*N*exp(-(x**2+y**2+z**2)/(2*MM_RADIUS**2)), where N is a
        normalization constant. In the core-shell model, only the shell is
        treated as a Gaussian and the core is always a point charge.
        """
        self.Se_p_orbitals_on_h = None
        """
        Forces the usage of p-orbitals on H for SEMI-EMPIRICAL calculations.
        This keyword applies only when the KIND is specifying an Hydrogen
        element. In all  other cases is simply ignored.
        """
        self.Gpw_type = None
        """
        Force one type to be treated by the GPW scheme, whatever are its
        primitives, even if the GAPW method is used
        """
        self.Ghost = None
        """
        This keyword makes all atoms of this kind ghost atoms, i.e. without
        pseudo or nuclear charge.Useful to just have the basis set at that
        position (BSSE calculations),or to have a non-interacting particle
        with BASIS_SET NONE
        """
        self.No_optimize = None
        """
        Skip optimization of this type (used in specific basis set or
        potential optimization schemes
        """
        self.BASIS = _basis1()
        self.GEMINAL = _geminal1()
        self.POTENTIAL = _potential2()
        self.DFT_PLUS_U = _dft_plus_u1()
        self.BS = _bs1()
        self._name = "KIND"
        self._keywords = [('Aux_basis_set', 'AUX_BASIS_SET'), ('Ri_aux_basis_set', 'RI_AUX_BASIS_SET'), ('Aux_basis_normalization', 'AUX_BASIS_NORMALIZATION'), ('Lri_basis_set', 'LRI_BASIS_SET'), ('Aux_fit_basis_set', 'AUX_FIT_BASIS_SET'), ('Aux_basis_fit_normalization', 'AUX_BASIS_FIT_NORMALIZATION'), ('Basis_set', 'BASIS_SET'), ('Geminal_basis_set', 'GEMINAL_BASIS_SET'), ('Elec_conf', 'ELEC_CONF'), ('Basis_normalization', 'BASIS_NORMALIZATION'), ('Core_correction', 'CORE_CORRECTION'), ('Element', 'ELEMENT'), ('Mass', 'MASS'), ('Potential', 'POTENTIAL'), ('Hard_exp_radius', 'HARD_EXP_RADIUS'), ('Max_rad_local', 'MAX_RAD_LOCAL'), ('Rho0_exp_radius', 'RHO0_EXP_RADIUS'), ('Lebedev_grid', 'LEBEDEV_GRID'), ('Radial_grid', 'RADIAL_GRID'), ('Alpha_scp', 'ALPHA_SCP'), ('I_scp', 'I_SCP'), ('Mm_radius', 'MM_RADIUS'), ('Se_p_orbitals_on_h', 'SE_P_ORBITALS_ON_H'), ('Gpw_type', 'GPW_TYPE'), ('Ghost', 'GHOST'), ('No_optimize', 'NO_OPTIMIZE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('BASIS', 'BASIS'), ('GEMINAL', 'GEMINAL'), ('POTENTIAL', 'POTENTIAL'), ('DFT_PLUS_U', 'DFT_PLUS_U'), ('BS', 'BS')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Auxiliary_basis_set(self):
        """
        See documentation for Aux_basis_set
        """
        return self.Aux_basis_set

    @property
    def Aux_basis(self):
        """
        See documentation for Aux_basis_set
        """
        return self.Aux_basis_set

    @property
    def Ri_mp2_basis_set(self):
        """
        See documentation for Ri_aux_basis_set
        """
        return self.Ri_aux_basis_set

    @property
    def Ri_rpa_basis_set(self):
        """
        See documentation for Ri_aux_basis_set
        """
        return self.Ri_aux_basis_set

    @property
    def Ri_aux_basis(self):
        """
        See documentation for Ri_aux_basis_set
        """
        return self.Ri_aux_basis_set

    @property
    def Auxiliary_basis_normalization(self):
        """
        See documentation for Aux_basis_normalization
        """
        return self.Aux_basis_normalization

    @property
    def Aux_basis_norm(self):
        """
        See documentation for Aux_basis_normalization
        """
        return self.Aux_basis_normalization

    @property
    def Lri_basis(self):
        """
        See documentation for Lri_basis_set
        """
        return self.Lri_basis_set

    @property
    def Auxiliary_fit_basis_set(self):
        """
        See documentation for Aux_fit_basis_set
        """
        return self.Aux_fit_basis_set

    @property
    def Aux_fit_basis(self):
        """
        See documentation for Aux_fit_basis_set
        """
        return self.Aux_fit_basis_set

    @property
    def Auxiliary_basis_fit_normalization(self):
        """
        See documentation for Aux_basis_fit_normalization
        """
        return self.Aux_basis_fit_normalization

    @property
    def Aux_basis_fit_norm(self):
        """
        See documentation for Aux_basis_fit_normalization
        """
        return self.Aux_basis_fit_normalization

    @property
    def Orbital_basis_set(self):
        """
        See documentation for Basis_set
        """
        return self.Basis_set

    @property
    def Orb_basis(self):
        """
        See documentation for Basis_set
        """
        return self.Basis_set

    @property
    def Orbital_basis_normalization(self):
        """
        See documentation for Basis_normalization
        """
        return self.Basis_normalization

    @property
    def Orb_basis_norm(self):
        """
        See documentation for Basis_normalization
        """
        return self.Basis_normalization

    @property
    def Element_symbol(self):
        """
        See documentation for Element
        """
        return self.Element

    @property
    def Atomic_mass(self):
        """
        See documentation for Mass
        """
        return self.Mass

    @property
    def Atomic_weight(self):
        """
        See documentation for Mass
        """
        return self.Mass

    @property
    def Weight(self):
        """
        See documentation for Mass
        """
        return self.Mass

    @property
    def Pot(self):
        """
        See documentation for Potential
        """
        return self.Potential

    @Auxiliary_basis_set.setter
    def Auxiliary_basis_set(self, value):
        self.Aux_basis_set = value

    @Aux_basis.setter
    def Aux_basis(self, value):
        self.Aux_basis_set = value

    @Ri_mp2_basis_set.setter
    def Ri_mp2_basis_set(self, value):
        self.Ri_aux_basis_set = value

    @Ri_rpa_basis_set.setter
    def Ri_rpa_basis_set(self, value):
        self.Ri_aux_basis_set = value

    @Ri_aux_basis.setter
    def Ri_aux_basis(self, value):
        self.Ri_aux_basis_set = value

    @Auxiliary_basis_normalization.setter
    def Auxiliary_basis_normalization(self, value):
        self.Aux_basis_normalization = value

    @Aux_basis_norm.setter
    def Aux_basis_norm(self, value):
        self.Aux_basis_normalization = value

    @Lri_basis.setter
    def Lri_basis(self, value):
        self.Lri_basis_set = value

    @Auxiliary_fit_basis_set.setter
    def Auxiliary_fit_basis_set(self, value):
        self.Aux_fit_basis_set = value

    @Aux_fit_basis.setter
    def Aux_fit_basis(self, value):
        self.Aux_fit_basis_set = value

    @Auxiliary_basis_fit_normalization.setter
    def Auxiliary_basis_fit_normalization(self, value):
        self.Aux_basis_fit_normalization = value

    @Aux_basis_fit_norm.setter
    def Aux_basis_fit_norm(self, value):
        self.Aux_basis_fit_normalization = value

    @Orbital_basis_set.setter
    def Orbital_basis_set(self, value):
        self.Basis_set = value

    @Orb_basis.setter
    def Orb_basis(self, value):
        self.Basis_set = value

    @Orbital_basis_normalization.setter
    def Orbital_basis_normalization(self, value):
        self.Basis_normalization = value

    @Orb_basis_norm.setter
    def Orb_basis_norm(self, value):
        self.Basis_normalization = value

    @Element_symbol.setter
    def Element_symbol(self, value):
        self.Element = value

    @Atomic_mass.setter
    def Atomic_mass(self, value):
        self.Mass = value

    @Atomic_weight.setter
    def Atomic_weight(self, value):
        self.Mass = value

    @Weight.setter
    def Weight(self, value):
        self.Mass = value

    @Pot.setter
    def Pot(self, value):
        self.Potential = value



class _buckmorse1(printable):
    """
    This section specifies the input parameters for Buckingham plus Morse
    potential type  Functional Form: V(r) = F0*(B1+B2)*EXP([A1+A2-r]/[B1+B
    2])-C/r^6+D*{EXP[-2*beta*(r-R0)]-2*EXP[-beta*(r-R0)]}.
    """
    def __init__(self):
        self.Atoms = None
        """
        Defines the atomic kind involved in the nonbond potential
        """
        self.F0 = None
        """
        Defines the f0 parameter of Buckingham+Morse potential
        """
        self.A1 = None
        """
        Defines the A1 parameter of Buckingham+Morse potential
        """
        self.A2 = None
        """
        Defines the A2 parameter of Buckingham+Morse potential
        """
        self.B1 = None
        """
        Defines the B1 parameter of Buckingham+Morse potential
        """
        self.B2 = None
        """
        Defines the B2 parameter of Buckingham+Morse potential
        """
        self.C = None
        """
        Defines the C parameter of Buckingham+Morse  potential
        """
        self.D = None
        """
        Defines the amplitude for the Morse part
        """
        self.R0 = None
        """
        Defines the equilibrium distance for the Morse part
        """
        self.Beta = None
        """
        Defines the width for the Morse part
        """
        self.Rcut = None
        """
        Defines the cutoff parameter of the Buckingham potential
        """
        self.Rmin = None
        """
        Defines the lower bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self.Rmax = None
        """
        Defines the upper bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self._name = "BUCKMORSE"
        self._keywords = [('Atoms', 'ATOMS'), ('F0', 'F0'), ('A1', 'A1'), ('A2', 'A2'), ('B1', 'B1'), ('B2', 'B2'), ('C', 'C'), ('D', 'D'), ('R0', 'R0'), ('Beta', 'BETA'), ('Rcut', 'RCUT'), ('Rmin', 'RMIN'), ('Rmax', 'RMAX')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _configuration1(printable):
    """
    Specify additional parameters for the combinatorial configurations.
    """
    def __init__(self):
        self.Glb_conf = None
        """
        Specifies the global configuration using 1 or 0.
        """
        self.Sub_conf = None
        """
        Specifies the subconfiguration using 1 or 0 belonging to the global
        configuration.
        """
        self.Multiplicity = None
        """
        Specify for each fragment the multiplicity. Two times the total spin
        plus one. Specify 3 for a triplet, 4 for a quartet,and so on. Default
        is 1 (singlet) for an even number and 2 (doublet) for an odd number of
        electrons.
        """
        self.Charge = None
        """
        The total charge for each fragment.
        """
        self._name = "CONFIGURATION"
        self._keywords = [('Glb_conf', 'GLB_CONF'), ('Sub_conf', 'SUB_CONF'), ('Multiplicity', 'MULTIPLICITY'), ('Charge', 'CHARGE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Multip(self):
        """
        See documentation for Multiplicity
        """
        return self.Multiplicity

    @Multip.setter
    def Multip(self, value):
        self.Multiplicity = value



class _beads1(printable):
    """
    Sets positions and velocities of the beads
    """
    def __init__(self):
        self.COORD = _coord6()
        self.VELOCITY = _velocity7()
        self._name = "BEADS"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('COORD', 'COORD'), ('VELOCITY', 'VELOCITY')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info30(printable):
    """
    controls the printing of ewald setup
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each221()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info31(printable):
    """
    Controls the printing of information regarding the run.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each229()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info32(printable):
    """
    Controls the printing of basic information during the run
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each236()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info33(printable):
    """
    Controls the printing of information regarding the run.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each246()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info34(printable):
    """
    Controls the printing of information regarding the run.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each265()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info35(printable):
    """
    Controls the printing of basic information during colvar setup.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each271()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info36(printable):
    """
    Controls the printing of basic information during colvar setup.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each273()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info37(printable):
    """
    Controls the printing of basic information during colvar setup.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each275()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info38(printable):
    """
    Controls the printing of basic information during colvar setup.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each276()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info39(printable):
    """
    Controls the printing basic info about the method
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each286()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each58(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each59(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _memory8(printable):
    """
    Sets up memory parameters for the storage of the ERI's if requested
    """
    def __init__(self):
        self.Eps_storage_scaling = None
        """
        Scaling factor to scale eps_schwarz. Storage threshold for compression
        will be EPS_SCHWARZ*EPS_STORAGE_SCALING.
        """
        self.Max_memory = None
        """
        Defines the maximum amount of memory [MB] to be consumed by the full
        HFX module. All temporary buffers and helper arrays are subtracted
        from this number. What remains will be used for storage of integrals.
        NOTE: This number is assumed to represent the memory available to one
        MPI process. When running a threaded version, cp2k automatically takes
        care of distributing the memory among all involved sub-processes.
        """
        self.Storage_location = None
        """
        Loaction where ERI's are stored if MAX_DISK_SPACE /=0 Expects a path
        to a directory.
        """
        self.Max_disk_space = None
        """
        Defines the maximum amount of disk space [MB] used to store
        precomputed compressed four-center integrals. If 0, nothing is stored
        to disk
        """
        self.Treat_forces_in_core = None
        """
        Determines whether the derivative ERI's should be stored to RAM or
        not. Only meaningful when performing Ehrenfest MD. Memory usage is
        defined via MAX_MEMORY, i.e. the memory is shared wit the energy
        ERI's.
        """
        self._name = "MEMORY"
        self._keywords = [('Eps_storage_scaling', 'EPS_STORAGE_SCALING'), ('Max_memory', 'MAX_MEMORY'), ('Storage_location', 'STORAGE_LOCATION'), ('Max_disk_space', 'MAX_DISK_SPACE'), ('Treat_forces_in_core', 'TREAT_FORCES_IN_CORE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Eps_storage(self):
        """
        See documentation for Eps_storage_scaling
        """
        return self.Eps_storage_scaling

    @Eps_storage.setter
    def Eps_storage(self, value):
        self.Eps_storage_scaling = value



class _each50(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each51(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each52(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each53(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _init1(printable):
    """
    Controls the initialization if the beads are not present
    """
    def __init__(self):
        self.Levy_pos_sample = None
        """
        Sample bead positions assuming free particle behavior (performs a Levy
        random walk of length P around the classical position of each atom at
        the physical temperature defined in PINT%TEMP)
        """
        self.Levy_correlated = None
        """
        Use the same Levy path for all atoms, though with mass-dependent
        variances (might help at very low T)
        """
        self.Levy_temp_factor = None
        """
        Multiplicative correction factor for the temperature at which the Levy
        walk is performed (correction is due to the interactions that modify
        the spread of a free particle)
        """
        self.Levy_seed = None
        """
        Initial seed for the (pseudo)random number generator that controls
        Levy walk for bead positions.
        """
        self.Randomize_pos = None
        """
        add gaussian noise to the positions of the beads
        """
        self.Centroid_speed = None
        """
        adds random velocity component to the centroid modes (useful to
        correct for the averaging out of the speed of various beads)
        """
        self.Velocity_quench = None
        """
        set the initial velocities to zero
        """
        self.Velocity_scale = None
        """
        scale initial velocities to the temperature given in MOTION%PINT%TEMP
        """
        self._name = "INIT"
        self._keywords = [('Levy_pos_sample', 'LEVY_POS_SAMPLE'), ('Levy_correlated', 'LEVY_CORRELATED'), ('Levy_temp_factor', 'LEVY_TEMP_FACTOR'), ('Levy_seed', 'LEVY_SEED'), ('Randomize_pos', 'RANDOMIZE_POS'), ('Centroid_speed', 'CENTROID_SPEED'), ('Velocity_quench', 'VELOCITY_QUENCH'), ('Velocity_scale', 'VELOCITY_SCALE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each55(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _isolated_atoms1(printable):
    """
     This section specifies the  atoms that one considers isolated. Useful
    when present  ions in solution.
    """
    def __init__(self):
        self.list_List = []
        self._name = "ISOLATED_ATOMS"
        self._keywords = []
        self._repeated_keywords = [('List', 'LIST')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_List(self, value):
        self.list_List.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _each57(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print31(printable):
    """
    printing of information during the core-level spectroscopy simulation
    """
    def __init__(self):
        self.WANNIER_CUBES = _wannier_cubes2()
        self.WANNIER_CENTERS = _wannier_centers2()
        self.WANNIER_SPREADS = _wannier_spreads2()
        self.LOC_RESTART = _loc_restart2()
        self.ITERATION_INFO = _iteration_info2()
        self.PROGRAM_RUN_INFO = _program_run_info26()
        self.XES_SPECTRUM = _xes_spectrum1()
        self.XAS_SPECTRUM = _xas_spectrum1()
        self.RESTART = _restart7()
        self.CLS_FUNCTION_CUBES = _cls_function_cubes1()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('WANNIER_CUBES', 'WANNIER_CUBES'), ('WANNIER_CENTERS', 'WANNIER_CENTERS'), ('WANNIER_SPREADS', 'WANNIER_SPREADS'), ('LOC_RESTART', 'LOC_RESTART'), ('ITERATION_INFO', 'ITERATION_INFO'), ('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('XES_SPECTRUM', 'XES_SPECTRUM'), ('XAS_SPECTRUM', 'XAS_SPECTRUM'), ('RESTART', 'RESTART'), ('CLS_FUNCTION_CUBES', 'CLS_FUNCTION_CUBES')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print30(printable):
    """
    Collects all printing options related to the Wannier centers and
    properties computed with Wannier centers.
    """
    def __init__(self):
        self.PROGRAM_RUN_INFO = _program_run_info25()
        self.WANNIER_CUBES = _wannier_cubes1()
        self.WANNIER_CENTERS = _wannier_centers1()
        self.WANNIER_SPREADS = _wannier_spreads1()
        self.LOC_RESTART = _loc_restart1()
        self.TOTAL_DIPOLE = _total_dipole1()
        self.MOLECULAR_DIPOLES = _molecular_dipoles1()
        self.MOLECULAR_STATES = _molecular_states1()
        self.WANNIER_STATES = _wannier_states1()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('WANNIER_CUBES', 'WANNIER_CUBES'), ('WANNIER_CENTERS', 'WANNIER_CENTERS'), ('WANNIER_SPREADS', 'WANNIER_SPREADS'), ('LOC_RESTART', 'LOC_RESTART'), ('TOTAL_DIPOLE', 'TOTAL_DIPOLE'), ('MOLECULAR_DIPOLES', 'MOLECULAR_DIPOLES'), ('MOLECULAR_STATES', 'MOLECULAR_STATES'), ('WANNIER_STATES', 'WANNIER_STATES')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print33(printable):
    """
    Section of possible print options for an RTP runs
    """
    def __init__(self):
        self.PROGRAM_RUN_INFO = _program_run_info28()
        self.RESTART = _restart8()
        self.RESTART_HISTORY = _restart_history3()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('RESTART', 'RESTART'), ('RESTART_HISTORY', 'RESTART_HISTORY')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print32(printable):
    """
    Collects all printing options related to the Wannier centers and
    properties computed with Wannier centers.
    """
    def __init__(self):
        self.PROGRAM_RUN_INFO = _program_run_info27()
        self.WANNIER_CUBES = _wannier_cubes3()
        self.WANNIER_CENTERS = _wannier_centers3()
        self.WANNIER_SPREADS = _wannier_spreads3()
        self.LOC_RESTART = _loc_restart3()
        self.TOTAL_DIPOLE = _total_dipole2()
        self.MOLECULAR_DIPOLES = _molecular_dipoles2()
        self.MOLECULAR_STATES = _molecular_states2()
        self.WANNIER_STATES = _wannier_states2()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('WANNIER_CUBES', 'WANNIER_CUBES'), ('WANNIER_CENTERS', 'WANNIER_CENTERS'), ('WANNIER_SPREADS', 'WANNIER_SPREADS'), ('LOC_RESTART', 'LOC_RESTART'), ('TOTAL_DIPOLE', 'TOTAL_DIPOLE'), ('MOLECULAR_DIPOLES', 'MOLECULAR_DIPOLES'), ('MOLECULAR_STATES', 'MOLECULAR_STATES'), ('WANNIER_STATES', 'WANNIER_STATES')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print35(printable):
    """
    Controls printing of Ewald properties
    """
    def __init__(self):
        self.PROGRAM_RUN_INFO = _program_run_info30()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print34(printable):
    """
    Section of possible print options in DFT code.
    """
    def __init__(self):
        self.PROGRAM_BANNER = _program_banner1()
        self.KINETIC_ENERGY = _kinetic_energy1()
        self.DERIVATIVES = _derivatives1()
        self.NEIGHBOR_LISTS = _neighbor_lists4()
        self.SUBCELL = _subcell2()
        self.AO_MATRICES = _ao_matrices1()
        self.MO = _mo1()
        self.MO_CUBES = _mo_cubes1()
        self.STM = _stm1()
        self.WFN_MIX = _wfn_mix1()
        self.GAPW = _gapw1()
        self.DFT_CONTROL_PARAMETERS = _dft_control_parameters1()
        self.OPTICAL_CONDUCTIVITY = _optical_conductivity1()
        self.E_DENSITY_CUBE = _e_density_cube1()
        self.TOT_DENSITY_CUBE = _tot_density_cube1()
        self.V_HARTREE_CUBE = _v_hartree_cube1()
        self.EFIELD_CUBE = _efield_cube1()
        self.ELF_CUBE = _elf_cube1()
        self.PDOS = _pdos1()
        self.LOCALIZATION = _localization1()
        self.MOMENTS = _moments1()
        self.MULLIKEN = _mulliken1()
        self.LOWDIN = _lowdin1()
        self.XRAY_DIFFRACTION_SPECTRUM = _xray_diffraction_spectrum1()
        self.ELECTRIC_FIELD_GRADIENT = _electric_field_gradient1()
        self.BASIS_MOLOPT_QUANTITIES = _basis_molopt_quantities1()
        self.HYPERFINE_COUPLING_TENSOR = _hyperfine_coupling_tensor1()
        self.OPTIMIZE_GEMINALS = _optimize_geminals1()
        self.PLUS_U = _plus_u1()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_BANNER', 'PROGRAM_BANNER'), ('KINETIC_ENERGY', 'KINETIC_ENERGY'), ('DERIVATIVES', 'DERIVATIVES'), ('NEIGHBOR_LISTS', 'NEIGHBOR_LISTS'), ('SUBCELL', 'SUBCELL'), ('AO_MATRICES', 'AO_MATRICES'), ('MO', 'MO'), ('MO_CUBES', 'MO_CUBES'), ('STM', 'STM'), ('WFN_MIX', 'WFN_MIX'), ('GAPW', 'GAPW'), ('DFT_CONTROL_PARAMETERS', 'DFT_CONTROL_PARAMETERS'), ('OPTICAL_CONDUCTIVITY', 'OPTICAL_CONDUCTIVITY'), ('E_DENSITY_CUBE', 'E_DENSITY_CUBE'), ('TOT_DENSITY_CUBE', 'TOT_DENSITY_CUBE'), ('V_HARTREE_CUBE', 'V_HARTREE_CUBE'), ('EFIELD_CUBE', 'EFIELD_CUBE'), ('ELF_CUBE', 'ELF_CUBE'), ('PDOS', 'PDOS'), ('LOCALIZATION', 'LOCALIZATION'), ('MOMENTS', 'MOMENTS'), ('MULLIKEN', 'MULLIKEN'), ('LOWDIN', 'LOWDIN'), ('XRAY_DIFFRACTION_SPECTRUM', 'XRAY_DIFFRACTION_SPECTRUM'), ('ELECTRIC_FIELD_GRADIENT', 'ELECTRIC_FIELD_GRADIENT'), ('BASIS_MOLOPT_QUANTITIES', 'BASIS_MOLOPT_QUANTITIES'), ('HYPERFINE_COUPLING_TENSOR', 'HYPERFINE_COUPLING_TENSOR'), ('OPTIMIZE_GEMINALS', 'OPTIMIZE_GEMINALS'), ('PLUS_U', 'PLUS_U')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print37(printable):
    """
    Section of possible print options in FORCE_MIXING.
    """
    def __init__(self):
        self.SUBCELL = _subcell4()
        self.NEIGHBOR_LISTS = _neighbor_lists7()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('SUBCELL', 'SUBCELL'), ('NEIGHBOR_LISTS', 'NEIGHBOR_LISTS')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print36(printable):
    """
    Section of possible print options in MM code.
    """
    def __init__(self):
        self.DERIVATIVES = _derivatives2()
        self.EWALD_INFO = _ewald_info2()
        self.DIPOLE = _dipole3()
        self.NEIGHBOR_LISTS = _neighbor_lists6()
        self.ITER_INFO = _iter_info1()
        self.SUBCELL = _subcell3()
        self.PROGRAM_BANNER = _program_banner2()
        self.PROGRAM_RUN_INFO = _program_run_info31()
        self.FF_PARAMETER_FILE = _ff_parameter_file1()
        self.FF_INFO = _ff_info1()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('DERIVATIVES', 'DERIVATIVES'), ('EWALD_INFO', 'EWALD_INFO'), ('DIPOLE', 'DIPOLE'), ('NEIGHBOR_LISTS', 'NEIGHBOR_LISTS'), ('ITER_INFO', 'ITER_INFO'), ('SUBCELL', 'SUBCELL'), ('PROGRAM_BANNER', 'PROGRAM_BANNER'), ('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('FF_PARAMETER_FILE', 'FF_PARAMETER_FILE'), ('FF_INFO', 'FF_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print39(printable):
    """
    Section of possible print options for an EP calculation.
    """
    def __init__(self):
        self.ENERGY = _energy9()
        self.RUN_INFO = _run_info1()
        self.EP_MATRIXES = _ep_matrixes1()
        self.EP_RHO_CUBE = _ep_rho_cube1()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('ENERGY', 'ENERGY'), ('RUN_INFO', 'RUN_INFO'), ('EP_MATRIXES', 'EP_MATRIXES'), ('EP_RHO_CUBE', 'EP_RHO_CUBE')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print38(printable):
    """
    Section of possible print options specific of the QMMM code.
    """
    def __init__(self):
        self.PGF = _pgf1()
        self.POTENTIAL = _potential1()
        self.MM_POTENTIAL = _mm_potential1()
        self.QMMM_MATRIX = _qmmm_matrix1()
        self.PROGRAM_BANNER = _program_banner3()
        self.PROGRAM_RUN_INFO = _program_run_info33()
        self.PERIODIC_INFO = _periodic_info1()
        self.GRID_INFORMATION = _grid_information2()
        self.DERIVATIVES = _derivatives3()
        self.QMMM_CHARGES = _qmmm_charges1()
        self.QMMM_LINK_INFO = _qmmm_link_info1()
        self.QS_DERIVATIVES = _qs_derivatives1()
        self.IMAGE_CHARGE_INFO = _image_charge_info1()
        self.IMAGE_CHARGE_RESTART = _image_charge_restart1()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PGF', 'PGF'), ('POTENTIAL', 'POTENTIAL'), ('MM_POTENTIAL', 'MM_POTENTIAL'), ('QMMM_MATRIX', 'QMMM_MATRIX'), ('PROGRAM_BANNER', 'PROGRAM_BANNER'), ('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('PERIODIC_INFO', 'PERIODIC_INFO'), ('GRID_INFORMATION', 'GRID_INFORMATION'), ('DERIVATIVES', 'DERIVATIVES'), ('QMMM_CHARGES', 'QMMM_CHARGES'), ('QMMM_LINK_INFO', 'QMMM_LINK_INFO'), ('QS_DERIVATIVES', 'QS_DERIVATIVES'), ('IMAGE_CHARGE_INFO', 'IMAGE_CHARGE_INFO'), ('IMAGE_CHARGE_RESTART', 'IMAGE_CHARGE_RESTART')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _job1(printable):
    """
    description of the jobs to be executed
    """
    def __init__(self):
        self.Directory = None
        """
        the directory in which the job should be executed
        """
        self.Input_file_name = None
        """
        the filename of the input file
        """
        self.Output_file_name = None
        """
        the filename of the output file, if not specified will use the project
        name in the &GLOBAL section.
        """
        self.Job_id = None
        """
        An ID used to indentify a job in DEPENDENCIES. JOB_IDs do not need to
        be unique, dependencies will be on all jobs with a given ID. If no
        JOB_ID is given, the index of the &JOB section in the input file will
        be used.
        """
        self.Dependencies = None
        """
        specifies a list of JOB_IDs on which the current job depends. The
        current job will not be executed before all the dependencies have
        finished. The keyword requires a MASTER_SLAVE farming run. Beyond the
        default case, some special cases might arise: 1) circular dependencies
        will lead to a deadlock. 2) This keyword is not compatible with CYCLE.
        3) MAX_JOBS_PER_GROUP is ignored (though only a total of
        MAX_JOBS_PER_GROUP*NGROUPS jobs will be executed) 4) dependencies on
        jobs that will not be executed (due to RESTART or MAX_JOBS_PER_GROUP)
        are ignored. Additionally, note that, on some file systems,  output
        (restart) files might not be immediately available on all compute
        nodes,potentially resulting in unexpected failures.
        """
        self._name = "JOB"
        self._keywords = [('Directory', 'DIRECTORY'), ('Input_file_name', 'INPUT_FILE_NAME'), ('Output_file_name', 'OUTPUT_FILE_NAME'), ('Job_id', 'JOB_ID'), ('Dependencies', 'DEPENDENCIES')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _memory5(printable):
    """
    Sets up memory parameters for the storage of the ERI's if requested
    """
    def __init__(self):
        self.Eps_storage_scaling = None
        """
        Scaling factor to scale eps_schwarz. Storage threshold for compression
        will be EPS_SCHWARZ*EPS_STORAGE_SCALING.
        """
        self.Max_memory = None
        """
        Defines the maximum amount of memory [MB] to be consumed by the full
        HFX module. All temporary buffers and helper arrays are subtracted
        from this number. What remains will be used for storage of integrals.
        NOTE: This number is assumed to represent the memory available to one
        MPI process. When running a threaded version, cp2k automatically takes
        care of distributing the memory among all involved sub-processes.
        """
        self.Storage_location = None
        """
        Loaction where ERI's are stored if MAX_DISK_SPACE /=0 Expects a path
        to a directory.
        """
        self.Max_disk_space = None
        """
        Defines the maximum amount of disk space [MB] used to store
        precomputed compressed four-center integrals. If 0, nothing is stored
        to disk
        """
        self.Treat_forces_in_core = None
        """
        Determines whether the derivative ERI's should be stored to RAM or
        not. Only meaningful when performing Ehrenfest MD. Memory usage is
        defined via MAX_MEMORY, i.e. the memory is shared wit the energy
        ERI's.
        """
        self._name = "MEMORY"
        self._keywords = [('Eps_storage_scaling', 'EPS_STORAGE_SCALING'), ('Max_memory', 'MAX_MEMORY'), ('Storage_location', 'STORAGE_LOCATION'), ('Max_disk_space', 'MAX_DISK_SPACE'), ('Treat_forces_in_core', 'TREAT_FORCES_IN_CORE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Eps_storage(self):
        """
        See documentation for Eps_storage_scaling
        """
        return self.Eps_storage_scaling

    @Eps_storage.setter
    def Eps_storage(self, value):
        self.Eps_storage_scaling = value



class _mulliken_restraint1(printable):
    """
    Use mulliken charges in a restraint (check code for details)
    """
    def __init__(self):
        self.Strength = None
        """
        force constant of the restraint
        """
        self.Target = None
        """
        target value of the restraint
        """
        self.Atoms = None
        """
        Specifies the list of atoms that is summed in the restraint
        """
        self._name = "MULLIKEN_RESTRAINT"
        self._keywords = [('Strength', 'STRENGTH'), ('Target', 'TARGET'), ('Atoms', 'ATOMS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _umbrella_integration1(printable):
    """
    Controls the calculation of free energy derivatives with the umbrella
    integration method.
    """
    def __init__(self):
        self.list_CONVERGENCE_CONTROL = []
        self.list_UVAR = []
        self._name = "UMBRELLA_INTEGRATION"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('CONVERGENCE_CONTROL', '_convergence_control1'), ('UVAR', '_uvar1')]

    def add_CONVERGENCE_CONTROL(self):
        new_section = _convergence_control1()
        self.list_CONVERGENCE_CONTROL.append(new_section)
        return new_section

    def add_UVAR(self):
        new_section = _uvar1()
        self.list_UVAR.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _properties1(printable):
    """
    This section is used to set up the PROPERTIES calculation.
    """
    def __init__(self):
        self.LINRES = _linres1()
        self.ET_COUPLING = _et_coupling1()
        self.RESP = _resp1()
        self.ATOMIC = _atomic1()
        self.FIT_CHARGE = _fit_charge1()
        self._name = "PROPERTIES"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('LINRES', 'LINRES'), ('ET_COUPLING', 'ET_COUPLING'), ('RESP', 'RESP'), ('ATOMIC', 'ATOMIC'), ('FIT_CHARGE', 'FIT_CHARGE')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _vel_control1(printable):
    """
    Setup parameters to control the velocity during a BAND MD run.
    """
    def __init__(self):
        self.Annealing = None
        """
        Specify the annealing coefficient
        """
        self.Proj_velocity_verlet = None
        """
        Uses a Projected Velocity Verlet instead of a normal Velocity Verlet.
        Every time the cosine between velocities and forces is < 0 velocities
        are zeroed.
        """
        self.Sd_like = None
        """
        Zeros velocity at each MD step emulating a steepest descent
        like(SD_LIKE) approach
        """
        self._name = "VEL_CONTROL"
        self._keywords = [('Annealing', 'ANNEALING'), ('Proj_velocity_verlet', 'PROJ_VELOCITY_VERLET'), ('Sd_like', 'SD_LIKE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _wfc_gpw4(printable):
    """
    Parameters for the GPW approach in Wavefunction-based Correlation
    methods
    """
    def __init__(self):
        self.Eps_grid = None
        """
        Determines a threshold for the GPW based integration
        """
        self.Eps_filter = None
        """
        Determines a threshold for the DBCSR based multiply (usually 10 times
        smaller than EPS_GRID).
        """
        self.Cutoff = None
        """
        The cutoff of the finest grid level in the MP2 gpw integration.
        """
        self.Rel_cutoff = None
        """
        Determines the grid at which a Gaussian is mapped.
        """
        self.Print_level = None
        """
        How much output is written by the individual groups.

        Available values:
            SILENT
                Almost no output
            LOW
                Little output
            MEDIUM
                Quite some output
            HIGH
                Lots of output
            DEBUG
                Everything is written out, useful for debugging purposes only
        """
        self._name = "WFC_GPW"
        self._keywords = [('Eps_grid', 'EPS_GRID'), ('Eps_filter', 'EPS_FILTER'), ('Cutoff', 'CUTOFF'), ('Rel_cutoff', 'REL_CUTOFF'), ('Print_level', 'PRINT_LEVEL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Relative_cutoff(self):
        """
        See documentation for Rel_cutoff
        """
        return self.Rel_cutoff

    @property
    def Iolevel(self):
        """
        See documentation for Print_level
        """
        return self.Print_level

    @Relative_cutoff.setter
    def Relative_cutoff(self, value):
        self.Rel_cutoff = value

    @Iolevel.setter
    def Iolevel(self, value):
        self.Print_level = value



class _wfc_gpw3(printable):
    """
    Parameters for the GPW approach in Wavefunction-based Correlation
    methods
    """
    def __init__(self):
        self.Eps_grid = None
        """
        Determines a threshold for the GPW based integration
        """
        self.Eps_filter = None
        """
        Determines a threshold for the DBCSR based multiply (usually 10 times
        smaller than EPS_GRID).
        """
        self.Cutoff = None
        """
        The cutoff of the finest grid level in the MP2 gpw integration.
        """
        self.Rel_cutoff = None
        """
        Determines the grid at which a Gaussian is mapped.
        """
        self.Print_level = None
        """
        How much output is written by the individual groups.

        Available values:
            SILENT
                Almost no output
            LOW
                Little output
            MEDIUM
                Quite some output
            HIGH
                Lots of output
            DEBUG
                Everything is written out, useful for debugging purposes only
        """
        self._name = "WFC_GPW"
        self._keywords = [('Eps_grid', 'EPS_GRID'), ('Eps_filter', 'EPS_FILTER'), ('Cutoff', 'CUTOFF'), ('Rel_cutoff', 'REL_CUTOFF'), ('Print_level', 'PRINT_LEVEL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Relative_cutoff(self):
        """
        See documentation for Rel_cutoff
        """
        return self.Rel_cutoff

    @property
    def Iolevel(self):
        """
        See documentation for Print_level
        """
        return self.Print_level

    @Relative_cutoff.setter
    def Relative_cutoff(self, value):
        self.Rel_cutoff = value

    @Iolevel.setter
    def Iolevel(self, value):
        self.Print_level = value



class _wfc_gpw2(printable):
    """
    Parameters for the GPW approach in Wavefunction-based Correlation
    methods
    """
    def __init__(self):
        self.Eps_grid = None
        """
        Determines a threshold for the GPW based integration
        """
        self.Eps_filter = None
        """
        Determines a threshold for the DBCSR based multiply (usually 10 times
        smaller than EPS_GRID).
        """
        self.Cutoff = None
        """
        The cutoff of the finest grid level in the MP2 gpw integration.
        """
        self.Rel_cutoff = None
        """
        Determines the grid at which a Gaussian is mapped.
        """
        self.Print_level = None
        """
        How much output is written by the individual groups.

        Available values:
            SILENT
                Almost no output
            LOW
                Little output
            MEDIUM
                Quite some output
            HIGH
                Lots of output
            DEBUG
                Everything is written out, useful for debugging purposes only
        """
        self._name = "WFC_GPW"
        self._keywords = [('Eps_grid', 'EPS_GRID'), ('Eps_filter', 'EPS_FILTER'), ('Cutoff', 'CUTOFF'), ('Rel_cutoff', 'REL_CUTOFF'), ('Print_level', 'PRINT_LEVEL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Relative_cutoff(self):
        """
        See documentation for Rel_cutoff
        """
        return self.Rel_cutoff

    @property
    def Iolevel(self):
        """
        See documentation for Print_level
        """
        return self.Print_level

    @Relative_cutoff.setter
    def Relative_cutoff(self, value):
        self.Rel_cutoff = value

    @Iolevel.setter
    def Iolevel(self, value):
        self.Print_level = value



class _wfc_gpw1(printable):
    """
    Parameters for the GPW approach in Wavefunction-based Correlation
    methods
    """
    def __init__(self):
        self.Eps_grid = None
        """
        Determines a threshold for the GPW based integration
        """
        self.Eps_filter = None
        """
        Determines a threshold for the DBCSR based multiply (usually 10 times
        smaller than EPS_GRID).
        """
        self.Cutoff = None
        """
        The cutoff of the finest grid level in the MP2 gpw integration.
        """
        self.Rel_cutoff = None
        """
        Determines the grid at which a Gaussian is mapped.
        """
        self.Print_level = None
        """
        How much output is written by the individual groups.

        Available values:
            SILENT
                Almost no output
            LOW
                Little output
            MEDIUM
                Quite some output
            HIGH
                Lots of output
            DEBUG
                Everything is written out, useful for debugging purposes only
        """
        self._name = "WFC_GPW"
        self._keywords = [('Eps_grid', 'EPS_GRID'), ('Eps_filter', 'EPS_FILTER'), ('Cutoff', 'CUTOFF'), ('Rel_cutoff', 'REL_CUTOFF'), ('Print_level', 'PRINT_LEVEL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Relative_cutoff(self):
        """
        See documentation for Rel_cutoff
        """
        return self.Rel_cutoff

    @property
    def Iolevel(self):
        """
        See documentation for Print_level
        """
        return self.Print_level

    @Relative_cutoff.setter
    def Relative_cutoff(self, value):
        self.Rel_cutoff = value

    @Iolevel.setter
    def Iolevel(self, value):
        self.Print_level = value



class _williams4(printable):
    """
    This section specifies the input parameters for WILLIAMS potential
    type.Functional form: V(r) = A*EXP(-B*r) - C / r^6 .
    """
    def __init__(self):
        self.Atoms = None
        """
        Defines the atomic kind involved in the nonbond potential
        """
        self.A = None
        """
        Defines the A parameter of the Williams potential
        """
        self.B = None
        """
        Defines the B parameter of the Williams potential
        """
        self.C = None
        """
        Defines the C parameter of the Williams potential
        """
        self.Rcut = None
        """
        Defines the cutoff parameter of the Williams potential
        """
        self.Rmin = None
        """
        Defines the lower bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self.Rmax = None
        """
        Defines the upper bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self._name = "WILLIAMS"
        self._keywords = [('Atoms', 'ATOMS'), ('A', 'A'), ('B', 'B'), ('C', 'C'), ('Rcut', 'RCUT'), ('Rmin', 'RMIN'), ('Rmax', 'RMAX')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _williams1(printable):
    """
    This section specifies the input parameters for WILLIAMS potential
    type.Functional form: V(r) = A*EXP(-B*r) - C / r^6 .
    """
    def __init__(self):
        self.Atoms = None
        """
        Defines the atomic kind involved in the nonbond potential
        """
        self.A = None
        """
        Defines the A parameter of the Williams potential
        """
        self.B = None
        """
        Defines the B parameter of the Williams potential
        """
        self.C = None
        """
        Defines the C parameter of the Williams potential
        """
        self.Rcut = None
        """
        Defines the cutoff parameter of the Williams potential
        """
        self.Rmin = None
        """
        Defines the lower bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self.Rmax = None
        """
        Defines the upper bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self._name = "WILLIAMS"
        self._keywords = [('Atoms', 'ATOMS'), ('A', 'A'), ('B', 'B'), ('C', 'C'), ('Rcut', 'RCUT'), ('Rmin', 'RMIN'), ('Rmax', 'RMAX')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _williams3(printable):
    """
    This section specifies the input parameters for WILLIAMS potential
    type.Functional form: V(r) = A*EXP(-B*r) - C / r^6 .
    """
    def __init__(self):
        self.Atoms = None
        """
        Defines the atomic kind involved in the nonbond potential
        """
        self.A = None
        """
        Defines the A parameter of the Williams potential
        """
        self.B = None
        """
        Defines the B parameter of the Williams potential
        """
        self.C = None
        """
        Defines the C parameter of the Williams potential
        """
        self.Rcut = None
        """
        Defines the cutoff parameter of the Williams potential
        """
        self.Rmin = None
        """
        Defines the lower bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self.Rmax = None
        """
        Defines the upper bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self._name = "WILLIAMS"
        self._keywords = [('Atoms', 'ATOMS'), ('A', 'A'), ('B', 'B'), ('C', 'C'), ('Rcut', 'RCUT'), ('Rmin', 'RMIN'), ('Rmax', 'RMAX')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _williams2(printable):
    """
    This section specifies the input parameters for WILLIAMS potential
    type.Functional form: V(r) = A*EXP(-B*r) - C / r^6 .
    """
    def __init__(self):
        self.Atoms = None
        """
        Defines the atomic kind involved in the nonbond potential
        """
        self.A = None
        """
        Defines the A parameter of the Williams potential
        """
        self.B = None
        """
        Defines the B parameter of the Williams potential
        """
        self.C = None
        """
        Defines the C parameter of the Williams potential
        """
        self.Rcut = None
        """
        Defines the cutoff parameter of the Williams potential
        """
        self.Rmin = None
        """
        Defines the lower bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self.Rmax = None
        """
        Defines the upper bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self._name = "WILLIAMS"
        self._keywords = [('Atoms', 'ATOMS'), ('A', 'A'), ('B', 'B'), ('C', 'C'), ('Rcut', 'RCUT'), ('Rmin', 'RMIN'), ('Rmax', 'RMAX')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _convergence_info1(printable):
    """
    Controls the printing of the convergence criteria during a BAND run
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each68()
        self._name = "CONVERGENCE_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _chi1(printable):
    """
    Information to initialize the Ad-Langevin thermostat DOF CHI
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify an initial thermostat DOF CHI for Ad-Langevin thermostat.
        """
        self._name = "CHI"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _chi2(printable):
    """
    Information to initialize the Ad-Langevin thermostat DOF CHI
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify an initial thermostat DOF CHI for Ad-Langevin thermostat.
        """
        self._name = "CHI"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _scp1(printable):
    """
    Parameters needed to set up the SCP-DFT method
    """
    def __init__(self):
        self.Section_parameters = None
        """
        controls the activation of the SCP method
        """
        self.Dispersion = None
        """
        Use dispersion correction through SCP method
        """
        self.PROGRAM_RUN_INFO = _program_run_info13()
        self._name = "SCP"
        self._keywords = [('Dispersion', 'DISPERSION')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _becke_roussel1(printable):
    """
    Becke Roussel exchange hole model. Can be usedas long range correction
    with a truncated coulomb potential
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Cutoff_radius = None
        """
        Defines the cutoff radius for the truncation. If put to zero, the
        standard full range potential will be used
        """
        self.Gamma = None
        """
        Parameter in the exchange hole. Usually this is put to 1.0 or 0.8
        """
        self._name = "BECKE_ROUSSEL"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Cutoff_radius', 'CUTOFF_RADIUS'), ('Gamma', 'GAMMA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _becke_roussel2(printable):
    """
    Becke Roussel exchange hole model. Can be usedas long range correction
    with a truncated coulomb potential
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Cutoff_radius = None
        """
        Defines the cutoff radius for the truncation. If put to zero, the
        standard full range potential will be used
        """
        self.Gamma = None
        """
        Parameter in the exchange hole. Usually this is put to 1.0 or 0.8
        """
        self._name = "BECKE_ROUSSEL"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Cutoff_radius', 'CUTOFF_RADIUS'), ('Gamma', 'GAMMA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _becke_roussel3(printable):
    """
    Becke Roussel exchange hole model. Can be usedas long range correction
    with a truncated coulomb potential
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Cutoff_radius = None
        """
        Defines the cutoff radius for the truncation. If put to zero, the
        standard full range potential will be used
        """
        self.Gamma = None
        """
        Parameter in the exchange hole. Usually this is put to 1.0 or 0.8
        """
        self._name = "BECKE_ROUSSEL"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Cutoff_radius', 'CUTOFF_RADIUS'), ('Gamma', 'GAMMA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _becke_roussel4(printable):
    """
    Becke Roussel exchange hole model. Can be usedas long range correction
    with a truncated coulomb potential
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Cutoff_radius = None
        """
        Defines the cutoff radius for the truncation. If put to zero, the
        standard full range potential will be used
        """
        self.Gamma = None
        """
        Parameter in the exchange hole. Usually this is put to 1.0 or 0.8
        """
        self._name = "BECKE_ROUSSEL"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Cutoff_radius', 'CUTOFF_RADIUS'), ('Gamma', 'GAMMA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _core_trajectory1(printable):
    """
    Controls the output of the trajectory of cores when the shell-model is
    used
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.Format = None
        """
        Specifies the format of the output file for the trajectory of cores.

        Available values:
            ATOMIC
                Write only the coordinates X,Y,Z without element symbols to a
                formatted file
            DCD
                Write the coordinates (no element labels) and the cell information to
                a binary file
            PDB
                Write the atomic information in PDB format to a formatted file
            XMOL
                Mostly known as XYZ format, provides in a formatted file:
                element_symbol X Y Z
            XYZ
                Alias name for XMOL
        """
        self.Charge_occup = None
        """
        Write the MM charges to the OCCUP field of the PDB file
        """
        self.Charge_beta = None
        """
        Write the MM charges to the BETA field of the PDB file
        """
        self.Charge_extended = None
        """
        Write the MM charges to the very last field of the PDB file (starting
        from column 81)
        """
        self.EACH = _each74()
        self._name = "CORE_TRAJECTORY"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT'), ('Format', 'FORMAT'), ('Charge_occup', 'CHARGE_OCCUP'), ('Charge_beta', 'CHARGE_BETA'), ('Charge_extended', 'CHARGE_EXTENDED')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Charge_o(self):
        """
        See documentation for Charge_occup
        """
        return self.Charge_occup

    @property
    def Charge_b(self):
        """
        See documentation for Charge_beta
        """
        return self.Charge_beta

    @Charge_o.setter
    def Charge_o(self, value):
        self.Charge_occup = value

    @Charge_b.setter
    def Charge_b(self, value):
        self.Charge_beta = value



class _distance_from_path1(printable):
    """
    Section defining the distance from a one dimensional reaction path in
    an Q-dimensional space of colvars. Constraining this colvar, allows to
    sample the space equidistant to the reaction path, both in the
    Q-dimensional colvar and 3N-Q remaining coordinates. For the details
    of the function see cited literature.
    """
    def __init__(self):
        self.Distances_rmsd = None
        """

        """
        self.Rmsd = None
        """

        """
        self.Subset_type = None
        """
        Define the subsytem used to compute the RMSD

        Available values:
            ALL
            LIST
        """
        self.Align_frames = None
        """
        Whether the reference frames should be aligned to minimize the RMSD
        """
        self.list_Atoms = []
        self.list_Function = []
        self.Variable = None
        """
        Specifies the name of the variable that parametrises the FUNCTION
        defining the reaction path.
        """
        self.Lambda = None
        """
        Specifies the exponent of the Gaussian used in the integral
        representation of the colvar.The shape of the space orthogonal to the
        reaction path is defined by this choice. In the limit of large values,
        it is given by the plane orthogonal to the path.In practice, modest
        values are required for stable numerical integration.
        """
        self.Step_size = None
        """
        Step size in the numerical integration, a few thousand points are
        common, and the proper number also depends on LAMBDA.
        """
        self.Range = None
        """
        The range of VARIABLE used for the parametrisation.
        """
        self.list_COLVAR = []
        self.list_FRAME = []
        self.MAP = _map2()
        self._name = "DISTANCE_FROM_PATH"
        self._keywords = [('Distances_rmsd', 'DISTANCES_RMSD'), ('Rmsd', 'RMSD'), ('Subset_type', 'SUBSET_TYPE'), ('Align_frames', 'ALIGN_FRAMES'), ('Variable', 'VARIABLE'), ('Lambda', 'LAMBDA'), ('Step_size', 'STEP_SIZE'), ('Range', 'RANGE')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Function', 'FUNCTION')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('MAP', 'MAP')]
        self._repeated_subsections = [('COLVAR', '_colvar3'), ('FRAME', '_frame5')]

    def add_COLVAR(self):
        new_section = _colvar3()
        self.list_COLVAR.append(new_section)
        return new_section

    def add_FRAME(self):
        new_section = _frame5()
        self.list_FRAME.append(new_section)
        return new_section

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Function(self, value):
        self.list_Function.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _sic2(printable):
    """
    parameters for the self interaction correction
    """
    def __init__(self):
        self.Sic_scaling_a = None
        """
        Scaling of the coulomb term in sic [experimental]
        """
        self.Sic_scaling_b = None
        """
        Scaling of the xc term in sic [experimental]
        """
        self.Sic_method = None
        """
        Method used to remove the self interaction

        Available values:
            NONE
                Do not apply a sic correction
            MAURI_US
                Employ a (scaled) correction proposed by Mauri and co-workers on the
                spin density / doublet unpaired orbital
            MAURI_SPZ
                Employ a (scaled) Perdew-Zunger expression on the spin density /
                doublet unpaired orbital
            AD
                The average density correction
            EXPLICIT_ORBITALS
                (scaled) Perdew-Zunger correction explicitly on a set of orbitals.
        """
        self.Orbital_set = None
        """
        Type of orbitals treated with the SIC

        Available values:
            UNPAIRED
                correction for the unpaired orbitals only, requires a restricted open
                shell calculation
            ALL
                correction for all orbitals, requires a LSD or ROKS calculation
        """
        self._name = "SIC"
        self._keywords = [('Sic_scaling_a', 'SIC_SCALING_A'), ('Sic_scaling_b', 'SIC_SCALING_B'), ('Sic_method', 'SIC_METHOD'), ('Orbital_set', 'ORBITAL_SET')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _sic1(printable):
    """
    parameters for the self interaction correction
    """
    def __init__(self):
        self.Sic_scaling_a = None
        """
        Scaling of the coulomb term in sic [experimental]
        """
        self.Sic_scaling_b = None
        """
        Scaling of the xc term in sic [experimental]
        """
        self.Sic_method = None
        """
        Method used to remove the self interaction

        Available values:
            NONE
                Do not apply a sic correction
            MAURI_US
                Employ a (scaled) correction proposed by Mauri and co-workers on the
                spin density / doublet unpaired orbital
            MAURI_SPZ
                Employ a (scaled) Perdew-Zunger expression on the spin density /
                doublet unpaired orbital
            AD
                The average density correction
            EXPLICIT_ORBITALS
                (scaled) Perdew-Zunger correction explicitly on a set of orbitals.
        """
        self.Orbital_set = None
        """
        Type of orbitals treated with the SIC

        Available values:
            UNPAIRED
                correction for the unpaired orbitals only, requires a restricted open
                shell calculation
            ALL
                correction for all orbitals, requires a LSD or ROKS calculation
        """
        self._name = "SIC"
        self._keywords = [('Sic_scaling_a', 'SIC_SCALING_A'), ('Sic_scaling_b', 'SIC_SCALING_B'), ('Sic_method', 'SIC_METHOD'), ('Orbital_set', 'ORBITAL_SET')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _chi3(printable):
    """
    Information to initialize the Ad-Langevin thermostat DOF CHI
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify an initial thermostat DOF CHI for Ad-Langevin thermostat.
        """
        self._name = "CHI"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _beta1(printable):
    """
    beta spin
    """
    def __init__(self):
        self.Nel = None
        """
        Orbital ccupation change per angular momentum quantum number.Applied
        to spin beta and active only in unrestricted calculations.
        """
        self.L = None
        """
        Angular momentum quantum number of theorbitals of beta spin whose
        occupation is changed.Active only for unrestricted calculations
        """
        self.N = None
        """
        Principal quantum number of theorbitals of beta spin whose occupation
        is changed. Default is the first not occupied.Active only for
        unrestricted calculations
        """
        self._name = "BETA"
        self._keywords = [('Nel', 'NEL'), ('L', 'L'), ('N', 'N')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _constant_env1(printable):
    """
    parameters for a constant envelop
    """
    def __init__(self):
        self.Start_step = None
        """
        First step the field is applied
        """
        self.End_step = None
        """
        Last step the field is applied
        """
        self._name = "CONSTANT_ENV"
        self._keywords = [('Start_step', 'START_STEP'), ('End_step', 'END_STEP')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _collective1(printable):
    """
    Used to constraint collective (general) degrees of freedom, writing
    langrangian multipliers to file.
    """
    def __init__(self):
        self.Colvar = None
        """
        Specifies the index (in input file order) of the type of colvar to
        constrain.
        """
        self.Molecule = None
        """
        Specifies the index of the molecule kind (in input file order)on which
        the constraint will be applied. MOLECULE and MOLNAME keyword exclude
        themself mutually.
        """
        self.Molname = None
        """
        Specifies the name of the molecule on which the constraint will be
        applied.
        """
        self.Intermolecular = None
        """
        Specify if the constraint/restraint is intermolecular.
        """
        self.Target = None
        """
        Specifies the target value of the constrained collective variable
        (units depend on the colvar).
        """
        self.Target_growth = None
        """
        Specifies the growth speed of the target value of the constrained
        collective variable.
        """
        self.Target_limit = None
        """
        Specifies the limit of the growth of the target value of the
        constrained collective variable. By default no limit at the colvar
        growth is set.
        """
        self.Exclude_qm = None
        """
        Does not apply the constraint to the QM region within a QM/MM
        calculation
        """
        self.Exclude_mm = None
        """
        Does not apply the constraint to the MM region within a QM/MM
        calculation
        """
        self.RESTRAINT = _restraint5()
        self._name = "COLLECTIVE"
        self._keywords = [('Colvar', 'COLVAR'), ('Molecule', 'MOLECULE'), ('Molname', 'MOLNAME'), ('Intermolecular', 'INTERMOLECULAR'), ('Target', 'TARGET'), ('Target_growth', 'TARGET_GROWTH'), ('Target_limit', 'TARGET_LIMIT'), ('Exclude_qm', 'EXCLUDE_QM'), ('Exclude_mm', 'EXCLUDE_MM')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('RESTRAINT', 'RESTRAINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Segname(self):
        """
        See documentation for Molname
        """
        return self.Molname

    @Segname.setter
    def Segname(self, value):
        self.Molname = value



class _hfx_ri3(printable):
    """
    All parameters needed in a HFX RI calculation
    """
    def __init__(self):
        self.Eps_screening = None
        """
        Accuracy of geminal integral evaluation
        """
        self.Eps_optimization = None
        """
        Accuracy of iterative RI fit
        """
        self.Max_iter = None
        """
        Maximum number of iteration in RI fit
        """
        self.PRINT = _print26()
        self._name = "HFX_RI"
        self._keywords = [('Eps_screening', 'EPS_SCREENING'), ('Eps_optimization', 'EPS_OPTIMIZATION'), ('Max_iter', 'MAX_ITER')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _hfx_ri2(printable):
    """
    All parameters needed in a HFX RI calculation
    """
    def __init__(self):
        self.Eps_screening = None
        """
        Accuracy of geminal integral evaluation
        """
        self.Eps_optimization = None
        """
        Accuracy of iterative RI fit
        """
        self.Max_iter = None
        """
        Maximum number of iteration in RI fit
        """
        self.PRINT = _print24()
        self._name = "HFX_RI"
        self._keywords = [('Eps_screening', 'EPS_SCREENING'), ('Eps_optimization', 'EPS_OPTIMIZATION'), ('Max_iter', 'MAX_ITER')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _hfx_ri1(printable):
    """
    All parameters needed in a HFX RI calculation
    """
    def __init__(self):
        self.Eps_screening = None
        """
        Accuracy of geminal integral evaluation
        """
        self.Eps_optimization = None
        """
        Accuracy of iterative RI fit
        """
        self.Max_iter = None
        """
        Maximum number of iteration in RI fit
        """
        self.PRINT = _print22()
        self._name = "HFX_RI"
        self._keywords = [('Eps_screening', 'EPS_SCREENING'), ('Eps_optimization', 'EPS_OPTIMIZATION'), ('Max_iter', 'MAX_ITER')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _hfx_ri7(printable):
    """
    All parameters needed in a HFX RI calculation
    """
    def __init__(self):
        self.Eps_screening = None
        """
        Accuracy of geminal integral evaluation
        """
        self.Eps_optimization = None
        """
        Accuracy of iterative RI fit
        """
        self.Max_iter = None
        """
        Maximum number of iteration in RI fit
        """
        self.PRINT = _print65()
        self._name = "HFX_RI"
        self._keywords = [('Eps_screening', 'EPS_SCREENING'), ('Eps_optimization', 'EPS_OPTIMIZATION'), ('Max_iter', 'MAX_ITER')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _hfx_ri6(printable):
    """
    All parameters needed in a HFX RI calculation
    """
    def __init__(self):
        self.Eps_screening = None
        """
        Accuracy of geminal integral evaluation
        """
        self.Eps_optimization = None
        """
        Accuracy of iterative RI fit
        """
        self.Max_iter = None
        """
        Maximum number of iteration in RI fit
        """
        self.PRINT = _print55()
        self._name = "HFX_RI"
        self._keywords = [('Eps_screening', 'EPS_SCREENING'), ('Eps_optimization', 'EPS_OPTIMIZATION'), ('Max_iter', 'MAX_ITER')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _hfx_ri5(printable):
    """
    All parameters needed in a HFX RI calculation
    """
    def __init__(self):
        self.Eps_screening = None
        """
        Accuracy of geminal integral evaluation
        """
        self.Eps_optimization = None
        """
        Accuracy of iterative RI fit
        """
        self.Max_iter = None
        """
        Maximum number of iteration in RI fit
        """
        self.PRINT = _print53()
        self._name = "HFX_RI"
        self._keywords = [('Eps_screening', 'EPS_SCREENING'), ('Eps_optimization', 'EPS_OPTIMIZATION'), ('Max_iter', 'MAX_ITER')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _hfx_ri4(printable):
    """
    All parameters needed in a HFX RI calculation
    """
    def __init__(self):
        self.Eps_screening = None
        """
        Accuracy of geminal integral evaluation
        """
        self.Eps_optimization = None
        """
        Accuracy of iterative RI fit
        """
        self.Max_iter = None
        """
        Maximum number of iteration in RI fit
        """
        self.PRINT = _print28()
        self._name = "HFX_RI"
        self._keywords = [('Eps_screening', 'EPS_SCREENING'), ('Eps_optimization', 'EPS_OPTIMIZATION'), ('Max_iter', 'MAX_ITER')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _temp_control1(printable):
    """
    Setup parameters to control the temperature during a BAND MD run.
    """
    def __init__(self):
        self.Temperature = None
        """
        Specify the target temperature
        """
        self.Temp_tol = None
        """
        Specify the tolerance on the temperature for rescaling
        """
        self.Temp_tol_steps = None
        """
        Specify the number of steps to apply a temperature control
        """
        self._name = "TEMP_CONTROL"
        self._keywords = [('Temperature', 'TEMPERATURE'), ('Temp_tol', 'TEMP_TOL'), ('Temp_tol_steps', 'TEMP_TOL_STEPS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _hfx_ri8(printable):
    """
    All parameters needed in a HFX RI calculation
    """
    def __init__(self):
        self.Eps_screening = None
        """
        Accuracy of geminal integral evaluation
        """
        self.Eps_optimization = None
        """
        Accuracy of iterative RI fit
        """
        self.Max_iter = None
        """
        Maximum number of iteration in RI fit
        """
        self.PRINT = _print67()
        self._name = "HFX_RI"
        self._keywords = [('Eps_screening', 'EPS_SCREENING'), ('Eps_optimization', 'EPS_OPTIMIZATION'), ('Max_iter', 'MAX_ITER')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each39(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info48(printable):
    """
    Controls the printing of information regarding the run.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each329()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _distance_function4(printable):
    """
    Section to define functions between two distances as collective
    variables. The function is defined as d1+coeff*d2
    """
    def __init__(self):
        self.Atoms = None
        """
        Specifies the indexes of atoms/points for the two bonds d1=(1-2)
        d2=(3-4).
        """
        self.Coefficient = None
        """
        Specifies the coefficient in the function for the constraint. -1.0 has
        to be used for distance difference, 1.0 for distance addition
        """
        self.Pbc = None
        """
        Whether periodic boundary conditions should be applied on the atomic
        position before computing the colvar or not.
        """
        self.list_POINT = []
        self._name = "DISTANCE_FUNCTION"
        self._keywords = [('Atoms', 'ATOMS'), ('Coefficient', 'COEFFICIENT'), ('Pbc', 'PBC')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point64')]

    def add_POINT(self):
        new_section = _point64()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Points(self):
        """
        See documentation for Atoms
        """
        return self.Atoms

    @Points.setter
    def Points(self, value):
        self.Atoms = value



class _energies1(printable):
    """
    Controls the printing of the EIP energies.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each259()
        self._name = "ENERGIES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _distance_function1(printable):
    """
    Section to define functions between two distances as collective
    variables. The function is defined as d1+coeff*d2
    """
    def __init__(self):
        self.Atoms = None
        """
        Specifies the indexes of atoms/points for the two bonds d1=(1-2)
        d2=(3-4).
        """
        self.Coefficient = None
        """
        Specifies the coefficient in the function for the constraint. -1.0 has
        to be used for distance difference, 1.0 for distance addition
        """
        self.Pbc = None
        """
        Whether periodic boundary conditions should be applied on the atomic
        position before computing the colvar or not.
        """
        self.list_POINT = []
        self._name = "DISTANCE_FUNCTION"
        self._keywords = [('Atoms', 'ATOMS'), ('Coefficient', 'COEFFICIENT'), ('Pbc', 'PBC')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point10')]

    def add_POINT(self):
        new_section = _point10()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Points(self):
        """
        See documentation for Atoms
        """
        return self.Atoms

    @Points.setter
    def Points(self, value):
        self.Atoms = value



class _distance_function2(printable):
    """
    Section to define functions between two distances as collective
    variables. The function is defined as d1+coeff*d2
    """
    def __init__(self):
        self.Atoms = None
        """
        Specifies the indexes of atoms/points for the two bonds d1=(1-2)
        d2=(3-4).
        """
        self.Coefficient = None
        """
        Specifies the coefficient in the function for the constraint. -1.0 has
        to be used for distance difference, 1.0 for distance addition
        """
        self.Pbc = None
        """
        Whether periodic boundary conditions should be applied on the atomic
        position before computing the colvar or not.
        """
        self.list_POINT = []
        self._name = "DISTANCE_FUNCTION"
        self._keywords = [('Atoms', 'ATOMS'), ('Coefficient', 'COEFFICIENT'), ('Pbc', 'PBC')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point28')]

    def add_POINT(self):
        new_section = _point28()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Points(self):
        """
        See documentation for Atoms
        """
        return self.Atoms

    @Points.setter
    def Points(self, value):
        self.Atoms = value



class _distance_function3(printable):
    """
    Section to define functions between two distances as collective
    variables. The function is defined as d1+coeff*d2
    """
    def __init__(self):
        self.Atoms = None
        """
        Specifies the indexes of atoms/points for the two bonds d1=(1-2)
        d2=(3-4).
        """
        self.Coefficient = None
        """
        Specifies the coefficient in the function for the constraint. -1.0 has
        to be used for distance difference, 1.0 for distance addition
        """
        self.Pbc = None
        """
        Whether periodic boundary conditions should be applied on the atomic
        position before computing the colvar or not.
        """
        self.list_POINT = []
        self._name = "DISTANCE_FUNCTION"
        self._keywords = [('Atoms', 'ATOMS'), ('Coefficient', 'COEFFICIENT'), ('Pbc', 'PBC')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point46')]

    def add_POINT(self):
        new_section = _point46()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Points(self):
        """
        See documentation for Atoms
        """
        return self.Atoms

    @Points.setter
    def Points(self, value):
        self.Atoms = value



class _each310(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each311(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each312(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each313(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each314(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each315(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each316(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each317(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each318(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each319(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _uvar1(printable):
    """
    This section specify the nature of the collective variables used in
    computing the free energy.
    """
    def __init__(self):
        self.Colvar = None
        """
        Specifies the colvar used to compute free energy
        """
        self._name = "UVAR"
        self._keywords = [('Colvar', 'COLVAR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _ff_parameter_file1(printable):
    """
    Controls the printing of Force Field parameter file
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each230()
        self._name = "FF_PARAMETER_FILE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _lyp4(printable):
    """
    Uses the LYP functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_c = None
        """
        scales the correlation part of the functional
        """
        self._name = "LYP"
        self._keywords = [('Scale_c', 'SCALE_C')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _lyp3(printable):
    """
    Uses the LYP functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_c = None
        """
        scales the correlation part of the functional
        """
        self._name = "LYP"
        self._keywords = [('Scale_c', 'SCALE_C')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _count1(printable):
    """
    Controls the printing of the number of function calls.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each264()
        self._name = "COUNT"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _lyp1(printable):
    """
    Uses the LYP functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_c = None
        """
        scales the correlation part of the functional
        """
        self._name = "LYP"
        self._keywords = [('Scale_c', 'SCALE_C')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _fit_basis1(printable):
    """
    Controls the printing of FIT BASIS task
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each363()
        self._name = "FIT_BASIS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each6(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each7(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each4(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each5(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each2(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _update1(printable):
    """
    update a result MO with with a linear combination of of original MOs.
    This section can be repeated to build arbitrary linear combinations
    using repeatedly y=a*y+b*x.
    """
    def __init__(self):
        self.Result_mo_index = None
        """
        Index of the MO (y) to be modified. Counting down in energy with
        HOMO=1
        """
        self.Result_marked_state = None
        """
        Specifies the MO according to the marks set in MOLECULAR_STATES. The
        value corresponds to the repetition  of MARK_STATES in
        MOLECULAR_STATES
        """
        self.Result_spin_index = None
        """
        Spin of the MO (y) to be modified.

        Available values:
            ALPHA
                Majority spin
            BETA
                Minority spin
        """
        self.Result_scale = None
        """
        Scaling factor of the result variable (a).
        """
        self.Orig_mo_index = None
        """
        Index of the original MO (x). Counting down in energy with HOMO=1 or
        up from LUMO=1, depending on ORIG_IS_VIRTUAL.
        """
        self.Orig_marked_state = None
        """
        Specifies the MO according to the marks set in MOLECULAR_STATES. The
        value corresponds to the repetition  of MARK_STATES in
        MOLECULAR_STATES
        """
        self.Orig_spin_index = None
        """
        Spin of the MO (x) to be modified.

        Available values:
            ALPHA
                Majority spin
            BETA
                Minority spin
        """
        self.Orig_scale = None
        """
        Scaling factor of the result variable (b).
        """
        self.Orig_is_virtual = None
        """
        The original MO (x) is a LUMO.
        """
        self._name = "UPDATE"
        self._keywords = [('Result_mo_index', 'RESULT_MO_INDEX'), ('Result_marked_state', 'RESULT_MARKED_STATE'), ('Result_spin_index', 'RESULT_SPIN_INDEX'), ('Result_scale', 'RESULT_SCALE'), ('Orig_mo_index', 'ORIG_MO_INDEX'), ('Orig_marked_state', 'ORIG_MARKED_STATE'), ('Orig_spin_index', 'ORIG_SPIN_INDEX'), ('Orig_scale', 'ORIG_SCALE'), ('Orig_is_virtual', 'ORIG_IS_VIRTUAL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each1(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each8(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each9(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _gv094(printable):
    """
    Combination of three different exchange hole models
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Cutoff_radius = None
        """
        Defines cutoff for lower integration boundary
        """
        self.Gamma = None
        """
        Parameter for Becke Roussel hole
        """
        self._name = "GV09"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Cutoff_radius', 'CUTOFF_RADIUS'), ('Gamma', 'GAMMA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _gv091(printable):
    """
    Combination of three different exchange hole models
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Cutoff_radius = None
        """
        Defines cutoff for lower integration boundary
        """
        self.Gamma = None
        """
        Parameter for Becke Roussel hole
        """
        self._name = "GV09"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Cutoff_radius', 'CUTOFF_RADIUS'), ('Gamma', 'GAMMA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _gv093(printable):
    """
    Combination of three different exchange hole models
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Cutoff_radius = None
        """
        Defines cutoff for lower integration boundary
        """
        self.Gamma = None
        """
        Parameter for Becke Roussel hole
        """
        self._name = "GV09"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Cutoff_radius', 'CUTOFF_RADIUS'), ('Gamma', 'GAMMA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _gv092(printable):
    """
    Combination of three different exchange hole models
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Cutoff_radius = None
        """
        Defines cutoff for lower integration boundary
        """
        self.Gamma = None
        """
        Parameter for Becke Roussel hole
        """
        self._name = "GV09"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Cutoff_radius', 'CUTOFF_RADIUS'), ('Gamma', 'GAMMA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each224(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each225(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each226(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each227(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each220(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each221(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each222(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each223(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each228(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each229(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each138(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each139(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each130(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each131(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each132(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each133(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each134(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each135(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each136(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each137(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _e_density_cube1(printable):
    """
    Controls the printing of cube files with the electronic density and,
    for LSD calculations, the spin density
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Stride = None
        """
        The stride (X,Y,Z) used to write the cube file (larger values result
        in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1
        number valid for all components.
        """
        self.Total_density = None
        """
        Print the total electronic density in the case of a GAPW run. This
        keyword has only an effect, if PAW atoms are present. The default is
        to print only the soft part of the electronic density and to ignore
        the hard part. NOTE: The total density in real space might exhibit
        unphysical features like spikes due to the finite and thus truncated g
        vector expansion
        """
        self.Append = None
        """
        append the cube files when they already exist
        """
        self.Xrd_interface = None
        """
        It activates the print out of exponents and coefficients for the
        Gaussian expansion of the core densities, based on atom calculations
        for each kind. The resulting core dansities are needed to compute the
        form factors. If GAPW the local densities are also given in terms of a
        Gaussian expansion, by fitting the difference between local-fhard and
        local-soft density for each atom. In this case the keyword
        TOTAL_DENSITY is set to FALSE
        """
        self.Ngauss = None
        """
        Number of Gaussian functions used in the expansion of atomic (core)
        density
        """
        self.EACH = _each192()
        self._name = "E_DENSITY_CUBE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Stride', 'STRIDE'), ('Total_density', 'TOTAL_DENSITY'), ('Append', 'APPEND'), ('Xrd_interface', 'XRD_INTERFACE'), ('Ngauss', 'NGAUSS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _localize1(printable):
    """
    Use one of the available methods to define the localization  and
    possibly to optimize it to a minimum or a maximum.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        controls the activation of the MOS localization procedure
        """
        self.Max_iter = None
        """
        Maximum number of iterations used for localization methods
        """
        self.Max_crazy_angle = None
        """
        Largest allowed angle for the crazy rotations algorithm (smaller is
        slower but more stable).
        """
        self.Crazy_scale = None
        """
        scale angles
        """
        self.Crazy_use_diag = None
        """
        Use diagonalization (slow) or pade based calculation of matrix
        exponentials.
        """
        self.Use_history = None
        """
        Generate an improved initial guess based on a history of results,
        which is useful during MD.Will only work if the number of states to be
        localized remains constant.
        """
        self.Eps_occupation = None
        """
        Tolerance in the occupation number to select only fully occupied
        orbitals for the rotation
        """
        self.Out_iter_each = None
        """
        Every how many iterations of the localization algorithm(Jacobi) the
        tolerance value is printed out
        """
        self.Eps_localization = None
        """
        Tolerance used in the convergence criterium of the localization
        methods.
        """
        self.Min_or_max = None
        """
        Requires the maximization of the spread of the wfn

        Available values:
            SPREADMIN
            SPREADMAX
        """
        self.Method = None
        """
        Method of optimization if any

        Available values:
            NONE
                No localization is applied
            JACOBI
                Using 2 x 2 rotations of the orbitals, slow but robust
            CRAZY
                A new fast method is applied, might be slightly less robust than
                jacobi, but usually much faster
            L1SD
                Steepest descent minimization of an approximate l1 norm
            DIRECT
                Using a direct minimisation approach
        """
        self.Jacobi_fallback = None
        """
        Use Jacobi method in case no convergence was achieved by using the
        crazy rotations method.
        """
        self.Restart = None
        """
        Restart the localization from a set of orbitals read from a
        localization restart file.
        """
        self.Lochomo_restart_file_name = None
        """
        File name where to read the MOS fromwhich to restart the localization
        procedure for occupied states
        """
        self.Loclumo_restart_file_name = None
        """
        File name where to read the MOS fromwhich to restart the localization
        procedure for unoccupied states
        """
        self.Operator = None
        """
        Type of opertator which defines the spread functional

        Available values:
            BERRY
            BOYS
            PIPEK
        """
        self.list_List = []
        self.list_List_unoccupied = []
        self.States = None
        """
        Which states to localize, LUMO up to now only available in GPW

        Available values:
            OCCUPIED
            UNOCCUPIED
            ALL
        """
        self.Energy_range = None
        """
        Select the orbitals to be localized within the given energy range.This
        type of selection cannot be added on top of the selection through a
        LIST. It reads to reals that are lower and higher boundaries of the
        energy range.
        """
        self.PRINT = _print30()
        self._name = "LOCALIZE"
        self._keywords = [('Max_iter', 'MAX_ITER'), ('Max_crazy_angle', 'MAX_CRAZY_ANGLE'), ('Crazy_scale', 'CRAZY_SCALE'), ('Crazy_use_diag', 'CRAZY_USE_DIAG'), ('Use_history', 'USE_HISTORY'), ('Eps_occupation', 'EPS_OCCUPATION'), ('Out_iter_each', 'OUT_ITER_EACH'), ('Eps_localization', 'EPS_LOCALIZATION'), ('Min_or_max', 'MIN_OR_MAX'), ('Method', 'METHOD'), ('Jacobi_fallback', 'JACOBI_FALLBACK'), ('Restart', 'RESTART'), ('Lochomo_restart_file_name', 'LOCHOMO_RESTART_FILE_NAME'), ('Loclumo_restart_file_name', 'LOCLUMO_RESTART_FILE_NAME'), ('Operator', 'OPERATOR'), ('States', 'STATES'), ('Energy_range', 'ENERGY_RANGE')]
        self._repeated_keywords = [('List', 'LIST'), ('List_unoccupied', 'LIST_UNOCCUPIED')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def add_List(self, value):
        self.list_List.append(value)

    def add_List_unoccupied(self, value):
        self.list_List_unoccupied.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _localize2(printable):
    """
    Use one of the available methods to define the localization  and
    possibly to optimize it to a minimum or a maximum.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        controls the activation of the MOS localization procedure
        """
        self.Max_iter = None
        """
        Maximum number of iterations used for localization methods
        """
        self.Max_crazy_angle = None
        """
        Largest allowed angle for the crazy rotations algorithm (smaller is
        slower but more stable).
        """
        self.Crazy_scale = None
        """
        scale angles
        """
        self.Crazy_use_diag = None
        """
        Use diagonalization (slow) or pade based calculation of matrix
        exponentials.
        """
        self.Use_history = None
        """
        Generate an improved initial guess based on a history of results,
        which is useful during MD.Will only work if the number of states to be
        localized remains constant.
        """
        self.Eps_occupation = None
        """
        Tolerance in the occupation number to select only fully occupied
        orbitals for the rotation
        """
        self.Out_iter_each = None
        """
        Every how many iterations of the localization algorithm(Jacobi) the
        tolerance value is printed out
        """
        self.Eps_localization = None
        """
        Tolerance used in the convergence criterium of the localization
        methods.
        """
        self.Min_or_max = None
        """
        Requires the maximization of the spread of the wfn

        Available values:
            SPREADMIN
            SPREADMAX
        """
        self.Method = None
        """
        Method of optimization if any

        Available values:
            NONE
                No localization is applied
            JACOBI
                Using 2 x 2 rotations of the orbitals, slow but robust
            CRAZY
                A new fast method is applied, might be slightly less robust than
                jacobi, but usually much faster
            L1SD
                Steepest descent minimization of an approximate l1 norm
            DIRECT
                Using a direct minimisation approach
        """
        self.Jacobi_fallback = None
        """
        Use Jacobi method in case no convergence was achieved by using the
        crazy rotations method.
        """
        self.Restart = None
        """
        Restart the localization from a set of orbitals read from a
        localization restart file.
        """
        self.Lochomo_restart_file_name = None
        """
        File name where to read the MOS fromwhich to restart the localization
        procedure for occupied states
        """
        self.Loclumo_restart_file_name = None
        """
        File name where to read the MOS fromwhich to restart the localization
        procedure for unoccupied states
        """
        self.Operator = None
        """
        Type of opertator which defines the spread functional

        Available values:
            BERRY
            BOYS
            PIPEK
        """
        self.list_List = []
        self.list_List_unoccupied = []
        self.States = None
        """
        Which states to localize, LUMO up to now only available in GPW

        Available values:
            OCCUPIED
            UNOCCUPIED
            ALL
        """
        self.Energy_range = None
        """
        Select the orbitals to be localized within the given energy range.This
        type of selection cannot be added on top of the selection through a
        LIST. It reads to reals that are lower and higher boundaries of the
        energy range.
        """
        self.PRINT = _print32()
        self._name = "LOCALIZE"
        self._keywords = [('Max_iter', 'MAX_ITER'), ('Max_crazy_angle', 'MAX_CRAZY_ANGLE'), ('Crazy_scale', 'CRAZY_SCALE'), ('Crazy_use_diag', 'CRAZY_USE_DIAG'), ('Use_history', 'USE_HISTORY'), ('Eps_occupation', 'EPS_OCCUPATION'), ('Out_iter_each', 'OUT_ITER_EACH'), ('Eps_localization', 'EPS_LOCALIZATION'), ('Min_or_max', 'MIN_OR_MAX'), ('Method', 'METHOD'), ('Jacobi_fallback', 'JACOBI_FALLBACK'), ('Restart', 'RESTART'), ('Lochomo_restart_file_name', 'LOCHOMO_RESTART_FILE_NAME'), ('Loclumo_restart_file_name', 'LOCLUMO_RESTART_FILE_NAME'), ('Operator', 'OPERATOR'), ('States', 'STATES'), ('Energy_range', 'ENERGY_RANGE')]
        self._repeated_keywords = [('List', 'LIST'), ('List_unoccupied', 'LIST_UNOCCUPIED')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def add_List(self, value):
        self.list_List.append(value)

    def add_List_unoccupied(self, value):
        self.list_List_unoccupied.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _localize3(printable):
    """
    Use one of the available methods to define the localization  and
    possibly to optimize it to a minimum or a maximum.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        controls the activation of the MOS localization procedure
        """
        self.Max_iter = None
        """
        Maximum number of iterations used for localization methods
        """
        self.Max_crazy_angle = None
        """
        Largest allowed angle for the crazy rotations algorithm (smaller is
        slower but more stable).
        """
        self.Crazy_scale = None
        """
        scale angles
        """
        self.Crazy_use_diag = None
        """
        Use diagonalization (slow) or pade based calculation of matrix
        exponentials.
        """
        self.Use_history = None
        """
        Generate an improved initial guess based on a history of results,
        which is useful during MD.Will only work if the number of states to be
        localized remains constant.
        """
        self.Eps_occupation = None
        """
        Tolerance in the occupation number to select only fully occupied
        orbitals for the rotation
        """
        self.Out_iter_each = None
        """
        Every how many iterations of the localization algorithm(Jacobi) the
        tolerance value is printed out
        """
        self.Eps_localization = None
        """
        Tolerance used in the convergence criterium of the localization
        methods.
        """
        self.Min_or_max = None
        """
        Requires the maximization of the spread of the wfn

        Available values:
            SPREADMIN
            SPREADMAX
        """
        self.Method = None
        """
        Method of optimization if any

        Available values:
            NONE
                No localization is applied
            JACOBI
                Using 2 x 2 rotations of the orbitals, slow but robust
            CRAZY
                A new fast method is applied, might be slightly less robust than
                jacobi, but usually much faster
            L1SD
                Steepest descent minimization of an approximate l1 norm
            DIRECT
                Using a direct minimisation approach
        """
        self.Jacobi_fallback = None
        """
        Use Jacobi method in case no convergence was achieved by using the
        crazy rotations method.
        """
        self.Restart = None
        """
        Restart the localization from a set of orbitals read from a
        localization restart file.
        """
        self.Lochomo_restart_file_name = None
        """
        File name where to read the MOS fromwhich to restart the localization
        procedure for occupied states
        """
        self.Loclumo_restart_file_name = None
        """
        File name where to read the MOS fromwhich to restart the localization
        procedure for unoccupied states
        """
        self.Operator = None
        """
        Type of opertator which defines the spread functional

        Available values:
            BERRY
            BOYS
            PIPEK
        """
        self.list_List = []
        self.list_List_unoccupied = []
        self.States = None
        """
        Which states to localize, LUMO up to now only available in GPW

        Available values:
            OCCUPIED
            UNOCCUPIED
            ALL
        """
        self.Energy_range = None
        """
        Select the orbitals to be localized within the given energy range.This
        type of selection cannot be added on top of the selection through a
        LIST. It reads to reals that are lower and higher boundaries of the
        energy range.
        """
        self.PRINT = _print48()
        self._name = "LOCALIZE"
        self._keywords = [('Max_iter', 'MAX_ITER'), ('Max_crazy_angle', 'MAX_CRAZY_ANGLE'), ('Crazy_scale', 'CRAZY_SCALE'), ('Crazy_use_diag', 'CRAZY_USE_DIAG'), ('Use_history', 'USE_HISTORY'), ('Eps_occupation', 'EPS_OCCUPATION'), ('Out_iter_each', 'OUT_ITER_EACH'), ('Eps_localization', 'EPS_LOCALIZATION'), ('Min_or_max', 'MIN_OR_MAX'), ('Method', 'METHOD'), ('Jacobi_fallback', 'JACOBI_FALLBACK'), ('Restart', 'RESTART'), ('Lochomo_restart_file_name', 'LOCHOMO_RESTART_FILE_NAME'), ('Loclumo_restart_file_name', 'LOCLUMO_RESTART_FILE_NAME'), ('Operator', 'OPERATOR'), ('States', 'STATES'), ('Energy_range', 'ENERGY_RANGE')]
        self._repeated_keywords = [('List', 'LIST'), ('List_unoccupied', 'LIST_UNOCCUPIED')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def add_List(self, value):
        self.list_List.append(value)

    def add_List_unoccupied(self, value):
        self.list_List_unoccupied.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _bend1(printable):
    """
    Specifies the bend potential of the MM system.
    """
    def __init__(self):
        self.Atoms = None
        """
        Defines the atomic kinds involved in the bend.
        """
        self.Kind = None
        """
        Define the kind of bend potential

        Available values:
            HARMONIC
                Functional Form (HARMONIC|G87): 1/2*K*(THETA-THETA0)^2
            CHARMM
                Functional Form (CHARMM|AMBER): K*(THETA-THETA0)^2
            AMBER
                Functional Form (CHARMM|AMBER): K*(THETA-THETA0)^2
            G87
                Functional Form (HARMONIC|G87): 1/2*K*(THETA-THETA0)^2
            G96
                Functional Form (G96): 1/2*K*(COS(THETA)-THETA0)^2
            CUBIC
                Functional Form (CUBIC): K*(THETA-THETA0)**2*(1+CB*(THETA-THETA0))
            MIXED_BEND_STRETCH
                Functional Form (MIXED_BEND_STRETCH): K*(THETA-THETA0)**2*(1+CB
                *(THETA-THETA0))+ KSS*(R12-R012)*(R32-R032)+KBS12*(R12-R012)*(THETA-
                THETA0)+KBS32*(R32-R032)*(THETA-THETA0)
            MM3
                Functional Form (MM3): 1/2*K*(THETA-THETA0)**2*(1-0.014*(THETA-
                THETA0)+5.6E-5*(THETA-THETA0)**2 -7.0E-7*(THETA-THETA0)**3+9.0E-10
                *(THETA-THETA0)**4)+KBS12*(R12-R012)*(THETA-THETA0)+ KBS32*(R32-R032
                )*(THETA-THETA0)
        """
        self.K = None
        """
        Defines the force constant of the potential
        """
        self.Cb = None
        """
        Defines the the cubic force constant of the bend
        """
        self.R012 = None
        """
        Mixed bend stretch parameter
        """
        self.R032 = None
        """
        Mixed bend stretch parameter
        """
        self.Kbs12 = None
        """
        Mixed bend stretch parameter
        """
        self.Kbs32 = None
        """
        Mixed bend stretch parameter
        """
        self.Kss = None
        """
        Mixed bend stretch parameter
        """
        self.Theta0 = None
        """
        Defines the equilibrium angle.
        """
        self.UB = _ub1()
        self._name = "BEND"
        self._keywords = [('Atoms', 'ATOMS'), ('Kind', 'KIND'), ('K', 'K'), ('Cb', 'CB'), ('R012', 'R012'), ('R032', 'R032'), ('Kbs12', 'KBS12'), ('Kbs32', 'KBS32'), ('Kss', 'KSS'), ('Theta0', 'THETA0')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('UB', 'UB')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _qmmm1(printable):
    """
    Input for QM/MM calculations.
    """
    def __init__(self):
        self.E_coupl = None
        """
        Specifies the type of the QM - MM electrostatic coupling.

        Available values:
            NONE
                Mechanical coupling (i.e. classical point charge based)
            COULOMB
                Using analytical 1/r potential (Coulomb) - not available for GPW/GAPW
            GAUSS
                Using fast gaussian expansion of the electrostatic potential
                (Erf(r/rc)/r)
            S-WAVE
                Using fast gaussian expansion of the s-wave electrostatic potential
        """
        self.Mm_potential_file_name = None
        """
        Name of the file containing the potential expansion in gaussians. See
        the USE_GEEP_LIB keyword.
        """
        self.Use_geep_lib = None
        """
         This keyword enables the use of the internal GEEP library to generate
        the gaussian expansion of the MM potential. Using this keyword there's
        no need to provide the MM_POTENTIAL_FILENAME. It expects a number from
        2 to 15 (the number of gaussian funtions to be used in the expansion.
        """
        self.Nocompatibility = None
        """
        This keyword disables the compatibility of QM/MM potential between
        CPMD and CP2K implementations. The compatibility is achieved using an
        MM potential of the form: Erf[x/rc]/x + (1/rc
        -2/(pi^1/2*rc))*Exp[-(x/rc)^2] .This keyword has effect only selecting
        GAUSS E_COUPLING type.
        """
        self.Eps_mm_rspace = None
        """
        Set the threshold for the collocation of the GEEP gaussian
        functions.this keyword affects only the GAUSS E_COUPLING.
        """
        self.Spherical_cutoff = None
        """
        Set the spherical cutoff for the QMMM electrostatic interaction. This
        acts like a charge multiplicative factor dependent on cutoff. For MM
        atoms farther than the SPHERICAL_CUTOFF(1) their charge is zero. The
        switch is performed with a smooth function:
        0.5*(1-TANH((r-[SPH_CUT(1)-20*SPH_CUT(2)])/(SPH_CUT(2)))). Two values
        are required: the first one is the distance cutoff. The second one
        controls the stiffness of the smoothing.
        """
        self.Parallel_scheme = None
        """
        Chooses the parallel_scheme for the long range Potential

        Available values:
            ATOM
                parallelizes on atoms. grids replicated.
            GRID
                parallelizes on grid slices. atoms replicated.
        """
        self.Nocenter = None
        """
        This keyword disables the automatic centering of the qm system every
        MD step.It centers the system only for the first step. Default .FALSE.
        (i.e. the QM system is centered every step)
        """
        self.Nocenter0 = None
        """
        This keyword disables the automatic centering of the qm system every
        MD step  even for the first step. Default .FALSE. (i.e. the QM system
        is centered every step)
        """
        self.Typ_center = None
        """
        This keyword specifies how the QM system is centered with respect to
        the QM box during MD.

        Available values:
            NONE
                centering is performes continuously
            GRID
                centering is performed in units of the grid spacing
        """
        self.Initial_translation_vector = None
        """
        This keyword specify the initial translation vector to be applied to
        the system.
        """
        self.Delta_charge = None
        """
        Additional net charge relative to that specified in DFT section.  Used
        automatically by force mixing
        """
        self.FORCE_MIXING = _force_mixing1()
        self.list_QM_KIND = []
        self.list_MM_KIND = []
        self.CELL = _cell3()
        self.PERIODIC = _periodic5()
        self.list_LINK = []
        self.INTERPOLATOR = _interpolator7()
        self.list_FORCEFIELD = []
        self.WALLS = _walls1()
        self.IMAGE_CHARGE = _image_charge1()
        self.PRINT = _print38()
        self._name = "QMMM"
        self._keywords = [('E_coupl', 'E_COUPL'), ('Mm_potential_file_name', 'MM_POTENTIAL_FILE_NAME'), ('Use_geep_lib', 'USE_GEEP_LIB'), ('Nocompatibility', 'NOCOMPATIBILITY'), ('Eps_mm_rspace', 'EPS_MM_RSPACE'), ('Spherical_cutoff', 'SPHERICAL_CUTOFF'), ('Parallel_scheme', 'PARALLEL_SCHEME'), ('Nocenter', 'NOCENTER'), ('Nocenter0', 'NOCENTER0'), ('Typ_center', 'TYP_CENTER'), ('Initial_translation_vector', 'INITIAL_TRANSLATION_VECTOR'), ('Delta_charge', 'DELTA_CHARGE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('FORCE_MIXING', 'FORCE_MIXING'), ('CELL', 'CELL'), ('PERIODIC', 'PERIODIC'), ('INTERPOLATOR', 'INTERPOLATOR'), ('WALLS', 'WALLS'), ('IMAGE_CHARGE', 'IMAGE_CHARGE'), ('PRINT', 'PRINT')]
        self._repeated_subsections = [('QM_KIND', '_qm_kind3'), ('MM_KIND', '_mm_kind1'), ('LINK', '_link3'), ('FORCEFIELD', '_forcefield2')]

    def add_QM_KIND(self):
        new_section = _qm_kind3()
        self.list_QM_KIND.append(new_section)
        return new_section

    def add_MM_KIND(self):
        new_section = _mm_kind1()
        self.list_MM_KIND.append(new_section)
        return new_section

    def add_LINK(self):
        new_section = _link3()
        self.list_LINK.append(new_section)
        return new_section

    def add_FORCEFIELD(self):
        new_section = _forcefield2()
        self.list_FORCEFIELD.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Qmmm_coupling(self):
        """
        See documentation for E_coupl
        """
        return self.E_coupl

    @property
    def Ecoupl(self):
        """
        See documentation for E_coupl
        """
        return self.E_coupl

    @Qmmm_coupling.setter
    def Qmmm_coupling(self, value):
        self.E_coupl = value

    @Ecoupl.setter
    def Ecoupl(self, value):
        self.E_coupl = value



class _center_coordinates1(printable):
    """
    Allows centering the coordinates of the system in the box. The
    centering point can be defined by the user.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Controls the activation of the centering method
        """
        self.Center_point = None
        """
        Specify the point used for centering the coordinates. Default is to
        center the system in cell/2.
        """
        self._name = "CENTER_COORDINATES"
        self._keywords = [('Center_point', 'CENTER_POINT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _dos1(printable):
    """
    Controls the printing of the Density of States (DOS).
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.N_gridpoints = None
        """
        Number of points in the computed DOS
        """
        self.EACH = _each103()
        self._name = "DOS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('N_gridpoints', 'N_GRIDPOINTS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _bmhft1(printable):
    """
    This section specifies the input parameters for BMHFT potential
    type.Functional form: V(r) = A * EXP(-B*r) - C/r^6 - D/r^8.Values
    available inside cp2k only for the Na/Cl pair.
    """
    def __init__(self):
        self.Atoms = None
        """
        Defines the atomic kind involved in the BMHFT nonbond potential
        """
        self.Map_atoms = None
        """
        Defines the kinds for which internally is defined the BMHFT nonbond
        potential at the moment only Na and Cl.
        """
        self.Rcut = None
        """
        Defines the cutoff parameter of the BMHFT potential
        """
        self.A = None
        """
        Defines the A parameter of the Fumi-Tosi Potential
        """
        self.B = None
        """
        Defines the B parameter of the Fumi-Tosi Potential
        """
        self.C = None
        """
        Defines the C parameter of the Fumi-Tosi Potential
        """
        self.D = None
        """
        Defines the D parameter of the Fumi-Tosi Potential
        """
        self.Rmin = None
        """
        Defines the lower bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self.Rmax = None
        """
        Defines the upper bound of the potential. If not set the range is the
        full range generate by the spline
        """
        self._name = "BMHFT"
        self._keywords = [('Atoms', 'ATOMS'), ('Map_atoms', 'MAP_ATOMS'), ('Rcut', 'RCUT'), ('A', 'A'), ('B', 'B'), ('C', 'C'), ('D', 'D'), ('Rmin', 'RMIN'), ('Rmax', 'RMAX')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each65(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each64(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each67(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _point22(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _each61(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each60(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each63(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each62(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each69(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each68(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _dbcsr1(printable):
    """
    Configuration options for the DBCSR library.
    """
    def __init__(self):
        self.Subcommunicators = None
        """
        Use MPI subcommunicators for transfers that are limited to process
        grid rows and columns.
        """
        self.Combined_types = None
        """
        Combine matrix index and data into a single MPI derived data type for
        communication (avoid using).
        """
        self.Use_mpi_allocation = None
        """
        Allow use of MPI-allocated memory for potentially faster network
        communication.
        """
        self.Use_cuda_host_allocation = None
        """
        Allow use of CUDA-allocated host-pinned memory (avoid using). (not
        available)
        """
        self.Mm_stack_size = None
        """
        Size of multiplication parameter stack.
        """
        self.Mm_driver = None
        """
        Select which routines to use for matrix block multiplications.

        Available values:
            BLAS
                BLAS
            MATMUL
                Fortran MATMUL
            SMM
                libsmm: a library for small matrix multiplies (only BLAS wrapper
                available in this binary)
            PLASMA
                PLASMA (not available)
            CUDA
                CUDA (not available)
        """
        self.N_size_mnk_stacks = None
        """
        Number of stacks to use for distinct atomic sizes (e.g., 2 for a
        system of mostly waters).
        """
        self.N_stack_buffers = None
        """
        Number of stack buffers to use (e.g., 2 when using GPUs)
        """
        self.Use_comm_thread = None
        """
        During multiplication, use a thread to periodically poll MPI to
        progress outstanding message completions.  This is beneficial on
        systems without a DMA-capable network adapter e.g. Cray XE6.
        """
        self.Comm_thread_load = None
        """
        If a communications thread is used, specify how much multiplication
        workload (%) the thread should perform in addition to communication
        tasks
        """
        self._name = "DBCSR"
        self._keywords = [('Subcommunicators', 'SUBCOMMUNICATORS'), ('Combined_types', 'COMBINED_TYPES'), ('Use_mpi_allocation', 'USE_MPI_ALLOCATION'), ('Use_cuda_host_allocation', 'USE_CUDA_HOST_ALLOCATION'), ('Mm_stack_size', 'MM_STACK_SIZE'), ('Mm_driver', 'MM_DRIVER'), ('N_size_mnk_stacks', 'N_SIZE_MNK_STACKS'), ('N_stack_buffers', 'N_STACK_BUFFERS'), ('Use_comm_thread', 'USE_COMM_THREAD'), ('Comm_thread_load', 'COMM_THREAD_LOAD')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each209(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print44(printable):
    """
    Controls the printing of the colvar specifications
    """
    def __init__(self):
        self.PROGRAM_RUN_INFO = _program_run_info36()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print45(printable):
    """
    Controls the printing of the colvar specifications
    """
    def __init__(self):
        self.PROGRAM_RUN_INFO = _program_run_info37()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _nose6(printable):
    """
    Controls the Nose-Hoover thermostats
    """
    def __init__(self):
        self.Nnos = None
        """
        length of nose-hoover chain. 0 means no thermostat
        """
        self.COORD = _coord7()
        self.VELOCITY = _velocity8()
        self._name = "NOSE"
        self._keywords = [('Nnos', 'NNOS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('COORD', 'COORD'), ('VELOCITY', 'VELOCITY')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print47(printable):
    """
    Controls printings related to the subsys
    """
    def __init__(self):
        self.ATOMIC_COORDINATES = _atomic_coordinates1()
        self.STRUCTURE_DATA = _structure_data2()
        self.INTERATOMIC_DISTANCES = _interatomic_distances1()
        self.TOPOLOGY_INFO = _topology_info1()
        self.CELL = _cell5()
        self.KINDS = _kinds1()
        self.SYMMETRY = _symmetry1()
        self.MOLECULES = _molecules1()
        self.RADII = _radii1()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('ATOMIC_COORDINATES', 'ATOMIC_COORDINATES'), ('STRUCTURE_DATA', 'STRUCTURE_DATA'), ('INTERATOMIC_DISTANCES', 'INTERATOMIC_DISTANCES'), ('TOPOLOGY_INFO', 'TOPOLOGY_INFO'), ('CELL', 'CELL'), ('KINDS', 'KINDS'), ('SYMMETRY', 'SYMMETRY'), ('MOLECULES', 'MOLECULES'), ('RADII', 'RADII')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print40(printable):
    """
    Section of possible print options in EIP code.
    """
    def __init__(self):
        self.ENERGIES = _energies1()
        self.ENERGIES_VAR = _energies_var1()
        self.FORCES = _forces3()
        self.COORD_AVG = _coord_avg1()
        self.COORD_VAR = _coord_var1()
        self.COUNT = _count1()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('ENERGIES', 'ENERGIES'), ('ENERGIES_VAR', 'ENERGIES_VAR'), ('FORCES', 'FORCES'), ('COORD_AVG', 'COORD_AVG'), ('COORD_VAR', 'COORD_VAR'), ('COUNT', 'COUNT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _pair_potential1(printable):
    """
    Information on the pair potential to calculate dispersion
    """
    def __init__(self):
        self.R_cutoff = None
        """
        Range of potential. The cutoff will be 2 times this value
        """
        self.Type = None
        """
        Type of potential. DFTD2 and DFTD3 are the Grimme D2 and D3 methods
        respectively.

        Available values:
            DFTD2
            DFTD3
        """
        self.Parameter_file_name = None
        """
        Name of the parameter file, may include a path
        """
        self.Reference_functional = None
        """
        Use parameters for this specific density functional
        """
        self.Scaling = None
        """
        XC Functional dependent scaling parameter, if set to zero CP2K
        attempts to guess the xc functional that is in use and sets the
        associated scaling parameter.
        """
        self.Exp_pre = None
        """
        Prefactor in exponential damping factor (DFT-D2 potential)
        """
        self.Eps_cn = None
        """
        Cutoff value for coordination number function (DFT-D3 method)
        """
        self.D3_scaling = None
        """
        XC Functional dependent scaling parameters (s6,sr6,s8) for the DFT-D3
        method,  if set to zero CP2K attempts to guess the xc functional from
        REFERENCE_FUNCTIONAL and sets the associated scaling parameter.
        """
        self.Calculate_c9_term = None
        """
        Calculate C9 terms in DFT-D3 model
        """
        self.Reference_c9_term = None
        """
        Calculate C9 terms in DFT-D3 model using reference coordination
        numbers
        """
        self.Long_range_correction = None
        """
        Calculate a long range correction to the DFT-D3 model
        """
        self.Verbose_output = None
        """
        Extensive output for the DFT-D2 and DFT-D3 models
        """
        self.list_Kind_coordination_numbers = []
        self.list_Atom_coordination_numbers = []
        self.list_Atomparm = []
        self.PRINT_DFTD = _print_dftd1()
        self._name = "PAIR_POTENTIAL"
        self._keywords = [('R_cutoff', 'R_CUTOFF'), ('Type', 'TYPE'), ('Parameter_file_name', 'PARAMETER_FILE_NAME'), ('Reference_functional', 'REFERENCE_FUNCTIONAL'), ('Scaling', 'SCALING'), ('Exp_pre', 'EXP_PRE'), ('Eps_cn', 'EPS_CN'), ('D3_scaling', 'D3_SCALING'), ('Calculate_c9_term', 'CALCULATE_C9_TERM'), ('Reference_c9_term', 'REFERENCE_C9_TERM'), ('Long_range_correction', 'LONG_RANGE_CORRECTION'), ('Verbose_output', 'VERBOSE_OUTPUT')]
        self._repeated_keywords = [('Kind_coordination_numbers', 'KIND_COORDINATION_NUMBERS'), ('Atom_coordination_numbers', 'ATOM_COORDINATION_NUMBERS'), ('Atomparm', 'ATOMPARM')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT_DFTD', 'PRINT_DFTD')]
        self._repeated_subsections = []

    def add_Kind_coordination_numbers(self, value):
        self.list_Kind_coordination_numbers.append(value)

    def add_Atom_coordination_numbers(self, value):
        self.list_Atom_coordination_numbers.append(value)

    def add_Atomparm(self, value):
        self.list_Atomparm.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _pair_potential2(printable):
    """
    Information on the pair potential to calculate dispersion
    """
    def __init__(self):
        self.R_cutoff = None
        """
        Range of potential. The cutoff will be 2 times this value
        """
        self.Type = None
        """
        Type of potential. DFTD2 and DFTD3 are the Grimme D2 and D3 methods
        respectively.

        Available values:
            DFTD2
            DFTD3
        """
        self.Parameter_file_name = None
        """
        Name of the parameter file, may include a path
        """
        self.Reference_functional = None
        """
        Use parameters for this specific density functional
        """
        self.Scaling = None
        """
        XC Functional dependent scaling parameter, if set to zero CP2K
        attempts to guess the xc functional that is in use and sets the
        associated scaling parameter.
        """
        self.Exp_pre = None
        """
        Prefactor in exponential damping factor (DFT-D2 potential)
        """
        self.Eps_cn = None
        """
        Cutoff value for coordination number function (DFT-D3 method)
        """
        self.D3_scaling = None
        """
        XC Functional dependent scaling parameters (s6,sr6,s8) for the DFT-D3
        method,  if set to zero CP2K attempts to guess the xc functional from
        REFERENCE_FUNCTIONAL and sets the associated scaling parameter.
        """
        self.Calculate_c9_term = None
        """
        Calculate C9 terms in DFT-D3 model
        """
        self.Reference_c9_term = None
        """
        Calculate C9 terms in DFT-D3 model using reference coordination
        numbers
        """
        self.Long_range_correction = None
        """
        Calculate a long range correction to the DFT-D3 model
        """
        self.Verbose_output = None
        """
        Extensive output for the DFT-D2 and DFT-D3 models
        """
        self.list_Kind_coordination_numbers = []
        self.list_Atom_coordination_numbers = []
        self.list_Atomparm = []
        self.PRINT_DFTD = _print_dftd2()
        self._name = "PAIR_POTENTIAL"
        self._keywords = [('R_cutoff', 'R_CUTOFF'), ('Type', 'TYPE'), ('Parameter_file_name', 'PARAMETER_FILE_NAME'), ('Reference_functional', 'REFERENCE_FUNCTIONAL'), ('Scaling', 'SCALING'), ('Exp_pre', 'EXP_PRE'), ('Eps_cn', 'EPS_CN'), ('D3_scaling', 'D3_SCALING'), ('Calculate_c9_term', 'CALCULATE_C9_TERM'), ('Reference_c9_term', 'REFERENCE_C9_TERM'), ('Long_range_correction', 'LONG_RANGE_CORRECTION'), ('Verbose_output', 'VERBOSE_OUTPUT')]
        self._repeated_keywords = [('Kind_coordination_numbers', 'KIND_COORDINATION_NUMBERS'), ('Atom_coordination_numbers', 'ATOM_COORDINATION_NUMBERS'), ('Atomparm', 'ATOMPARM')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT_DFTD', 'PRINT_DFTD')]
        self._repeated_subsections = []

    def add_Kind_coordination_numbers(self, value):
        self.list_Kind_coordination_numbers.append(value)

    def add_Atom_coordination_numbers(self, value):
        self.list_Atom_coordination_numbers.append(value)

    def add_Atomparm(self, value):
        self.list_Atomparm.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _print43(printable):
    """
    Controls the printing of the colvar specifications
    """
    def __init__(self):
        self.PROGRAM_RUN_INFO = _program_run_info35()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _coord15(printable):
    """
    The positions for RMSD used for restart
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify positions of the system
        """
        self._name = "COORD"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _coord14(printable):
    """
    The positions for RMSD used for restart
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify positions of the system
        """
        self._name = "COORD"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _coord16(printable):
    """
    The positions for RMSD used for restart
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify positions of the system
        """
        self._name = "COORD"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _print48(printable):
    """
    Collects all printing options related to the Wannier centers and
    properties computed with Wannier centers.
    """
    def __init__(self):
        self.PROGRAM_RUN_INFO = _program_run_info39()
        self.WANNIER_CUBES = _wannier_cubes5()
        self.WANNIER_CENTERS = _wannier_centers5()
        self.WANNIER_SPREADS = _wannier_spreads5()
        self.LOC_RESTART = _loc_restart5()
        self.TOTAL_DIPOLE = _total_dipole4()
        self.MOLECULAR_DIPOLES = _molecular_dipoles4()
        self.MOLECULAR_STATES = _molecular_states4()
        self.WANNIER_STATES = _wannier_states4()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('WANNIER_CUBES', 'WANNIER_CUBES'), ('WANNIER_CENTERS', 'WANNIER_CENTERS'), ('WANNIER_SPREADS', 'WANNIER_SPREADS'), ('LOC_RESTART', 'LOC_RESTART'), ('TOTAL_DIPOLE', 'TOTAL_DIPOLE'), ('MOLECULAR_DIPOLES', 'MOLECULAR_DIPOLES'), ('MOLECULAR_STATES', 'MOLECULAR_STATES'), ('WANNIER_STATES', 'WANNIER_STATES')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print49(printable):
    """
    print results of induced current density calculation
    """
    def __init__(self):
        self.CURRENT_CUBES = _current_cubes1()
        self.RESPONSE_FUNCTION_CUBES = _response_function_cubes1()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('CURRENT_CUBES', 'CURRENT_CUBES'), ('RESPONSE_FUNCTION_CUBES', 'RESPONSE_FUNCTION_CUBES')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _coord13(printable):
    """
    The positions for RMSD used for restart
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify positions of the system
        """
        self._name = "COORD"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _coord12(printable):
    """
    The positions for RMSD used for restart
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify positions of the system
        """
        self._name = "COORD"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _scrf1(printable):
    """
    Adds an implicit solvation model to the DFT calculation. Know also as
    Self Consistent Reaction Field.
    """
    def __init__(self):
        self.Eps_out = None
        """
        Value of the dielectric constant outside the sphere
        """
        self.Lmax = None
        """
        Maximum value of L used in the multipole expansion
        """
        self.SPHERE = _sphere1()
        self.PROGRAM_RUN_INFO = _program_run_info23()
        self._name = "SCRF"
        self._keywords = [('Eps_out', 'EPS_OUT'), ('Lmax', 'LMAX')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('SPHERE', 'SPHERE'), ('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _tfw4(printable):
    """
    Uses the TFW functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self._name = "TFW"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _tfw1(printable):
    """
    Uses the TFW functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self._name = "TFW"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _lowdin1(printable):
    """
    Controls the printing of the Lowdin (spin) population analysis
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Print_gop = None
        """
        Print the orbital populations in addition to the atomic populations
        and net charges
        """
        self.Print_all = None
        """
        Print all information including the full symmetrically orthogonalised
        density matrix
        """
        self.EACH = _each210()
        self._name = "LOWDIN"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Print_gop', 'PRINT_GOP'), ('Print_all', 'PRINT_ALL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _tfw3(printable):
    """
    Uses the TFW functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self._name = "TFW"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _tfw2(printable):
    """
    Uses the TFW functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self._name = "TFW"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _cubes6(printable):
    """
    Controls the printing of cube files
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Stride = None
        """
        The stride (X,Y,Z) used to write the cube file (larger values result
        in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1
        number valid for all components.
        """
        self.EACH = _each207()
        self._name = "CUBES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Stride', 'STRIDE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _cubes7(printable):
    """
    Controls the printing of cube files
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Stride = None
        """
        The stride (X,Y,Z) used to write the cube file (larger values result
        in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1
        number valid for all components.
        """
        self.EACH = _each294()
        self._name = "CUBES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Stride', 'STRIDE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _cubes4(printable):
    """
    Controls the printing of cube files
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Stride = None
        """
        The stride (X,Y,Z) used to write the cube file (larger values result
        in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1
        number valid for all components.
        """
        self.EACH = _each175()
        self._name = "CUBES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Stride', 'STRIDE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _cubes5(printable):
    """
    Controls the printing of cube files
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Stride = None
        """
        The stride (X,Y,Z) used to write the cube file (larger values result
        in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1
        number valid for all components.
        """
        self.EACH = _each205()
        self._name = "CUBES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Stride', 'STRIDE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _cubes2(printable):
    """
    Controls the printing of cube files
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Stride = None
        """
        The stride (X,Y,Z) used to write the cube file (larger values result
        in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1
        number valid for all components.
        """
        self.EACH = _each154()
        self._name = "CUBES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Stride', 'STRIDE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _cubes3(printable):
    """
    Controls the printing of cube files
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Stride = None
        """
        The stride (X,Y,Z) used to write the cube file (larger values result
        in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1
        number valid for all components.
        """
        self.EACH = _each173()
        self._name = "CUBES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Stride', 'STRIDE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _cubes1(printable):
    """
    Controls the printing of cube files
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Stride = None
        """
        The stride (X,Y,Z) used to write the cube file (larger values result
        in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1
        number valid for all components.
        """
        self.EACH = _each152()
        self._name = "CUBES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Stride', 'STRIDE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _non_local4(printable):
    """
    Information on the non local dispersion functional
    """
    def __init__(self):
        self.Type = None
        """
        Type of functional (the corresponding kernel data file should be
        selected).

        Available values:
            DRSLL
            LMKLL
            RVV10
        """
        self.Verbose_output = None
        """
        Extensive output for non local functionals
        """
        self.Kernel_file_name = None
        """
        Name of the kernel data file, may include a path.vdW_kernel_table.dat
        is for DRSLL and LMKLL andrVV10_kernel_table.dat is for rVV10.
        """
        self.Cutoff = None
        """
        The cutoff of the FFT grid used in the calculation of the nonlocal vdW
        functional [Ry].
        """
        self.Parameters = None
        """
        Parameters b and C of the rVV10 functional
        """
        self._name = "NON_LOCAL"
        self._keywords = [('Type', 'TYPE'), ('Verbose_output', 'VERBOSE_OUTPUT'), ('Kernel_file_name', 'KERNEL_FILE_NAME'), ('Cutoff', 'CUTOFF'), ('Parameters', 'PARAMETERS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _non_local3(printable):
    """
    Information on the non local dispersion functional
    """
    def __init__(self):
        self.Type = None
        """
        Type of functional (the corresponding kernel data file should be
        selected).

        Available values:
            DRSLL
            LMKLL
            RVV10
        """
        self.Verbose_output = None
        """
        Extensive output for non local functionals
        """
        self.Kernel_file_name = None
        """
        Name of the kernel data file, may include a path.vdW_kernel_table.dat
        is for DRSLL and LMKLL andrVV10_kernel_table.dat is for rVV10.
        """
        self.Cutoff = None
        """
        The cutoff of the FFT grid used in the calculation of the nonlocal vdW
        functional [Ry].
        """
        self.Parameters = None
        """
        Parameters b and C of the rVV10 functional
        """
        self._name = "NON_LOCAL"
        self._keywords = [('Type', 'TYPE'), ('Verbose_output', 'VERBOSE_OUTPUT'), ('Kernel_file_name', 'KERNEL_FILE_NAME'), ('Cutoff', 'CUTOFF'), ('Parameters', 'PARAMETERS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _non_local2(printable):
    """
    Information on the non local dispersion functional
    """
    def __init__(self):
        self.Type = None
        """
        Type of functional (the corresponding kernel data file should be
        selected).

        Available values:
            DRSLL
            LMKLL
            RVV10
        """
        self.Verbose_output = None
        """
        Extensive output for non local functionals
        """
        self.Kernel_file_name = None
        """
        Name of the kernel data file, may include a path.vdW_kernel_table.dat
        is for DRSLL and LMKLL andrVV10_kernel_table.dat is for rVV10.
        """
        self.Cutoff = None
        """
        The cutoff of the FFT grid used in the calculation of the nonlocal vdW
        functional [Ry].
        """
        self.Parameters = None
        """
        Parameters b and C of the rVV10 functional
        """
        self._name = "NON_LOCAL"
        self._keywords = [('Type', 'TYPE'), ('Verbose_output', 'VERBOSE_OUTPUT'), ('Kernel_file_name', 'KERNEL_FILE_NAME'), ('Cutoff', 'CUTOFF'), ('Parameters', 'PARAMETERS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _non_local1(printable):
    """
    Information on the non local dispersion functional
    """
    def __init__(self):
        self.Type = None
        """
        Type of functional (the corresponding kernel data file should be
        selected).

        Available values:
            DRSLL
            LMKLL
            RVV10
        """
        self.Verbose_output = None
        """
        Extensive output for non local functionals
        """
        self.Kernel_file_name = None
        """
        Name of the kernel data file, may include a path.vdW_kernel_table.dat
        is for DRSLL and LMKLL andrVV10_kernel_table.dat is for rVV10.
        """
        self.Cutoff = None
        """
        The cutoff of the FFT grid used in the calculation of the nonlocal vdW
        functional [Ry].
        """
        self.Parameters = None
        """
        Parameters b and C of the rVV10 functional
        """
        self._name = "NON_LOCAL"
        self._keywords = [('Type', 'TYPE'), ('Verbose_output', 'VERBOSE_OUTPUT'), ('Kernel_file_name', 'KERNEL_FILE_NAME'), ('Cutoff', 'CUTOFF'), ('Parameters', 'PARAMETERS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _response_basis1(printable):
    """
    Calculate a response basis set contraction scheme
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Delta_charge = None
        """
        Variation of charge used in finite difference calculation
        """
        self.Derivatives = None
        """
        Number of wavefunction derivatives to calculate
        """
        self.EACH = _each359()
        self._name = "RESPONSE_BASIS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Delta_charge', 'DELTA_CHARGE'), ('Derivatives', 'DERIVATIVES')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _real_time_propagation1(printable):
    """
    Parameters needed to set up the real time propagation for the electron
    dynamics
    """
    def __init__(self):
        self.Max_iter = None
        """
        Maximal number of iterations for the self consistent propagator loop.
        """
        self.Eps_iter = None
        """
        Convergence criterium for the self consistent propagator loop.
        """
        self.Aspc_order = None
        """
        Speciefies how many steps will be used for extrapolation. One will be
        always used which is means X(t+dt)=X(t)
        """
        self.Extrapolation = None
        """
        Controls which quantity is extrapolated

        Available values:
            MOS
                Direct extrapolation on the MO matrices
            S_KS
                Extrapolation on the Kohn-Sham matrix, resp. the exponential in case
                of ETRS
        """
        self.Mat_exp = None
        """
        Which method should be used to calculate the exponential in the
        propagator. For Ehrenfest MD only the Taylor method works, for real
        time propagation diagonalization works as well.

        Available values:
            TAYLOR
                exponential is evaluated using scaling and squaring in combination
                with a taylor expansion of the exponential.
            DIAG
                uses the eignvalues an eigenvectors to calculate the exponential.
            PADE
                uses scaling and squaring together with the pade approximation
            ARNOLDI
                uses arnoldi subspace algorithm to compute exp(H)*MO directly, can't
                be used in combination with Crank Nicholson
        """
        self.Sc_check_start = None
        """
        Speciefies how many iteration steps will be done without a check for
        self consistency. Can save some time in big calculations.
        """
        self.Exp_accuracy = None
        """
        Accuracy for the taylor and pade approximation. This is only an upper
        bound bound since the norm used for the guess is an upper bound for
        the needed one.
        """
        self.Propagator = None
        """
        Which propagator should be used for the orbitals

        Available values:
            ETRS
                enforced time reversible symmetry
            CN
                Crank Nicholson propagator
            EM
                Exponential midpoint propagator
        """
        self.Initial_wfn = None
        """
        Controls the initial WFN used for propagation.

        Available values:
            SCF_WFN
                An SCF run is performed to get the initial state.
            RESTART_WFN
                A wavefunction from a previous scf is propageted. Especially useful,
                if electronic constraints or restraints are used in the previous
                calculation, since these do not work in the rtp scheme.
            RT_RESTART
                use the wavefunction of a real time propagation/ehrenfest run
        """
        self.Apply_delta_pulse = None
        """
        Applies a delta kick to the initial wfn (only RTP for now - the EMD
        case is not yet implemented).
        """
        self.Periodic = None
        """
        Apply a delta-kick that is compatible with periodic boundary
        conditions for any value of DELTA_PULSE_SCALE. Uses perturbation
        theory for the preparation of the initial wfn. Note that the pulse is
        only applied when INITIAL_WFN is set to SCF_WFN, and not for restarts
        (RT_RESTART).
        """
        self.Delta_pulse_direction = None
        """
        Direction of the applied electric field. The k vector is given as
        2*Pi*[i,j,k]*inv(h_mat), which for PERIODIC .FALSE. yields exp(ikr)
        periodic with the unit cell, only if DELTA_PULSE_SCALE is set to
        unity. For an orthorhombic cell [1,0,0] yields [2*Pi/L_x,0,0]. For
        small cells, this results in a very large kick.
        """
        self.Delta_pulse_scale = None
        """
        Scale the k vector, which for PERIODIC .FALSE. results in exp(ikr) no
        longer being periodic with the unit cell. The norm of k is the
        strength of the applied electric field in atomic units.
        """
        self.Hfx_balance_in_core = None
        """
        If HFX is used, this keyword forces a redistribution/recalculation of
        the integrals, balanced with respect to the in core steps.
        """
        self.PRINT = _print33()
        self._name = "REAL_TIME_PROPAGATION"
        self._keywords = [('Max_iter', 'MAX_ITER'), ('Eps_iter', 'EPS_ITER'), ('Aspc_order', 'ASPC_ORDER'), ('Extrapolation', 'EXTRAPOLATION'), ('Mat_exp', 'MAT_EXP'), ('Sc_check_start', 'SC_CHECK_START'), ('Exp_accuracy', 'EXP_ACCURACY'), ('Propagator', 'PROPAGATOR'), ('Initial_wfn', 'INITIAL_WFN'), ('Apply_delta_pulse', 'APPLY_DELTA_PULSE'), ('Periodic', 'PERIODIC'), ('Delta_pulse_direction', 'DELTA_PULSE_DIRECTION'), ('Delta_pulse_scale', 'DELTA_PULSE_SCALE'), ('Hfx_balance_in_core', 'HFX_BALANCE_IN_CORE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _diagonalization1(printable):
    """
    Set up type and parameters for Kohn-Sham matrix diagonalization.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        controls the activation of the diagonalization method
        """
        self.Algorithm = None
        """
        Algorithm to be used for diagonalization

        Available values:
            STANDARD
                Standard diagonalization: LAPACK methods or Jacobi.
            OT
                Iterative diagonalization using OT method
            LANCZOS
                Block Krylov-space approach to self-consistent diagonalisation
            DAVIDSON
                Preconditioned blocked Davidson
        """
        self.Jacobi_threshold = None
        """
        Controls the accuracy of the pseudo-diagonalization method using
        Jacobi rotations
        """
        self.Eps_jacobi = None
        """
        Below this threshold value for the SCF convergence the pseudo-
        diagonalization method using Jacobi rotations is activated. This
        method is much faster than a real diagonalization and it is even
        speeding up while achieving full convergence.However, it needs a pre-
        converged wavefunction obtained by at least one real diagonalization
        which is further optimized while keeping the original eigenvalue
        spectrum. The MO eigenvalues are NOT updated. The method might be
        useful to speed up calculations for large systems e.g. using a semi-
        empirical method.
        """
        self.Eps_adapt = None
        """
        Required accuracy in iterative diagonalization as compared to current
        SCF convergence
        """
        self.Max_iter = None
        """
        Maximum number of iterations in iterative diagonalization
        """
        self.Eps_iter = None
        """
        Required accuracy in iterative diagonalization
        """
        self.OT = _ot2()
        self.KRYLOV = _krylov1()
        self.DIAG_SUB_SCF = _diag_sub_scf1()
        self.DAVIDSON = _davidson1()
        self._name = "DIAGONALIZATION"
        self._keywords = [('Algorithm', 'ALGORITHM'), ('Jacobi_threshold', 'JACOBI_THRESHOLD'), ('Eps_jacobi', 'EPS_JACOBI'), ('Eps_adapt', 'EPS_ADAPT'), ('Max_iter', 'MAX_ITER'), ('Eps_iter', 'EPS_ITER')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('OT', 'OT'), ('KRYLOV', 'KRYLOV'), ('DIAG_SUB_SCF', 'DIAG_SUB_SCF'), ('DAVIDSON', 'DAVIDSON')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _point36(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _wnumber1(printable):
    """
    Controls the output of the helium winding number
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each60()
        self._name = "WNUMBER"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _diis_info1(printable):
    """
    Controls the printing of diis info during a BAND run
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each66()
        self._name = "DIIS_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _diis_info2(printable):
    """
    Controls the printing of diis information.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each98()
        self._name = "DIIS_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _molden_vib1(printable):
    """
    Controls the printing for visualization in molden format
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each352()
        self._name = "MOLDEN_VIB"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _string_method1(printable):
    """
    Controls parameters for String Method type calculation only.
    """
    def __init__(self):
        self.Spline_order = None
        """
        Specify the oder of the spline used in the String Method.
        """
        self.Smoothing = None
        """
        Smoothing parameter for the reparametrization of the frames.
        """
        self._name = "STRING_METHOD"
        self._keywords = [('Spline_order', 'SPLINE_ORDER'), ('Smoothing', 'SMOOTHING')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _s4(printable):
    """
    The s variable for GLE used for restart
    """
    def __init__(self):
        self.Default_keyword = None
        """
        Specify s variable for GLE thermostat
        """
        self._name = "S"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _core_velocities1(printable):
    """
    controls the output of the velocities of cores when the shell model is
    used
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.Format = None
        """
        Specifies the format of the output file for the velocities of cores.

        Available values:
            ATOMIC
                Write only the coordinates X,Y,Z without element symbols to a
                formatted file
            DCD
                Write the coordinates (no element labels) and the cell information to
                a binary file
            XMOL
                Mostly known as XYZ format, provides in a formatted file:
                element_symbol X Y Z
            XYZ
                Alias name for XMOL
        """
        self.EACH = _each78()
        self._name = "CORE_VELOCITIES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT'), ('Format', 'FORMAT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _ext_lagrange_vvp1(printable):
    """
    Colvar velocities within an extended Lagrangian formalism.Used for
    RESTART.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specified the velocities
        """
        self._name = "EXT_LAGRANGE_VVP"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _mass9(printable):
    """
    The masses for NOSE HOOVER used for restart
    """
    def __init__(self):
        self.Default_keyword = None
        """
        Specify masses of the system
        """
        self._name = "MASS"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _mass8(printable):
    """
    The masses for NOSE HOOVER used for restart
    """
    def __init__(self):
        self.Default_keyword = None
        """
        Specify masses of the system
        """
        self._name = "MASS"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _mass7(printable):
    """
    Information to initialize the Ad-Langevin thermostat DOF MASS
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify an initial thermostat DOF MASS for Ad-Langevin thermostat.
        """
        self._name = "MASS"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _mass6(printable):
    """
    The masses for NOSE HOOVER used for restart
    """
    def __init__(self):
        self.Default_keyword = None
        """
        Specify masses of the system
        """
        self._name = "MASS"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _mass5(printable):
    """
    Information to initialize the Ad-Langevin thermostat DOF MASS
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify an initial thermostat DOF MASS for Ad-Langevin thermostat.
        """
        self._name = "MASS"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _mass4(printable):
    """
    The masses for NOSE HOOVER used for restart
    """
    def __init__(self):
        self.Default_keyword = None
        """
        Specify masses of the system
        """
        self._name = "MASS"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _fragment3(printable):
    """
    Specify the atom number belonging to this fragment.
    """
    def __init__(self):
        self.List = None
        """
        Specifies a list of atoms.
        """
        self._name = "FRAGMENT"
        self._keywords = [('List', 'LIST')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _fragment2(printable):
    """
    Fragment definition
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Defines the index of the fragment defined
        """
        self.Map = None
        """
        Provides the index of the fragment of the MIXED force_eval mapped on
        the locally defined fragment.
        """
        self.Default_keyword = None
        """
        Starting and ending atomic index defining one fragment must be
        provided
        """
        self._name = "FRAGMENT"
        self._keywords = [('Map', 'MAP')]
        self._repeated_keywords = []
        self._default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _fragment1(printable):
    """
    Fragment definition
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Defines the index of the fragment defined
        """
        self.list_Default_keyword = []
        """
        Starting and ending atomic index defining one fragment must be
        provided
        """
        self._name = "FRAGMENT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _coord1(printable):
    """
    The positions for NOSE HOOVER used for restart
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify positions of the system
        """
        self._name = "COORD"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _coord3(printable):
    """
    The positions for NOSE HOOVER used for restart
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify positions of the system
        """
        self._name = "COORD"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _coord2(printable):
    """
    The positions for NOSE HOOVER used for restart
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify positions of the system
        """
        self._name = "COORD"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _coord5(printable):
    """
    The positions for NOSE HOOVER used for restart
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify positions of the system
        """
        self._name = "COORD"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _coord4(printable):
    """
    The positions for NOSE HOOVER used for restart
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify positions of the system
        """
        self._name = "COORD"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _coord7(printable):
    """
    The positions for NOSE used for restart
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify positions of the system
        """
        self._name = "COORD"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _coord6(printable):
    """
    The positions for BEADS used for restart
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify positions of the system
        """
        self._name = "COORD"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _coord9(printable):
    """
    The positions for BAND used for restart
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify positions of the system
        """
        self._name = "COORD"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _coord8(printable):
    """
    The positions for HELIUM used for restart
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify positions of the system
        """
        self._name = "COORD"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _efield1(printable):
    """
    parameters for finite, time dependent, nonperiodic electric fields
    """
    def __init__(self):
        self.Intensity = None
        """
        Intensity of the electric field in W*cm-2 which corresponds to a
        maximal amplitude in a.u. of sqrt(I/(3.50944*10^16))
        """
        self.Polarisation = None
        """
        Polarisation vector of electric field
        """
        self.Wavelength = None
        """
        Wavelength of efield field
        """
        self.Phase = None
        """
        phase offset of the cosine given in multiples of pi
        """
        self.Envelop = None
        """
        Shape of the efield pulse

        Available values:
            CONSTANT
                No envelop function is applied to the strength
            GAUSSIAN
                A Gaussian function is used as envelop
            RAMP
                Linear tune in/out of the field
        """
        self.list_CONSTANT_ENV = []
        self.list_RAMP_ENV = []
        self.list_GAUSSIAN_ENV = []
        self._name = "EFIELD"
        self._keywords = [('Intensity', 'INTENSITY'), ('Polarisation', 'POLARISATION'), ('Wavelength', 'WAVELENGTH'), ('Phase', 'PHASE'), ('Envelop', 'ENVELOP')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('CONSTANT_ENV', '_constant_env1'), ('RAMP_ENV', '_ramp_env1'), ('GAUSSIAN_ENV', '_gaussian_env1')]

    def add_CONSTANT_ENV(self):
        new_section = _constant_env1()
        self.list_CONSTANT_ENV.append(new_section)
        return new_section

    def add_RAMP_ENV(self):
        new_section = _ramp_env1()
        self.list_RAMP_ENV.append(new_section)
        return new_section

    def add_GAUSSIAN_ENV(self):
        new_section = _gaussian_env1()
        self.list_GAUSSIAN_ENV.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _lyp2(printable):
    """
    Uses the LYP functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_c = None
        """
        scales the correlation part of the functional
        """
        self._name = "LYP"
        self._keywords = [('Scale_c', 'SCALE_C')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _weights1(printable):
    """
    Controls the printing of FP info during flexible partitioning
    simulations.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each48()
        self._name = "WEIGHTS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each303(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each302(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each301(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each300(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each307(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each306(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each305(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each304(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _convergence_control1(printable):
    """
    This section specify parameters controlling the convergence of the
    free energy.
    """
    def __init__(self):
        self.Coarse_grained_width = None
        """
        Width of segments in MD steps to generate the set of coarse grained
        data, providing a correlation independent data set.
        """
        self.Max_coarse_grained_width = None
        """
        Max Width of segments in MD steps to generate the set of coarse
        grained data.
        """
        self.Coarse_grained_points = None
        """
        Set the minimum amount of coarse grained points to collect before
        starting the statistical analysis
        """
        self.Eps_conv = None
        """
        Set the relative tolerance for the convergence of the collective
        variable averages used to compute the free energy.
        """
        self.K_confidence_limit = None
        """
        Set the confidence limit for the Mann-Kendall trend test.
        """
        self.Sw_confidence_limit = None
        """
        Set the confidence limit for the Shapiro-Wilks normality test.
        """
        self.Vn_confidence_limit = None
        """
        Set the confidence limit for the Von Neumann serial correlation test.
        """
        self._name = "CONVERGENCE_CONTROL"
        self._keywords = [('Coarse_grained_width', 'COARSE_GRAINED_WIDTH'), ('Max_coarse_grained_width', 'MAX_COARSE_GRAINED_WIDTH'), ('Coarse_grained_points', 'COARSE_GRAINED_POINTS'), ('Eps_conv', 'EPS_CONV'), ('K_confidence_limit', 'K_CONFIDENCE_LIMIT'), ('Sw_confidence_limit', 'SW_CONFIDENCE_LIMIT'), ('Vn_confidence_limit', 'VN_CONFIDENCE_LIMIT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Cg_width(self):
        """
        See documentation for Coarse_grained_width
        """
        return self.Coarse_grained_width

    @property
    def Max_cg_width(self):
        """
        See documentation for Max_coarse_grained_width
        """
        return self.Max_coarse_grained_width

    @property
    def Cg_points(self):
        """
        See documentation for Coarse_grained_points
        """
        return self.Coarse_grained_points

    @Cg_width.setter
    def Cg_width(self, value):
        self.Coarse_grained_width = value

    @Max_cg_width.setter
    def Max_cg_width(self, value):
        self.Max_coarse_grained_width = value

    @Cg_points.setter
    def Cg_points(self, value):
        self.Coarse_grained_points = value



class _resp_charges_to_file1(printable):
    """
    Controls the printing of the RESP charges to a file.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each331()
        self._name = "RESP_CHARGES_TO_FILE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each309(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _convergence_control2(printable):
    """
    Setup parameters to control the convergence criteria for BAND
    """
    def __init__(self):
        self.Max_dr = None
        """
        Tolerance on the maximum value of the displacement on the BAND.
        """
        self.Max_force = None
        """
        Tolerance on the maximum value of Forces on the BAND.
        """
        self.Rms_dr = None
        """
        Tolerance on RMS displacements on the BAND.
        """
        self.Rms_force = None
        """
        Tolerance on RMS Forces on the BAND.
        """
        self._name = "CONVERGENCE_CONTROL"
        self._keywords = [('Max_dr', 'MAX_DR'), ('Max_force', 'MAX_FORCE'), ('Rms_dr', 'RMS_DR'), ('Rms_force', 'RMS_FORCE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _hbp1(printable):
    """
    Section to define the hbond wannier centre as a collective variables.
    """
    def __init__(self):
        self.Rcut = None
        """
        Parameter used for computing the cutoff radius for searching the
        wannier centres around an atom
        """
        self.Shift = None
        """
        Parameter used for shifting each term in the sum
        """
        self.Npoints = None
        """
        The number of points in the path
        """
        self.list_Atoms = []
        self.list_Points = self.list_Atoms
        self.list_POINT = []
        self._name = "HBP"
        self._keywords = [('Rcut', 'RCUT'), ('Shift', 'SHIFT'), ('Npoints', 'NPOINTS')]
        self._repeated_keywords = [('Atoms', 'ATOMS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point16')]

    def add_POINT(self):
        new_section = _point16()
        self.list_POINT.append(new_section)
        return new_section

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Points(self, value):
        self.list_ATOMS.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _hbp2(printable):
    """
    Section to define the hbond wannier centre as a collective variables.
    """
    def __init__(self):
        self.Rcut = None
        """
        Parameter used for computing the cutoff radius for searching the
        wannier centres around an atom
        """
        self.Shift = None
        """
        Parameter used for shifting each term in the sum
        """
        self.Npoints = None
        """
        The number of points in the path
        """
        self.list_Atoms = []
        self.list_Points = self.list_Atoms
        self.list_POINT = []
        self._name = "HBP"
        self._keywords = [('Rcut', 'RCUT'), ('Shift', 'SHIFT'), ('Npoints', 'NPOINTS')]
        self._repeated_keywords = [('Atoms', 'ATOMS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point34')]

    def add_POINT(self):
        new_section = _point34()
        self.list_POINT.append(new_section)
        return new_section

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Points(self, value):
        self.list_ATOMS.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _hbp3(printable):
    """
    Section to define the hbond wannier centre as a collective variables.
    """
    def __init__(self):
        self.Rcut = None
        """
        Parameter used for computing the cutoff radius for searching the
        wannier centres around an atom
        """
        self.Shift = None
        """
        Parameter used for shifting each term in the sum
        """
        self.Npoints = None
        """
        The number of points in the path
        """
        self.list_Atoms = []
        self.list_Points = self.list_Atoms
        self.list_POINT = []
        self._name = "HBP"
        self._keywords = [('Rcut', 'RCUT'), ('Shift', 'SHIFT'), ('Npoints', 'NPOINTS')]
        self._repeated_keywords = [('Atoms', 'ATOMS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point52')]

    def add_POINT(self):
        new_section = _point52()
        self.list_POINT.append(new_section)
        return new_section

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Points(self, value):
        self.list_ATOMS.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _hbp4(printable):
    """
    Section to define the hbond wannier centre as a collective variables.
    """
    def __init__(self):
        self.Rcut = None
        """
        Parameter used for computing the cutoff radius for searching the
        wannier centres around an atom
        """
        self.Shift = None
        """
        Parameter used for shifting each term in the sum
        """
        self.Npoints = None
        """
        The number of points in the path
        """
        self.list_Atoms = []
        self.list_Points = self.list_Atoms
        self.list_POINT = []
        self._name = "HBP"
        self._keywords = [('Rcut', 'RCUT'), ('Shift', 'SHIFT'), ('Npoints', 'NPOINTS')]
        self._repeated_keywords = [('Atoms', 'ATOMS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point70')]

    def add_POINT(self):
        new_section = _point70()
        self.list_POINT.append(new_section)
        return new_section

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Points(self, value):
        self.list_ATOMS.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _shell_energy1(printable):
    """
    Controls the output of the shell-energy file (only if shell-model)
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each34()
        self._name = "SHELL_ENERGY"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each237(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each236(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each235(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each234(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each233(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each232(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each231(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each230(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each239(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each238(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _becke_restraint1(printable):
    """
    Use Becke weight population in a restraint/constraint
    """
    def __init__(self):
        self.Strength = None
        """
        force constant of the restraint
        """
        self.Target = None
        """
        target value of the restraint
        """
        self.Atoms = None
        """
        Specifies the list of atoms that is summed in the restraint
        """
        self.Coeff = None
        """
        Defines the the coefficient of the atom in the atom list (default is
        one)
        """
        self.Functional_form = None
        """
        Specifies the functional form of the term added

        Available values:
            RESTRAINT
                Harmonic potential: s*(q-t)**2
            CONSTRAINT
                Constraint form: s*(q-t)
        """
        self.Type_of_density = None
        """
        Specifies the type of density used for the fitting

        Available values:
            FULL
                Full density
            SPIN
                Spin density
        """
        self.PROGRAM_RUN_INFO = _program_run_info16()
        self._name = "BECKE_RESTRAINT"
        self._keywords = [('Strength', 'STRENGTH'), ('Target', 'TARGET'), ('Atoms', 'ATOMS'), ('Coeff', 'COEFF'), ('Functional_form', 'FUNCTIONAL_FORM'), ('Type_of_density', 'TYPE_OF_DENSITY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each3(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each129(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each128(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each123(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each122(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each121(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each120(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each127(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each126(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each125(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each124(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _dft_control_parameters1(printable):
    """
    Controls the printing of dft control parameters.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each190()
        self._name = "DFT_CONTROL_PARAMETERS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each369(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each368(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _history1(printable):
    """
    writes a history of the function value and parameters
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each347()
        self._name = "HISTORY"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _distance1(printable):
    """
    Section to define the distance as a collective variables.
    """
    def __init__(self):
        self.Atoms = None
        """
        Specifies the indexes of atoms/points defining the distance.
        """
        self.Axis = None
        """
        Define the axes along which the colvar should be evaluated

        Available values:
            XYZ
            X
            Y
            Z
            XY
            XZ
            YZ
        """
        self.list_POINT = []
        self._name = "DISTANCE"
        self._keywords = [('Atoms', 'ATOMS'), ('Axis', 'AXIS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point1')]

    def add_POINT(self):
        new_section = _point1()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Points(self):
        """
        See documentation for Atoms
        """
        return self.Atoms

    @Points.setter
    def Points(self, value):
        self.Atoms = value



class _distance2(printable):
    """
    Section to define the distance as a collective variables.
    """
    def __init__(self):
        self.Atoms = None
        """
        Specifies the indexes of atoms/points defining the distance.
        """
        self.Axis = None
        """
        Define the axes along which the colvar should be evaluated

        Available values:
            XYZ
            X
            Y
            Z
            XY
            XZ
            YZ
        """
        self.list_POINT = []
        self._name = "DISTANCE"
        self._keywords = [('Atoms', 'ATOMS'), ('Axis', 'AXIS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point19')]

    def add_POINT(self):
        new_section = _point19()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Points(self):
        """
        See documentation for Atoms
        """
        return self.Atoms

    @Points.setter
    def Points(self, value):
        self.Atoms = value



class _distance3(printable):
    """
    Section to define the distance as a collective variables.
    """
    def __init__(self):
        self.Atoms = None
        """
        Specifies the indexes of atoms/points defining the distance.
        """
        self.Axis = None
        """
        Define the axes along which the colvar should be evaluated

        Available values:
            XYZ
            X
            Y
            Z
            XY
            XZ
            YZ
        """
        self.list_POINT = []
        self._name = "DISTANCE"
        self._keywords = [('Atoms', 'ATOMS'), ('Axis', 'AXIS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point37')]

    def add_POINT(self):
        new_section = _point37()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Points(self):
        """
        See documentation for Atoms
        """
        return self.Atoms

    @Points.setter
    def Points(self, value):
        self.Atoms = value



class _distance4(printable):
    """
    Section to define the distance as a collective variables.
    """
    def __init__(self):
        self.Atoms = None
        """
        Specifies the indexes of atoms/points defining the distance.
        """
        self.Axis = None
        """
        Define the axes along which the colvar should be evaluated

        Available values:
            XYZ
            X
            Y
            Z
            XY
            XZ
            YZ
        """
        self.list_POINT = []
        self._name = "DISTANCE"
        self._keywords = [('Atoms', 'ATOMS'), ('Axis', 'AXIS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point55')]

    def add_POINT(self):
        new_section = _point55()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Points(self):
        """
        See documentation for Atoms
        """
        return self.Atoms

    @Points.setter
    def Points(self, value):
        self.Atoms = value



class _mo1(printable):
    """
    Controls the printing of the molecular orbitals.Note that this is only
    functional with diagonalization based methods, in particular not with
    OT (see MO_CUBES)
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Cartesian = None
        """
        If the printkey is activated controls the printing of the mo in the
        cartesian basis
        """
        self.Eigenvalues = None
        """
        If the printkey is activated controls the printing of the eigenvalues
        of the mos
        """
        self.Eigenvectors = None
        """
        If the printkey is activated controls the printing of the eigenvectors
        of the mos
        """
        self.Occupation_numbers = None
        """
        If the printkey is activated controls the printing of the occupation
        numbers of the mos
        """
        self.Ndigits = None
        """
        Specify the number of digits used to print the MO eigenvalues and
        occupation numbers
        """
        self.Mo_index_range = None
        """
        Allows to print only a subset of the MO eigenvectors or eigenvalues.
        The indices of the first and the last MO have to be specified
        """
        self.EACH = _each185()
        self._name = "MO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Cartesian', 'CARTESIAN'), ('Eigenvalues', 'EIGENVALUES'), ('Eigenvectors', 'EIGENVECTORS'), ('Occupation_numbers', 'OCCUPATION_NUMBERS'), ('Ndigits', 'NDIGITS'), ('Mo_index_range', 'MO_INDEX_RANGE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Eigvals(self):
        """
        See documentation for Eigenvalues
        """
        return self.Eigenvalues

    @property
    def Eigvecs(self):
        """
        See documentation for Eigenvectors
        """
        return self.Eigenvectors

    @property
    def Occnums(self):
        """
        See documentation for Occupation_numbers
        """
        return self.Occupation_numbers

    @property
    def Mo_range(self):
        """
        See documentation for Mo_index_range
        """
        return self.Mo_index_range

    @property
    def Range(self):
        """
        See documentation for Mo_index_range
        """
        return self.Mo_index_range

    @Eigvals.setter
    def Eigvals(self, value):
        self.Eigenvalues = value

    @Eigvecs.setter
    def Eigvecs(self, value):
        self.Eigenvectors = value

    @Occnums.setter
    def Occnums(self, value):
        self.Occupation_numbers = value

    @Mo_range.setter
    def Mo_range(self, value):
        self.Mo_index_range = value

    @Range.setter
    def Range(self, value):
        self.Mo_index_range = value



class _ep_rho_cube1(printable):
    """
    Prints out a cube file with the calculated rho
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Rho0 = None
        """
        print the cube of rho0,the psi0 derived density matrix
        """
        self.Rho1 = None
        """
        print the value of the blocs of rho1, the psi1 (and psi0) derived
        density matrix
        """
        self.Stride = None
        """
        The stride (X,Y,Z) used to write the cube file (larger values result
        in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1
        number valid for all components.
        """
        self.Mo_s_inv = None
        """
        print the value of the inverse of the mo overlap matrix
        """
        self.EACH = _each258()
        self._name = "EP_RHO_CUBE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Rho0', 'RHO0'), ('Rho1', 'RHO1'), ('Stride', 'STRIDE'), ('Mo_s_inv', 'MO_S_INV')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _cube_data1(printable):
    """
    Density data used for restarts
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Cubefile data
        """
        self._name = "CUBE_DATA"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _current1(printable):
    """
    The induced current density is calculated by DFPT.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        controls the activation of the induced current calculation
        """
        self.Gauge = None
        """
        The gauge used to compute the induced current within GAPW.

        Available values:
            R
                Position gauge (doesnt work well).
            R_AND_STEP_FUNCTION
                Position and step function for the soft and the local parts,
                respectively.
            ATOM
                Atoms.
        """
        self.Gauge_atom_radius = None
        """
        Build the gauge=atom using only the atoms within this radius.
        """
        self.Use_old_gauge_atom = None
        """
        Use the old way to compute the gauge.
        """
        self.Orbital_center = None
        """
        The orbital center.

        Available values:
            WANNIER
                Use the Wannier centers.
            COMMON
                Use a common center (works only for an isolate molecule).
            ATOM
                Use the atoms as center.
            BOX
                Boxing.
        """
        self.Common_center = None
        """
        The common center
        """
        self.Nbox = None
        """
        How many boxes along each directions
        """
        self.Chi_pbc = None
        """
        Calculate the succeptibility correction to the shift with PBC
        """
        self.list_Selected_states_on_atom_list = []
        self.Selected_states_atom_radius = None
        """
        Select all the states included in the given radius arround each atoms
        in SELECTED_STATES_ON_ATOM_LIST.
        """
        self.Restart_current = None
        """
        Restart the induced current density calculation from a previous run
        (not working yet).
        """
        self.PRINT = _print49()
        self.INTERPOLATOR = _interpolator8()
        self._name = "CURRENT"
        self._keywords = [('Gauge', 'GAUGE'), ('Gauge_atom_radius', 'GAUGE_ATOM_RADIUS'), ('Use_old_gauge_atom', 'USE_OLD_GAUGE_ATOM'), ('Orbital_center', 'ORBITAL_CENTER'), ('Common_center', 'COMMON_CENTER'), ('Nbox', 'NBOX'), ('Chi_pbc', 'CHI_PBC'), ('Selected_states_atom_radius', 'SELECTED_STATES_ATOM_RADIUS'), ('Restart_current', 'RESTART_CURRENT')]
        self._repeated_keywords = [('Selected_states_on_atom_list', 'SELECTED_STATES_ON_ATOM_LIST')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT', 'PRINT'), ('INTERPOLATOR', 'INTERPOLATOR')]
        self._repeated_subsections = []

    def add_Selected_states_on_atom_list(self, value):
        self.list_Selected_states_on_atom_list.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _buffer_links1(printable):
    """
    Information about possible links for automatic covalent bond breaking
    for the buffer QM/MM calculation.Ignored - need to implement buffer
    selection by atom and walking of connectivity data.
    """
    def __init__(self):
        self.list_LINK = []
        self._name = "BUFFER_LINKS"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('LINK', '_link2')]

    def add_LINK(self):
        new_section = _link2()
        self.list_LINK.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _each72(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each73(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info18(printable):
    """
    Controls the printing of information on the HFX RI approximation
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each121()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info19(printable):
    """
    Controls the printing of information on the HFX RI approximation
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each128()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each76(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each77(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each74(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each75(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info12(printable):
    """
    Controls the printing of basic information during the SCF
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each94()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print_dftd2(printable):
    """
    Controls the printing of some info about DFTD contributions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each137()
        self._name = "PRINT_DFTD"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each78(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info11(printable):
    """
    Controls the printing of information during the evaluation of the
    mixed environment.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each89()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info16(printable):
    """
    Controls the printing basic info about the method
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each112()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info17(printable):
    """
    Controls the printing of information on the HFX RI approximation
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each115()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info14(printable):
    """
    Controls the printing of basic information during the run
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each107()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info15(printable):
    """
    Controls the printing basic info about the method
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each111()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print57(printable):
    """
    printing of information during the linear response calculation
    """
    def __init__(self):
        self.PROGRAM_RUN_INFO = _program_run_info42()
        self.RESTART = _restart10()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('RESTART', 'RESTART')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print56(printable):
    """
    print results of epr calculation
    """
    def __init__(self):
        self.NABLAVKS_CUBES = _nablavks_cubes1()
        self.G_TENSOR = _g_tensor1()
        self.RESPONSE_FUNCTION_CUBES = _response_function_cubes3()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('NABLAVKS_CUBES', 'NABLAVKS_CUBES'), ('G_TENSOR', 'G_TENSOR'), ('RESPONSE_FUNCTION_CUBES', 'RESPONSE_FUNCTION_CUBES')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print55(printable):
    """
    Print results of a HFX RI calculation
    """
    def __init__(self):
        self.PROGRAM_RUN_INFO = _program_run_info41()
        self.GEMINAL_BASIS = _geminal_basis6()
        self.CHARGE = _charge7()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('GEMINAL_BASIS', 'GEMINAL_BASIS'), ('CHARGE', 'CHARGE')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print54(printable):
    """
    Controls the printing of info about load balance
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Load_balance_info = None
        """
        Activates the printing of load balance information
        """
        self.EACH = _each315()
        self._name = "PRINT"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Load_balance_info', 'LOAD_BALANCE_INFO')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print53(printable):
    """
    Print results of a HFX RI calculation
    """
    def __init__(self):
        self.PROGRAM_RUN_INFO = _program_run_info40()
        self.GEMINAL_BASIS = _geminal_basis5()
        self.CHARGE = _charge6()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('GEMINAL_BASIS', 'GEMINAL_BASIS'), ('CHARGE', 'CHARGE')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print52(printable):
    """
    Controls the printing of info about load balance
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Load_balance_info = None
        """
        Activates the printing of load balance information
        """
        self.EACH = _each309()
        self._name = "PRINT"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Load_balance_info', 'LOAD_BALANCE_INFO')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print51(printable):
    """
    print results of the indirect spin-spin calculation
    """
    def __init__(self):
        self.K_MATRIX = _k_matrix1()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('K_MATRIX', 'K_MATRIX')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print50(printable):
    """
    print results of nmr calculation
    """
    def __init__(self):
        self.RESPONSE_FUNCTION_CUBES = _response_function_cubes2()
        self.CHI_TENSOR = _chi_tensor1()
        self.SHIELDING_TENSOR = _shielding_tensor1()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('RESPONSE_FUNCTION_CUBES', 'RESPONSE_FUNCTION_CUBES'), ('CHI_TENSOR', 'CHI_TENSOR'), ('SHIELDING_TENSOR', 'SHIELDING_TENSOR')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _num2d_mc1(printable):
    """
    provides parameters for the 2D Monte Carlo procedure
    """
    def __init__(self):
        self.Moves = None
        """
        Total number of Monte Carlo moves to use in the optimization
        """
        self.Cycles = None
        """
        How many annealing cycles to use
        """
        self.Reduction_steps = None
        """
        How many temperature reduction steps have to be performed per cycle
        """
        self.Reduction_factor = None
        """
        How to scale the temperature at each reduction step
        """
        self.Temperature = None
        """
        Highest temperature to be used (in units of the maximum cost of a non-
        zero 2D block)
        """
        self.Tolerance = None
        """
        If the found distribution is within a fraction of the theoretical
        optimal one, the optimization stops
        """
        self.Swap_probability = None
        """
        Probability of a col/row assignment swap
        """
        self.Opt_target = None
        """
        The aim of the MC optimization

        Available values:
            SMALLEST_MAXIMUM
                minimize the maximum cost
            PERFECT_BALANCE
                minimize the deviance from the average
        """
        self.PROGRAM_RUN_INFO = _program_run_info14()
        self._name = "2D_MC"
        self._keywords = [('Moves', 'MOVES'), ('Cycles', 'CYCLES'), ('Reduction_steps', 'REDUCTION_STEPS'), ('Reduction_factor', 'REDUCTION_FACTOR'), ('Temperature', 'TEMPERATURE'), ('Tolerance', 'TOLERANCE'), ('Swap_probability', 'SWAP_PROBABILITY'), ('Opt_target', 'OPT_TARGET')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print59(printable):
    """
    Controls the printing of basic information during the run
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each333()
        self._name = "PRINT"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print58(printable):
    """
    Section of possible print options specific for the RESP code.
    """
    def __init__(self):
        self.PROGRAM_RUN_INFO = _program_run_info48()
        self.COORD_FIT_POINTS = _coord_fit_points1()
        self.RESP_CHARGES_TO_FILE = _resp_charges_to_file1()
        self.V_RESP_CUBE = _v_resp_cube1()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('COORD_FIT_POINTS', 'COORD_FIT_POINTS'), ('RESP_CHARGES_TO_FILE', 'RESP_CHARGES_TO_FILE'), ('V_RESP_CUBE', 'V_RESP_CUBE')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _symmetry1(printable):
    """
    controls the output of symmetry information
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Molecule = None
        """
        Assume the system is an isolated molecule
        """
        self.Eps_geo = None
        """
        Accuracy required for symmetry detection
        """
        self.Standard_orientation = None
        """
        Print molecular coordinates in standard orientation
        """
        self.Inertia = None
        """
        Print molecular inertia tensor
        """
        self.Symmetry_elements = None
        """
        Print symmetry elements
        """
        self.All = None
        """
        Print all symmetry information
        """
        self.Rotation_matrices = None
        """
        All the rotation matrices of the point group
        """
        self.Check_symmetry = None
        """
        Check if calculated symmetry has expected value. Use either
        Schoenfliess or Hermann-Maugin symbols
        """
        self.EACH = _each283()
        self._name = "SYMMETRY"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Molecule', 'MOLECULE'), ('Eps_geo', 'EPS_GEO'), ('Standard_orientation', 'STANDARD_ORIENTATION'), ('Inertia', 'INERTIA'), ('Symmetry_elements', 'SYMMETRY_ELEMENTS'), ('All', 'ALL'), ('Rotation_matrices', 'ROTATION_MATRICES'), ('Check_symmetry', 'CHECK_SYMMETRY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _ke_gga4(printable):
    """
    Uses one of the KE_GGA functionals (optimized versions of some of
    these functionals might be available outside this section).
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Functional = None
        """
        Which one of the KE_GGA functionals should be used

        Available values:
            OL1
            OL2
            LLP
            PW86
            PW91
            LC
            T92
            PBE
        """
        self._name = "KE_GGA"
        self._keywords = [('Functional', 'FUNCTIONAL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _ke_gga3(printable):
    """
    Uses one of the KE_GGA functionals (optimized versions of some of
    these functionals might be available outside this section).
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Functional = None
        """
        Which one of the KE_GGA functionals should be used

        Available values:
            OL1
            OL2
            LLP
            PW86
            PW91
            LC
            T92
            PBE
        """
        self._name = "KE_GGA"
        self._keywords = [('Functional', 'FUNCTIONAL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _ke_gga2(printable):
    """
    Uses one of the KE_GGA functionals (optimized versions of some of
    these functionals might be available outside this section).
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Functional = None
        """
        Which one of the KE_GGA functionals should be used

        Available values:
            OL1
            OL2
            LLP
            PW86
            PW91
            LC
            T92
            PBE
        """
        self._name = "KE_GGA"
        self._keywords = [('Functional', 'FUNCTIONAL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _ke_gga1(printable):
    """
    Uses one of the KE_GGA functionals (optimized versions of some of
    these functionals might be available outside this section).
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Functional = None
        """
        Which one of the KE_GGA functionals should be used

        Available values:
            OL1
            OL2
            LLP
            PW86
            PW91
            LC
            T92
            PBE
        """
        self._name = "KE_GGA"
        self._keywords = [('Functional', 'FUNCTIONAL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _becke88_lr4(printable):
    """
    Uses the Becke 88 longrange exchange functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Omega = None
        """
        Potential parameter in erf(omega*r)/r
        """
        self._name = "BECKE88_LR"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Omega', 'OMEGA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _becke88_lr1(printable):
    """
    Uses the Becke 88 longrange exchange functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Omega = None
        """
        Potential parameter in erf(omega*r)/r
        """
        self._name = "BECKE88_LR"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Omega', 'OMEGA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _becke88_lr2(printable):
    """
    Uses the Becke 88 longrange exchange functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Omega = None
        """
        Potential parameter in erf(omega*r)/r
        """
        self._name = "BECKE88_LR"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Omega', 'OMEGA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _becke88_lr3(printable):
    """
    Uses the Becke 88 longrange exchange functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Omega = None
        """
        Potential parameter in erf(omega*r)/r
        """
        self._name = "BECKE88_LR"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Omega', 'OMEGA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _walls1(printable):
    """
    Enables Walls for the QM box. This can be used to avoid that QM  atoms
    move out of the QM box.
    """
    def __init__(self):
        self.Wall_skin = None
        """
        Specify the value of the skin of the Wall in each dimension. The
        wall's effect is felt when atoms fall within the skin of the Wall.
        """
        self.Type = None
        """
        Specifies the type of wall

        Available values:
            NONE
                No Wall around QM box
            REFLECTIVE
                Reflective Wall around QM box
            QUADRATIC
                Quadratic Wall around QM box
        """
        self.K = None
        """
        Specify the value of the the force constant for the quadratic wall
        """
        self._name = "WALLS"
        self._keywords = [('Wall_skin', 'WALL_SKIN'), ('Type', 'TYPE'), ('K', 'K')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _link3(printable):
    """
    Specify information on the QM/MM link treatment
    """
    def __init__(self):
        self.Qm_index = None
        """
        Specifies the index of the QM atom involved in the QM/MM link
        """
        self.Qm_kind = None
        """
        Specifies the element of the QM capping atom involved in the QM/MM
        link
        """
        self.Mm_index = None
        """
        Specifies the index of the MM atom involved in the QM/MM link, Default
        hydrogen.
        """
        self.Radius = None
        """
        Overwrite the specification of the radius only for the MM atom
        involved in the link.Default is to use the same radius as for the
        specified type.
        """
        self.Corr_radius = None
        """
        Overwrite the specification of the correction radius only for the MM
        atom involved in the link.Default is to use the same correction radius
        as for the specified type.
        """
        self.Link_type = None
        """
        Specifies the method to use to treat the defined QM/MM link

        Available values:
            IMOMM
            GHO
            PSEUDO
        """
        self.Alpha_imomm = None
        """
        Specifies the scaling factor to be used for projecting the forces on
        the capping hydrogen in the IMOMM QM/MM link scheme to the MM atom of
        the link. A good guess can be derived from the bond distances of the
        forcefield: alpha = r_eq(QM-MM) / r_eq(QM-H).
        """
        self.Qmmm_scale_factor = None
        """
        Specifies the scaling factor for the MM charge involved in the link
        QM/MM. This keyword affects only the QM/MM potential, it doesn't
        affect the electrostatic in  the classical part of the code. Default
        1.0 i.e. no charge rescaling of the MM atom of the QM/MM link bond.
        """
        self.Fist_scale_factor = None
        """
        Specifies the scaling factor for the MM charge involved in the link
        QM/MM. This keyword modifies the MM charge in FIST. The modified
        charge will be used then also for the generation of the QM/MM
        potential. Default 1.0 i.e. no charge rescaling of the MM atom of the
        QM/MM link bond.
        """
        self.list_MOVE_MM_CHARGE = []
        self.list_ADD_MM_CHARGE = []
        self._name = "LINK"
        self._keywords = [('Qm_index', 'QM_INDEX'), ('Qm_kind', 'QM_KIND'), ('Mm_index', 'MM_INDEX'), ('Radius', 'RADIUS'), ('Corr_radius', 'CORR_RADIUS'), ('Link_type', 'LINK_TYPE'), ('Alpha_imomm', 'ALPHA_IMOMM'), ('Qmmm_scale_factor', 'QMMM_SCALE_FACTOR'), ('Fist_scale_factor', 'FIST_SCALE_FACTOR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('MOVE_MM_CHARGE', '_move_mm_charge3'), ('ADD_MM_CHARGE', '_add_mm_charge3')]

    def add_MOVE_MM_CHARGE(self):
        new_section = _move_mm_charge3()
        self.list_MOVE_MM_CHARGE.append(new_section)
        return new_section

    def add_ADD_MM_CHARGE(self):
        new_section = _add_mm_charge3()
        self.list_ADD_MM_CHARGE.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Qm(self):
        """
        See documentation for Qm_index
        """
        return self.Qm_index

    @property
    def Mm(self):
        """
        See documentation for Mm_index
        """
        return self.Mm_index

    @property
    def Link(self):
        """
        See documentation for Link_type
        """
        return self.Link_type

    @property
    def Type(self):
        """
        See documentation for Link_type
        """
        return self.Link_type

    @property
    def Ltype(self):
        """
        See documentation for Link_type
        """
        return self.Link_type

    @property
    def Alpha(self):
        """
        See documentation for Alpha_imomm
        """
        return self.Alpha_imomm

    @property
    def Qmmm_charge_scale(self):
        """
        See documentation for Qmmm_scale_factor
        """
        return self.Qmmm_scale_factor

    @property
    def Qmmm_charge_factor(self):
        """
        See documentation for Qmmm_scale_factor
        """
        return self.Qmmm_scale_factor

    @property
    def Qmmm_scale_charge(self):
        """
        See documentation for Qmmm_scale_factor
        """
        return self.Qmmm_scale_factor

    @property
    def Fist_charge_scale(self):
        """
        See documentation for Fist_scale_factor
        """
        return self.Fist_scale_factor

    @property
    def Fist_charge_factor(self):
        """
        See documentation for Fist_scale_factor
        """
        return self.Fist_scale_factor

    @property
    def Fist_scale_charge(self):
        """
        See documentation for Fist_scale_factor
        """
        return self.Fist_scale_factor

    @Qm.setter
    def Qm(self, value):
        self.Qm_index = value

    @Mm.setter
    def Mm(self, value):
        self.Mm_index = value

    @Link.setter
    def Link(self, value):
        self.Link_type = value

    @Type.setter
    def Type(self, value):
        self.Link_type = value

    @Ltype.setter
    def Ltype(self, value):
        self.Link_type = value

    @Alpha.setter
    def Alpha(self, value):
        self.Alpha_imomm = value

    @Qmmm_charge_scale.setter
    def Qmmm_charge_scale(self, value):
        self.Qmmm_scale_factor = value

    @Qmmm_charge_factor.setter
    def Qmmm_charge_factor(self, value):
        self.Qmmm_scale_factor = value

    @Qmmm_scale_charge.setter
    def Qmmm_scale_charge(self, value):
        self.Qmmm_scale_factor = value

    @Fist_charge_scale.setter
    def Fist_charge_scale(self, value):
        self.Fist_scale_factor = value

    @Fist_charge_factor.setter
    def Fist_charge_factor(self, value):
        self.Fist_scale_factor = value

    @Fist_scale_charge.setter
    def Fist_scale_charge(self, value):
        self.Fist_scale_factor = value



class _link2(printable):
    """
    Specify information on the QM/MM link treatment
    """
    def __init__(self):
        self.Qm_index = None
        """
        Specifies the index of the QM atom involved in the QM/MM link
        """
        self.Qm_kind = None
        """
        Specifies the element of the QM capping atom involved in the QM/MM
        link
        """
        self.Mm_index = None
        """
        Specifies the index of the MM atom involved in the QM/MM link, Default
        hydrogen.
        """
        self.Radius = None
        """
        Overwrite the specification of the radius only for the MM atom
        involved in the link.Default is to use the same radius as for the
        specified type.
        """
        self.Corr_radius = None
        """
        Overwrite the specification of the correction radius only for the MM
        atom involved in the link.Default is to use the same correction radius
        as for the specified type.
        """
        self.Link_type = None
        """
        Specifies the method to use to treat the defined QM/MM link

        Available values:
            IMOMM
            GHO
            PSEUDO
        """
        self.Alpha_imomm = None
        """
        Specifies the scaling factor to be used for projecting the forces on
        the capping hydrogen in the IMOMM QM/MM link scheme to the MM atom of
        the link. A good guess can be derived from the bond distances of the
        forcefield: alpha = r_eq(QM-MM) / r_eq(QM-H).
        """
        self.Qmmm_scale_factor = None
        """
        Specifies the scaling factor for the MM charge involved in the link
        QM/MM. This keyword affects only the QM/MM potential, it doesn't
        affect the electrostatic in  the classical part of the code. Default
        1.0 i.e. no charge rescaling of the MM atom of the QM/MM link bond.
        """
        self.Fist_scale_factor = None
        """
        Specifies the scaling factor for the MM charge involved in the link
        QM/MM. This keyword modifies the MM charge in FIST. The modified
        charge will be used then also for the generation of the QM/MM
        potential. Default 1.0 i.e. no charge rescaling of the MM atom of the
        QM/MM link bond.
        """
        self.list_MOVE_MM_CHARGE = []
        self.list_ADD_MM_CHARGE = []
        self._name = "LINK"
        self._keywords = [('Qm_index', 'QM_INDEX'), ('Qm_kind', 'QM_KIND'), ('Mm_index', 'MM_INDEX'), ('Radius', 'RADIUS'), ('Corr_radius', 'CORR_RADIUS'), ('Link_type', 'LINK_TYPE'), ('Alpha_imomm', 'ALPHA_IMOMM'), ('Qmmm_scale_factor', 'QMMM_SCALE_FACTOR'), ('Fist_scale_factor', 'FIST_SCALE_FACTOR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('MOVE_MM_CHARGE', '_move_mm_charge2'), ('ADD_MM_CHARGE', '_add_mm_charge2')]

    def add_MOVE_MM_CHARGE(self):
        new_section = _move_mm_charge2()
        self.list_MOVE_MM_CHARGE.append(new_section)
        return new_section

    def add_ADD_MM_CHARGE(self):
        new_section = _add_mm_charge2()
        self.list_ADD_MM_CHARGE.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Qm(self):
        """
        See documentation for Qm_index
        """
        return self.Qm_index

    @property
    def Mm(self):
        """
        See documentation for Mm_index
        """
        return self.Mm_index

    @property
    def Link(self):
        """
        See documentation for Link_type
        """
        return self.Link_type

    @property
    def Type(self):
        """
        See documentation for Link_type
        """
        return self.Link_type

    @property
    def Ltype(self):
        """
        See documentation for Link_type
        """
        return self.Link_type

    @property
    def Alpha(self):
        """
        See documentation for Alpha_imomm
        """
        return self.Alpha_imomm

    @property
    def Qmmm_charge_scale(self):
        """
        See documentation for Qmmm_scale_factor
        """
        return self.Qmmm_scale_factor

    @property
    def Qmmm_charge_factor(self):
        """
        See documentation for Qmmm_scale_factor
        """
        return self.Qmmm_scale_factor

    @property
    def Qmmm_scale_charge(self):
        """
        See documentation for Qmmm_scale_factor
        """
        return self.Qmmm_scale_factor

    @property
    def Fist_charge_scale(self):
        """
        See documentation for Fist_scale_factor
        """
        return self.Fist_scale_factor

    @property
    def Fist_charge_factor(self):
        """
        See documentation for Fist_scale_factor
        """
        return self.Fist_scale_factor

    @property
    def Fist_scale_charge(self):
        """
        See documentation for Fist_scale_factor
        """
        return self.Fist_scale_factor

    @Qm.setter
    def Qm(self, value):
        self.Qm_index = value

    @Mm.setter
    def Mm(self, value):
        self.Mm_index = value

    @Link.setter
    def Link(self, value):
        self.Link_type = value

    @Type.setter
    def Type(self, value):
        self.Link_type = value

    @Ltype.setter
    def Ltype(self, value):
        self.Link_type = value

    @Alpha.setter
    def Alpha(self, value):
        self.Alpha_imomm = value

    @Qmmm_charge_scale.setter
    def Qmmm_charge_scale(self, value):
        self.Qmmm_scale_factor = value

    @Qmmm_charge_factor.setter
    def Qmmm_charge_factor(self, value):
        self.Qmmm_scale_factor = value

    @Qmmm_scale_charge.setter
    def Qmmm_scale_charge(self, value):
        self.Qmmm_scale_factor = value

    @Fist_charge_scale.setter
    def Fist_charge_scale(self, value):
        self.Fist_scale_factor = value

    @Fist_charge_factor.setter
    def Fist_charge_factor(self, value):
        self.Fist_scale_factor = value

    @Fist_scale_charge.setter
    def Fist_scale_charge(self, value):
        self.Fist_scale_factor = value



class _link1(printable):
    """
    Specify information on the QM/MM link treatment
    """
    def __init__(self):
        self.Qm_index = None
        """
        Specifies the index of the QM atom involved in the QM/MM link
        """
        self.Qm_kind = None
        """
        Specifies the element of the QM capping atom involved in the QM/MM
        link
        """
        self.Mm_index = None
        """
        Specifies the index of the MM atom involved in the QM/MM link, Default
        hydrogen.
        """
        self.Radius = None
        """
        Overwrite the specification of the radius only for the MM atom
        involved in the link.Default is to use the same radius as for the
        specified type.
        """
        self.Corr_radius = None
        """
        Overwrite the specification of the correction radius only for the MM
        atom involved in the link.Default is to use the same correction radius
        as for the specified type.
        """
        self.Link_type = None
        """
        Specifies the method to use to treat the defined QM/MM link

        Available values:
            IMOMM
            GHO
            PSEUDO
        """
        self.Alpha_imomm = None
        """
        Specifies the scaling factor to be used for projecting the forces on
        the capping hydrogen in the IMOMM QM/MM link scheme to the MM atom of
        the link. A good guess can be derived from the bond distances of the
        forcefield: alpha = r_eq(QM-MM) / r_eq(QM-H).
        """
        self.Qmmm_scale_factor = None
        """
        Specifies the scaling factor for the MM charge involved in the link
        QM/MM. This keyword affects only the QM/MM potential, it doesn't
        affect the electrostatic in  the classical part of the code. Default
        1.0 i.e. no charge rescaling of the MM atom of the QM/MM link bond.
        """
        self.Fist_scale_factor = None
        """
        Specifies the scaling factor for the MM charge involved in the link
        QM/MM. This keyword modifies the MM charge in FIST. The modified
        charge will be used then also for the generation of the QM/MM
        potential. Default 1.0 i.e. no charge rescaling of the MM atom of the
        QM/MM link bond.
        """
        self.list_MOVE_MM_CHARGE = []
        self.list_ADD_MM_CHARGE = []
        self._name = "LINK"
        self._keywords = [('Qm_index', 'QM_INDEX'), ('Qm_kind', 'QM_KIND'), ('Mm_index', 'MM_INDEX'), ('Radius', 'RADIUS'), ('Corr_radius', 'CORR_RADIUS'), ('Link_type', 'LINK_TYPE'), ('Alpha_imomm', 'ALPHA_IMOMM'), ('Qmmm_scale_factor', 'QMMM_SCALE_FACTOR'), ('Fist_scale_factor', 'FIST_SCALE_FACTOR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('MOVE_MM_CHARGE', '_move_mm_charge1'), ('ADD_MM_CHARGE', '_add_mm_charge1')]

    def add_MOVE_MM_CHARGE(self):
        new_section = _move_mm_charge1()
        self.list_MOVE_MM_CHARGE.append(new_section)
        return new_section

    def add_ADD_MM_CHARGE(self):
        new_section = _add_mm_charge1()
        self.list_ADD_MM_CHARGE.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Qm(self):
        """
        See documentation for Qm_index
        """
        return self.Qm_index

    @property
    def Mm(self):
        """
        See documentation for Mm_index
        """
        return self.Mm_index

    @property
    def Link(self):
        """
        See documentation for Link_type
        """
        return self.Link_type

    @property
    def Type(self):
        """
        See documentation for Link_type
        """
        return self.Link_type

    @property
    def Ltype(self):
        """
        See documentation for Link_type
        """
        return self.Link_type

    @property
    def Alpha(self):
        """
        See documentation for Alpha_imomm
        """
        return self.Alpha_imomm

    @property
    def Qmmm_charge_scale(self):
        """
        See documentation for Qmmm_scale_factor
        """
        return self.Qmmm_scale_factor

    @property
    def Qmmm_charge_factor(self):
        """
        See documentation for Qmmm_scale_factor
        """
        return self.Qmmm_scale_factor

    @property
    def Qmmm_scale_charge(self):
        """
        See documentation for Qmmm_scale_factor
        """
        return self.Qmmm_scale_factor

    @property
    def Fist_charge_scale(self):
        """
        See documentation for Fist_scale_factor
        """
        return self.Fist_scale_factor

    @property
    def Fist_charge_factor(self):
        """
        See documentation for Fist_scale_factor
        """
        return self.Fist_scale_factor

    @property
    def Fist_scale_charge(self):
        """
        See documentation for Fist_scale_factor
        """
        return self.Fist_scale_factor

    @Qm.setter
    def Qm(self, value):
        self.Qm_index = value

    @Mm.setter
    def Mm(self, value):
        self.Mm_index = value

    @Link.setter
    def Link(self, value):
        self.Link_type = value

    @Type.setter
    def Type(self, value):
        self.Link_type = value

    @Ltype.setter
    def Ltype(self, value):
        self.Link_type = value

    @Alpha.setter
    def Alpha(self, value):
        self.Alpha_imomm = value

    @Qmmm_charge_scale.setter
    def Qmmm_charge_scale(self, value):
        self.Qmmm_scale_factor = value

    @Qmmm_charge_factor.setter
    def Qmmm_charge_factor(self, value):
        self.Qmmm_scale_factor = value

    @Qmmm_scale_charge.setter
    def Qmmm_scale_charge(self, value):
        self.Qmmm_scale_factor = value

    @Fist_charge_scale.setter
    def Fist_charge_scale(self, value):
        self.Fist_scale_factor = value

    @Fist_charge_factor.setter
    def Fist_charge_factor(self, value):
        self.Fist_scale_factor = value

    @Fist_scale_charge.setter
    def Fist_scale_charge(self, value):
        self.Fist_scale_factor = value



class _colvar2(printable):
    """
    This section specifies the nature of the collective variables.
    """
    def __init__(self):
        self.DISTANCE = _distance2()
        self.ANGLE = _angle3()
        self.TORSION = _torsion4()
        self.COORDINATION = _coordination2()
        self.POPULATION = _population2()
        self.GYRATION_RADIUS = _gyration_radius2()
        self.DISTANCE_POINT_PLANE = _distance_point_plane2()
        self.ANGLE_PLANE_PLANE = _angle_plane_plane2()
        self.BOND_ROTATION = _bond_rotation2()
        self.DISTANCE_FUNCTION = _distance_function2()
        self.QPARM = _qparm2()
        self.HYDRONIUM = _hydronium2()
        self.RMSD = _rmsd2()
        self.XYZ_DIAG = _xyz_diag2()
        self.XYZ_OUTERDIAG = _xyz_outerdiag2()
        self.U = _u2()
        self.WC = _wc2()
        self.HBP = _hbp2()
        self.RING_PUCKERING = _ring_puckering2()
        self.CONDITIONED_DISTANCE = _conditioned_distance2()
        self.list_PRINT = []
        self.COLVAR_FUNC_INFO = _colvar_func_info1()
        self._name = "COLVAR"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('DISTANCE', 'DISTANCE'), ('ANGLE', 'ANGLE'), ('TORSION', 'TORSION'), ('COORDINATION', 'COORDINATION'), ('POPULATION', 'POPULATION'), ('GYRATION_RADIUS', 'GYRATION_RADIUS'), ('DISTANCE_POINT_PLANE', 'DISTANCE_POINT_PLANE'), ('ANGLE_PLANE_PLANE', 'ANGLE_PLANE_PLANE'), ('BOND_ROTATION', 'BOND_ROTATION'), ('DISTANCE_FUNCTION', 'DISTANCE_FUNCTION'), ('QPARM', 'QPARM'), ('HYDRONIUM', 'HYDRONIUM'), ('RMSD', 'RMSD'), ('XYZ_DIAG', 'XYZ_DIAG'), ('XYZ_OUTERDIAG', 'XYZ_OUTERDIAG'), ('U', 'U'), ('WC', 'WC'), ('HBP', 'HBP'), ('RING_PUCKERING', 'RING_PUCKERING'), ('CONDITIONED_DISTANCE', 'CONDITIONED_DISTANCE'), ('COLVAR_FUNC_INFO', 'COLVAR_FUNC_INFO')]
        self._repeated_subsections = [('PRINT', '_print43')]

    def add_PRINT(self):
        new_section = _print43()
        self.list_PRINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _colvar3(printable):
    """
    This section specifies the nature of the collective variables.
    """
    def __init__(self):
        self.DISTANCE = _distance3()
        self.ANGLE = _angle4()
        self.TORSION = _torsion5()
        self.COORDINATION = _coordination3()
        self.POPULATION = _population3()
        self.GYRATION_RADIUS = _gyration_radius3()
        self.DISTANCE_POINT_PLANE = _distance_point_plane3()
        self.ANGLE_PLANE_PLANE = _angle_plane_plane3()
        self.BOND_ROTATION = _bond_rotation3()
        self.DISTANCE_FUNCTION = _distance_function3()
        self.QPARM = _qparm3()
        self.HYDRONIUM = _hydronium3()
        self.RMSD = _rmsd3()
        self.XYZ_DIAG = _xyz_diag3()
        self.XYZ_OUTERDIAG = _xyz_outerdiag3()
        self.U = _u3()
        self.WC = _wc3()
        self.HBP = _hbp3()
        self.RING_PUCKERING = _ring_puckering3()
        self.CONDITIONED_DISTANCE = _conditioned_distance3()
        self.list_PRINT = []
        self.COLVAR_FUNC_INFO = _colvar_func_info2()
        self._name = "COLVAR"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('DISTANCE', 'DISTANCE'), ('ANGLE', 'ANGLE'), ('TORSION', 'TORSION'), ('COORDINATION', 'COORDINATION'), ('POPULATION', 'POPULATION'), ('GYRATION_RADIUS', 'GYRATION_RADIUS'), ('DISTANCE_POINT_PLANE', 'DISTANCE_POINT_PLANE'), ('ANGLE_PLANE_PLANE', 'ANGLE_PLANE_PLANE'), ('BOND_ROTATION', 'BOND_ROTATION'), ('DISTANCE_FUNCTION', 'DISTANCE_FUNCTION'), ('QPARM', 'QPARM'), ('HYDRONIUM', 'HYDRONIUM'), ('RMSD', 'RMSD'), ('XYZ_DIAG', 'XYZ_DIAG'), ('XYZ_OUTERDIAG', 'XYZ_OUTERDIAG'), ('U', 'U'), ('WC', 'WC'), ('HBP', 'HBP'), ('RING_PUCKERING', 'RING_PUCKERING'), ('CONDITIONED_DISTANCE', 'CONDITIONED_DISTANCE'), ('COLVAR_FUNC_INFO', 'COLVAR_FUNC_INFO')]
        self._repeated_subsections = [('PRINT', '_print44')]

    def add_PRINT(self):
        new_section = _print44()
        self.list_PRINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _colvar1(printable):
    """
    Controls the printing of COLVAR summary information during
    metadynamics. When an extended Lagrangian use used, the files contain
    (in order): colvar value of the extended Lagrangian,  instantaneous
    colvar value, force due to the harmonic term of the extended
    Lagrangian and the force due to the previously spawned hills, the
    force due to the walls, the velocities in the extended  Lagrangian,
    the potential of the harmonic term of the Lagrangian, the potential
    energy of the hills, the potential energy of the walls and the
    temperature of the extended Lagrangian. When the extended Lagrangian
    is not used, all related fields are omitted.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each43()
        self._name = "COLVAR"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _colvar4(printable):
    """
    This section specifies the nature of the collective variables.
    """
    def __init__(self):
        self.DISTANCE = _distance4()
        self.ANGLE = _angle5()
        self.TORSION = _torsion6()
        self.COORDINATION = _coordination4()
        self.POPULATION = _population4()
        self.GYRATION_RADIUS = _gyration_radius4()
        self.DISTANCE_POINT_PLANE = _distance_point_plane4()
        self.ANGLE_PLANE_PLANE = _angle_plane_plane4()
        self.BOND_ROTATION = _bond_rotation4()
        self.DISTANCE_FUNCTION = _distance_function4()
        self.QPARM = _qparm4()
        self.HYDRONIUM = _hydronium4()
        self.RMSD = _rmsd4()
        self.XYZ_DIAG = _xyz_diag4()
        self.XYZ_OUTERDIAG = _xyz_outerdiag4()
        self.U = _u4()
        self.WC = _wc4()
        self.HBP = _hbp4()
        self.RING_PUCKERING = _ring_puckering4()
        self.CONDITIONED_DISTANCE = _conditioned_distance4()
        self.list_PRINT = []
        self.COLVAR_FUNC_INFO = _colvar_func_info3()
        self._name = "COLVAR"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('DISTANCE', 'DISTANCE'), ('ANGLE', 'ANGLE'), ('TORSION', 'TORSION'), ('COORDINATION', 'COORDINATION'), ('POPULATION', 'POPULATION'), ('GYRATION_RADIUS', 'GYRATION_RADIUS'), ('DISTANCE_POINT_PLANE', 'DISTANCE_POINT_PLANE'), ('ANGLE_PLANE_PLANE', 'ANGLE_PLANE_PLANE'), ('BOND_ROTATION', 'BOND_ROTATION'), ('DISTANCE_FUNCTION', 'DISTANCE_FUNCTION'), ('QPARM', 'QPARM'), ('HYDRONIUM', 'HYDRONIUM'), ('RMSD', 'RMSD'), ('XYZ_DIAG', 'XYZ_DIAG'), ('XYZ_OUTERDIAG', 'XYZ_OUTERDIAG'), ('U', 'U'), ('WC', 'WC'), ('HBP', 'HBP'), ('RING_PUCKERING', 'RING_PUCKERING'), ('CONDITIONED_DISTANCE', 'CONDITIONED_DISTANCE'), ('COLVAR_FUNC_INFO', 'COLVAR_FUNC_INFO')]
        self._repeated_subsections = [('PRINT', '_print45')]

    def add_PRINT(self):
        new_section = _print45()
        self.list_PRINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _colvar5(printable):
    """
    This section specifies the nature of the collective variables.
    """
    def __init__(self):
        self.DISTANCE = _distance1()
        self.ANGLE = _angle2()
        self.TORSION = _torsion3()
        self.COORDINATION = _coordination1()
        self.POPULATION = _population1()
        self.GYRATION_RADIUS = _gyration_radius1()
        self.DISTANCE_POINT_PLANE = _distance_point_plane1()
        self.ANGLE_PLANE_PLANE = _angle_plane_plane1()
        self.BOND_ROTATION = _bond_rotation1()
        self.DISTANCE_FUNCTION = _distance_function1()
        self.QPARM = _qparm1()
        self.HYDRONIUM = _hydronium1()
        self.RMSD = _rmsd1()
        self.XYZ_DIAG = _xyz_diag1()
        self.XYZ_OUTERDIAG = _xyz_outerdiag1()
        self.U = _u1()
        self.WC = _wc1()
        self.HBP = _hbp1()
        self.RING_PUCKERING = _ring_puckering1()
        self.CONDITIONED_DISTANCE = _conditioned_distance1()
        self.REACTION_PATH = _reaction_path1()
        self.DISTANCE_FROM_PATH = _distance_from_path1()
        self.COMBINE_COLVAR = _combine_colvar1()
        self.list_PRINT = []
        self.COLVAR_FUNC_INFO = _colvar_func_info4()
        self._name = "COLVAR"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('DISTANCE', 'DISTANCE'), ('ANGLE', 'ANGLE'), ('TORSION', 'TORSION'), ('COORDINATION', 'COORDINATION'), ('POPULATION', 'POPULATION'), ('GYRATION_RADIUS', 'GYRATION_RADIUS'), ('DISTANCE_POINT_PLANE', 'DISTANCE_POINT_PLANE'), ('ANGLE_PLANE_PLANE', 'ANGLE_PLANE_PLANE'), ('BOND_ROTATION', 'BOND_ROTATION'), ('DISTANCE_FUNCTION', 'DISTANCE_FUNCTION'), ('QPARM', 'QPARM'), ('HYDRONIUM', 'HYDRONIUM'), ('RMSD', 'RMSD'), ('XYZ_DIAG', 'XYZ_DIAG'), ('XYZ_OUTERDIAG', 'XYZ_OUTERDIAG'), ('U', 'U'), ('WC', 'WC'), ('HBP', 'HBP'), ('RING_PUCKERING', 'RING_PUCKERING'), ('CONDITIONED_DISTANCE', 'CONDITIONED_DISTANCE'), ('REACTION_PATH', 'REACTION_PATH'), ('DISTANCE_FROM_PATH', 'DISTANCE_FROM_PATH'), ('COMBINE_COLVAR', 'COMBINE_COLVAR'), ('COLVAR_FUNC_INFO', 'COLVAR_FUNC_INFO')]
        self._repeated_subsections = [('PRINT', '_print46')]

    def add_PRINT(self):
        new_section = _print46()
        self.list_PRINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _gaussian1(printable):
    """
    Parameters controlling the gaussian wall.
    """
    def __init__(self):
        self.Ww = None
        """
        Specify the height of the gaussian: WW*e^(-((CV-POS)/sigma)^2)
        """
        self.Sigma = None
        """
        Specify the width of the gaussian: WW*e^(-((CV-POS)/sigma)^2)
        """
        self._name = "GAUSSIAN"
        self._keywords = [('Ww', 'WW'), ('Sigma', 'SIGMA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _msd_kind1(printable):
    """
    Controls the output of msd per kind
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each28()
        self._name = "MSD_KIND"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _plane2(printable):
    """
    This section defines the plane. When using this colvar, two plane
    section must be defined!
    """
    def __init__(self):
        self.Def_type = None
        """
        Specify how the plane is defined: either by 3 atoms or by a fixed
        normal vector. At least one plane must be defined through atoms.

        Available values:
            ATOMS
                Plane defined by the position of 3 atoms
            VECTOR
                Plane defined by a fixed normal vector
        """
        self.Atoms = None
        """
        Specifies the indexes of 3 atoms/points defining the plane.
        """
        self.Normal_vector = None
        """
        Alternatively to 3 atoms/points one can define one of the two, planes
        by defining its NORMAL vector.
        """
        self._name = "PLANE"
        self._keywords = [('Def_type', 'DEF_TYPE'), ('Atoms', 'ATOMS'), ('Normal_vector', 'NORMAL_VECTOR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _plane3(printable):
    """
    This section defines the plane. When using this colvar, two plane
    section must be defined!
    """
    def __init__(self):
        self.Def_type = None
        """
        Specify how the plane is defined: either by 3 atoms or by a fixed
        normal vector. At least one plane must be defined through atoms.

        Available values:
            ATOMS
                Plane defined by the position of 3 atoms
            VECTOR
                Plane defined by a fixed normal vector
        """
        self.Atoms = None
        """
        Specifies the indexes of 3 atoms/points defining the plane.
        """
        self.Normal_vector = None
        """
        Alternatively to 3 atoms/points one can define one of the two, planes
        by defining its NORMAL vector.
        """
        self._name = "PLANE"
        self._keywords = [('Def_type', 'DEF_TYPE'), ('Atoms', 'ATOMS'), ('Normal_vector', 'NORMAL_VECTOR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _plane1(printable):
    """
    This section defines the plane. When using this colvar, two plane
    section must be defined!
    """
    def __init__(self):
        self.Def_type = None
        """
        Specify how the plane is defined: either by 3 atoms or by a fixed
        normal vector. At least one plane must be defined through atoms.

        Available values:
            ATOMS
                Plane defined by the position of 3 atoms
            VECTOR
                Plane defined by a fixed normal vector
        """
        self.Atoms = None
        """
        Specifies the indexes of 3 atoms/points defining the plane.
        """
        self.Normal_vector = None
        """
        Alternatively to 3 atoms/points one can define one of the two, planes
        by defining its NORMAL vector.
        """
        self._name = "PLANE"
        self._keywords = [('Def_type', 'DEF_TYPE'), ('Atoms', 'ATOMS'), ('Normal_vector', 'NORMAL_VECTOR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _plane4(printable):
    """
    This section defines the plane. When using this colvar, two plane
    section must be defined!
    """
    def __init__(self):
        self.Def_type = None
        """
        Specify how the plane is defined: either by 3 atoms or by a fixed
        normal vector. At least one plane must be defined through atoms.

        Available values:
            ATOMS
                Plane defined by the position of 3 atoms
            VECTOR
                Plane defined by a fixed normal vector
        """
        self.Atoms = None
        """
        Specifies the indexes of 3 atoms/points defining the plane.
        """
        self.Normal_vector = None
        """
        Alternatively to 3 atoms/points one can define one of the two, planes
        by defining its NORMAL vector.
        """
        self._name = "PLANE"
        self._keywords = [('Def_type', 'DEF_TYPE'), ('Atoms', 'ATOMS'), ('Normal_vector', 'NORMAL_VECTOR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _forces_inst1(printable):
    """
    Controls the output of the instantaneous helium forces on the solute
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each59()
        self._name = "FORCES_INST"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _ri_rpa4(printable):
    """
    Parameters influencing the RI RPA method
    """
    def __init__(self):
        self.Quadrature_points = None
        """
        Number of quadrature points for the numerical integration in the RI-
        RPA method.
        """
        self.Size_freq_integ_group = None
        """
        Group size for frequency integration, that is the number of processes
        involved in the computation of each integration point.
        SIZE_FREQ_INTEG_GROUP has to be a multiple of GROUP_SIZE in the
        WF_CORRELATION section. The default (-1) is automatic.
        """
        self.list_HF = []
        self._name = "RI_RPA"
        self._keywords = [('Quadrature_points', 'QUADRATURE_POINTS'), ('Size_freq_integ_group', 'SIZE_FREQ_INTEG_GROUP')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('HF', '_hf8')]

    def add_HF(self):
        new_section = _hf8()
        self.list_HF.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Rpa_num_quad_points(self):
        """
        See documentation for Quadrature_points
        """
        return self.Quadrature_points

    @property
    def Rpa_group_size(self):
        """
        See documentation for Size_freq_integ_group
        """
        return self.Size_freq_integ_group

    @Rpa_num_quad_points.setter
    def Rpa_num_quad_points(self, value):
        self.Quadrature_points = value

    @Rpa_group_size.setter
    def Rpa_group_size(self, value):
        self.Size_freq_integ_group = value



class _ri_rpa2(printable):
    """
    Parameters influencing the RI RPA method
    """
    def __init__(self):
        self.Quadrature_points = None
        """
        Number of quadrature points for the numerical integration in the RI-
        RPA method.
        """
        self.Size_freq_integ_group = None
        """
        Group size for frequency integration, that is the number of processes
        involved in the computation of each integration point.
        SIZE_FREQ_INTEG_GROUP has to be a multiple of GROUP_SIZE in the
        WF_CORRELATION section. The default (-1) is automatic.
        """
        self.list_HF = []
        self._name = "RI_RPA"
        self._keywords = [('Quadrature_points', 'QUADRATURE_POINTS'), ('Size_freq_integ_group', 'SIZE_FREQ_INTEG_GROUP')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('HF', '_hf4')]

    def add_HF(self):
        new_section = _hf4()
        self.list_HF.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Rpa_num_quad_points(self):
        """
        See documentation for Quadrature_points
        """
        return self.Quadrature_points

    @property
    def Rpa_group_size(self):
        """
        See documentation for Size_freq_integ_group
        """
        return self.Size_freq_integ_group

    @Rpa_num_quad_points.setter
    def Rpa_num_quad_points(self, value):
        self.Quadrature_points = value

    @Rpa_group_size.setter
    def Rpa_group_size(self, value):
        self.Size_freq_integ_group = value



class _ri_rpa3(printable):
    """
    Parameters influencing the RI RPA method
    """
    def __init__(self):
        self.Quadrature_points = None
        """
        Number of quadrature points for the numerical integration in the RI-
        RPA method.
        """
        self.Size_freq_integ_group = None
        """
        Group size for frequency integration, that is the number of processes
        involved in the computation of each integration point.
        SIZE_FREQ_INTEG_GROUP has to be a multiple of GROUP_SIZE in the
        WF_CORRELATION section. The default (-1) is automatic.
        """
        self.list_HF = []
        self._name = "RI_RPA"
        self._keywords = [('Quadrature_points', 'QUADRATURE_POINTS'), ('Size_freq_integ_group', 'SIZE_FREQ_INTEG_GROUP')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('HF', '_hf6')]

    def add_HF(self):
        new_section = _hf6()
        self.list_HF.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Rpa_num_quad_points(self):
        """
        See documentation for Quadrature_points
        """
        return self.Quadrature_points

    @property
    def Rpa_group_size(self):
        """
        See documentation for Size_freq_integ_group
        """
        return self.Size_freq_integ_group

    @Rpa_num_quad_points.setter
    def Rpa_num_quad_points(self, value):
        self.Quadrature_points = value

    @Rpa_group_size.setter
    def Rpa_group_size(self, value):
        self.Size_freq_integ_group = value



class _ri_rpa1(printable):
    """
    Parameters influencing the RI RPA method
    """
    def __init__(self):
        self.Quadrature_points = None
        """
        Number of quadrature points for the numerical integration in the RI-
        RPA method.
        """
        self.Size_freq_integ_group = None
        """
        Group size for frequency integration, that is the number of processes
        involved in the computation of each integration point.
        SIZE_FREQ_INTEG_GROUP has to be a multiple of GROUP_SIZE in the
        WF_CORRELATION section. The default (-1) is automatic.
        """
        self.list_HF = []
        self._name = "RI_RPA"
        self._keywords = [('Quadrature_points', 'QUADRATURE_POINTS'), ('Size_freq_integ_group', 'SIZE_FREQ_INTEG_GROUP')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('HF', '_hf2')]

    def add_HF(self):
        new_section = _hf2()
        self.list_HF.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Rpa_num_quad_points(self):
        """
        See documentation for Quadrature_points
        """
        return self.Quadrature_points

    @property
    def Rpa_group_size(self):
        """
        See documentation for Size_freq_integ_group
        """
        return self.Size_freq_integ_group

    @Rpa_num_quad_points.setter
    def Rpa_num_quad_points(self, value):
        self.Quadrature_points = value

    @Rpa_group_size.setter
    def Rpa_group_size(self, value):
        self.Size_freq_integ_group = value



class _molecular_states4(printable):
    """
    Controls printing of molecular states
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Cube_eval_range = None
        """
        only write cubes if the eigenvalues of the corresponding molecular
        states lie in the given interval. Default is all states.
        """
        self.list_Mark_states = []
        self.EACH = _each293()
        self.CUBES = _cubes7()
        self._name = "MOLECULAR_STATES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Cube_eval_range', 'CUBE_EVAL_RANGE')]
        self._repeated_keywords = [('Mark_states', 'MARK_STATES')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH'), ('CUBES', 'CUBES')]
        self._repeated_subsections = []

    def add_Mark_states(self, value):
        self.list_Mark_states.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _molecular_states2(printable):
    """
    Controls printing of molecular states
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Cube_eval_range = None
        """
        only write cubes if the eigenvalues of the corresponding molecular
        states lie in the given interval. Default is all states.
        """
        self.list_Mark_states = []
        self.EACH = _each172()
        self.CUBES = _cubes3()
        self._name = "MOLECULAR_STATES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Cube_eval_range', 'CUBE_EVAL_RANGE')]
        self._repeated_keywords = [('Mark_states', 'MARK_STATES')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH'), ('CUBES', 'CUBES')]
        self._repeated_subsections = []

    def add_Mark_states(self, value):
        self.list_Mark_states.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _molecular_states3(printable):
    """
    Controls printing of molecular states
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Cube_eval_range = None
        """
        only write cubes if the eigenvalues of the corresponding molecular
        states lie in the given interval. Default is all states.
        """
        self.list_Mark_states = []
        self.EACH = _each204()
        self.CUBES = _cubes5()
        self._name = "MOLECULAR_STATES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Cube_eval_range', 'CUBE_EVAL_RANGE')]
        self._repeated_keywords = [('Mark_states', 'MARK_STATES')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH'), ('CUBES', 'CUBES')]
        self._repeated_subsections = []

    def add_Mark_states(self, value):
        self.list_Mark_states.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _molecular_states1(printable):
    """
    Controls printing of molecular states
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Cube_eval_range = None
        """
        only write cubes if the eigenvalues of the corresponding molecular
        states lie in the given interval. Default is all states.
        """
        self.list_Mark_states = []
        self.EACH = _each151()
        self.CUBES = _cubes1()
        self._name = "MOLECULAR_STATES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Cube_eval_range', 'CUBE_EVAL_RANGE')]
        self._repeated_keywords = [('Mark_states', 'MARK_STATES')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH'), ('CUBES', 'CUBES')]
        self._repeated_subsections = []

    def add_Mark_states(self, value):
        self.list_Mark_states.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _xc3(printable):
    """
    parameters needed calculate the xc potential
    """
    def __init__(self):
        self.Density_cutoff = None
        """
        The cutoff on the density used by the xc calculation
        """
        self.Gradient_cutoff = None
        """
        The cutoff on the gradient of the density used by the xc calculation
        """
        self.Density_smooth_cutoff_range = None
        """
        Parameter for the smoothing procedure inxc calculation
        """
        self.Tau_cutoff = None
        """
        The cutoff on tau used by the xc calculation
        """
        self.Functional_routine = None
        """
        Select the code for xc calculation

        Available values:
            NEW
            OLD
            TEST_LSD
            DEBUG
        """
        self.XC_GRID = _xc_grid3()
        self.XC_FUNCTIONAL = _xc_functional3()
        self.list_HF = []
        self.list_WF_CORRELATION = []
        self.ADIABATIC_RESCALING = _adiabatic_rescaling3()
        self.XC_POTENTIAL = _xc_potential3()
        self.VDW_POTENTIAL = _vdw_potential3()
        self._name = "XC"
        self._keywords = [('Density_cutoff', 'DENSITY_CUTOFF'), ('Gradient_cutoff', 'GRADIENT_CUTOFF'), ('Density_smooth_cutoff_range', 'DENSITY_SMOOTH_CUTOFF_RANGE'), ('Tau_cutoff', 'TAU_CUTOFF'), ('Functional_routine', 'FUNCTIONAL_ROUTINE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('XC_GRID', 'XC_GRID'), ('XC_FUNCTIONAL', 'XC_FUNCTIONAL'), ('ADIABATIC_RESCALING', 'ADIABATIC_RESCALING'), ('XC_POTENTIAL', 'XC_POTENTIAL'), ('VDW_POTENTIAL', 'VDW_POTENTIAL')]
        self._repeated_subsections = [('HF', '_hf5'), ('WF_CORRELATION', '_wf_correlation3')]

    def add_HF(self):
        new_section = _hf5()
        self.list_HF.append(new_section)
        return new_section

    def add_WF_CORRELATION(self):
        new_section = _wf_correlation3()
        self.list_WF_CORRELATION.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _adiabatic_dynamics1(printable):
    """
    Parameters used in canonical adiabatic free energy sampling (CAFES).
    """
    def __init__(self):
        self.Temp_fast = None
        """
        Temperature in K used to control the fast degrees of freedom
        """
        self.Temp_slow = None
        """
        Temperature in K used to control the slow degrees of freedom
        """
        self.Temp_tol_fast = None
        """
        Maximum accepted temperature deviation from the expected value, for
        the fast motion.If 0, no rescaling is performed
        """
        self.Temp_tol_slow = None
        """
        Maximum accepted temperature deviation from the expected value, for
        the slow motion.If 0, no rescaling is performed
        """
        self.N_resp_fast = None
        """
        number of respa steps for fast degrees of freedom
        """
        self.THERMOSTAT_FAST = _thermostat_fast1()
        self.THERMOSTAT_SLOW = _thermostat_slow1()
        self._name = "ADIABATIC_DYNAMICS"
        self._keywords = [('Temp_fast', 'TEMP_FAST'), ('Temp_slow', 'TEMP_SLOW'), ('Temp_tol_fast', 'TEMP_TOL_FAST'), ('Temp_tol_slow', 'TEMP_TOL_SLOW'), ('N_resp_fast', 'N_RESP_FAST')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('THERMOSTAT_FAST', 'THERMOSTAT_FAST'), ('THERMOSTAT_SLOW', 'THERMOSTAT_SLOW')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _velocity10(printable):
    """
    The velocities for simple systems or the centroid mode in PI runs, xyz
    format by default
    """
    def __init__(self):
        self.Pint_unit = None
        """
        Specify the units of measurement for the velocities (currently works
        only for the path integral code). All available CP2K units can be
        used.
        """
        self.list_Default_keyword = []
        """
        The atoms velocities in xyz format. The same order as the atom's order
        is assumed.
        """
        self._name = "VELOCITY"
        self._keywords = [('Pint_unit', 'PINT_UNIT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _gapw1(printable):
    """
    Controls the printing of some gapw related information (debug).
    """
    def __init__(self):
        self.PROJECTORS = _projectors1()
        self.RHO0_INFORMATION = _rho0_information1()
        self._name = "GAPW"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROJECTORS', 'PROJECTORS'), ('RHO0_INFORMATION', 'RHO0_INFORMATION')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _rdf2(printable):
    """
    Controls the output of the helium radial distribution function
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each53()
        self._name = "RDF"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _mixed5(printable):
    """
    This section allows to use any function of the energy subsystems  in a
    mixed_env calculation as a collective variable.
    """
    def __init__(self):
        self.Energy_function = None
        """
        Specifies the functional form of the collective variable in
        mathematical notation.
        """
        self.Variables = None
        """
        Defines the variables of the functional form. To allow an efficient
        mapping the order of the energy variables will be considered identical
        to the order of the force_eval in the force_eval_order list.
        """
        self.list_Parameters = []
        self.list_Values = []
        self.list_Units = []
        self.Dx = None
        """
        Parameter used for computing the derivative with the Ridders method.
        """
        self.Error_limit = None
        """
        Checks that the error in computing the derivative is not larger than
        the value set. In case prints a warning message.
        """
        self._name = "MIXED"
        self._keywords = [('Energy_function', 'ENERGY_FUNCTION'), ('Variables', 'VARIABLES'), ('Dx', 'DX'), ('Error_limit', 'ERROR_LIMIT')]
        self._repeated_keywords = [('Parameters', 'PARAMETERS'), ('Values', 'VALUES'), ('Units', 'UNITS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Parameters(self, value):
        self.list_Parameters.append(value)

    def add_Values(self, value):
        self.list_Values.append(value)

    def add_Units(self, value):
        self.list_Units.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _mixed4(printable):
    """
    This section allows to use any function of the energy subsystems  in a
    mixed_env calculation as a collective variable.
    """
    def __init__(self):
        self.Energy_function = None
        """
        Specifies the functional form of the collective variable in
        mathematical notation.
        """
        self.Variables = None
        """
        Defines the variables of the functional form. To allow an efficient
        mapping the order of the energy variables will be considered identical
        to the order of the force_eval in the force_eval_order list.
        """
        self.list_Parameters = []
        self.list_Values = []
        self.list_Units = []
        self.Dx = None
        """
        Parameter used for computing the derivative with the Ridders method.
        """
        self.Error_limit = None
        """
        Checks that the error in computing the derivative is not larger than
        the value set. In case prints a warning message.
        """
        self._name = "MIXED"
        self._keywords = [('Energy_function', 'ENERGY_FUNCTION'), ('Variables', 'VARIABLES'), ('Dx', 'DX'), ('Error_limit', 'ERROR_LIMIT')]
        self._repeated_keywords = [('Parameters', 'PARAMETERS'), ('Values', 'VALUES'), ('Units', 'UNITS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Parameters(self, value):
        self.list_Parameters.append(value)

    def add_Values(self, value):
        self.list_Values.append(value)

    def add_Units(self, value):
        self.list_Units.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _mixed3(printable):
    """
    This section allows to use any function of the energy subsystems  in a
    mixed_env calculation as a collective variable.
    """
    def __init__(self):
        self.Energy_function = None
        """
        Specifies the functional form of the collective variable in
        mathematical notation.
        """
        self.Variables = None
        """
        Defines the variables of the functional form. To allow an efficient
        mapping the order of the energy variables will be considered identical
        to the order of the force_eval in the force_eval_order list.
        """
        self.list_Parameters = []
        self.list_Values = []
        self.list_Units = []
        self.Dx = None
        """
        Parameter used for computing the derivative with the Ridders method.
        """
        self.Error_limit = None
        """
        Checks that the error in computing the derivative is not larger than
        the value set. In case prints a warning message.
        """
        self._name = "MIXED"
        self._keywords = [('Energy_function', 'ENERGY_FUNCTION'), ('Variables', 'VARIABLES'), ('Dx', 'DX'), ('Error_limit', 'ERROR_LIMIT')]
        self._repeated_keywords = [('Parameters', 'PARAMETERS'), ('Values', 'VALUES'), ('Units', 'UNITS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Parameters(self, value):
        self.list_Parameters.append(value)

    def add_Values(self, value):
        self.list_Values.append(value)

    def add_Units(self, value):
        self.list_Units.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _mixed2(printable):
    """
    This section allows to use any function of the energy subsystems  in a
    mixed_env calculation as a collective variable.
    """
    def __init__(self):
        self.Energy_function = None
        """
        Specifies the functional form of the collective variable in
        mathematical notation.
        """
        self.Variables = None
        """
        Defines the variables of the functional form. To allow an efficient
        mapping the order of the energy variables will be considered identical
        to the order of the force_eval in the force_eval_order list.
        """
        self.list_Parameters = []
        self.list_Values = []
        self.list_Units = []
        self.Dx = None
        """
        Parameter used for computing the derivative with the Ridders method.
        """
        self.Error_limit = None
        """
        Checks that the error in computing the derivative is not larger than
        the value set. In case prints a warning message.
        """
        self._name = "MIXED"
        self._keywords = [('Energy_function', 'ENERGY_FUNCTION'), ('Variables', 'VARIABLES'), ('Dx', 'DX'), ('Error_limit', 'ERROR_LIMIT')]
        self._repeated_keywords = [('Parameters', 'PARAMETERS'), ('Values', 'VALUES'), ('Units', 'UNITS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Parameters(self, value):
        self.list_Parameters.append(value)

    def add_Values(self, value):
        self.list_Values.append(value)

    def add_Units(self, value):
        self.list_Units.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _mixed1(printable):
    """
    This section contains all information to run with a hamiltonian
    defined by a mixing of force_evals
    """
    def __init__(self):
        self.Mixing_type = None
        """
        The type of mixing to be employed

        Available values:
            LINEAR_COMBINATION
                Linear combination of force envs (support only 2 force_evals)
            MINIMUM
                Use the force env with the minimum energy (support only 2 force_evals)
            COUPLED
                Consider the force envs as a two state system with a given coupling
                matrix element (support only 2 force_evals)
            RESTRAINT
                Use the difference between the energy of the force envs as a restraint
                on the first (support only 2 force_evals)
            GENMIX
                Defines a user-driven generica coupling (support for an unlimited
                number of force_eval)
        """
        self.Group_partition = None
        """
        gives the exact number of processors for each group. If not specified
        processors allocated will be equally distributed for the specified
        subforce_eval, trying to build a number of groups equal to the number
        of subforce_eval specified.
        """
        self.Ngroups = None
        """
        Gives the wanted number of groups. If not specified the number of
        groups is set to the number of subforce_eval defined.
        """
        self.LINEAR = _linear1()
        self.COUPLING = _coupling1()
        self.RESTRAINT = _restraint7()
        self.GENERIC = _generic1()
        self.list_MAPPING = []
        self.PRINT = _print17()
        self._name = "MIXED"
        self._keywords = [('Mixing_type', 'MIXING_TYPE'), ('Group_partition', 'GROUP_PARTITION'), ('Ngroups', 'NGROUPS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('LINEAR', 'LINEAR'), ('COUPLING', 'COUPLING'), ('RESTRAINT', 'RESTRAINT'), ('GENERIC', 'GENERIC'), ('PRINT', 'PRINT')]
        self._repeated_subsections = [('MAPPING', '_mapping1')]

    def add_MAPPING(self):
        new_section = _mapping1()
        self.list_MAPPING.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Ngroup(self):
        """
        See documentation for Ngroups
        """
        return self.Ngroups

    @Ngroup.setter
    def Ngroup(self, value):
        self.Ngroups = value



class _multiple_force_evals1(printable):
    """
    Describes how to handle multiple force_evals.
    """
    def __init__(self):
        self.Force_eval_order = None
        """
        Specify the orders of the different force_eval. When using a MIXED
        force_eval this does not need to be specified in this list, because it
        that takes into account only the real energy contributions
        """
        self.Multiple_subsys = None
        """
        Specify if force_eval have different subsys. In case they share the
        same subsys, it needs to be specified only in the MIXED force_eval (if
        using MIXED) or in the force_eval corresponding to first force_eval of
        the previous order (when not using MIXED).
        """
        self._name = "MULTIPLE_FORCE_EVALS"
        self._keywords = [('Force_eval_order', 'FORCE_EVAL_ORDER'), ('Multiple_subsys', 'MULTIPLE_SUBSYS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _current_cubes1(printable):
    """
    Controls the printing of the induced current density (not working
    yet).
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Stride = None
        """
        The stride (X,Y,Z) used to write the cube file (larger values result
        in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1
        number valid for all components (not working yet).
        """
        self.Append = None
        """
        append the cube files when they already exist
        """
        self.EACH = _each297()
        self._name = "CURRENT_CUBES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Stride', 'STRIDE'), ('Append', 'APPEND')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each336(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each324(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each334(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each335(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each332(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each333(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each330(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each331(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each338(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each339(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _interaction_potential3(printable):
    """
    Parameters the interaction potential in computing the biel integrals
    """
    def __init__(self):
        self.Potential_type = None
        """
        Which interaction potential should be used (Coulomb, TShPSC operator).

        Available values:
            COULOMB
                Coulomb potential: 1/r
            TSHPSC
                TShPSC: 1/x - s/Rc  ->  for x<=Rc (1-s)/Rc - (x-Rc)/Rc^2 +
                (x-Rc)^2/Rc^3 - (2*n^2-7*n+9-4*s)*(x-Rc)^3/(Rc^4*(n^2-2*n+1)*(n-1)) +
                (6-3*s-4*n+n^2)*(x-Rc)^4/(Rc^5*(n^4-4*n^3+6*n^2-4*n+1))   -> for
                Rc<x<=n*Rc (4th order polynomial)  0  -> for x>n*Rc
        """
        self.Truncation_radius = None
        """
        Determines truncation radius for the truncated TShPSC potential. Only
        valid when doing truncated calculation
        """
        self.Tshpsc_data = None
        """
        Location of the file TShPSC.dat that contains the data for the
        evaluation of the TShPSC G0
        """
        self._name = "INTERACTION_POTENTIAL"
        self._keywords = [('Potential_type', 'POTENTIAL_TYPE'), ('Truncation_radius', 'TRUNCATION_RADIUS'), ('Tshpsc_data', 'TSHPSC_DATA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _periodic_info1(printable):
    """
    Controls the printing of information regarding the periodic boundary
    condition.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each247()
        self._name = "PERIODIC_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _scptb1(printable):
    """
    Parameters needed to set up the SCPTB methods
    """
    def __init__(self):
        self.Parameter_file_name = None
        """
        Specify file that contains the atomic parameters
        """
        self.Dispersion_parameter_file = None
        """
        Specify file that contains the atomic dispersion parameters
        """
        self.Dispersion = None
        """
        Use dispersion correction
        """
        self.Dispersion_radius = None
        """
        Define radius of dispersion interaction
        """
        self.Coordination_cutoff = None
        """
        Define cutoff for coordination number calculation
        """
        self.D3_scaling = None
        """
        Scaling parameters (s6,sr6,s8) for the D3 dispersion method,
        """
        self.Sto_ng = None
        """
        Provides the order of the Slater orbital expansion of Gaussian-Type
        Orbitals.
        """
        self.Pair_cutoff = None
        """
        Define cutoff for pair potential calculation
        """
        self.Do_ewald = None
        """
        Use Ewald type method instead of direct sum for Coulomb interaction
        """
        self.Do_scc = None
        """
        Use self consistent charge method. Can be used together with DO_SCP to
        get TB method
        """
        self.Do_scp = None
        """
        Use SCP method. Can be used to switch off SCP to get a SCC-DFTB method
        """
        self._name = "SCPTB"
        self._keywords = [('Parameter_file_name', 'PARAMETER_FILE_NAME'), ('Dispersion_parameter_file', 'DISPERSION_PARAMETER_FILE'), ('Dispersion', 'DISPERSION'), ('Dispersion_radius', 'DISPERSION_RADIUS'), ('Coordination_cutoff', 'COORDINATION_CUTOFF'), ('D3_scaling', 'D3_SCALING'), ('Sto_ng', 'STO_NG'), ('Pair_cutoff', 'PAIR_CUTOFF'), ('Do_ewald', 'DO_EWALD'), ('Do_scc', 'DO_SCC'), ('Do_scp', 'DO_SCP')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _total_numbers1(printable):
    """
    Controls the printing of the total number of atoms, kinds,...
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each338()
        self._name = "TOTAL_NUMBERS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each14(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each208(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _quadratic1(printable):
    """
    Parameters controlling the quadratic wall
    """
    def __init__(self):
        self.Direction = None
        """
        Specify the direction of the wall.

        Available values:
            WALL_PLUS
                Wall extends from the position towards larger values of COLVAR
            WALL_MINUS
                Wall extends from the position towards smaller values of COLVAR
        """
        self.K = None
        """
        Specify the value of the quadratic potential constant: K*(CV-POS)^2
        """
        self._name = "QUADRATIC"
        self._keywords = [('Direction', 'DIRECTION'), ('K', 'K')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each15(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each202(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each203(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each200(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each201(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each206(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each207(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each204(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each205(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _xc1(printable):
    """
    parameters needed calculate the xc potential
    """
    def __init__(self):
        self.Density_cutoff = None
        """
        The cutoff on the density used by the xc calculation
        """
        self.Gradient_cutoff = None
        """
        The cutoff on the gradient of the density used by the xc calculation
        """
        self.Density_smooth_cutoff_range = None
        """
        Parameter for the smoothing procedure inxc calculation
        """
        self.Tau_cutoff = None
        """
        The cutoff on tau used by the xc calculation
        """
        self.Functional_routine = None
        """
        Select the code for xc calculation

        Available values:
            NEW
            OLD
            TEST_LSD
            DEBUG
        """
        self.XC_GRID = _xc_grid1()
        self.XC_FUNCTIONAL = _xc_functional1()
        self.list_HF = []
        self.list_WF_CORRELATION = []
        self.ADIABATIC_RESCALING = _adiabatic_rescaling1()
        self.XC_POTENTIAL = _xc_potential1()
        self.VDW_POTENTIAL = _vdw_potential1()
        self._name = "XC"
        self._keywords = [('Density_cutoff', 'DENSITY_CUTOFF'), ('Gradient_cutoff', 'GRADIENT_CUTOFF'), ('Density_smooth_cutoff_range', 'DENSITY_SMOOTH_CUTOFF_RANGE'), ('Tau_cutoff', 'TAU_CUTOFF'), ('Functional_routine', 'FUNCTIONAL_ROUTINE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('XC_GRID', 'XC_GRID'), ('XC_FUNCTIONAL', 'XC_FUNCTIONAL'), ('ADIABATIC_RESCALING', 'ADIABATIC_RESCALING'), ('XC_POTENTIAL', 'XC_POTENTIAL'), ('VDW_POTENTIAL', 'VDW_POTENTIAL')]
        self._repeated_subsections = [('HF', '_hf1'), ('WF_CORRELATION', '_wf_correlation1')]

    def add_HF(self):
        new_section = _hf1()
        self.list_HF.append(new_section)
        return new_section

    def add_WF_CORRELATION(self):
        new_section = _wf_correlation1()
        self.list_WF_CORRELATION.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _xc2(printable):
    """
    parameters needed calculate the xc potential
    """
    def __init__(self):
        self.Density_cutoff = None
        """
        The cutoff on the density used by the xc calculation
        """
        self.Gradient_cutoff = None
        """
        The cutoff on the gradient of the density used by the xc calculation
        """
        self.Density_smooth_cutoff_range = None
        """
        Parameter for the smoothing procedure inxc calculation
        """
        self.Tau_cutoff = None
        """
        The cutoff on tau used by the xc calculation
        """
        self.Functional_routine = None
        """
        Select the code for xc calculation

        Available values:
            NEW
            OLD
            TEST_LSD
            DEBUG
        """
        self.XC_GRID = _xc_grid2()
        self.XC_FUNCTIONAL = _xc_functional2()
        self.list_HF = []
        self.list_WF_CORRELATION = []
        self.ADIABATIC_RESCALING = _adiabatic_rescaling2()
        self.XC_POTENTIAL = _xc_potential2()
        self.VDW_POTENTIAL = _vdw_potential2()
        self._name = "XC"
        self._keywords = [('Density_cutoff', 'DENSITY_CUTOFF'), ('Gradient_cutoff', 'GRADIENT_CUTOFF'), ('Density_smooth_cutoff_range', 'DENSITY_SMOOTH_CUTOFF_RANGE'), ('Tau_cutoff', 'TAU_CUTOFF'), ('Functional_routine', 'FUNCTIONAL_ROUTINE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('XC_GRID', 'XC_GRID'), ('XC_FUNCTIONAL', 'XC_FUNCTIONAL'), ('ADIABATIC_RESCALING', 'ADIABATIC_RESCALING'), ('XC_POTENTIAL', 'XC_POTENTIAL'), ('VDW_POTENTIAL', 'VDW_POTENTIAL')]
        self._repeated_subsections = [('HF', '_hf3'), ('WF_CORRELATION', '_wf_correlation2')]

    def add_HF(self):
        new_section = _hf3()
        self.list_HF.append(new_section)
        return new_section

    def add_WF_CORRELATION(self):
        new_section = _wf_correlation2()
        self.list_WF_CORRELATION.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _point66(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _xc4(printable):
    """
    parameters needed calculate the xc potential
    """
    def __init__(self):
        self.Density_cutoff = None
        """
        The cutoff on the density used by the xc calculation
        """
        self.Gradient_cutoff = None
        """
        The cutoff on the gradient of the density used by the xc calculation
        """
        self.Density_smooth_cutoff_range = None
        """
        Parameter for the smoothing procedure inxc calculation
        """
        self.Tau_cutoff = None
        """
        The cutoff on tau used by the xc calculation
        """
        self.Functional_routine = None
        """
        Select the code for xc calculation

        Available values:
            NEW
            OLD
            TEST_LSD
            DEBUG
        """
        self.XC_GRID = _xc_grid4()
        self.XC_FUNCTIONAL = _xc_functional4()
        self.list_HF = []
        self.list_WF_CORRELATION = []
        self.ADIABATIC_RESCALING = _adiabatic_rescaling4()
        self.XC_POTENTIAL = _xc_potential4()
        self.VDW_POTENTIAL = _vdw_potential4()
        self._name = "XC"
        self._keywords = [('Density_cutoff', 'DENSITY_CUTOFF'), ('Gradient_cutoff', 'GRADIENT_CUTOFF'), ('Density_smooth_cutoff_range', 'DENSITY_SMOOTH_CUTOFF_RANGE'), ('Tau_cutoff', 'TAU_CUTOFF'), ('Functional_routine', 'FUNCTIONAL_ROUTINE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('XC_GRID', 'XC_GRID'), ('XC_FUNCTIONAL', 'XC_FUNCTIONAL'), ('ADIABATIC_RESCALING', 'ADIABATIC_RESCALING'), ('XC_POTENTIAL', 'XC_POTENTIAL'), ('VDW_POTENTIAL', 'VDW_POTENTIAL')]
        self._repeated_subsections = [('HF', '_hf7'), ('WF_CORRELATION', '_wf_correlation4')]

    def add_HF(self):
        new_section = _hf7()
        self.list_HF.append(new_section)
        return new_section

    def add_WF_CORRELATION(self):
        new_section = _wf_correlation4()
        self.list_WF_CORRELATION.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _each10(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _point60(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _conditioned_distance4(printable):
    """
    Section to define the conditioned distance as a collective variable.
    """
    def __init__(self):
        self.list_Atoms_distance = []
        self.list_Atoms_from = []
        self.list_Points_from = self.list_Atoms_from
        self.list_Atoms_to = []
        self.list_Points_to = self.list_Atoms_to
        self.list_Kinds_from = []
        self.list_Kinds_to = []
        self.R0 = None
        """
        Specify the R0 parameter in the coordination function.
        """
        self.Nn = None
        """
        Sets the value of the numerator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Nd = None
        """
        Sets the value of the denominator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Lambda = None
        """
        Specify the lambda parameter at the exponent of the conditioned
        distance function.
        """
        self.list_POINT = []
        self._name = "CONDITIONED_DISTANCE"
        self._keywords = [('R0', 'R0'), ('Nn', 'NN'), ('Nd', 'ND'), ('Lambda', 'LAMBDA')]
        self._repeated_keywords = [('Atoms_distance', 'ATOMS_DISTANCE'), ('Atoms_from', 'ATOMS_FROM'), ('Atoms_to', 'ATOMS_TO'), ('Kinds_from', 'KINDS_FROM'), ('Kinds_to', 'KINDS_TO')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point72')]

    def add_POINT(self):
        new_section = _point72()
        self.list_POINT.append(new_section)
        return new_section

    def add_Atoms_distance(self, value):
        self.list_Atoms_distance.append(value)

    def add_Atoms_from(self, value):
        self.list_Atoms_from.append(value)

    def add_Atoms_to(self, value):
        self.list_Atoms_to.append(value)

    def add_Kinds_from(self, value):
        self.list_Kinds_from.append(value)

    def add_Kinds_to(self, value):
        self.list_Kinds_to.append(value)

    def add_Points_from(self, value):
        self.list_KINDS_TO.append(value)

    def add_Points_to(self, value):
        self.list_KINDS_TO.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def R_0(self):
        """
        See documentation for R0
        """
        return self.R0

    @property
    def Expon_numerator(self):
        """
        See documentation for Nn
        """
        return self.Nn

    @property
    def Expon_denominator(self):
        """
        See documentation for Nd
        """
        return self.Nd

    @R_0.setter
    def R_0(self, value):
        self.R0 = value

    @Expon_numerator.setter
    def Expon_numerator(self, value):
        self.Nn = value

    @Expon_denominator.setter
    def Expon_denominator(self, value):
        self.Nd = value



class _conditioned_distance1(printable):
    """
    Section to define the conditioned distance as a collective variable.
    """
    def __init__(self):
        self.list_Atoms_distance = []
        self.list_Atoms_from = []
        self.list_Points_from = self.list_Atoms_from
        self.list_Atoms_to = []
        self.list_Points_to = self.list_Atoms_to
        self.list_Kinds_from = []
        self.list_Kinds_to = []
        self.R0 = None
        """
        Specify the R0 parameter in the coordination function.
        """
        self.Nn = None
        """
        Sets the value of the numerator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Nd = None
        """
        Sets the value of the denominator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Lambda = None
        """
        Specify the lambda parameter at the exponent of the conditioned
        distance function.
        """
        self.list_POINT = []
        self._name = "CONDITIONED_DISTANCE"
        self._keywords = [('R0', 'R0'), ('Nn', 'NN'), ('Nd', 'ND'), ('Lambda', 'LAMBDA')]
        self._repeated_keywords = [('Atoms_distance', 'ATOMS_DISTANCE'), ('Atoms_from', 'ATOMS_FROM'), ('Atoms_to', 'ATOMS_TO'), ('Kinds_from', 'KINDS_FROM'), ('Kinds_to', 'KINDS_TO')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point18')]

    def add_POINT(self):
        new_section = _point18()
        self.list_POINT.append(new_section)
        return new_section

    def add_Atoms_distance(self, value):
        self.list_Atoms_distance.append(value)

    def add_Atoms_from(self, value):
        self.list_Atoms_from.append(value)

    def add_Atoms_to(self, value):
        self.list_Atoms_to.append(value)

    def add_Kinds_from(self, value):
        self.list_Kinds_from.append(value)

    def add_Kinds_to(self, value):
        self.list_Kinds_to.append(value)

    def add_Points_from(self, value):
        self.list_KINDS_TO.append(value)

    def add_Points_to(self, value):
        self.list_KINDS_TO.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def R_0(self):
        """
        See documentation for R0
        """
        return self.R0

    @property
    def Expon_numerator(self):
        """
        See documentation for Nn
        """
        return self.Nn

    @property
    def Expon_denominator(self):
        """
        See documentation for Nd
        """
        return self.Nd

    @R_0.setter
    def R_0(self, value):
        self.R0 = value

    @Expon_numerator.setter
    def Expon_numerator(self, value):
        self.Nn = value

    @Expon_denominator.setter
    def Expon_denominator(self, value):
        self.Nd = value



class _each12(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _conditioned_distance3(printable):
    """
    Section to define the conditioned distance as a collective variable.
    """
    def __init__(self):
        self.list_Atoms_distance = []
        self.list_Atoms_from = []
        self.list_Points_from = self.list_Atoms_from
        self.list_Atoms_to = []
        self.list_Points_to = self.list_Atoms_to
        self.list_Kinds_from = []
        self.list_Kinds_to = []
        self.R0 = None
        """
        Specify the R0 parameter in the coordination function.
        """
        self.Nn = None
        """
        Sets the value of the numerator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Nd = None
        """
        Sets the value of the denominator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Lambda = None
        """
        Specify the lambda parameter at the exponent of the conditioned
        distance function.
        """
        self.list_POINT = []
        self._name = "CONDITIONED_DISTANCE"
        self._keywords = [('R0', 'R0'), ('Nn', 'NN'), ('Nd', 'ND'), ('Lambda', 'LAMBDA')]
        self._repeated_keywords = [('Atoms_distance', 'ATOMS_DISTANCE'), ('Atoms_from', 'ATOMS_FROM'), ('Atoms_to', 'ATOMS_TO'), ('Kinds_from', 'KINDS_FROM'), ('Kinds_to', 'KINDS_TO')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point54')]

    def add_POINT(self):
        new_section = _point54()
        self.list_POINT.append(new_section)
        return new_section

    def add_Atoms_distance(self, value):
        self.list_Atoms_distance.append(value)

    def add_Atoms_from(self, value):
        self.list_Atoms_from.append(value)

    def add_Atoms_to(self, value):
        self.list_Atoms_to.append(value)

    def add_Kinds_from(self, value):
        self.list_Kinds_from.append(value)

    def add_Kinds_to(self, value):
        self.list_Kinds_to.append(value)

    def add_Points_from(self, value):
        self.list_KINDS_TO.append(value)

    def add_Points_to(self, value):
        self.list_KINDS_TO.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def R_0(self):
        """
        See documentation for R0
        """
        return self.R0

    @property
    def Expon_numerator(self):
        """
        See documentation for Nn
        """
        return self.Nn

    @property
    def Expon_denominator(self):
        """
        See documentation for Nd
        """
        return self.Nd

    @R_0.setter
    def R_0(self, value):
        self.R0 = value

    @Expon_numerator.setter
    def Expon_numerator(self, value):
        self.Nn = value

    @Expon_denominator.setter
    def Expon_denominator(self, value):
        self.Nd = value



class _conditioned_distance2(printable):
    """
    Section to define the conditioned distance as a collective variable.
    """
    def __init__(self):
        self.list_Atoms_distance = []
        self.list_Atoms_from = []
        self.list_Points_from = self.list_Atoms_from
        self.list_Atoms_to = []
        self.list_Points_to = self.list_Atoms_to
        self.list_Kinds_from = []
        self.list_Kinds_to = []
        self.R0 = None
        """
        Specify the R0 parameter in the coordination function.
        """
        self.Nn = None
        """
        Sets the value of the numerator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Nd = None
        """
        Sets the value of the denominator of the exponential factorin the
        coordination FUNCTION.
        """
        self.Lambda = None
        """
        Specify the lambda parameter at the exponent of the conditioned
        distance function.
        """
        self.list_POINT = []
        self._name = "CONDITIONED_DISTANCE"
        self._keywords = [('R0', 'R0'), ('Nn', 'NN'), ('Nd', 'ND'), ('Lambda', 'LAMBDA')]
        self._repeated_keywords = [('Atoms_distance', 'ATOMS_DISTANCE'), ('Atoms_from', 'ATOMS_FROM'), ('Atoms_to', 'ATOMS_TO'), ('Kinds_from', 'KINDS_FROM'), ('Kinds_to', 'KINDS_TO')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point36')]

    def add_POINT(self):
        new_section = _point36()
        self.list_POINT.append(new_section)
        return new_section

    def add_Atoms_distance(self, value):
        self.list_Atoms_distance.append(value)

    def add_Atoms_from(self, value):
        self.list_Atoms_from.append(value)

    def add_Atoms_to(self, value):
        self.list_Atoms_to.append(value)

    def add_Kinds_from(self, value):
        self.list_Kinds_from.append(value)

    def add_Kinds_to(self, value):
        self.list_Kinds_to.append(value)

    def add_Points_from(self, value):
        self.list_KINDS_TO.append(value)

    def add_Points_to(self, value):
        self.list_KINDS_TO.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def R_0(self):
        """
        See documentation for R0
        """
        return self.R0

    @property
    def Expon_numerator(self):
        """
        See documentation for Nn
        """
        return self.Nn

    @property
    def Expon_denominator(self):
        """
        See documentation for Nd
        """
        return self.Nd

    @R_0.setter
    def R_0(self, value):
        self.R0 = value

    @Expon_numerator.setter
    def Expon_numerator(self, value):
        self.Nn = value

    @Expon_denominator.setter
    def Expon_denominator(self, value):
        self.Nd = value



class _memory6(printable):
    """
    Sets up memory parameters for the storage of the ERI's if requested
    """
    def __init__(self):
        self.Eps_storage_scaling = None
        """
        Scaling factor to scale eps_schwarz. Storage threshold for compression
        will be EPS_SCHWARZ*EPS_STORAGE_SCALING.
        """
        self.Max_memory = None
        """
        Defines the maximum amount of memory [MB] to be consumed by the full
        HFX module. All temporary buffers and helper arrays are subtracted
        from this number. What remains will be used for storage of integrals.
        NOTE: This number is assumed to represent the memory available to one
        MPI process. When running a threaded version, cp2k automatically takes
        care of distributing the memory among all involved sub-processes.
        """
        self.Storage_location = None
        """
        Loaction where ERI's are stored if MAX_DISK_SPACE /=0 Expects a path
        to a directory.
        """
        self.Max_disk_space = None
        """
        Defines the maximum amount of disk space [MB] used to store
        precomputed compressed four-center integrals. If 0, nothing is stored
        to disk
        """
        self.Treat_forces_in_core = None
        """
        Determines whether the derivative ERI's should be stored to RAM or
        not. Only meaningful when performing Ehrenfest MD. Memory usage is
        defined via MAX_MEMORY, i.e. the memory is shared wit the energy
        ERI's.
        """
        self._name = "MEMORY"
        self._keywords = [('Eps_storage_scaling', 'EPS_STORAGE_SCALING'), ('Max_memory', 'MAX_MEMORY'), ('Storage_location', 'STORAGE_LOCATION'), ('Max_disk_space', 'MAX_DISK_SPACE'), ('Treat_forces_in_core', 'TREAT_FORCES_IN_CORE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Eps_storage(self):
        """
        See documentation for Eps_storage_scaling
        """
        return self.Eps_storage_scaling

    @Eps_storage.setter
    def Eps_storage(self, value):
        self.Eps_storage_scaling = value



class _memory7(printable):
    """
    Sets up memory parameters for the storage of the ERI's if requested
    """
    def __init__(self):
        self.Eps_storage_scaling = None
        """
        Scaling factor to scale eps_schwarz. Storage threshold for compression
        will be EPS_SCHWARZ*EPS_STORAGE_SCALING.
        """
        self.Max_memory = None
        """
        Defines the maximum amount of memory [MB] to be consumed by the full
        HFX module. All temporary buffers and helper arrays are subtracted
        from this number. What remains will be used for storage of integrals.
        NOTE: This number is assumed to represent the memory available to one
        MPI process. When running a threaded version, cp2k automatically takes
        care of distributing the memory among all involved sub-processes.
        """
        self.Storage_location = None
        """
        Loaction where ERI's are stored if MAX_DISK_SPACE /=0 Expects a path
        to a directory.
        """
        self.Max_disk_space = None
        """
        Defines the maximum amount of disk space [MB] used to store
        precomputed compressed four-center integrals. If 0, nothing is stored
        to disk
        """
        self.Treat_forces_in_core = None
        """
        Determines whether the derivative ERI's should be stored to RAM or
        not. Only meaningful when performing Ehrenfest MD. Memory usage is
        defined via MAX_MEMORY, i.e. the memory is shared wit the energy
        ERI's.
        """
        self._name = "MEMORY"
        self._keywords = [('Eps_storage_scaling', 'EPS_STORAGE_SCALING'), ('Max_memory', 'MAX_MEMORY'), ('Storage_location', 'STORAGE_LOCATION'), ('Max_disk_space', 'MAX_DISK_SPACE'), ('Treat_forces_in_core', 'TREAT_FORCES_IN_CORE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Eps_storage(self):
        """
        See documentation for Eps_storage_scaling
        """
        return self.Eps_storage_scaling

    @Eps_storage.setter
    def Eps_storage(self, value):
        self.Eps_storage_scaling = value



class _memory4(printable):
    """
    Sets up memory parameters for the storage of the ERI's if requested
    """
    def __init__(self):
        self.Eps_storage_scaling = None
        """
        Scaling factor to scale eps_schwarz. Storage threshold for compression
        will be EPS_SCHWARZ*EPS_STORAGE_SCALING.
        """
        self.Max_memory = None
        """
        Defines the maximum amount of memory [MB] to be consumed by the full
        HFX module. All temporary buffers and helper arrays are subtracted
        from this number. What remains will be used for storage of integrals.
        NOTE: This number is assumed to represent the memory available to one
        MPI process. When running a threaded version, cp2k automatically takes
        care of distributing the memory among all involved sub-processes.
        """
        self.Storage_location = None
        """
        Loaction where ERI's are stored if MAX_DISK_SPACE /=0 Expects a path
        to a directory.
        """
        self.Max_disk_space = None
        """
        Defines the maximum amount of disk space [MB] used to store
        precomputed compressed four-center integrals. If 0, nothing is stored
        to disk
        """
        self.Treat_forces_in_core = None
        """
        Determines whether the derivative ERI's should be stored to RAM or
        not. Only meaningful when performing Ehrenfest MD. Memory usage is
        defined via MAX_MEMORY, i.e. the memory is shared wit the energy
        ERI's.
        """
        self._name = "MEMORY"
        self._keywords = [('Eps_storage_scaling', 'EPS_STORAGE_SCALING'), ('Max_memory', 'MAX_MEMORY'), ('Storage_location', 'STORAGE_LOCATION'), ('Max_disk_space', 'MAX_DISK_SPACE'), ('Treat_forces_in_core', 'TREAT_FORCES_IN_CORE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Eps_storage(self):
        """
        See documentation for Eps_storage_scaling
        """
        return self.Eps_storage_scaling

    @Eps_storage.setter
    def Eps_storage(self, value):
        self.Eps_storage_scaling = value



class _point62(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _memory2(printable):
    """
    Sets up memory parameters for the storage of the ERI's if requested
    """
    def __init__(self):
        self.Eps_storage_scaling = None
        """
        Scaling factor to scale eps_schwarz. Storage threshold for compression
        will be EPS_SCHWARZ*EPS_STORAGE_SCALING.
        """
        self.Max_memory = None
        """
        Defines the maximum amount of memory [MB] to be consumed by the full
        HFX module. All temporary buffers and helper arrays are subtracted
        from this number. What remains will be used for storage of integrals.
        NOTE: This number is assumed to represent the memory available to one
        MPI process. When running a threaded version, cp2k automatically takes
        care of distributing the memory among all involved sub-processes.
        """
        self.Storage_location = None
        """
        Loaction where ERI's are stored if MAX_DISK_SPACE /=0 Expects a path
        to a directory.
        """
        self.Max_disk_space = None
        """
        Defines the maximum amount of disk space [MB] used to store
        precomputed compressed four-center integrals. If 0, nothing is stored
        to disk
        """
        self.Treat_forces_in_core = None
        """
        Determines whether the derivative ERI's should be stored to RAM or
        not. Only meaningful when performing Ehrenfest MD. Memory usage is
        defined via MAX_MEMORY, i.e. the memory is shared wit the energy
        ERI's.
        """
        self._name = "MEMORY"
        self._keywords = [('Eps_storage_scaling', 'EPS_STORAGE_SCALING'), ('Max_memory', 'MAX_MEMORY'), ('Storage_location', 'STORAGE_LOCATION'), ('Max_disk_space', 'MAX_DISK_SPACE'), ('Treat_forces_in_core', 'TREAT_FORCES_IN_CORE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Eps_storage(self):
        """
        See documentation for Eps_storage_scaling
        """
        return self.Eps_storage_scaling

    @Eps_storage.setter
    def Eps_storage(self, value):
        self.Eps_storage_scaling = value



class _memory3(printable):
    """
    Sets up memory parameters for the storage of the ERI's if requested
    """
    def __init__(self):
        self.Eps_storage_scaling = None
        """
        Scaling factor to scale eps_schwarz. Storage threshold for compression
        will be EPS_SCHWARZ*EPS_STORAGE_SCALING.
        """
        self.Max_memory = None
        """
        Defines the maximum amount of memory [MB] to be consumed by the full
        HFX module. All temporary buffers and helper arrays are subtracted
        from this number. What remains will be used for storage of integrals.
        NOTE: This number is assumed to represent the memory available to one
        MPI process. When running a threaded version, cp2k automatically takes
        care of distributing the memory among all involved sub-processes.
        """
        self.Storage_location = None
        """
        Loaction where ERI's are stored if MAX_DISK_SPACE /=0 Expects a path
        to a directory.
        """
        self.Max_disk_space = None
        """
        Defines the maximum amount of disk space [MB] used to store
        precomputed compressed four-center integrals. If 0, nothing is stored
        to disk
        """
        self.Treat_forces_in_core = None
        """
        Determines whether the derivative ERI's should be stored to RAM or
        not. Only meaningful when performing Ehrenfest MD. Memory usage is
        defined via MAX_MEMORY, i.e. the memory is shared wit the energy
        ERI's.
        """
        self._name = "MEMORY"
        self._keywords = [('Eps_storage_scaling', 'EPS_STORAGE_SCALING'), ('Max_memory', 'MAX_MEMORY'), ('Storage_location', 'STORAGE_LOCATION'), ('Max_disk_space', 'MAX_DISK_SPACE'), ('Treat_forces_in_core', 'TREAT_FORCES_IN_CORE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Eps_storage(self):
        """
        See documentation for Eps_storage_scaling
        """
        return self.Eps_storage_scaling

    @Eps_storage.setter
    def Eps_storage(self, value):
        self.Eps_storage_scaling = value



class _memory1(printable):
    """
    Sets up memory parameters for the storage of the integrals
    """
    def __init__(self):
        self.Eps_storage = None
        """
        Storage threshold for compression is EPS_STORAGE
        """
        self.Max_memory = None
        """
        Defines the maximum amount of memory [MB] used to store precomputed
        (possibly compressed) two-electron two-center integrals
        """
        self.Compress = None
        """
        Enables the compression of the integrals in memory.
        """
        self._name = "MEMORY"
        self._keywords = [('Eps_storage', 'EPS_STORAGE'), ('Max_memory', 'MAX_MEMORY'), ('Compress', 'COMPRESS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _virtual_site1(printable):
    """
    This section is used to set a virtual interaction-site constraint.
    """
    def __init__(self):
        self.Molecule = None
        """
        Specifies the molecule number on which constraint will be applied.
        MOLECULE and MOLNAME keyword exclude themself mutually.
        """
        self.Molname = None
        """
        Specifies the name of the molecule on which the constraint will be
        applied.
        """
        self.Intermolecular = None
        """
        Specify if the constraint/restraint is intermolecular.
        """
        self.Atoms = None
        """
        Atoms' index on which apply the constraint (v i j k), first is virtual
        site
        """
        self.Parameters = None
        """
        The constrained paramters' values to construct virtual
        site.r_v=a*r_ij+b*r_kj
        """
        self.Exclude_qm = None
        """
        Does not apply the constraint to the QM region within a QM/MM
        calculation
        """
        self.Exclude_mm = None
        """
        Does not apply the constraint to the MM region within a QM/MM
        calculation
        """
        self.RESTRAINT = _restraint4()
        self._name = "VIRTUAL_SITE"
        self._keywords = [('Molecule', 'MOLECULE'), ('Molname', 'MOLNAME'), ('Intermolecular', 'INTERMOLECULAR'), ('Atoms', 'ATOMS'), ('Parameters', 'PARAMETERS'), ('Exclude_qm', 'EXCLUDE_QM'), ('Exclude_mm', 'EXCLUDE_MM')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('RESTRAINT', 'RESTRAINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Mol(self):
        """
        See documentation for Molecule
        """
        return self.Molecule

    @property
    def Segname(self):
        """
        See documentation for Molname
        """
        return self.Molname

    @Mol.setter
    def Mol(self, value):
        self.Molecule = value

    @Segname.setter
    def Segname(self, value):
        self.Molname = value



class _r_ldos1(printable):
    """
    Controls the printing of local PDOS, projected on 3D volume in real
    space, the volume is defined in terms of position with respect to
    atoms in the lists
    """
    def __init__(self):
        self.list_List = []
        self.Xrange = None
        """
        range of positions in Cartesian direction x: all grid points within
        this range from at least one atom of the list are considered
        """
        self.Yrange = None
        """
        range of positions in Cartesian direction y: all grid points within
        this range from at least one atom of the list are considered
        """
        self.Zrange = None
        """
        range of positions in Cartesian direction z: all grid points within
        this range from at least one atom of the list are considered
        """
        self.Erange = None
        """
        only project states with the eigenvalues in the given interval.
        Default is all states.
        """
        self._name = "R_LDOS"
        self._keywords = [('Xrange', 'XRANGE'), ('Yrange', 'YRANGE'), ('Zrange', 'ZRANGE'), ('Erange', 'ERANGE')]
        self._repeated_keywords = [('List', 'LIST')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_List(self, value):
        self.list_List.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _shielding_tensor1(printable):
    """
    Controls the printing of the chemical shift
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Atoms_lu_bounds = None
        """
        The lower and upper atomic index for which the tensor is printed
        """
        self.list_Atoms_list = []
        self.EACH = _each302()
        self._name = "SHIELDING_TENSOR"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Atoms_lu_bounds', 'ATOMS_LU_BOUNDS')]
        self._repeated_keywords = [('Atoms_list', 'ATOMS_LIST')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def add_Atoms_list(self, value):
        self.list_Atoms_list.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Atoms_lu(self):
        """
        See documentation for Atoms_lu_bounds
        """
        return self.Atoms_lu_bounds

    @Atoms_lu.setter
    def Atoms_lu(self, value):
        self.Atoms_lu_bounds = value



class _ext_lagrange_ss01(printable):
    """
    Colvar position within an extended Lagrangian formalism.Used for
    RESTART.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specified the positions
        """
        self._name = "EXT_LAGRANGE_SS0"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _rot_opt1(printable):
    """
    This section sets the environment for the optimization of the rotation
    of the Dimer.
    """
    def __init__(self):
        self.Optimizer = None
        """
        Specify which method to use to perform a geometry optimization.

        Available values:
            BFGS
                Most efficient minimizer, but only for 'small' systems, as it relies
                on diagonalization of a full Hessian matrix
            LBFGS
                Limit memory variant of the above, can also be applied to large
                systems, not as well fine-tuned
            CG
                conjugate gradients, robust minimizer (depending on the line search)
                also OK for large systems
        """
        self.Max_iter = None
        """
        Specifies the maximum number of geometry optimization steps. One step
        might imply several force evaluations for the CG and LBFGS optimizers.
        """
        self.Max_dr = None
        """
        Convergence criterium for the maximum geometry change between the
        current and the last optimizer iteration.
        """
        self.Max_force = None
        """
        Convergence criterium for the maximum force component of the current
        configuration.
        """
        self.Rms_dr = None
        """
        Convergence criterium for the root mean square (RMS) geometry change
        between the current and the last optimizer iteration.
        """
        self.Rms_force = None
        """
        Convergence criterium for the root mean square (RMS) force of the
        current configuration.
        """
        self.Step_start_val = None
        """
        The starting step value for the ROT_OPT module.
        """
        self.LBFGS = _lbfgs2()
        self.CG = _cg2()
        self.BFGS = _bfgs2()
        self.list_PRINT = []
        self._name = "ROT_OPT"
        self._keywords = [('Optimizer', 'OPTIMIZER'), ('Max_iter', 'MAX_ITER'), ('Max_dr', 'MAX_DR'), ('Max_force', 'MAX_FORCE'), ('Rms_dr', 'RMS_DR'), ('Rms_force', 'RMS_FORCE'), ('Step_start_val', 'STEP_START_VAL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('LBFGS', 'LBFGS'), ('CG', 'CG'), ('BFGS', 'BFGS')]
        self._repeated_subsections = [('PRINT', '_print2')]

    def add_PRINT(self):
        new_section = _print2()
        self.list_PRINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Minimizer(self):
        """
        See documentation for Optimizer
        """
        return self.Optimizer

    @Minimizer.setter
    def Minimizer(self, value):
        self.Optimizer = value



class _each18(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _generic1(printable):
    """
    User driven coupling between two or more force_eval.
    """
    def __init__(self):
        self.Mixing_function = None
        """
        Specifies the mixing functional form in mathematical notation.
        """
        self.Variables = None
        """
        Defines the variables of the functional form. To allow an efficient
        mapping the order of the energy variables will be considered identical
        to the order of the force_eval in the force_eval_order list.
        """
        self.list_Parameters = []
        self.list_Values = []
        self.list_Units = []
        self.Dx = None
        """
        Parameter used for computing the derivative with the Ridders method.
        """
        self.Error_limit = None
        """
        Checks that the error in computing the derivative is not larger than
        the value set. In case prints a warning message.
        """
        self._name = "GENERIC"
        self._keywords = [('Mixing_function', 'MIXING_FUNCTION'), ('Variables', 'VARIABLES'), ('Dx', 'DX'), ('Error_limit', 'ERROR_LIMIT')]
        self._repeated_keywords = [('Parameters', 'PARAMETERS'), ('Values', 'VALUES'), ('Units', 'UNITS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Parameters(self, value):
        self.list_Parameters.append(value)

    def add_Values(self, value):
        self.list_Values.append(value)

    def add_Units(self, value):
        self.list_Units.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point68(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _each118(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each119(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each116(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each117(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each114(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each115(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each112(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each113(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each110(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each111(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _distribution1d1(printable):
    """
    Each node prints out its distribution info ...
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each341()
        self._name = "DISTRIBUTION1D"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _vwn1(printable):
    """
    Uses the VWN functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_c = None
        """
        scales the correlation part of the functional
        """
        self.Functional_type = None
        """
        Which version of the VWN functional should be used

        Available values:
            VWN5
                This is the recommended (correct) version of the VWN functional
            VWN3
                This version is the default in Gaussian, but not recommended.Notice
                that it is also employed in Gaussian's default version of B3LYP
        """
        self._name = "VWN"
        self._keywords = [('Scale_c', 'SCALE_C'), ('Functional_type', 'FUNCTIONAL_TYPE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _vwn3(printable):
    """
    Uses the VWN functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_c = None
        """
        scales the correlation part of the functional
        """
        self.Functional_type = None
        """
        Which version of the VWN functional should be used

        Available values:
            VWN5
                This is the recommended (correct) version of the VWN functional
            VWN3
                This version is the default in Gaussian, but not recommended.Notice
                that it is also employed in Gaussian's default version of B3LYP
        """
        self._name = "VWN"
        self._keywords = [('Scale_c', 'SCALE_C'), ('Functional_type', 'FUNCTIONAL_TYPE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _vwn2(printable):
    """
    Uses the VWN functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_c = None
        """
        scales the correlation part of the functional
        """
        self.Functional_type = None
        """
        Which version of the VWN functional should be used

        Available values:
            VWN5
                This is the recommended (correct) version of the VWN functional
            VWN3
                This version is the default in Gaussian, but not recommended.Notice
                that it is also employed in Gaussian's default version of B3LYP
        """
        self._name = "VWN"
        self._keywords = [('Scale_c', 'SCALE_C'), ('Functional_type', 'FUNCTIONAL_TYPE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _vwn4(printable):
    """
    Uses the VWN functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_c = None
        """
        scales the correlation part of the functional
        """
        self.Functional_type = None
        """
        Which version of the VWN functional should be used

        Available values:
            VWN5
                This is the recommended (correct) version of the VWN functional
            VWN3
                This version is the default in Gaussian, but not recommended.Notice
                that it is also employed in Gaussian's default version of B3LYP
        """
        self._name = "VWN"
        self._keywords = [('Scale_c', 'SCALE_C'), ('Functional_type', 'FUNCTIONAL_TYPE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _hbonds1(printable):
    """
    This section is used to set bonds constraints involving Hydrogen atoms
    """
    def __init__(self):
        self.Atom_type = None
        """
        Defines the atoms' type forming a bond with an hydrogen. If not
        specified  the default bond value of the first molecule is used as
        constraint target
        """
        self.Molecule = None
        """
        Specifies the indexes of the molecule kind (in input file order)on
        which the constraint will be applied. MOLECULE and MOLNAME keyword
        exclude themself mutually.
        """
        self.Molname = None
        """
        Specifies the names of the molecule on which the constraint will be
        applied.
        """
        self.Exclude_qm = None
        """
        Does not shake HBONDS in the QM region within a QM/MM calculation
        """
        self.Exclude_mm = None
        """
        Does not shake HBONDS in the MM region within a QM/MM calculation
        """
        self.Targets = None
        """
        The constrained distances' values  for the types defines in ATOM_TYPE.
        """
        self.RESTRAINT = _restraint1()
        self._name = "HBONDS"
        self._keywords = [('Atom_type', 'ATOM_TYPE'), ('Molecule', 'MOLECULE'), ('Molname', 'MOLNAME'), ('Exclude_qm', 'EXCLUDE_QM'), ('Exclude_mm', 'EXCLUDE_MM'), ('Targets', 'TARGETS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('RESTRAINT', 'RESTRAINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Segname(self):
        """
        See documentation for Molname
        """
        return self.Molname

    @Segname.setter
    def Segname(self, value):
        self.Molname = value



class _ewald2(printable):
    """
    Ewald parameters controlling electrostatic only for CLASSICAL MM.
    """
    def __init__(self):
        self.Ewald_type = None
        """
        The type of ewald you want to perform. NONE standard real-space
        coulomb potential is computed together with the non-bonded
        contributions. EWALD is the standard non-fft based ewald. SPME is the
        smooth particle mesh using beta-Euler splines (recommended). PME is
        the particle mesh using fft interpolation.

        Available values:
            NONE
            EWALD
            PME
            SPME
        """
        self.Ewald_accuracy = None
        """
        Expected accuracy in the Ewald sum. This number affects only the
        calculation of the cutoff for the real-space term of the ewald
        summation (EWALD|PME|SPME) as well as the construction of the neighbor
        lists (if the cutoff for non-bonded terms is smaller than the value
        employed to compute the EWALD real-space term). This keyword has no
        effect on the reciprocal space term (which can be tuned
        independently).
        """
        self.Rcut = None
        """
        Explicitly provide the real-space cutoff of the ewald summation
        (EWALD|PME|SPME). If present, overwrites the estimate of
        EWALD_ACCURACY and may affect the construction of the neighbor lists
        for non-bonded terms (in FIST), if the value specified is larger than
        the cutoff for non-bonded interactions.
        """
        self.Alpha = None
        """
        alpha parameter associated with Ewald (EWALD|PME|SPME). Recommended
        for small systems is is alpha = 3.5 / r_cut. Tuning alpha, r_cut and
        gmax is needed to obtain O(N**1.5) scaling for ewald.
        """
        self.Gmax = None
        """
        number of grid points (SPME and EWALD). If a single number is
        specified,the same number of points is used for all three directions
        on the grid.If three numbers are given, each direction can have a
        different number of points.The number of points needs to be FFTable
        (which depends on the library used) and odd for EWALD.The optimal
        number depends e.g. on alpha and the size of the cell. 1 point per
        Angstrom is common.
        """
        self.Ns_max = None
        """
        number of grid points on small mesh (PME only), should be odd.
        """
        self.O_spline = None
        """
        order of the beta-Euler spline (SPME only)
        """
        self.Epsilon = None
        """
        tolerance of gaussians for fft interpolation (PME only)
        """
        self.list_RS_GRID = []
        self.MULTIPOLES = _multipoles2()
        self.PRINT = _print35()
        self._name = "EWALD"
        self._keywords = [('Ewald_type', 'EWALD_TYPE'), ('Ewald_accuracy', 'EWALD_ACCURACY'), ('Rcut', 'RCUT'), ('Alpha', 'ALPHA'), ('Gmax', 'GMAX'), ('Ns_max', 'NS_MAX'), ('O_spline', 'O_SPLINE'), ('Epsilon', 'EPSILON')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('MULTIPOLES', 'MULTIPOLES'), ('PRINT', 'PRINT')]
        self._repeated_subsections = [('RS_GRID', '_rs_grid4')]

    def add_RS_GRID(self):
        new_section = _rs_grid4()
        self.list_RS_GRID.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _ewald1(printable):
    """
    Ewald parameters controlling electrostatic only for CLASSICAL MM.
    """
    def __init__(self):
        self.Ewald_type = None
        """
        The type of ewald you want to perform. NONE standard real-space
        coulomb potential is computed together with the non-bonded
        contributions. EWALD is the standard non-fft based ewald. SPME is the
        smooth particle mesh using beta-Euler splines (recommended). PME is
        the particle mesh using fft interpolation.

        Available values:
            NONE
            EWALD
            PME
            SPME
        """
        self.Ewald_accuracy = None
        """
        Expected accuracy in the Ewald sum. This number affects only the
        calculation of the cutoff for the real-space term of the ewald
        summation (EWALD|PME|SPME) as well as the construction of the neighbor
        lists (if the cutoff for non-bonded terms is smaller than the value
        employed to compute the EWALD real-space term). This keyword has no
        effect on the reciprocal space term (which can be tuned
        independently).
        """
        self.Rcut = None
        """
        Explicitly provide the real-space cutoff of the ewald summation
        (EWALD|PME|SPME). If present, overwrites the estimate of
        EWALD_ACCURACY and may affect the construction of the neighbor lists
        for non-bonded terms (in FIST), if the value specified is larger than
        the cutoff for non-bonded interactions.
        """
        self.Alpha = None
        """
        alpha parameter associated with Ewald (EWALD|PME|SPME). Recommended
        for small systems is is alpha = 3.5 / r_cut. Tuning alpha, r_cut and
        gmax is needed to obtain O(N**1.5) scaling for ewald.
        """
        self.Gmax = None
        """
        number of grid points (SPME and EWALD). If a single number is
        specified,the same number of points is used for all three directions
        on the grid.If three numbers are given, each direction can have a
        different number of points.The number of points needs to be FFTable
        (which depends on the library used) and odd for EWALD.The optimal
        number depends e.g. on alpha and the size of the cell. 1 point per
        Angstrom is common.
        """
        self.Ns_max = None
        """
        number of grid points on small mesh (PME only), should be odd.
        """
        self.O_spline = None
        """
        order of the beta-Euler spline (SPME only)
        """
        self.Epsilon = None
        """
        tolerance of gaussians for fft interpolation (PME only)
        """
        self.list_RS_GRID = []
        self.MULTIPOLES = _multipoles1()
        self.PRINT = _print29()
        self._name = "EWALD"
        self._keywords = [('Ewald_type', 'EWALD_TYPE'), ('Ewald_accuracy', 'EWALD_ACCURACY'), ('Rcut', 'RCUT'), ('Alpha', 'ALPHA'), ('Gmax', 'GMAX'), ('Ns_max', 'NS_MAX'), ('O_spline', 'O_SPLINE'), ('Epsilon', 'EPSILON')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('MULTIPOLES', 'MULTIPOLES'), ('PRINT', 'PRINT')]
        self._repeated_subsections = [('RS_GRID', '_rs_grid3')]

    def add_RS_GRID(self):
        new_section = _rs_grid3()
        self.list_RS_GRID.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _low_spin_roks1(printable):
    """
    Specify the details of the low spin ROKS method.In particular, one can
    specify various terms added to the energy of the high spin roks
    configuration with a energy scaling factor, and a prescription of the
    spin state.
    """
    def __init__(self):
        self.Energy_scaling = None
        """
        The scaling factors for each term added to the total energy.This list
        should contain one number for each term added to the total energy.
        """
        self.list_Spin_configuration = []
        self._name = "LOW_SPIN_ROKS"
        self._keywords = [('Energy_scaling', 'ENERGY_SCALING')]
        self._repeated_keywords = [('Spin_configuration', 'SPIN_CONFIGURATION')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Spin_configuration(self, value):
        self.list_Spin_configuration.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _each89(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each88(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each87(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each86(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each85(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each84(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each83(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each82(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each81(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each80(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _rmsd1(printable):
    """
    Section to define a CV as function of RMSD computed with respect to
    given reference configurations. For 2 configurations the colvar is
    equal to: ss = (RMSDA-RMSDB)/(RMSDA+RMSDB), while if only 1
    configuration is given, then the colvar is just the RMSD from that
    frame.
    """
    def __init__(self):
        self.Subset_type = None
        """
        Define the subsytem used to compute the RMSD

        Available values:
            ALL
            LIST
            WEIGHT_LIST
        """
        self.Align_frames = None
        """
        Whether the reference frames should be aligned to minimize the RMSD
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.list_FRAME = []
        self._name = "RMSD"
        self._keywords = [('Subset_type', 'SUBSET_TYPE'), ('Align_frames', 'ALIGN_FRAMES')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('FRAME', '_frame1')]

    def add_FRAME(self):
        new_section = _frame1()
        self.list_FRAME.append(new_section)
        return new_section

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _rmsd3(printable):
    """
    Section to define a CV as function of RMSD computed with respect to
    given reference configurations. For 2 configurations the colvar is
    equal to: ss = (RMSDA-RMSDB)/(RMSDA+RMSDB), while if only 1
    configuration is given, then the colvar is just the RMSD from that
    frame.
    """
    def __init__(self):
        self.Subset_type = None
        """
        Define the subsytem used to compute the RMSD

        Available values:
            ALL
            LIST
            WEIGHT_LIST
        """
        self.Align_frames = None
        """
        Whether the reference frames should be aligned to minimize the RMSD
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.list_FRAME = []
        self._name = "RMSD"
        self._keywords = [('Subset_type', 'SUBSET_TYPE'), ('Align_frames', 'ALIGN_FRAMES')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('FRAME', '_frame4')]

    def add_FRAME(self):
        new_section = _frame4()
        self.list_FRAME.append(new_section)
        return new_section

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _rmsd2(printable):
    """
    Section to define a CV as function of RMSD computed with respect to
    given reference configurations. For 2 configurations the colvar is
    equal to: ss = (RMSDA-RMSDB)/(RMSDA+RMSDB), while if only 1
    configuration is given, then the colvar is just the RMSD from that
    frame.
    """
    def __init__(self):
        self.Subset_type = None
        """
        Define the subsytem used to compute the RMSD

        Available values:
            ALL
            LIST
            WEIGHT_LIST
        """
        self.Align_frames = None
        """
        Whether the reference frames should be aligned to minimize the RMSD
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.list_FRAME = []
        self._name = "RMSD"
        self._keywords = [('Subset_type', 'SUBSET_TYPE'), ('Align_frames', 'ALIGN_FRAMES')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('FRAME', '_frame2')]

    def add_FRAME(self):
        new_section = _frame2()
        self.list_FRAME.append(new_section)
        return new_section

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _rmsd4(printable):
    """
    Section to define a CV as function of RMSD computed with respect to
    given reference configurations. For 2 configurations the colvar is
    equal to: ss = (RMSDA-RMSDB)/(RMSDA+RMSDB), while if only 1
    configuration is given, then the colvar is just the RMSD from that
    frame.
    """
    def __init__(self):
        self.Subset_type = None
        """
        Define the subsytem used to compute the RMSD

        Available values:
            ALL
            LIST
            WEIGHT_LIST
        """
        self.Align_frames = None
        """
        Whether the reference frames should be aligned to minimize the RMSD
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.list_FRAME = []
        self._name = "RMSD"
        self._keywords = [('Subset_type', 'SUBSET_TYPE'), ('Align_frames', 'ALIGN_FRAMES')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('FRAME', '_frame6')]

    def add_FRAME(self):
        new_section = _frame6()
        self.list_FRAME.append(new_section)
        return new_section

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _coord_avg1(printable):
    """
    Controls the printing of the average coordination number.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each262()
        self._name = "COORD_AVG"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print62(printable):
    """
    Section controlling the print information during a vibrational
    analysis.
    """
    def __init__(self):
        self.BANNER = _banner2()
        self.PROGRAM_RUN_INFO = _program_run_info51()
        self.MOLDEN_VIB = _molden_vib1()
        self.ROTATIONAL_INFO = _rotational_info3()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('BANNER', 'BANNER'), ('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('MOLDEN_VIB', 'MOLDEN_VIB'), ('ROTATIONAL_INFO', 'ROTATIONAL_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print63(printable):
    """
    Section of possible print options specific of the ATOM code.
    """
    def __init__(self):
        self.PROGRAM_BANNER = _program_banner4()
        self.METHOD_INFO = _method_info1()
        self.BASIS_SET = _basis_set1()
        self.POTENTIAL = _potential3()
        self.FIT_DENSITY = _fit_density1()
        self.RESPONSE_BASIS = _response_basis1()
        self.SCF_INFO = _scf_info1()
        self.ORBITALS = _orbitals1()
        self.FIT_PSEUDO = _fit_pseudo1()
        self.FIT_BASIS = _fit_basis1()
        self.UPF_FILE = _upf_file1()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_BANNER', 'PROGRAM_BANNER'), ('METHOD_INFO', 'METHOD_INFO'), ('BASIS_SET', 'BASIS_SET'), ('POTENTIAL', 'POTENTIAL'), ('FIT_DENSITY', 'FIT_DENSITY'), ('RESPONSE_BASIS', 'RESPONSE_BASIS'), ('SCF_INFO', 'SCF_INFO'), ('ORBITALS', 'ORBITALS'), ('FIT_PSEUDO', 'FIT_PSEUDO'), ('FIT_BASIS', 'FIT_BASIS'), ('UPF_FILE', 'UPF_FILE')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print60(printable):
    """
    Properties that you want to output and that are common to all methods
    """
    def __init__(self):
        self.PROGRAM_RUN_INFO = _program_run_info49()
        self.FORCES = _forces4()
        self.GRID_INFORMATION = _grid_information3()
        self.TOTAL_NUMBERS = _total_numbers1()
        self.DISTRIBUTION = _distribution2()
        self.DISTRIBUTION2D = _distribution2d1()
        self.DISTRIBUTION1D = _distribution1d1()
        self.STRESS_TENSOR = _stress_tensor1()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('FORCES', 'FORCES'), ('GRID_INFORMATION', 'GRID_INFORMATION'), ('TOTAL_NUMBERS', 'TOTAL_NUMBERS'), ('DISTRIBUTION', 'DISTRIBUTION'), ('DISTRIBUTION2D', 'DISTRIBUTION2D'), ('DISTRIBUTION1D', 'DISTRIBUTION1D'), ('STRESS_TENSOR', 'STRESS_TENSOR')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print61(printable):
    """
    Controls the printing mode selective vibrational analysis
    """
    def __init__(self):
        self.MS_RESTART = _ms_restart1()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('MS_RESTART', 'MS_RESTART')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print66(printable):
    """
    Controls the printing of info about load balance
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Load_balance_info = None
        """
        Activates the printing of load balance information
        """
        self.EACH = _each372()
        self._name = "PRINT"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Load_balance_info', 'LOAD_BALANCE_INFO')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print67(printable):
    """
    Print results of a HFX RI calculation
    """
    def __init__(self):
        self.PROGRAM_RUN_INFO = _program_run_info53()
        self.GEMINAL_BASIS = _geminal_basis8()
        self.CHARGE = _charge9()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('GEMINAL_BASIS', 'GEMINAL_BASIS'), ('CHARGE', 'CHARGE')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print64(printable):
    """
    Controls the printing of info about load balance
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Load_balance_info = None
        """
        Activates the printing of load balance information
        """
        self.EACH = _each366()
        self._name = "PRINT"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Load_balance_info', 'LOAD_BALANCE_INFO')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _print65(printable):
    """
    Print results of a HFX RI calculation
    """
    def __init__(self):
        self.PROGRAM_RUN_INFO = _program_run_info52()
        self.GEMINAL_BASIS = _geminal_basis7()
        self.CHARGE = _charge8()
        self._name = "PRINT"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('GEMINAL_BASIS', 'GEMINAL_BASIS'), ('CHARGE', 'CHARGE')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _grid_information2(printable):
    """
    Controls the printing of information regarding the PW grid structures
    for PERIODIC qm/mm calculations.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each248()
        self._name = "GRID_INFORMATION"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _grid_information3(printable):
    """
    Controls the printing of information regarding the PW and RS grid
    structures.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each337()
        self._name = "GRID_INFORMATION"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _grid_information1(printable):
    """
    Controls the printing of information regarding the PW and RS grid
    structures (ONLY for TEST run).
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each5()
        self._name = "GRID_INFORMATION"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _core_velocity1(printable):
    """
    The velocities of cores for shell-model potentials, in xyz format
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        The core velocities in xyz format. The same order as the shell
        coordinate is assumed.
        """
        self._name = "CORE_VELOCITY"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _hf8(printable):
    """
    Sets up the Hartree-Fock parameters if requested
    """
    def __init__(self):
        self.Fraction = None
        """
        The fraction of Hartree-Fock to add to the total energy. 1.0 implies
        standard Hartree-Fock if used with XC_FUNCTIONAL NONE. NOTE: In a
        mixed potential calculation this should be set to 1.0, otherwise all
        parts are multiplied with this factor.
        """
        self.Treat_lsd_in_core = None
        """
        Determines how spin denisities are taken into account. If true, the
        beta spin density is included via a second in core call. If false,
        alpha and beta spins are done in one shot
        """
        self.Pw_hfx = None
        """
        Compute the Hartree-Fock energy also in the plane wave basis.The value
        is ignored, and intended for debugging only.
        """
        self.Pw_hfx_blocksize = None
        """
        Improve the performance of pw_hfx at the cost of some additional
        memory by storing the realspace representation of PW_HFX_BLOCKSIZE
        states.
        """
        self.HF_INFO = _hf_info8()
        self.PERIODIC = _periodic9()
        self.SCREENING = _screening9()
        self.INTERACTION_POTENTIAL = _interaction_potential11()
        self.LOAD_BALANCE = _load_balance8()
        self.MEMORY = _memory9()
        self.HFX_RI = _hfx_ri8()
        self._name = "HF"
        self._keywords = [('Fraction', 'FRACTION'), ('Treat_lsd_in_core', 'TREAT_LSD_IN_CORE'), ('Pw_hfx', 'PW_HFX'), ('Pw_hfx_blocksize', 'PW_HFX_BLOCKSIZE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('HF_INFO', 'HF_INFO'), ('PERIODIC', 'PERIODIC'), ('SCREENING', 'SCREENING'), ('INTERACTION_POTENTIAL', 'INTERACTION_POTENTIAL'), ('LOAD_BALANCE', 'LOAD_BALANCE'), ('MEMORY', 'MEMORY'), ('HFX_RI', 'HFX_RI')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _hf7(printable):
    """
    Sets up the Hartree-Fock parameters if requested
    """
    def __init__(self):
        self.Fraction = None
        """
        The fraction of Hartree-Fock to add to the total energy. 1.0 implies
        standard Hartree-Fock if used with XC_FUNCTIONAL NONE. NOTE: In a
        mixed potential calculation this should be set to 1.0, otherwise all
        parts are multiplied with this factor.
        """
        self.Treat_lsd_in_core = None
        """
        Determines how spin denisities are taken into account. If true, the
        beta spin density is included via a second in core call. If false,
        alpha and beta spins are done in one shot
        """
        self.Pw_hfx = None
        """
        Compute the Hartree-Fock energy also in the plane wave basis.The value
        is ignored, and intended for debugging only.
        """
        self.Pw_hfx_blocksize = None
        """
        Improve the performance of pw_hfx at the cost of some additional
        memory by storing the realspace representation of PW_HFX_BLOCKSIZE
        states.
        """
        self.HF_INFO = _hf_info7()
        self.PERIODIC = _periodic8()
        self.SCREENING = _screening8()
        self.INTERACTION_POTENTIAL = _interaction_potential10()
        self.LOAD_BALANCE = _load_balance7()
        self.MEMORY = _memory8()
        self.HFX_RI = _hfx_ri7()
        self._name = "HF"
        self._keywords = [('Fraction', 'FRACTION'), ('Treat_lsd_in_core', 'TREAT_LSD_IN_CORE'), ('Pw_hfx', 'PW_HFX'), ('Pw_hfx_blocksize', 'PW_HFX_BLOCKSIZE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('HF_INFO', 'HF_INFO'), ('PERIODIC', 'PERIODIC'), ('SCREENING', 'SCREENING'), ('INTERACTION_POTENTIAL', 'INTERACTION_POTENTIAL'), ('LOAD_BALANCE', 'LOAD_BALANCE'), ('MEMORY', 'MEMORY'), ('HFX_RI', 'HFX_RI')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _hf6(printable):
    """
    Sets up the Hartree-Fock parameters if requested
    """
    def __init__(self):
        self.Fraction = None
        """
        The fraction of Hartree-Fock to add to the total energy. 1.0 implies
        standard Hartree-Fock if used with XC_FUNCTIONAL NONE. NOTE: In a
        mixed potential calculation this should be set to 1.0, otherwise all
        parts are multiplied with this factor.
        """
        self.Treat_lsd_in_core = None
        """
        Determines how spin denisities are taken into account. If true, the
        beta spin density is included via a second in core call. If false,
        alpha and beta spins are done in one shot
        """
        self.Pw_hfx = None
        """
        Compute the Hartree-Fock energy also in the plane wave basis.The value
        is ignored, and intended for debugging only.
        """
        self.Pw_hfx_blocksize = None
        """
        Improve the performance of pw_hfx at the cost of some additional
        memory by storing the realspace representation of PW_HFX_BLOCKSIZE
        states.
        """
        self.HF_INFO = _hf_info6()
        self.PERIODIC = _periodic7()
        self.SCREENING = _screening7()
        self.INTERACTION_POTENTIAL = _interaction_potential8()
        self.LOAD_BALANCE = _load_balance6()
        self.MEMORY = _memory7()
        self.HFX_RI = _hfx_ri6()
        self._name = "HF"
        self._keywords = [('Fraction', 'FRACTION'), ('Treat_lsd_in_core', 'TREAT_LSD_IN_CORE'), ('Pw_hfx', 'PW_HFX'), ('Pw_hfx_blocksize', 'PW_HFX_BLOCKSIZE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('HF_INFO', 'HF_INFO'), ('PERIODIC', 'PERIODIC'), ('SCREENING', 'SCREENING'), ('INTERACTION_POTENTIAL', 'INTERACTION_POTENTIAL'), ('LOAD_BALANCE', 'LOAD_BALANCE'), ('MEMORY', 'MEMORY'), ('HFX_RI', 'HFX_RI')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _hf5(printable):
    """
    Sets up the Hartree-Fock parameters if requested
    """
    def __init__(self):
        self.Fraction = None
        """
        The fraction of Hartree-Fock to add to the total energy. 1.0 implies
        standard Hartree-Fock if used with XC_FUNCTIONAL NONE. NOTE: In a
        mixed potential calculation this should be set to 1.0, otherwise all
        parts are multiplied with this factor.
        """
        self.Treat_lsd_in_core = None
        """
        Determines how spin denisities are taken into account. If true, the
        beta spin density is included via a second in core call. If false,
        alpha and beta spins are done in one shot
        """
        self.Pw_hfx = None
        """
        Compute the Hartree-Fock energy also in the plane wave basis.The value
        is ignored, and intended for debugging only.
        """
        self.Pw_hfx_blocksize = None
        """
        Improve the performance of pw_hfx at the cost of some additional
        memory by storing the realspace representation of PW_HFX_BLOCKSIZE
        states.
        """
        self.HF_INFO = _hf_info5()
        self.PERIODIC = _periodic6()
        self.SCREENING = _screening6()
        self.INTERACTION_POTENTIAL = _interaction_potential7()
        self.LOAD_BALANCE = _load_balance5()
        self.MEMORY = _memory6()
        self.HFX_RI = _hfx_ri5()
        self._name = "HF"
        self._keywords = [('Fraction', 'FRACTION'), ('Treat_lsd_in_core', 'TREAT_LSD_IN_CORE'), ('Pw_hfx', 'PW_HFX'), ('Pw_hfx_blocksize', 'PW_HFX_BLOCKSIZE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('HF_INFO', 'HF_INFO'), ('PERIODIC', 'PERIODIC'), ('SCREENING', 'SCREENING'), ('INTERACTION_POTENTIAL', 'INTERACTION_POTENTIAL'), ('LOAD_BALANCE', 'LOAD_BALANCE'), ('MEMORY', 'MEMORY'), ('HFX_RI', 'HFX_RI')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _hf4(printable):
    """
    Sets up the Hartree-Fock parameters if requested
    """
    def __init__(self):
        self.Fraction = None
        """
        The fraction of Hartree-Fock to add to the total energy. 1.0 implies
        standard Hartree-Fock if used with XC_FUNCTIONAL NONE. NOTE: In a
        mixed potential calculation this should be set to 1.0, otherwise all
        parts are multiplied with this factor.
        """
        self.Treat_lsd_in_core = None
        """
        Determines how spin denisities are taken into account. If true, the
        beta spin density is included via a second in core call. If false,
        alpha and beta spins are done in one shot
        """
        self.Pw_hfx = None
        """
        Compute the Hartree-Fock energy also in the plane wave basis.The value
        is ignored, and intended for debugging only.
        """
        self.Pw_hfx_blocksize = None
        """
        Improve the performance of pw_hfx at the cost of some additional
        memory by storing the realspace representation of PW_HFX_BLOCKSIZE
        states.
        """
        self.HF_INFO = _hf_info4()
        self.PERIODIC = _periodic4()
        self.SCREENING = _screening5()
        self.INTERACTION_POTENTIAL = _interaction_potential5()
        self.LOAD_BALANCE = _load_balance4()
        self.MEMORY = _memory5()
        self.HFX_RI = _hfx_ri4()
        self._name = "HF"
        self._keywords = [('Fraction', 'FRACTION'), ('Treat_lsd_in_core', 'TREAT_LSD_IN_CORE'), ('Pw_hfx', 'PW_HFX'), ('Pw_hfx_blocksize', 'PW_HFX_BLOCKSIZE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('HF_INFO', 'HF_INFO'), ('PERIODIC', 'PERIODIC'), ('SCREENING', 'SCREENING'), ('INTERACTION_POTENTIAL', 'INTERACTION_POTENTIAL'), ('LOAD_BALANCE', 'LOAD_BALANCE'), ('MEMORY', 'MEMORY'), ('HFX_RI', 'HFX_RI')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _hf3(printable):
    """
    Sets up the Hartree-Fock parameters if requested
    """
    def __init__(self):
        self.Fraction = None
        """
        The fraction of Hartree-Fock to add to the total energy. 1.0 implies
        standard Hartree-Fock if used with XC_FUNCTIONAL NONE. NOTE: In a
        mixed potential calculation this should be set to 1.0, otherwise all
        parts are multiplied with this factor.
        """
        self.Treat_lsd_in_core = None
        """
        Determines how spin denisities are taken into account. If true, the
        beta spin density is included via a second in core call. If false,
        alpha and beta spins are done in one shot
        """
        self.Pw_hfx = None
        """
        Compute the Hartree-Fock energy also in the plane wave basis.The value
        is ignored, and intended for debugging only.
        """
        self.Pw_hfx_blocksize = None
        """
        Improve the performance of pw_hfx at the cost of some additional
        memory by storing the realspace representation of PW_HFX_BLOCKSIZE
        states.
        """
        self.HF_INFO = _hf_info3()
        self.PERIODIC = _periodic3()
        self.SCREENING = _screening4()
        self.INTERACTION_POTENTIAL = _interaction_potential4()
        self.LOAD_BALANCE = _load_balance3()
        self.MEMORY = _memory4()
        self.HFX_RI = _hfx_ri3()
        self._name = "HF"
        self._keywords = [('Fraction', 'FRACTION'), ('Treat_lsd_in_core', 'TREAT_LSD_IN_CORE'), ('Pw_hfx', 'PW_HFX'), ('Pw_hfx_blocksize', 'PW_HFX_BLOCKSIZE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('HF_INFO', 'HF_INFO'), ('PERIODIC', 'PERIODIC'), ('SCREENING', 'SCREENING'), ('INTERACTION_POTENTIAL', 'INTERACTION_POTENTIAL'), ('LOAD_BALANCE', 'LOAD_BALANCE'), ('MEMORY', 'MEMORY'), ('HFX_RI', 'HFX_RI')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _hf2(printable):
    """
    Sets up the Hartree-Fock parameters if requested
    """
    def __init__(self):
        self.Fraction = None
        """
        The fraction of Hartree-Fock to add to the total energy. 1.0 implies
        standard Hartree-Fock if used with XC_FUNCTIONAL NONE. NOTE: In a
        mixed potential calculation this should be set to 1.0, otherwise all
        parts are multiplied with this factor.
        """
        self.Treat_lsd_in_core = None
        """
        Determines how spin denisities are taken into account. If true, the
        beta spin density is included via a second in core call. If false,
        alpha and beta spins are done in one shot
        """
        self.Pw_hfx = None
        """
        Compute the Hartree-Fock energy also in the plane wave basis.The value
        is ignored, and intended for debugging only.
        """
        self.Pw_hfx_blocksize = None
        """
        Improve the performance of pw_hfx at the cost of some additional
        memory by storing the realspace representation of PW_HFX_BLOCKSIZE
        states.
        """
        self.HF_INFO = _hf_info2()
        self.PERIODIC = _periodic2()
        self.SCREENING = _screening3()
        self.INTERACTION_POTENTIAL = _interaction_potential2()
        self.LOAD_BALANCE = _load_balance2()
        self.MEMORY = _memory3()
        self.HFX_RI = _hfx_ri2()
        self._name = "HF"
        self._keywords = [('Fraction', 'FRACTION'), ('Treat_lsd_in_core', 'TREAT_LSD_IN_CORE'), ('Pw_hfx', 'PW_HFX'), ('Pw_hfx_blocksize', 'PW_HFX_BLOCKSIZE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('HF_INFO', 'HF_INFO'), ('PERIODIC', 'PERIODIC'), ('SCREENING', 'SCREENING'), ('INTERACTION_POTENTIAL', 'INTERACTION_POTENTIAL'), ('LOAD_BALANCE', 'LOAD_BALANCE'), ('MEMORY', 'MEMORY'), ('HFX_RI', 'HFX_RI')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _hf1(printable):
    """
    Sets up the Hartree-Fock parameters if requested
    """
    def __init__(self):
        self.Fraction = None
        """
        The fraction of Hartree-Fock to add to the total energy. 1.0 implies
        standard Hartree-Fock if used with XC_FUNCTIONAL NONE. NOTE: In a
        mixed potential calculation this should be set to 1.0, otherwise all
        parts are multiplied with this factor.
        """
        self.Treat_lsd_in_core = None
        """
        Determines how spin denisities are taken into account. If true, the
        beta spin density is included via a second in core call. If false,
        alpha and beta spins are done in one shot
        """
        self.Pw_hfx = None
        """
        Compute the Hartree-Fock energy also in the plane wave basis.The value
        is ignored, and intended for debugging only.
        """
        self.Pw_hfx_blocksize = None
        """
        Improve the performance of pw_hfx at the cost of some additional
        memory by storing the realspace representation of PW_HFX_BLOCKSIZE
        states.
        """
        self.HF_INFO = _hf_info1()
        self.PERIODIC = _periodic1()
        self.SCREENING = _screening2()
        self.INTERACTION_POTENTIAL = _interaction_potential1()
        self.LOAD_BALANCE = _load_balance1()
        self.MEMORY = _memory2()
        self.HFX_RI = _hfx_ri1()
        self._name = "HF"
        self._keywords = [('Fraction', 'FRACTION'), ('Treat_lsd_in_core', 'TREAT_LSD_IN_CORE'), ('Pw_hfx', 'PW_HFX'), ('Pw_hfx_blocksize', 'PW_HFX_BLOCKSIZE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('HF_INFO', 'HF_INFO'), ('PERIODIC', 'PERIODIC'), ('SCREENING', 'SCREENING'), ('INTERACTION_POTENTIAL', 'INTERACTION_POTENTIAL'), ('LOAD_BALANCE', 'LOAD_BALANCE'), ('MEMORY', 'MEMORY'), ('HFX_RI', 'HFX_RI')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _nonbonded141(printable):
    """
    This section specifies the input parameters for 1-4 NON-BONDED
    interactions.
    """
    def __init__(self):
        self.list_LENNARD_JONES = []
        self.list_WILLIAMS = []
        self.list_GOODWIN = []
        self.list_GENPOT = []
        self._name = "NONBONDED14"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('LENNARD_JONES', '_lennard_jones2'), ('WILLIAMS', '_williams2'), ('GOODWIN', '_goodwin2'), ('GENPOT', '_genpot2')]

    def add_LENNARD_JONES(self):
        new_section = _lennard_jones2()
        self.list_LENNARD_JONES.append(new_section)
        return new_section

    def add_WILLIAMS(self):
        new_section = _williams2()
        self.list_WILLIAMS.append(new_section)
        return new_section

    def add_GOODWIN(self):
        new_section = _goodwin2()
        self.list_GOODWIN.append(new_section)
        return new_section

    def add_GENPOT(self):
        new_section = _genpot2()
        self.list_GENPOT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _nonbonded142(printable):
    """
    This section specifies the input parameters for 1-4 NON-BONDED
    interactions.
    """
    def __init__(self):
        self.list_LENNARD_JONES = []
        self.list_WILLIAMS = []
        self.list_GOODWIN = []
        self.list_GENPOT = []
        self._name = "NONBONDED14"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('LENNARD_JONES', '_lennard_jones4'), ('WILLIAMS', '_williams4'), ('GOODWIN', '_goodwin4'), ('GENPOT', '_genpot4')]

    def add_LENNARD_JONES(self):
        new_section = _lennard_jones4()
        self.list_LENNARD_JONES.append(new_section)
        return new_section

    def add_WILLIAMS(self):
        new_section = _williams4()
        self.list_WILLIAMS.append(new_section)
        return new_section

    def add_GOODWIN(self):
        new_section = _goodwin4()
        self.list_GOODWIN.append(new_section)
        return new_section

    def add_GENPOT(self):
        new_section = _genpot4()
        self.list_GENPOT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _relativistic1(printable):
    """
    parameters needed and setup for relativistic calculations
    """
    def __init__(self):
        self.Method = None
        """
        type of relativistic correction used

        Available values:
            NONE
            DKH
        """
        self.Dkh_order = None
        """
        The order of the DKH transformation
        """
        self.Transformation = None
        """
        type of DKH transformation, full: use full matrix transformation,
        molecule: use transformation blocked by molecule, atom: use atomic
        blocks

        Available values:
            FULL
            MOLECULE
            ATOM
        """
        self.Z_cutoff = None
        """
        The minimal atomic number considered for atom transformation
        """
        self.Potential = None
        """
        External potential used in DKH transformation, full 1/r or erfc(r)/r

        Available values:
            FULL
            ERFC
        """
        self._name = "RELATIVISTIC"
        self._keywords = [('Method', 'METHOD'), ('Dkh_order', 'DKH_ORDER'), ('Transformation', 'TRANSFORMATION'), ('Z_cutoff', 'Z_CUTOFF'), ('Potential', 'POTENTIAL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _gyration_radius1(printable):
    """
    Section to define the gyration radius as a collective variable.
    """
    def __init__(self):
        self.list_Atoms = []
        self.list_Points = self.list_Atoms
        self.list_Kinds = []
        self.list_POINT = []
        self._name = "GYRATION_RADIUS"
        self._keywords = []
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Kinds', 'KINDS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point6')]

    def add_POINT(self):
        new_section = _point6()
        self.list_POINT.append(new_section)
        return new_section

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Kinds(self, value):
        self.list_Kinds.append(value)

    def add_Points(self, value):
        self.list_KINDS.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _gyration_radius2(printable):
    """
    Section to define the gyration radius as a collective variable.
    """
    def __init__(self):
        self.list_Atoms = []
        self.list_Points = self.list_Atoms
        self.list_Kinds = []
        self.list_POINT = []
        self._name = "GYRATION_RADIUS"
        self._keywords = []
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Kinds', 'KINDS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point24')]

    def add_POINT(self):
        new_section = _point24()
        self.list_POINT.append(new_section)
        return new_section

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Kinds(self, value):
        self.list_Kinds.append(value)

    def add_Points(self, value):
        self.list_KINDS.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _gyration_radius3(printable):
    """
    Section to define the gyration radius as a collective variable.
    """
    def __init__(self):
        self.list_Atoms = []
        self.list_Points = self.list_Atoms
        self.list_Kinds = []
        self.list_POINT = []
        self._name = "GYRATION_RADIUS"
        self._keywords = []
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Kinds', 'KINDS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point42')]

    def add_POINT(self):
        new_section = _point42()
        self.list_POINT.append(new_section)
        return new_section

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Kinds(self, value):
        self.list_Kinds.append(value)

    def add_Points(self, value):
        self.list_KINDS.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _gyration_radius4(printable):
    """
    Section to define the gyration radius as a collective variable.
    """
    def __init__(self):
        self.list_Atoms = []
        self.list_Points = self.list_Atoms
        self.list_Kinds = []
        self.list_POINT = []
        self._name = "GYRATION_RADIUS"
        self._keywords = []
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Kinds', 'KINDS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point60')]

    def add_POINT(self):
        new_section = _point60()
        self.list_POINT.append(new_section)
        return new_section

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Kinds(self, value):
        self.list_Kinds.append(value)

    def add_Points(self, value):
        self.list_KINDS.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _center1(printable):
    """
    Defines the center of the sphere.
    """
    def __init__(self):
        self.Xyz = None
        """
        Coordinates of the center of the sphere
        """
        self.Atom_list = None
        """
        Defines a list of atoms to define the center of the sphere
        """
        self.Weight = None
        """
        Defines the weight used to define the center of the sphere (if
        ATOM_LIST is provided)

        Available values:
            UNIT
            MASS
        """
        self.Fixed = None
        """
        Specify if the center of the sphere should be fixed or allowed to move
        """
        self._name = "CENTER"
        self._keywords = [('Xyz', 'XYZ'), ('Atom_list', 'ATOM_LIST'), ('Weight', 'WEIGHT'), ('Fixed', 'FIXED')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _atomic1(printable):
    """
    Controls the calculation and printing of atomic properties
    """
    def __init__(self):
        self.Energy = None
        """
        Calculate atomic energies
        """
        self.Pressure = None
        """
        Calculate atomic pressure tensors
        """
        self.PRINT = _print59()
        self._name = "ATOMIC"
        self._keywords = [('Energy', 'ENERGY'), ('Pressure', 'PRESSURE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _mt1(printable):
    """
    Sets up parameters of  Martyna-Tuckerman poisson solver. Note that
    exact results are only guaranteed if the unit cell is twice as large
    as charge density (and serious artefacts can result if the cell is
    much smaller).
    """
    def __init__(self):
        self.Alpha = None
        """
        Convergence parameter ALPHA*RMIN. Default value 7.0
        """
        self.Rel_cutoff = None
        """
        Specify the multiplicative factor for the CUTOFF keyword in MULTI_GRID
        section. The result gives the cutoff at which the 1/r non-periodic
        FFT3D is evaluated.Default is 2.0
        """
        self._name = "MT"
        self._keywords = [('Alpha', 'ALPHA'), ('Rel_cutoff', 'REL_CUTOFF')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _mt2(printable):
    """
    Sets up parameters of  Martyna-Tuckerman poisson solver. Note that
    exact results are only guaranteed if the unit cell is twice as large
    as charge density (and serious artefacts can result if the cell is
    much smaller).
    """
    def __init__(self):
        self.Alpha = None
        """
        Convergence parameter ALPHA*RMIN. Default value 7.0
        """
        self.Rel_cutoff = None
        """
        Specify the multiplicative factor for the CUTOFF keyword in MULTI_GRID
        section. The result gives the cutoff at which the 1/r non-periodic
        FFT3D is evaluated.Default is 2.0
        """
        self._name = "MT"
        self._keywords = [('Alpha', 'ALPHA'), ('Rel_cutoff', 'REL_CUTOFF')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _machine_arch1(printable):
    """
    Configuration options for the machine architecture.
    """
    def __init__(self):
        self.Print_resume = None
        """
        Print the compute node architecture number of components.
        """
        self.Print_full = None
        """
        Print full machine architecture
        """
        self.Print_branch = None
        """
        Print machine architecture component organization.
        """
        self.Print_thread = None
        """
        Print the threads binding in the machine.
        """
        self.Print_thread_cur = None
        """
        Print the current threads binding in the machine.
        """
        self.Print_proc = None
        """
        Print the process binding in the machine.
        """
        self.Sched_thread = None
        """
        Enable thread scheduling on the compute node.
        """
        self.Sched_mpi = None
        """
        Enable process scheduling on the compute node.
        """
        self.Mem_pol = None
        """
        Enable memory binding on the compute node.
        """
        self.Process = None
        """
        Core ID for each MPI process of a compute node. It will be used to
        place the MPI process.
        """
        self.Thread = None
        """
        Core ID for each thread of a compute node. It will be used to place
        the thread.
        """
        self.Memory = None
        """
        The memory banks ID for each MPI process. It will beuse to set memory
        bank of the MPI process
        """
        self.Mpi_reordering = None
        """
        Apply a global MPI reordering for the run
        """
        self._name = "MACHINE_ARCH"
        self._keywords = [('Print_resume', 'PRINT_RESUME'), ('Print_full', 'PRINT_FULL'), ('Print_branch', 'PRINT_BRANCH'), ('Print_thread', 'PRINT_THREAD'), ('Print_thread_cur', 'PRINT_THREAD_CUR'), ('Print_proc', 'PRINT_PROC'), ('Sched_thread', 'SCHED_THREAD'), ('Sched_mpi', 'SCHED_MPI'), ('Mem_pol', 'MEM_POL'), ('Process', 'PROCESS'), ('Thread', 'THREAD'), ('Memory', 'MEMORY'), ('Mpi_reordering', 'MPI_REORDERING')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _point10(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point11(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point12(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point13(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _ep_matrixes1(printable):
    """
    Prints various matrixes of an ep calculation
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Psi0 = None
        """
        print the value of the psi0 matrix
        """
        self.Psi0_blocks = None
        """
        print the value of the blocs of the psi0 matrix
        """
        self.Psi1 = None
        """
        print the value of the psi1 matrix
        """
        self.Mo_s_inv = None
        """
        print the value of the inverse of the mo overlap matrix
        """
        self.EACH = _each257()
        self._name = "EP_MATRIXES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Psi0', 'PSI0'), ('Psi0_blocks', 'PSI0_BLOCKS'), ('Psi1', 'PSI1'), ('Mo_s_inv', 'MO_S_INV')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _point15(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point16(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point17(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point18(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point19(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _iter_info1(printable):
    """
    Activates the printing of iteration info during the self-consistent
    calculation of a polarizable forcefield.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each226()
        self._name = "ITER_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _tf3(printable):
    """
    Uses the TF functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self._name = "TF"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _tf2(printable):
    """
    Uses the TF functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self._name = "TF"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _tf1(printable):
    """
    Uses the TF functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self._name = "TF"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _tf4(printable):
    """
    Uses the TF functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self._name = "TF"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _nablavks_cubes1(printable):
    """
    Controls the printing of the components of nabla v_ks
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Stride = None
        """
        The stride (X,Y,Z) used to write the cube file (larger values result
        in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1
        number valid for all components.
        """
        self.Append = None
        """
        append the cube files when they already exist
        """
        self.EACH = _each306()
        self._name = "NABLAVKS_CUBES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Stride', 'STRIDE'), ('Append', 'APPEND')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _topology_info1(printable):
    """
    controls the printing of information in the topology settings
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Xtl_info = None
        """
        Prints information when parsing XTL files.
        """
        self.Cif_info = None
        """
        Prints information when parsing CIF files.
        """
        self.Pdb_info = None
        """
        Prints information when parsing PDB files.
        """
        self.Xyz_info = None
        """
        Prints information when parsing XYZ files.
        """
        self.Psf_info = None
        """
        Prints information when parsing PSF files.
        """
        self.Amber_info = None
        """
        Prints information when parsing ABER topology files.
        """
        self.G96_info = None
        """
        Prints information when parsing G96 files.
        """
        self.Crd_info = None
        """
        Prints information when parsing CRD files.
        """
        self.Gtop_info = None
        """
        Prints information when parsing GROMOS topology files.
        """
        self.Util_info = None
        """
        Prints information regarding topology utilities
        """
        self.Generate_info = None
        """
        Prints information regarding topology generation
        """
        self.EACH = _each280()
        self._name = "TOPOLOGY_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Xtl_info', 'XTL_INFO'), ('Cif_info', 'CIF_INFO'), ('Pdb_info', 'PDB_INFO'), ('Xyz_info', 'XYZ_INFO'), ('Psf_info', 'PSF_INFO'), ('Amber_info', 'AMBER_INFO'), ('G96_info', 'G96_INFO'), ('Crd_info', 'CRD_INFO'), ('Gtop_info', 'GTOP_INFO'), ('Util_info', 'UTIL_INFO'), ('Generate_info', 'GENERATE_INFO')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _variable1(printable):
    """
    Defines initial values for variables and their labels
    """
    def __init__(self):
        self.Value = None
        """
        Initial value of the variable
        """
        self.Fixed = None
        """
        Is this variable fixed or should it be optimized.
        """
        self.Label = None
        """
        The label used in the input file, i.e. ${LABEL} will be replaced by
        the VALUE specified.
        """
        self._name = "VARIABLE"
        self._keywords = [('Value', 'VALUE'), ('Fixed', 'FIXED'), ('Label', 'LABEL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _xwpbe4(printable):
    """
    Uses the short range PBE functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Scale_x0 = None
        """
        scales the exchange part of the original hole PBE-functional
        """
        self.Omega = None
        """
        screening parameter
        """
        self._name = "XWPBE"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Scale_x0', 'SCALE_X0'), ('Omega', 'OMEGA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _restraint4(printable):
    """
    Activate and specify information on restraint instead of constraint
    """
    def __init__(self):
        self.K = None
        """
        Specifies the force constant for the harmonic restraint. The
        functional form for the restraint is: K*(X-TARGET)^2.
        """
        self._name = "RESTRAINT"
        self._keywords = [('K', 'K')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _xwpbe3(printable):
    """
    Uses the short range PBE functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Scale_x0 = None
        """
        scales the exchange part of the original hole PBE-functional
        """
        self.Omega = None
        """
        screening parameter
        """
        self._name = "XWPBE"
        self._keywords = [('Scale_x', 'SCALE_X'), ('Scale_x0', 'SCALE_X0'), ('Omega', 'OMEGA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _restraint7(printable):
    """
    Restraint between two force_eval: E = E1 + k*(E1-E2-t)**2
    """
    def __init__(self):
        self.Restraint_target = None
        """
        Target value of the restraint (t)
        """
        self.Restraint_strength = None
        """
        Strength of the restraint (k) in k*(E1-E2-t)**2
        """
        self._name = "RESTRAINT"
        self._keywords = [('Restraint_target', 'RESTRAINT_TARGET'), ('Restraint_strength', 'RESTRAINT_STRENGTH')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _core_forces1(printable):
    """
    controls the output of the forces on cores when shell-model is used
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.Format = None
        """
        Specifies the format of the output file for the forces on cores.

        Available values:
            ATOMIC
                Write only the coordinates X,Y,Z without element symbols to a
                formatted file
            DCD
                Write the coordinates (no element labels) and the cell information to
                a binary file
            XMOL
                Mostly known as XYZ format, provides in a formatted file:
                element_symbol X Y Z
            XYZ
                Alias name for XMOL
        """
        self.EACH = _each83()
        self._name = "CORE_FORCES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT'), ('Format', 'FORMAT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _lagrange_multipliers1(printable):
    """
    Prints out the lagrange multipliers of the specified constraints
    during an MD.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each47()
        self._name = "LAGRANGE_MULTIPLIERS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _point14(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _opbend1(printable):
    """
    Specifies the out of plane bend potential of the MM system.(Only
    defined for atom quadruples which are also defined as an improper
    pattern in the topology.)
    """
    def __init__(self):
        self.Atoms = None
        """
        Defines the atomic kinds involved in the opbend.
        """
        self.Kind = None
        """
        Define the kind of out of plane bend potential

        Available values:
            HARMONIC
                Functional Form (HARMONIC): 0.5 * K * [ PHI - PHI0 ]**2
            MM2
                Functional Form (MM2|MM3|MM4): K * [ PHI - PHI0 ]**2
            MM3
                Functional Form (MM2|MM3|MM4): K * [ PHI - PHI0 ]**2
            MM4
                Functional Form (MM2|MM3|MM4): K * [ PHI - PHI0 ]**2
        """
        self.K = None
        """
        Defines the force constant of the potential
        """
        self.Phi0 = None
        """
        Defines the phase of the potential.
        """
        self._name = "OPBEND"
        self._keywords = [('Atoms', 'ATOMS'), ('Kind', 'KIND'), ('K', 'K'), ('Phi0', 'PHI0')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _ddapc_restraint_a1(printable):
    """
    Use DDAPC charges in a restraint (check code for details), section can
    be repeated, but only one constraint is possible at the moment.
    """
    def __init__(self):
        self.Strength = None
        """
        force constant of the restraint
        """
        self.Type_of_density = None
        """
        Specifies the type of density used for the fitting

        Available values:
            FULL
                Full density
            SPIN
                Spin density
        """
        self.Target = None
        """
        target value of the restraint
        """
        self.Atoms = None
        """
        Specifies the list of atoms that is summed in the restraint
        """
        self.Coeff = None
        """
        Defines the the coefficient of the atom in the atom list (default is
        one), currently DDAPC only
        """
        self.Functional_form = None
        """
        Specifies the functional form of the term added

        Available values:
            RESTRAINT
                Harmonic potential: s*(q-t)**2
            CONSTRAINT
                Constraint form: s*(q-t)
        """
        self.PROGRAM_RUN_INFO = _program_run_info43()
        self._name = "DDAPC_RESTRAINT_A"
        self._keywords = [('Strength', 'STRENGTH'), ('Type_of_density', 'TYPE_OF_DENSITY'), ('Target', 'TARGET'), ('Atoms', 'ATOMS'), ('Coeff', 'COEFF'), ('Functional_form', 'FUNCTIONAL_FORM')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _ri_mp22(printable):
    """
    Parameters influencing the RI MP2 method
    """
    def __init__(self):
        self.Block_size = None
        """
        Determines the blocking used for communication in RI-MP2. Larger
        BLOCK_SIZE reduces communication but requires more memory. The default
        (-1) is automatic.
        """
        self._name = "RI_MP2"
        self._keywords = [('Block_size', 'BLOCK_SIZE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Message_size(self):
        """
        See documentation for Block_size
        """
        return self.Block_size

    @Message_size.setter
    def Message_size(self, value):
        self.Block_size = value



class _ri_mp23(printable):
    """
    Parameters influencing the RI MP2 method
    """
    def __init__(self):
        self.Block_size = None
        """
        Determines the blocking used for communication in RI-MP2. Larger
        BLOCK_SIZE reduces communication but requires more memory. The default
        (-1) is automatic.
        """
        self._name = "RI_MP2"
        self._keywords = [('Block_size', 'BLOCK_SIZE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Message_size(self):
        """
        See documentation for Block_size
        """
        return self.Block_size

    @Message_size.setter
    def Message_size(self, value):
        self.Block_size = value



class _ri_mp21(printable):
    """
    Parameters influencing the RI MP2 method
    """
    def __init__(self):
        self.Block_size = None
        """
        Determines the blocking used for communication in RI-MP2. Larger
        BLOCK_SIZE reduces communication but requires more memory. The default
        (-1) is automatic.
        """
        self._name = "RI_MP2"
        self._keywords = [('Block_size', 'BLOCK_SIZE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Message_size(self):
        """
        See documentation for Block_size
        """
        return self.Block_size

    @Message_size.setter
    def Message_size(self, value):
        self.Block_size = value



class _ri_mp24(printable):
    """
    Parameters influencing the RI MP2 method
    """
    def __init__(self):
        self.Block_size = None
        """
        Determines the blocking used for communication in RI-MP2. Larger
        BLOCK_SIZE reduces communication but requires more memory. The default
        (-1) is automatic.
        """
        self._name = "RI_MP2"
        self._keywords = [('Block_size', 'BLOCK_SIZE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Message_size(self):
        """
        See documentation for Block_size
        """
        return self.Block_size

    @Message_size.setter
    def Message_size(self, value):
        self.Block_size = value



class _nmr1(printable):
    """
    The chemical shift is calculated by DFPT.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        controls the activation of the nmr calculation
        """
        self.Interpolate_shift = None
        """
        Calculate the soft part of the chemical shift by interpolation
        """
        self.Nics = None
        """
        Calculate the chemical shift in a set of points   given from an
        external file
        """
        self.Nics_file_name = None
        """
        Name of the file with the NICS points coordinates
        """
        self.Restart_nmr = None
        """
        Restart the NMR calculation from a previous run (NOT WORKING YET)
        """
        self.Shift_gapw_radius = None
        """
        While computing the local part of the shift (GAPW), the integration is
        restricted to nuclei that are within this radius.
        """
        self.PRINT = _print50()
        self.INTERPOLATOR = _interpolator9()
        self._name = "NMR"
        self._keywords = [('Interpolate_shift', 'INTERPOLATE_SHIFT'), ('Nics', 'NICS'), ('Nics_file_name', 'NICS_FILE_NAME'), ('Restart_nmr', 'RESTART_NMR'), ('Shift_gapw_radius', 'SHIFT_GAPW_RADIUS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT', 'PRINT'), ('INTERPOLATOR', 'INTERPOLATOR')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each219(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each218(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _linres1(printable):
    """
    The linear response is used to calculate one of the  following
    properties: nmr, epr, raman, ...
    """
    def __init__(self):
        self.Eps = None
        """
        target accuracy for the convergence of the conjugate gradient.
        """
        self.Max_iter = None
        """
        Maximum number of conjugate gradient iteration to be performed for one
        optimization.
        """
        self.Restart_every = None
        """
        Restart the conjugate gradient after the specified number of
        iterations.
        """
        self.Preconditioner = None
        """
        Type of preconditioner to be used with all minimization schemes. They
        differ in effectiveness, cost of construction, cost of application.
        Properly preconditioned minimization can be orders of magnitude faster
        than doing nothing.

        Available values:
            FULL_ALL
                Most effective state selective preconditioner based on
                diagonalization, requires the ENERGY_GAP parameter to be an
                underestimate of the HOMO-LUMO gap. This preconditioner is recommended
                for almost all systems, except very large systems where
                make_preconditioner would dominate the total computational cost.
            FULL_SINGLE_INVERSE
                Based on H-eS cholesky inversion, similar to FULL_SINGLE in
                preconditioning efficiency but cheaper to construct, might be somewhat
                less robust. Recommended for large systems.
            FULL_SINGLE
                Based on H-eS diagonalisation, not as good as FULL_ALL, but somewhat
                cheaper to apply.
            FULL_KINETIC
                Cholesky inversion of S and T, fast construction, robust, and
                relatively good, use for very large systems.
            FULL_S_INVERSE
                Cholesky inversion of S, not as good as FULL_KINETIC, yet equally
                expensive.
            SPARSE_DIAG
                Only based on atomic blocks, very cheap in construction but quite
                poor.
            SPARSE_KINETIC
                Toward -sparse- linear solver for T-eS.
            NONE
                skip preconditioning
        """
        self.Energy_gap = None
        """
        Energy gap estimate [a.u.] for preconditioning
        """
        self.Restart = None
        """
        Restart the response calculation if the restart file exists
        """
        self.Wfn_restart_file_name = None
        """
        Root of the file names where to read the response functions fromwhich
        to restart the calculation of the linear response
        """
        self.LOCALIZE = _localize3()
        self.CURRENT = _current1()
        self.NMR = _nmr1()
        self.SPINSPIN = _spinspin1()
        self.EPR = _epr1()
        self.PRINT = _print57()
        self._name = "LINRES"
        self._keywords = [('Eps', 'EPS'), ('Max_iter', 'MAX_ITER'), ('Restart_every', 'RESTART_EVERY'), ('Preconditioner', 'PRECONDITIONER'), ('Energy_gap', 'ENERGY_GAP'), ('Restart', 'RESTART'), ('Wfn_restart_file_name', 'WFN_RESTART_FILE_NAME')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('LOCALIZE', 'LOCALIZE'), ('CURRENT', 'CURRENT'), ('NMR', 'NMR'), ('SPINSPIN', 'SPINSPIN'), ('EPR', 'EPR'), ('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Restart_file_name(self):
        """
        See documentation for Wfn_restart_file_name
        """
        return self.Wfn_restart_file_name

    @Restart_file_name.setter
    def Restart_file_name(self, value):
        self.Wfn_restart_file_name = value



class _each215(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each214(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each217(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each216(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each211(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each210(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each213(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each212(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _gle4(printable):
    """
    paramameters of the gle thermostat. This section can be generated
    from http://gle4md.berlios.de/compose.php?page=matrix
    """
    def __init__(self):
        self.Ndim = None
        """
        Size of the gle matrix
        """
        self.A_scale = None
        """
        scaling factor for matrix A (for generic matrix A, depends on the
        characteristic frequency of the system).
        """
        self.list_A_list = []
        self.list_C_list = []
        self.THERMOSTAT_ENERGY = _thermostat_energy7()
        self.RNG_INIT = _rng_init7()
        self.S = _s4()
        self._name = "GLE"
        self._keywords = [('Ndim', 'NDIM'), ('A_scale', 'A_SCALE')]
        self._repeated_keywords = [('A_list', 'A_LIST'), ('C_list', 'C_LIST')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('THERMOSTAT_ENERGY', 'THERMOSTAT_ENERGY'), ('RNG_INIT', 'RNG_INIT'), ('S', 'S')]
        self._repeated_subsections = []

    def add_A_list(self, value):
        self.list_A_list.append(value)

    def add_C_list(self, value):
        self.list_C_list.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _nonperiodic_sys1(printable):
    """
    Specifies the parameter for sampling the RESP fitting points for non-
    periodic systems, i.e. systems that do not involve surfaces. This
    section can be used with periodic and nonperiodic Poisson solvers, it
    only affects the sampling of grid points. All grid points in the shell
    defined by rmin and rmax are accepted for fitting.
    """
    def __init__(self):
        self.X_low = None
        """
        Specifies the lower boundary of the box along X used to sample the
        potential.
        """
        self.X_hi = None
        """
        Specifies the upper boundary of the box along X used to sample the
        potential.
        """
        self.Y_low = None
        """
        Specifies the lower boundary of the box along Y used to sample the
        potential.
        """
        self.Y_hi = None
        """
        Specifies the upper boundary of the box along Y used to sample the
        potential.
        """
        self.Z_low = None
        """
        Specifies the lower boundary of the box along Z used to sample the
        potential.
        """
        self.Z_hi = None
        """
        Specifies the upper boundary of the box along Z used to sample the
        potential.
        """
        self.Rmax = None
        """
        Specifies the maximum distance a fit point is away from an atom. Valid
        for all atomic kinds for which no RMAX_KIND are specified.
        """
        self.Rmin = None
        """
        Specifies the minimum distance a fit point is away from an atom. Valid
        for all atomic kinds for which no RMIN_KIND are specified.
        """
        self.list_Rmax_kind = []
        self.list_Rmin_kind = []
        self._name = "NONPERIODIC_SYS"
        self._keywords = [('X_low', 'X_LOW'), ('X_hi', 'X_HI'), ('Y_low', 'Y_LOW'), ('Y_hi', 'Y_HI'), ('Z_low', 'Z_LOW'), ('Z_hi', 'Z_HI'), ('Rmax', 'RMAX'), ('Rmin', 'RMIN')]
        self._repeated_keywords = [('Rmax_kind', 'RMAX_KIND'), ('Rmin_kind', 'RMIN_KIND')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Rmax_kind(self, value):
        self.list_Rmax_kind.append(value)

    def add_Rmin_kind(self, value):
        self.list_Rmin_kind.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _thermostat_slow1(printable):
    """
    Specify thermostat type and parameters controlling the thermostat.
    """
    def __init__(self):
        self.Type = None
        """
        Specify the thermostat used for the constant temperature ensembles.

        Available values:
            NOSE
                Uses only the Nose-Hoover thermostat.
        """
        self.Region = None
        """
        Determines the defined region for slow thermostat

        Available values:
            GLOBAL
            MOLECULE
            MASSIVE
            DEFINED
            NONE
        """
        self.list_DEFINE_REGION = []
        self.NOSE = _nose5()
        self._name = "THERMOSTAT_SLOW"
        self._keywords = [('Type', 'TYPE'), ('Region', 'REGION')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('NOSE', 'NOSE')]
        self._repeated_subsections = [('DEFINE_REGION', '_define_region4')]

    def add_DEFINE_REGION(self):
        new_section = _define_region4()
        self.list_DEFINE_REGION.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _each329(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each328(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each321(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each320(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each323(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each322(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each325(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _bsse1(printable):
    """
    This section is used to set up the BSSE calculation. It also requires
    that for each atomic kind X a kind X_ghost is present, with the GHOST
    keyword specified, in addition to the other required fields.
    """
    def __init__(self):
        self.list_FRAGMENT = []
        self.list_CONFIGURATION = []
        self.list_FRAGMENT_ENERGIES = []
        self.PRINT = _print41()
        self._name = "BSSE"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT', 'PRINT')]
        self._repeated_subsections = [('FRAGMENT', '_fragment3'), ('CONFIGURATION', '_configuration1'), ('FRAGMENT_ENERGIES', '_fragment_energies1')]

    def add_FRAGMENT(self):
        new_section = _fragment3()
        self.list_FRAGMENT.append(new_section)
        return new_section

    def add_CONFIGURATION(self):
        new_section = _configuration1()
        self.list_CONFIGURATION.append(new_section)
        return new_section

    def add_FRAGMENT_ENERGIES(self):
        new_section = _fragment_energies1()
        self.list_FRAGMENT_ENERGIES.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _each327(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each326(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each101(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each100(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each103(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each102(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each105(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each104(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each107(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each106(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each109(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each108(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _energy5(printable):
    """
    Controls the output the ener file
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each33()
        self._name = "ENERGY"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _energy4(printable):
    """
    Controls the output of kinetic energy, and potential energy  of the
    defined thermostat.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each27()
        self._name = "ENERGY"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _energy7(printable):
    """
    Controls the output of the path integral energies
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each61()
        self._name = "ENERGY"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _energy6(printable):
    """
    Controls the output of the helium energies (averaged over MC step)
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each50()
        self._name = "ENERGY"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _energy1(printable):
    """
    Controls the output of kinetic energy, and potential energy  of the
    defined thermostat.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each20()
        self._name = "ENERGY"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _energy3(printable):
    """
    Controls the output of kinetic energy, and potential energy  of the
    defined thermostat.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each24()
        self._name = "ENERGY"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _energy2(printable):
    """
    Controls the output of kinetic energy, and potential energy  of the
    defined barostat.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each21()
        self._name = "ENERGY"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _energy9(printable):
    """
    Controls the printing of the various energies
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each255()
        self._name = "ENERGY"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _energy8(printable):
    """
    Controls the printing of the ENER file in a BAND run
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each70()
        self._name = "ENERGY"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _interpolator2(printable):
    """
    controls the interpolation for the G-space term
    """
    def __init__(self):
        self.Aint_precond = None
        """
        the approximate inverse to use to get the starting point for the
        linear solver of the spline3 methods

        Available values:
            COPY
            SPL3_NOPBC_AINT1
            SPL3_NOPBC_PRECOND1
            SPL3_NOPBC_AINT2
            SPL3_NOPBC_PRECOND2
            SPL3_NOPBC_PRECOND3
        """
        self.Precond = None
        """
        The preconditioner used for the linear solver of the spline3 methods

        Available values:
            COPY
            SPL3_NOPBC_AINT1
            SPL3_NOPBC_PRECOND1
            SPL3_NOPBC_AINT2
            SPL3_NOPBC_PRECOND2
            SPL3_NOPBC_PRECOND3
        """
        self.Eps_x = None
        """
        accuracy on the solution for spline3 the interpolators
        """
        self.Eps_r = None
        """
        accuracy on the residual for spline3 the interpolators
        """
        self.Max_iter = None
        """
        the maximum number of iterations
        """
        self.CONV_INFO = _conv_info2()
        self._name = "INTERPOLATOR"
        self._keywords = [('Aint_precond', 'AINT_PRECOND'), ('Precond', 'PRECOND'), ('Eps_x', 'EPS_X'), ('Eps_r', 'EPS_R'), ('Max_iter', 'MAX_ITER')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('CONV_INFO', 'CONV_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Maxiter(self):
        """
        See documentation for Max_iter
        """
        return self.Max_iter

    @Maxiter.setter
    def Maxiter(self, value):
        self.Max_iter = value



class _interpolator3(printable):
    """
    controls the interpolation for the G-space term
    """
    def __init__(self):
        self.Aint_precond = None
        """
        the approximate inverse to use to get the starting point for the
        linear solver of the spline3 methods

        Available values:
            COPY
            SPL3_NOPBC_AINT1
            SPL3_NOPBC_PRECOND1
            SPL3_NOPBC_AINT2
            SPL3_NOPBC_PRECOND2
            SPL3_NOPBC_PRECOND3
        """
        self.Precond = None
        """
        The preconditioner used for the linear solver of the spline3 methods

        Available values:
            COPY
            SPL3_NOPBC_AINT1
            SPL3_NOPBC_PRECOND1
            SPL3_NOPBC_AINT2
            SPL3_NOPBC_PRECOND2
            SPL3_NOPBC_PRECOND3
        """
        self.Eps_x = None
        """
        accuracy on the solution for spline3 the interpolators
        """
        self.Eps_r = None
        """
        accuracy on the residual for spline3 the interpolators
        """
        self.Max_iter = None
        """
        the maximum number of iterations
        """
        self.CONV_INFO = _conv_info3()
        self._name = "INTERPOLATOR"
        self._keywords = [('Aint_precond', 'AINT_PRECOND'), ('Precond', 'PRECOND'), ('Eps_x', 'EPS_X'), ('Eps_r', 'EPS_R'), ('Max_iter', 'MAX_ITER')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('CONV_INFO', 'CONV_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Maxiter(self):
        """
        See documentation for Max_iter
        """
        return self.Max_iter

    @Maxiter.setter
    def Maxiter(self, value):
        self.Max_iter = value



class _interpolator1(printable):
    """
    kind of interpolation used between the multigrids
    """
    def __init__(self):
        self.Kind = None
        """
        the interpolator to use

        Available values:
            PW
            SPLINE3_NOPBC
            SPLINE3
        """
        self.Safe_computation = None
        """
        if a non unrolled calculation is to be performed in parallel
        """
        self.Aint_precond = None
        """
        the approximate inverse to use to get the starting point for the
        linear solver of the spline3 methods

        Available values:
            COPY
            SPL3_NOPBC_AINT1
            SPL3_NOPBC_AINT2
            SPL3_NOPBC_PRECOND1
            SPL3_NOPBC_PRECOND2
            SPL3_NOPBC_PRECOND3
        """
        self.Precond = None
        """
        The preconditioner used for the linear solver of the spline3 methods

        Available values:
            COPY
            SPL3_NOPBC_AINT1
            SPL3_NOPBC_AINT2
            SPL3_NOPBC_PRECOND1
            SPL3_NOPBC_PRECOND2
            SPL3_NOPBC_PRECOND3
        """
        self.Eps_x = None
        """
        accuracy on the solution for spline3 the interpolators
        """
        self.Eps_r = None
        """
        accuracy on the residual for spline3 the interpolators
        """
        self.Max_iter = None
        """
        the maximum number of iterations
        """
        self.CONV_INFO = _conv_info1()
        self._name = "INTERPOLATOR"
        self._keywords = [('Kind', 'KIND'), ('Safe_computation', 'SAFE_COMPUTATION'), ('Aint_precond', 'AINT_PRECOND'), ('Precond', 'PRECOND'), ('Eps_x', 'EPS_X'), ('Eps_r', 'EPS_R'), ('Max_iter', 'MAX_ITER')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('CONV_INFO', 'CONV_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Maxiter(self):
        """
        See documentation for Max_iter
        """
        return self.Max_iter

    @Maxiter.setter
    def Maxiter(self, value):
        self.Max_iter = value



class _interpolator6(printable):
    """
    controls the interpolation for the G-space term
    """
    def __init__(self):
        self.Aint_precond = None
        """
        the approximate inverse to use to get the starting point for the
        linear solver of the spline3 methods

        Available values:
            COPY
            SPL3_NOPBC_AINT1
            SPL3_NOPBC_PRECOND1
            SPL3_NOPBC_AINT2
            SPL3_NOPBC_PRECOND2
            SPL3_NOPBC_PRECOND3
        """
        self.Precond = None
        """
        The preconditioner used for the linear solver of the spline3 methods

        Available values:
            COPY
            SPL3_NOPBC_AINT1
            SPL3_NOPBC_PRECOND1
            SPL3_NOPBC_AINT2
            SPL3_NOPBC_PRECOND2
            SPL3_NOPBC_PRECOND3
        """
        self.Eps_x = None
        """
        accuracy on the solution for spline3 the interpolators
        """
        self.Eps_r = None
        """
        accuracy on the residual for spline3 the interpolators
        """
        self.Max_iter = None
        """
        the maximum number of iterations
        """
        self.CONV_INFO = _conv_info6()
        self._name = "INTERPOLATOR"
        self._keywords = [('Aint_precond', 'AINT_PRECOND'), ('Precond', 'PRECOND'), ('Eps_x', 'EPS_X'), ('Eps_r', 'EPS_R'), ('Max_iter', 'MAX_ITER')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('CONV_INFO', 'CONV_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Maxiter(self):
        """
        See documentation for Max_iter
        """
        return self.Max_iter

    @Maxiter.setter
    def Maxiter(self, value):
        self.Max_iter = value



class _interpolator7(printable):
    """
    kind of interpolation used between the multigrids
    """
    def __init__(self):
        self.Kind = None
        """
        the interpolator to use

        Available values:
            SPLINE3_NOPBC
        """
        self.Safe_computation = None
        """
        if a non unrolled calculation is to be performed in parallel
        """
        self.Aint_precond = None
        """
        the approximate inverse to use to get the starting point for the
        linear solver of the spline3 methods

        Available values:
            COPY
            SPL3_NOPBC_AINT1
            SPL3_NOPBC_PRECOND1
            SPL3_NOPBC_AINT2
            SPL3_NOPBC_PRECOND2
            SPL3_NOPBC_PRECOND3
        """
        self.Precond = None
        """
        The preconditioner used for the linear solver of the spline3 methods

        Available values:
            COPY
            SPL3_NOPBC_AINT1
            SPL3_NOPBC_PRECOND1
            SPL3_NOPBC_AINT2
            SPL3_NOPBC_PRECOND2
            SPL3_NOPBC_PRECOND3
        """
        self.Eps_x = None
        """
        accuracy on the solution for spline3 the interpolators
        """
        self.Eps_r = None
        """
        accuracy on the residual for spline3 the interpolators
        """
        self.Max_iter = None
        """
        the maximum number of iterations
        """
        self.CONV_INFO = _conv_info7()
        self.SPL_COEFFS = _spl_coeffs1()
        self._name = "INTERPOLATOR"
        self._keywords = [('Kind', 'KIND'), ('Safe_computation', 'SAFE_COMPUTATION'), ('Aint_precond', 'AINT_PRECOND'), ('Precond', 'PRECOND'), ('Eps_x', 'EPS_X'), ('Eps_r', 'EPS_R'), ('Max_iter', 'MAX_ITER')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('CONV_INFO', 'CONV_INFO'), ('SPL_COEFFS', 'SPL_COEFFS')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Maxiter(self):
        """
        See documentation for Max_iter
        """
        return self.Max_iter

    @Maxiter.setter
    def Maxiter(self, value):
        self.Max_iter = value



class _interpolator4(printable):
    """
    controls the interpolation for the G-space term
    """
    def __init__(self):
        self.Aint_precond = None
        """
        the approximate inverse to use to get the starting point for the
        linear solver of the spline3 methods

        Available values:
            COPY
            SPL3_NOPBC_AINT1
            SPL3_NOPBC_PRECOND1
            SPL3_NOPBC_AINT2
            SPL3_NOPBC_PRECOND2
            SPL3_NOPBC_PRECOND3
        """
        self.Precond = None
        """
        The preconditioner used for the linear solver of the spline3 methods

        Available values:
            COPY
            SPL3_NOPBC_AINT1
            SPL3_NOPBC_PRECOND1
            SPL3_NOPBC_AINT2
            SPL3_NOPBC_PRECOND2
            SPL3_NOPBC_PRECOND3
        """
        self.Eps_x = None
        """
        accuracy on the solution for spline3 the interpolators
        """
        self.Eps_r = None
        """
        accuracy on the residual for spline3 the interpolators
        """
        self.Max_iter = None
        """
        the maximum number of iterations
        """
        self.CONV_INFO = _conv_info4()
        self._name = "INTERPOLATOR"
        self._keywords = [('Aint_precond', 'AINT_PRECOND'), ('Precond', 'PRECOND'), ('Eps_x', 'EPS_X'), ('Eps_r', 'EPS_R'), ('Max_iter', 'MAX_ITER')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('CONV_INFO', 'CONV_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Maxiter(self):
        """
        See documentation for Max_iter
        """
        return self.Max_iter

    @Maxiter.setter
    def Maxiter(self, value):
        self.Max_iter = value



class _interpolator5(printable):
    """
    controls the interpolation for the G-space term
    """
    def __init__(self):
        self.Aint_precond = None
        """
        the approximate inverse to use to get the starting point for the
        linear solver of the spline3 methods

        Available values:
            COPY
            SPL3_NOPBC_AINT1
            SPL3_NOPBC_PRECOND1
            SPL3_NOPBC_AINT2
            SPL3_NOPBC_PRECOND2
            SPL3_NOPBC_PRECOND3
        """
        self.Precond = None
        """
        The preconditioner used for the linear solver of the spline3 methods

        Available values:
            COPY
            SPL3_NOPBC_AINT1
            SPL3_NOPBC_PRECOND1
            SPL3_NOPBC_AINT2
            SPL3_NOPBC_PRECOND2
            SPL3_NOPBC_PRECOND3
        """
        self.Eps_x = None
        """
        accuracy on the solution for spline3 the interpolators
        """
        self.Eps_r = None
        """
        accuracy on the residual for spline3 the interpolators
        """
        self.Max_iter = None
        """
        the maximum number of iterations
        """
        self.CONV_INFO = _conv_info5()
        self._name = "INTERPOLATOR"
        self._keywords = [('Aint_precond', 'AINT_PRECOND'), ('Precond', 'PRECOND'), ('Eps_x', 'EPS_X'), ('Eps_r', 'EPS_R'), ('Max_iter', 'MAX_ITER')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('CONV_INFO', 'CONV_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Maxiter(self):
        """
        See documentation for Max_iter
        """
        return self.Max_iter

    @Maxiter.setter
    def Maxiter(self, value):
        self.Max_iter = value



class _interpolator8(printable):
    """
    kind of interpolation used between the multigrids
    """
    def __init__(self):
        self.Kind = None
        """
        the interpolator to use

        Available values:
            PW
            SPLINE3_NOPBC
            SPLINE3
        """
        self.Safe_computation = None
        """
        if a non unrolled calculation is to be performed in parallel
        """
        self.Aint_precond = None
        """
        the approximate inverse to use to get the starting point for the
        linear solver of the spline3 methods

        Available values:
            COPY
            SPL3_NOPBC_AINT1
            SPL3_NOPBC_AINT2
            SPL3_NOPBC_PRECOND1
            SPL3_NOPBC_PRECOND2
            SPL3_NOPBC_PRECOND3
        """
        self.Precond = None
        """
        The preconditioner used for the linear solver of the spline3 methods

        Available values:
            COPY
            SPL3_NOPBC_AINT1
            SPL3_NOPBC_AINT2
            SPL3_NOPBC_PRECOND1
            SPL3_NOPBC_PRECOND2
            SPL3_NOPBC_PRECOND3
        """
        self.Eps_x = None
        """
        accuracy on the solution for spline3 the interpolators
        """
        self.Eps_r = None
        """
        accuracy on the residual for spline3 the interpolators
        """
        self.Max_iter = None
        """
        the maximum number of iterations
        """
        self.CONV_INFO = _conv_info8()
        self._name = "INTERPOLATOR"
        self._keywords = [('Kind', 'KIND'), ('Safe_computation', 'SAFE_COMPUTATION'), ('Aint_precond', 'AINT_PRECOND'), ('Precond', 'PRECOND'), ('Eps_x', 'EPS_X'), ('Eps_r', 'EPS_R'), ('Max_iter', 'MAX_ITER')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('CONV_INFO', 'CONV_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Maxiter(self):
        """
        See documentation for Max_iter
        """
        return self.Max_iter

    @Maxiter.setter
    def Maxiter(self, value):
        self.Max_iter = value



class _ub1(printable):
    """
    Specifies the Urey-Bradley potential between the external atoms
    defining the angle
    """
    def __init__(self):
        self.Kind = None
        """
        Define the kind of Urey-Bradleypotential.

        Available values:
            HARMONIC
                Functional Form (HARMONIC|G87): 1/2*K*(R-R0)^2
            CHARMM
                Functional Form (CHARMM|AMBER): K*(R-R0)^2
            AMBER
                Functional Form (CHARMM|AMBER): K*(R-R0)^2
            G87
                Functional Form (HARMONIC|G87): 1/2*K*(R-R0)^2
            G96
                Functional Form (G96): 1/4*K*(R-R0)^2
            QUARTIC
                Functional Form (QUARTIC):
                (1/2*K1+[1/3*K2+1/4*K3*|R-R0|]*|R-R0|)(R-R0)^2
            MORSE
                Functional Form (MORSE): K1*[(1-exp(-K2*(R-R0)))^2-1])
            CUBIC
                Functional Form (CUBIC): K*(R-R0)^2*(1+cs*(R-R0)+7/12*(cs^2*(R-R0)^2))
            FUES
                Functional Form (FUES): 1/2*K*R0^2*(1+R0/R*(R0/R-2))
        """
        self.K = None
        """
        Defines the force constant of the potential. For QUARTIC potentials
        three numbers are expected.
        """
        self.Cs = None
        """
        Defines the cubic stretch term.
        """
        self.R0 = None
        """
        Defines the equilibrium distance.
        """
        self._name = "UB"
        self._keywords = [('Kind', 'KIND'), ('K', 'K'), ('Cs', 'CS'), ('R0', 'R0')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _adiabatic_rescaling4(printable):
    """
    Parameters for self interation corrected hybrid functionals
    """
    def __init__(self):
        self.Functional_type = None
        """
        Which Hybrid functional should be used. (Has to be consistent with the
        definitions in XC and HF).

        Available values:
            MCY3
                Use MCY3 hybrid functional
        """
        self.Lambda = None
        """
        The point to be used along the adiabatic curve (0<lambda<1)
        """
        self.Omega = None
        """
        Long-range parameter
        """
        self.Functional_model = None
        """
        Which model for the coupling constant integration should be used.

        Available values:
            PADE
                Use pade model: W(lambda)=a+(b*lambda)/(1+c*lambda)
        """
        self._name = "ADIABATIC_RESCALING"
        self._keywords = [('Functional_type', 'FUNCTIONAL_TYPE'), ('Lambda', 'LAMBDA'), ('Omega', 'OMEGA'), ('Functional_model', 'FUNCTIONAL_MODEL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _adiabatic_rescaling1(printable):
    """
    Parameters for self interation corrected hybrid functionals
    """
    def __init__(self):
        self.Functional_type = None
        """
        Which Hybrid functional should be used. (Has to be consistent with the
        definitions in XC and HF).

        Available values:
            MCY3
                Use MCY3 hybrid functional
        """
        self.Lambda = None
        """
        The point to be used along the adiabatic curve (0<lambda<1)
        """
        self.Omega = None
        """
        Long-range parameter
        """
        self.Functional_model = None
        """
        Which model for the coupling constant integration should be used.

        Available values:
            PADE
                Use pade model: W(lambda)=a+(b*lambda)/(1+c*lambda)
        """
        self._name = "ADIABATIC_RESCALING"
        self._keywords = [('Functional_type', 'FUNCTIONAL_TYPE'), ('Lambda', 'LAMBDA'), ('Omega', 'OMEGA'), ('Functional_model', 'FUNCTIONAL_MODEL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _adiabatic_rescaling3(printable):
    """
    Parameters for self interation corrected hybrid functionals
    """
    def __init__(self):
        self.Functional_type = None
        """
        Which Hybrid functional should be used. (Has to be consistent with the
        definitions in XC and HF).

        Available values:
            MCY3
                Use MCY3 hybrid functional
        """
        self.Lambda = None
        """
        The point to be used along the adiabatic curve (0<lambda<1)
        """
        self.Omega = None
        """
        Long-range parameter
        """
        self.Functional_model = None
        """
        Which model for the coupling constant integration should be used.

        Available values:
            PADE
                Use pade model: W(lambda)=a+(b*lambda)/(1+c*lambda)
        """
        self._name = "ADIABATIC_RESCALING"
        self._keywords = [('Functional_type', 'FUNCTIONAL_TYPE'), ('Lambda', 'LAMBDA'), ('Omega', 'OMEGA'), ('Functional_model', 'FUNCTIONAL_MODEL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _adiabatic_rescaling2(printable):
    """
    Parameters for self interation corrected hybrid functionals
    """
    def __init__(self):
        self.Functional_type = None
        """
        Which Hybrid functional should be used. (Has to be consistent with the
        definitions in XC and HF).

        Available values:
            MCY3
                Use MCY3 hybrid functional
        """
        self.Lambda = None
        """
        The point to be used along the adiabatic curve (0<lambda<1)
        """
        self.Omega = None
        """
        Long-range parameter
        """
        self.Functional_model = None
        """
        Which model for the coupling constant integration should be used.

        Available values:
            PADE
                Use pade model: W(lambda)=a+(b*lambda)/(1+c*lambda)
        """
        self._name = "ADIABATIC_RESCALING"
        self._keywords = [('Functional_type', 'FUNCTIONAL_TYPE'), ('Lambda', 'LAMBDA'), ('Omega', 'OMEGA'), ('Functional_model', 'FUNCTIONAL_MODEL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _rs_pw_transfer1(printable):
    """
    Describes how to benchmark the rs_pw_transfer routines.
    """
    def __init__(self):
        self.Grid = None
        """
        Specify the number of grid points (not all grid points are allowed)
        """
        self.Halo_size = None
        """
        number of grid points of the halo
        """
        self.N_loop = None
        """
        Number of rs_pw_transfers being timed
        """
        self.Rs2pw = None
        """
        should the direction be rs2pw (pw2rs otherwise)
        """
        self.list_RS_GRID = []
        self._name = "RS_PW_TRANSFER"
        self._keywords = [('Grid', 'GRID'), ('Halo_size', 'HALO_SIZE'), ('N_loop', 'N_LOOP'), ('Rs2pw', 'RS2PW')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('RS_GRID', '_rs_grid1')]

    def add_RS_GRID(self):
        new_section = _rs_grid1()
        self.list_RS_GRID.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _rho0_information1(printable):
    """
    If the printkey is activated controls if information on rho0 is
    printed.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.EACH = _each189()
        self._name = "RHO0_INFORMATION"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _detailed_energy1(printable):
    """
    Controls the printing of detailed energy information.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each97()
        self._name = "DETAILED_ENERGY"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _improper2(printable):
    """
    Section used to add/remove improper in the connectivity. Useful for
    systems with a complex connectivity, difficult to find out
    automatically.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        controls the activation of the bond

        Available values:
            ADD
            REMOVE
        """
        self.list_Atoms = []
        self._name = "IMPROPER"
        self._keywords = []
        self._repeated_keywords = [('Atoms', 'ATOMS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _improper1(printable):
    """
    Specifies the improper torsion potential of the MM system.
    """
    def __init__(self):
        self.Atoms = None
        """
        Defines the atomic kinds involved in the improper tors.
        """
        self.Kind = None
        """
        Define the kind of improper torsion potential

        Available values:
            CHARMM
                Functional Form (CHARMM): K * [ PHI - PHI0 ]**2
            G87
                Functional Form (G87|G96|HARMONIC): 0.5 * K * [ PHI - PHI0 ]**2
            G96
                Functional Form (G87|G96|HARMONIC): 0.5 * K * [ PHI - PHI0 ]**2
            HARMONIC
                Functional Form (G87|G96|HARMONIC): 0.5 * K * [ PHI - PHI0 ]**2
        """
        self.K = None
        """
        Defines the force constant of the potential
        """
        self.Phi0 = None
        """
        Defines the phase of the potential.
        """
        self._name = "IMPROPER"
        self._keywords = [('Atoms', 'ATOMS'), ('Kind', 'KIND'), ('K', 'K'), ('Phi0', 'PHI0')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _com1(printable):
    """
    Controls the output of the center of mass
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each65()
        self._name = "COM"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _pbe4(printable):
    """
    Uses the PBE functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Parametrization = None
        """
        switches between the different parametrizations of the functional

        Available values:
            ORIG
                original PBE
            REVPBE
                revised PBE (revPBE)
            PBESOL
                PBE for solids and surfaces (PBEsol)
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self.Scale_c = None
        """
        scales the correlation part of the functional
        """
        self._name = "PBE"
        self._keywords = [('Parametrization', 'PARAMETRIZATION'), ('Scale_x', 'SCALE_X'), ('Scale_c', 'SCALE_C')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each98(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each99(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each94(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each95(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each96(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each97(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each90(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each91(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each92(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each93(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _structure_data2(printable):
    """
    Request the printing of special structure data during a structure
    optimization (in MOTION%PRINT) or when setting up a subsys (in
    SUBSYS%PRINT).
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.list_Position = []
        self.list_Pos = self.list_Position
        self.list_Position_scaled = []
        self.list_Pos_scaled = self.list_Position_scaled
        self.list_Distance = []
        self.list_Dis = self.list_Distance
        self.list_Angle = []
        self.list_Ang = self.list_Angle
        self.list_Dihedral_angle = []
        self.list_Dihedral = self.list_Dihedral_angle
        self.list_Dih = self.list_Dihedral_angle
        self.EACH = _each278()
        self._name = "STRUCTURE_DATA"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT')]
        self._repeated_keywords = [('Position', 'POSITION'), ('Position_scaled', 'POSITION_SCALED'), ('Distance', 'DISTANCE'), ('Angle', 'ANGLE'), ('Dihedral_angle', 'DIHEDRAL_ANGLE')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def add_Position(self, value):
        self.list_Position.append(value)

    def add_Position_scaled(self, value):
        self.list_Position_scaled.append(value)

    def add_Distance(self, value):
        self.list_Distance.append(value)

    def add_Angle(self, value):
        self.list_Angle.append(value)

    def add_Dihedral_angle(self, value):
        self.list_Dihedral_angle.append(value)

    def add_Pos(self, value):
        self.list_DIHEDRAL_ANGLE.append(value)

    def add_Pos_scaled(self, value):
        self.list_DIHEDRAL_ANGLE.append(value)

    def add_Dis(self, value):
        self.list_DIHEDRAL_ANGLE.append(value)

    def add_Ang(self, value):
        self.list_DIHEDRAL_ANGLE.append(value)

    def add_Dihedral(self, value):
        self.list_DIHEDRAL_ANGLE.append(value)

    def add_Dih(self, value):
        self.list_DIHEDRAL_ANGLE.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _structure_data1(printable):
    """
    Request the printing of special structure data during a structure
    optimization (in MOTION%PRINT) or when setting up a subsys (in
    SUBSYS%PRINT).
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.list_Position = []
        self.list_Pos = self.list_Position
        self.list_Position_scaled = []
        self.list_Pos_scaled = self.list_Position_scaled
        self.list_Distance = []
        self.list_Dis = self.list_Distance
        self.list_Angle = []
        self.list_Ang = self.list_Angle
        self.list_Dihedral_angle = []
        self.list_Dihedral = self.list_Dihedral_angle
        self.list_Dih = self.list_Dihedral_angle
        self.EACH = _each79()
        self._name = "STRUCTURE_DATA"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT')]
        self._repeated_keywords = [('Position', 'POSITION'), ('Position_scaled', 'POSITION_SCALED'), ('Distance', 'DISTANCE'), ('Angle', 'ANGLE'), ('Dihedral_angle', 'DIHEDRAL_ANGLE')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def add_Position(self, value):
        self.list_Position.append(value)

    def add_Position_scaled(self, value):
        self.list_Position_scaled.append(value)

    def add_Distance(self, value):
        self.list_Distance.append(value)

    def add_Angle(self, value):
        self.list_Angle.append(value)

    def add_Dihedral_angle(self, value):
        self.list_Dihedral_angle.append(value)

    def add_Pos(self, value):
        self.list_DIHEDRAL_ANGLE.append(value)

    def add_Pos_scaled(self, value):
        self.list_DIHEDRAL_ANGLE.append(value)

    def add_Dis(self, value):
        self.list_DIHEDRAL_ANGLE.append(value)

    def add_Ang(self, value):
        self.list_DIHEDRAL_ANGLE.append(value)

    def add_Dihedral(self, value):
        self.list_DIHEDRAL_ANGLE.append(value)

    def add_Dih(self, value):
        self.list_DIHEDRAL_ANGLE.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _each66(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _rho1(printable):
    """
    Density distribution settings
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Whether or not to actually calculate densities (requires significant
        amount of memory, depending on the value of NBIN)
        """
        self.Nbin = None
        """
        Number of bins
        """
        self.Iweight = None
        """
        Weight the restarted density should be given (number of MC steps used
        to average the restarted density, negative value - the same weight as
        the run-time density, usually should not be changed)
        """
        self.CUBE_DATA = _cube_data1()
        self._name = "RHO"
        self._keywords = [('Nbin', 'NBIN'), ('Iweight', 'IWEIGHT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('CUBE_DATA', 'CUBE_DATA')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _rho2(printable):
    """
    Controls the output of the helium density (Gaussian cube file format)
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Backup_copies = None
        """
        Specifies the maximum number of backup copies.
        """
        self.EACH = _each54()
        self._name = "RHO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Backup_copies', 'BACKUP_COPIES')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _direct_canonical3(printable):
    """
    Parameters influencing the direct canonical method
    """
    def __init__(self):
        self.Big_send = None
        """
        Send big messages between processes (useful for >48 processors).
        """
        self._name = "DIRECT_CANONICAL"
        self._keywords = [('Big_send', 'BIG_SEND')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _direct_canonical2(printable):
    """
    Parameters influencing the direct canonical method
    """
    def __init__(self):
        self.Big_send = None
        """
        Send big messages between processes (useful for >48 processors).
        """
        self._name = "DIRECT_CANONICAL"
        self._keywords = [('Big_send', 'BIG_SEND')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _direct_canonical1(printable):
    """
    Parameters influencing the direct canonical method
    """
    def __init__(self):
        self.Big_send = None
        """
        Send big messages between processes (useful for >48 processors).
        """
        self._name = "DIRECT_CANONICAL"
        self._keywords = [('Big_send', 'BIG_SEND')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _direct_canonical4(printable):
    """
    Parameters influencing the direct canonical method
    """
    def __init__(self):
        self.Big_send = None
        """
        Send big messages between processes (useful for >48 processors).
        """
        self._name = "DIRECT_CANONICAL"
        self._keywords = [('Big_send', 'BIG_SEND')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _spline1(printable):
    """
    specifies parameters to set up the splines used in the nonboned
    interactions (both pair body potential and many body potential)
    """
    def __init__(self):
        self.R0_nb = None
        """
        Specify the minimum value of the distance interval  that brackets the
        value of emax_spline.
        """
        self.Rcut_nb = None
        """
        Cutoff radius for nonbonded interactions. This value overrides  the
        value specified in the potential definition and is global for all
        potentials.
        """
        self.Emax_spline = None
        """
        Specify the maximum value of the potential up to which splines will be
        constructed
        """
        self.Emax_accuracy = None
        """
        Specify the maximum value of energy used to check the accuracy
        requested through EPS_SPLINE. Energy values larger than EMAX_ACCURACY
        generally do not  satisfy the requested accuracy
        """
        self.Eps_spline = None
        """
        Specify the threshold for the choice of the number of points used in
        the splines (comparing the splined value with the  analytically
        evaluated one)
        """
        self.Npoints = None
        """
        Override the default search for an accurate spline by specifying a
        fixed number of spline points.
        """
        self.Unique_spline = None
        """
        For few potentials (Lennard-Jones) one global optimal spline is
        generated instead of different optimal splines for each kind of
        potential
        """
        self._name = "SPLINE"
        self._keywords = [('R0_nb', 'R0_NB'), ('Rcut_nb', 'RCUT_NB'), ('Emax_spline', 'EMAX_SPLINE'), ('Emax_accuracy', 'EMAX_ACCURACY'), ('Eps_spline', 'EPS_SPLINE'), ('Npoints', 'NPOINTS'), ('Unique_spline', 'UNIQUE_SPLINE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _bs1(printable):
    """
    Define the required atomic orbital occupation assigned in
    initialization of the density matrix, by adding or subtracting
    electrons from specific angular momentum channels. It works only with
    GUESS ATOMIC.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        controls the activation of the BS section
        """
        self.ALPHA = _alpha1()
        self.BETA = _beta1()
        self._name = "BS"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('ALPHA', 'ALPHA'), ('BETA', 'BETA')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _coordinates1(printable):
    """
    Controls the output of helium coordinates
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Format = None
        """
        Output file format for the coordinates

        Available values:
            PDB
                Bead coordinates and connectivity is written in PDB format
            XYZ
                Only bead coordinates are written in XYZ format
        """
        self.EACH = _each52()
        self._name = "COORDINATES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Format', 'FORMAT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _multipoles3(printable):
    """
    Specifies the dipoles and quadrupoles for particles.
    """
    def __init__(self):
        self.DIPOLES = _dipoles1()
        self.QUADRUPOLES = _quadrupoles1()
        self._name = "MULTIPOLES"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('DIPOLES', 'DIPOLES'), ('QUADRUPOLES', 'QUADRUPOLES')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _multipoles2(printable):
    """
    Enables the use of multipoles in the treatment of the electrostatics.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Controls the activation of the Multipoles
        """
        self.Max_multipole_expansion = None
        """
        Specify the maximum level of multipoles expansion used  for the
        electrostatics.

        Available values:
            NONE
                No multipolar terms! Check the codes providing a zero contribution.
            CHARGE
                Use up to the Charge term
            DIPOLE
                Use up to the Dipole term
            QUADRUPOLE
                Use up to the Quadrupole term
        """
        self.Pol_scf = None
        """
        Specify the method to obtain self consistent induced multipole
        moments.

        Available values:
            NONE
                No inducible multipoles.
            SELF_CONSISTENT
                Conventional self-consistent iteration.
            CONJUGATE_GRADIENT
                Linear conjugate-gradient optimization of the sum of the electrostatic
                and induction energy. This method does not support non-linear
                polarization but is sometimes faster.
        """
        self.Max_ipol_iter = None
        """
        Specify the maximum number of iterations for induced dipoles
        """
        self.Eps_pol = None
        """
        Specify the rmsd threshold for the derivatives of the energy towards
        the Cartesian dipoles components
        """
        self._name = "MULTIPOLES"
        self._keywords = [('Max_multipole_expansion', 'MAX_MULTIPOLE_EXPANSION'), ('Pol_scf', 'POL_SCF'), ('Max_ipol_iter', 'MAX_IPOL_ITER'), ('Eps_pol', 'EPS_POL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _p86c1(printable):
    """
    Uses the P86C functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_c = None
        """
        scales the correlation part of the functional
        """
        self._name = "P86C"
        self._keywords = [('Scale_c', 'SCALE_C')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _p86c2(printable):
    """
    Uses the P86C functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_c = None
        """
        scales the correlation part of the functional
        """
        self._name = "P86C"
        self._keywords = [('Scale_c', 'SCALE_C')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _velocity3(printable):
    """
    The velocities for NOSE HOOVER used for restart
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify velocities of the system
        """
        self._name = "VELOCITY"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _velocity4(printable):
    """
    The velocities for NOSE HOOVER used for restart
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify velocities of the system
        """
        self._name = "VELOCITY"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _velocity5(printable):
    """
    The velocities for NOSE HOOVER used for restart
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify velocities of the system
        """
        self._name = "VELOCITY"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _velocity6(printable):
    """
    The velocities for NOSE HOOVER used for restart
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify velocities of the system
        """
        self._name = "VELOCITY"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _velocity7(printable):
    """
    The velocities for BEADS used for restart
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify velocities of the system
        """
        self._name = "VELOCITY"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _velocity8(printable):
    """
    The velocities for NOSE used for restart
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify velocities of the system
        """
        self._name = "VELOCITY"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _velocity9(printable):
    """
    The velocities for BAND used for restart
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify velocities of the system
        """
        self._name = "VELOCITY"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _thermal_region1(printable):
    """
    Define regions where different initialization and control of the
    temperature is used.
    """
    def __init__(self):
        self.Force_rescaling = None
        """
        Control the rescaling ot the velocities in all the regions,  according
        to the temperature assigned to each reagion, when RESTART_VELOCITY in
        EXT_RESTART is active.
        """
        self.list_DEFINE_REGION = []
        self.PRINT = _print11()
        self._name = "THERMAL_REGION"
        self._keywords = [('Force_rescaling', 'FORCE_RESCALING')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PRINT', 'PRINT')]
        self._repeated_subsections = [('DEFINE_REGION', '_define_region6')]

    def add_DEFINE_REGION(self):
        new_section = _define_region6()
        self.list_DEFINE_REGION.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _point8(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point9(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point6(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point7(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point4(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point5(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point2(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point3(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point1(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _print_specific_e_density_cube1(printable):
    """
    Controls the printing of cube files with the electronic density
    (states) contributing to the density of states within the specific
    energy range (MIN_ENERGY<= E <=MAX_ENERGY). MIN_ENERGY and MAX_ENERGY
    need to be specified explicitly.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Stride = None
        """
        The stride (X,Y,Z) used to write the cube file (larger values result
        in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1
        number valid for all components.
        """
        self.Min_energy = None
        """
        Lower bounds of the energy ranges of interest.
        """
        self.Max_energy = None
        """
        Upper bounds of the energy ranges of interest.
        """
        self.EACH = _each104()
        self._name = "PRINT_SPECIFIC_E_DENSITY_CUBE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Stride', 'STRIDE'), ('Min_energy', 'MIN_ENERGY'), ('Max_energy', 'MAX_ENERGY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _linear1(printable):
    """
    Linear combination between two force_eval:  F= lambda F1 + (1-lambda)
    F2
    """
    def __init__(self):
        self.Lambda = None
        """
        Specify the mixing parameter lambda in the formula:
        """
        self._name = "LINEAR"
        self._keywords = [('Lambda', 'LAMBDA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _tot_density_cube1(printable):
    """
    Controls printing of cube files with the total density
    (electrons+atomic core). Note that the value of the total density is
    positive where the electron density dominates and negative where the
    core is.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Stride = None
        """
        The stride (X,Y,Z) used to write the cube file (larger values result
        in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1
        number valid for all components.
        """
        self.Append = None
        """
        append the cube files when they already exist
        """
        self.EACH = _each193()
        self._name = "TOT_DENSITY_CUBE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Stride', 'STRIDE'), ('Append', 'APPEND')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _spawned_hills_pos1(printable):
    """
    The position of the spawned hills during metadynamics.Used for
    RESTART.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify the spawned hills
        """
        self._name = "SPAWNED_HILLS_POS"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _replica1(printable):
    """
    Specify coordinates and velocities (possibly) of the replica
    """
    def __init__(self):
        self.Collective = None
        """
        Specifies the value of the collective variables used in the projected
        BAND method. The order of the values is the order of the COLLECTIVE
        section in the constraints/restraints section
        """
        self.Coord_file_name = None
        """
        Name of the xyz file with coordinates (alternative to &COORD section)
        """
        self.COORD = _coord9()
        self.VELOCITY = _velocity9()
        self._name = "REPLICA"
        self._keywords = [('Collective', 'COLLECTIVE'), ('Coord_file_name', 'COORD_FILE_NAME')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('COORD', 'COORD'), ('VELOCITY', 'VELOCITY')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _mc1(printable):
    """
    This section sets parameters to set up a MonteCarlo calculation.
    """
    def __init__(self):
        self.Nstep = None
        """
        Specifies the number of MC cycles.
        """
        self.Iprint = None
        """
        Prints coordinate/cell/etc information every IPRINT steps.
        """
        self.Nmoves = None
        """
        Specifies the number of classical moves between energy evaluations.
        """
        self.Nswapmoves = None
        """
        How many insertions to try per swap move.
        """
        self.Lbias = None
        """
        Dictates if we presample moves with a different potential.
        """
        self.Lstop = None
        """
        Makes nstep in terms of steps, instead of cycles.
        """
        self.Ldiscrete = None
        """
        Changes the volume of the box in discrete steps, one side at a time.
        """
        self.Restart = None
        """
        Read initial configuration from restart file.
        """
        self.Iupvolume = None
        """
        Every iupvolume steps update maximum volume displacement.
        """
        self.Iuptrans = None
        """
        Every iuptrans steps update maximum translation.
        """
        self.Nvirial = None
        """
        Use this many random orientations to compute the second virial
        coefficient (ENSEMBLE=VIRIAL)
        """
        self.Ensemble = None
        """
        Specify the type of simulation

        Available values:
            TRADITIONAL
            GEMC_NVT
            GEMC_NPT
            VIRIAL
        """
        self.Restart_file_name = None
        """
        Name of the restart file for MC information.
        """
        self.Moves_file_name = None
        """
        The file to print the move statistics to.
        """
        self.Molecules_file_name = None
        """
        The file to print the number of molecules to.
        """
        self.Coordinate_file_name = None
        """
        The file to print the current coordinates to.
        """
        self.Energy_file_name = None
        """
        The file to print current energies to.
        """
        self.Data_file_name = None
        """
        The file to print current configurational info to.
        """
        self.Cell_file_name = None
        """
        The file to print current cell length info to.
        """
        self.Max_disp_file_name = None
        """
        The file to print current maximum displacement info to.
        """
        self.Box2_file_name = None
        """
        For GEMC, the name of the input file for the other box.
        """
        self.Pressure = None
        """
        The pressure for NpT simulations, in bar.
        """
        self.Temperature = None
        """
        The temperature of the simulation, in Kelvin.
        """
        self.Pmswap = None
        """
        The probability of attempting a swap move.
        """
        self.Pmswap_mol = None
        """
        The probability of attempting a molecule swap of a given molecule
        type.
        """
        self.Pmhmc = None
        """
        The probability of attempting a hybrid MC move.
        """
        self.Pmhmc_box = None
        """
        The probability of attempting a HMC move on this box.
        """
        self.Pmvolume = None
        """
        The probability of attempting a volume move.
        """
        self.Pmvol_box = None
        """
        The probability of attempting a volume move on this box (GEMC_NpT).
        """
        self.Pmrot_mol = None
        """
        The probability of attempting a molecule rotation of a given molecule
        type.
        """
        self.Pmtraion = None
        """
        The probability of attempting a conformational change.
        """
        self.Pmtraion_mol = None
        """
        The probability of attempting a conformational change of a given
        molecule type.
        """
        self.Pmtrans = None
        """
        The probability of attempting a molecule translation.
        """
        self.Pmtrans_mol = None
        """
        The probability of attempting a molecule translation of a given
        molecule type.
        """
        self.Rmvolume = None
        """
        Maximum volume displacement, in angstrom**3.
        """
        self.Avbmc_atom = None
        """
        The target atom for an AVBMC swap move for each molecule type.
        """
        self.Rmbond = None
        """
        Maximum bond length displacement, in angstroms, for each molecule
        type.
        """
        self.Rmangle = None
        """
        Maximum bond angle displacement, in degrees, for each molecule type.
        """
        self.Rmdihedral = None
        """
        Maximum dihedral angle distplacement, in degrees, for each molecule
        type.
        """
        self.Rmrot = None
        """
        Maximum rotational displacement, in degrees, for each molecule type.
        """
        self.Rmtrans = None
        """
        Maximum translational displacement, in angstroms, for each molecule
        type.
        """
        self.Virial_temps = None
        """
        The temperatures you wish to compute the virial coefficient for.  Only
        used if ensemble=VIRIAL.
        """
        self.Avbmc_rmin = None
        """
        The inner radius for an AVBMC swap move, in angstroms for every
        molecule type.
        """
        self.Avbmc_rmax = None
        """
        The outer radius for an AVBMC swap move, in angstroms, for every
        molecule type.
        """
        self.Pmavbmc = None
        """
        The probability of attempting an AVBMC swap move.
        """
        self.Pmavbmc_mol = None
        """
        The probability of attempting an AVBMC swap move on each molecule
        type.
        """
        self.Pbias = None
        """
        The probability of swapping to an inner region in an AVBMC swap move
        for each molecule type.
        """
        self.Discrete_step = None
        """
        The size of the discrete volume move step, in angstroms.
        """
        self.Eta = None
        """
        The free energy bias (in Kelvin) for swapping a molecule of each type
        into this box.
        """
        self.Randomtoskip = None
        """
        Number of random numbers from the acceptance/rejection stream to skip
        """
        self._name = "MC"
        self._keywords = [('Nstep', 'NSTEP'), ('Iprint', 'IPRINT'), ('Nmoves', 'NMOVES'), ('Nswapmoves', 'NSWAPMOVES'), ('Lbias', 'LBIAS'), ('Lstop', 'LSTOP'), ('Ldiscrete', 'LDISCRETE'), ('Restart', 'RESTART'), ('Iupvolume', 'IUPVOLUME'), ('Iuptrans', 'IUPTRANS'), ('Nvirial', 'NVIRIAL'), ('Ensemble', 'ENSEMBLE'), ('Restart_file_name', 'RESTART_FILE_NAME'), ('Moves_file_name', 'MOVES_FILE_NAME'), ('Molecules_file_name', 'MOLECULES_FILE_NAME'), ('Coordinate_file_name', 'COORDINATE_FILE_NAME'), ('Energy_file_name', 'ENERGY_FILE_NAME'), ('Data_file_name', 'DATA_FILE_NAME'), ('Cell_file_name', 'CELL_FILE_NAME'), ('Max_disp_file_name', 'MAX_DISP_FILE_NAME'), ('Box2_file_name', 'BOX2_FILE_NAME'), ('Pressure', 'PRESSURE'), ('Temperature', 'TEMPERATURE'), ('Pmswap', 'PMSWAP'), ('Pmswap_mol', 'PMSWAP_MOL'), ('Pmhmc', 'PMHMC'), ('Pmhmc_box', 'PMHMC_BOX'), ('Pmvolume', 'PMVOLUME'), ('Pmvol_box', 'PMVOL_BOX'), ('Pmrot_mol', 'PMROT_MOL'), ('Pmtraion', 'PMTRAION'), ('Pmtraion_mol', 'PMTRAION_MOL'), ('Pmtrans', 'PMTRANS'), ('Pmtrans_mol', 'PMTRANS_MOL'), ('Rmvolume', 'RMVOLUME'), ('Avbmc_atom', 'AVBMC_ATOM'), ('Rmbond', 'RMBOND'), ('Rmangle', 'RMANGLE'), ('Rmdihedral', 'RMDIHEDRAL'), ('Rmrot', 'RMROT'), ('Rmtrans', 'RMTRANS'), ('Virial_temps', 'VIRIAL_TEMPS'), ('Avbmc_rmin', 'AVBMC_RMIN'), ('Avbmc_rmax', 'AVBMC_RMAX'), ('Pmavbmc', 'PMAVBMC'), ('Pmavbmc_mol', 'PMAVBMC_MOL'), ('Pbias', 'PBIAS'), ('Discrete_step', 'DISCRETE_STEP'), ('Eta', 'ETA'), ('Randomtoskip', 'RANDOMTOSKIP')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _interatomic_distances1(printable):
    """
    controls the output of the interatomic distances when setting up
    theforce environment
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.EACH = _each279()
        self._name = "INTERATOMIC_DISTANCES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _restart9(printable):
    """
    Controls the dumping of the restart file during BSSE runs.By default
    the restart is updated after each configuration calculation is
    completed.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each266()
        self._name = "RESTART"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _restart8(printable):
    """
    Controls the dumping of the MO restart file during rtp.By default
    keeps a short history of three restarts.See also RESTART_HISTORY
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Backup_copies = None
        """
        Specifies the maximum index of backup copies.
        """
        self.EACH = _each177()
        self._name = "RESTART"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Backup_copies', 'BACKUP_COPIES')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _cuda1(printable):
    """
    For CUDA support related input
    """
    def __init__(self):
        self.Memory = None
        """
        Allocates this much device memory (in kB)
        """
        self._name = "CUDA"
        self._keywords = [('Memory', 'MEMORY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _restart5(printable):
    """
    Controls the dumping of the restart file during runs. By default keeps
    a short history of three restarts. See also RESTART_HISTORY
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Backup_copies = None
        """
        Specifies the maximum number of backup copies.
        """
        self.Split_restart_file = None
        """
        If specified selected input sections, which are growing with the
        number of atoms in the system, are written to another restart file in
        binary format instead of the default restart file in human readable
        ASCII format. This split of the restart file may provide significant
        memory savings and an accelerated I/O for systems with a very large
        number of atoms
        """
        self.EACH = _each86()
        self._name = "RESTART"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Backup_copies', 'BACKUP_COPIES'), ('Split_restart_file', 'SPLIT_RESTART_FILE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _restart4(printable):
    """
    Controls the printing of Hessian Restart file
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each16()
        self._name = "RESTART"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _restart7(printable):
    """
    Controls the dumping of MO restart file during the scfof a Core-Level-
    Spectroscopy calculation. For each new excited atom,one different
    restart file is dumped. These restart files should beemployed only to
    restart the same type of CLS calculation, i.e. with the same core
    potential.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each163()
        self._name = "RESTART"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _restart6(printable):
    """
    Controls the dumping of the MO restart file during scf.By default
    keeps a short history of three restarts.See also RESTART_HISTORY
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Backup_copies = None
        """
        Specifies the maximum index of backup copies.
        """
        self.EACH = _each91()
        self._name = "RESTART"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Backup_copies', 'BACKUP_COPIES')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _restart1(printable):
    """
    Controls the printing of Hessian Restart file
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each8()
        self._name = "RESTART"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _neighbor_lists7(printable):
    """
    Activates the printing of the neighbor lists used for the hysteretic
    region calculations.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.EACH = _each233()
        self._name = "NEIGHBOR_LISTS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _restart3(printable):
    """
    Controls the printing of Hessian Restart file
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each13()
        self._name = "RESTART"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _restart2(printable):
    """
    Controls the printing of Hessian Restart file
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each9()
        self._name = "RESTART"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _nose4(printable):
    """
    paramameters of the Nose Hoover thermostat chain
    """
    def __init__(self):
        self.Length = None
        """
        length of the Nose-Hoover chain
        """
        self.Yoshida = None
        """
        order of the yoshida integretor usef for the thermostat
        """
        self.Timecon = None
        """
        timeconstant of the thermostat chain
        """
        self.Mts = None
        """
        number of multiple timesteps to be used for the NoseHoover chain
        """
        self.COORD = _coord4()
        self.VELOCITY = _velocity5()
        self.MASS = _mass8()
        self.FORCE = _force4()
        self._name = "NOSE"
        self._keywords = [('Length', 'LENGTH'), ('Yoshida', 'YOSHIDA'), ('Timecon', 'TIMECON'), ('Mts', 'MTS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('COORD', 'COORD'), ('VELOCITY', 'VELOCITY'), ('MASS', 'MASS'), ('FORCE', 'FORCE')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Multiple_time_steps(self):
        """
        See documentation for Mts
        """
        return self.Mts

    @property
    def Mult_t_steps(self):
        """
        See documentation for Mts
        """
        return self.Mts

    @Multiple_time_steps.setter
    def Multiple_time_steps(self, value):
        self.Mts = value

    @Mult_t_steps.setter
    def Mult_t_steps(self, value):
        self.Mts = value



class _neighbor_lists6(printable):
    """
    Activates the printing of the neighbor lists.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.EACH = _each225()
        self._name = "NEIGHBOR_LISTS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _screening8(printable):
    """
    Sets up screening parameters if requested
    """
    def __init__(self):
        self.Eps_schwarz = None
        """
        Screens the near field part of the electronic repulsion integrals
        using the Schwarz inequality for the given threshold.
        """
        self.Eps_schwarz_forces = None
        """
        Screens the near field part of the electronic repulsion integrals
        using the Schwarz inequality for the given threshold. This will be
        approximately the accuracy of the forces,  and should normally be
        similar to EPS_SCF
        """
        self.Screen_p_forces = None
        """
        Screens the electronic repulsion integrals for the forces using the
        density matrix. This results in a significant speedup for large
        systems, but might require a somewhat tigher EPS_SCHWARZ_FORCES.
        """
        self.Screen_on_initial_p = None
        """
        Screen on an initial density matrix. For the first MD step this matrix
        must be provided by a Restart File.
        """
        self.P_screen_correction_factor = None
        """
        Recalculates integrals on the fly if the actual density matrix is
        larger by a given factor than the initial one. If the factor is set to
        0.0_dp, this feature is disbled.
        """
        self._name = "SCREENING"
        self._keywords = [('Eps_schwarz', 'EPS_SCHWARZ'), ('Eps_schwarz_forces', 'EPS_SCHWARZ_FORCES'), ('Screen_p_forces', 'SCREEN_P_FORCES'), ('Screen_on_initial_p', 'SCREEN_ON_INITIAL_P'), ('P_screen_correction_factor', 'P_SCREEN_CORRECTION_FACTOR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _screening9(printable):
    """
    Sets up screening parameters if requested
    """
    def __init__(self):
        self.Eps_schwarz = None
        """
        Screens the near field part of the electronic repulsion integrals
        using the Schwarz inequality for the given threshold.
        """
        self.Eps_schwarz_forces = None
        """
        Screens the near field part of the electronic repulsion integrals
        using the Schwarz inequality for the given threshold. This will be
        approximately the accuracy of the forces,  and should normally be
        similar to EPS_SCF
        """
        self.Screen_p_forces = None
        """
        Screens the electronic repulsion integrals for the forces using the
        density matrix. This results in a significant speedup for large
        systems, but might require a somewhat tigher EPS_SCHWARZ_FORCES.
        """
        self.Screen_on_initial_p = None
        """
        Screen on an initial density matrix. For the first MD step this matrix
        must be provided by a Restart File.
        """
        self.P_screen_correction_factor = None
        """
        Recalculates integrals on the fly if the actual density matrix is
        larger by a given factor than the initial one. If the factor is set to
        0.0_dp, this feature is disbled.
        """
        self._name = "SCREENING"
        self._keywords = [('Eps_schwarz', 'EPS_SCHWARZ'), ('Eps_schwarz_forces', 'EPS_SCHWARZ_FORCES'), ('Screen_p_forces', 'SCREEN_P_FORCES'), ('Screen_on_initial_p', 'SCREEN_ON_INITIAL_P'), ('P_screen_correction_factor', 'P_SCREEN_CORRECTION_FACTOR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _nose5(printable):
    """
    paramameters of the Nose Hoover thermostat chain
    """
    def __init__(self):
        self.Length = None
        """
        length of the Nose-Hoover chain
        """
        self.Yoshida = None
        """
        order of the yoshida integretor usef for the thermostat
        """
        self.Timecon = None
        """
        timeconstant of the thermostat chain
        """
        self.Mts = None
        """
        number of multiple timesteps to be used for the NoseHoover chain
        """
        self.COORD = _coord5()
        self.VELOCITY = _velocity6()
        self.MASS = _mass9()
        self.FORCE = _force5()
        self._name = "NOSE"
        self._keywords = [('Length', 'LENGTH'), ('Yoshida', 'YOSHIDA'), ('Timecon', 'TIMECON'), ('Mts', 'MTS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('COORD', 'COORD'), ('VELOCITY', 'VELOCITY'), ('MASS', 'MASS'), ('FORCE', 'FORCE')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Multiple_time_steps(self):
        """
        See documentation for Mts
        """
        return self.Mts

    @property
    def Mult_t_steps(self):
        """
        See documentation for Mts
        """
        return self.Mts

    @Multiple_time_steps.setter
    def Multiple_time_steps(self, value):
        self.Mts = value

    @Mult_t_steps.setter
    def Mult_t_steps(self, value):
        self.Mts = value



class _angle_plane_plane3(printable):
    """
    This section defines the angle between two planes as a collective
    variables.
    """
    def __init__(self):
        self.list_PLANE = []
        self.list_POINT = []
        self._name = "ANGLE_PLANE_PLANE"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('PLANE', '_plane3'), ('POINT', '_point44')]

    def add_PLANE(self):
        new_section = _plane3()
        self.list_PLANE.append(new_section)
        return new_section

    def add_POINT(self):
        new_section = _point44()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _screening5(printable):
    """
    Sets up screening parameters if requested
    """
    def __init__(self):
        self.Eps_schwarz = None
        """
        Screens the near field part of the electronic repulsion integrals
        using the Schwarz inequality for the given threshold.
        """
        self.Eps_schwarz_forces = None
        """
        Screens the near field part of the electronic repulsion integrals
        using the Schwarz inequality for the given threshold. This will be
        approximately the accuracy of the forces,  and should normally be
        similar to EPS_SCF
        """
        self.Screen_p_forces = None
        """
        Screens the electronic repulsion integrals for the forces using the
        density matrix. This results in a significant speedup for large
        systems, but might require a somewhat tigher EPS_SCHWARZ_FORCES.
        """
        self.Screen_on_initial_p = None
        """
        Screen on an initial density matrix. For the first MD step this matrix
        must be provided by a Restart File.
        """
        self.P_screen_correction_factor = None
        """
        Recalculates integrals on the fly if the actual density matrix is
        larger by a given factor than the initial one. If the factor is set to
        0.0_dp, this feature is disbled.
        """
        self._name = "SCREENING"
        self._keywords = [('Eps_schwarz', 'EPS_SCHWARZ'), ('Eps_schwarz_forces', 'EPS_SCHWARZ_FORCES'), ('Screen_p_forces', 'SCREEN_P_FORCES'), ('Screen_on_initial_p', 'SCREEN_ON_INITIAL_P'), ('P_screen_correction_factor', 'P_SCREEN_CORRECTION_FACTOR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _angle_plane_plane1(printable):
    """
    This section defines the angle between two planes as a collective
    variables.
    """
    def __init__(self):
        self.list_PLANE = []
        self.list_POINT = []
        self._name = "ANGLE_PLANE_PLANE"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('PLANE', '_plane1'), ('POINT', '_point8')]

    def add_PLANE(self):
        new_section = _plane1()
        self.list_PLANE.append(new_section)
        return new_section

    def add_POINT(self):
        new_section = _point8()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _screening7(printable):
    """
    Sets up screening parameters if requested
    """
    def __init__(self):
        self.Eps_schwarz = None
        """
        Screens the near field part of the electronic repulsion integrals
        using the Schwarz inequality for the given threshold.
        """
        self.Eps_schwarz_forces = None
        """
        Screens the near field part of the electronic repulsion integrals
        using the Schwarz inequality for the given threshold. This will be
        approximately the accuracy of the forces,  and should normally be
        similar to EPS_SCF
        """
        self.Screen_p_forces = None
        """
        Screens the electronic repulsion integrals for the forces using the
        density matrix. This results in a significant speedup for large
        systems, but might require a somewhat tigher EPS_SCHWARZ_FORCES.
        """
        self.Screen_on_initial_p = None
        """
        Screen on an initial density matrix. For the first MD step this matrix
        must be provided by a Restart File.
        """
        self.P_screen_correction_factor = None
        """
        Recalculates integrals on the fly if the actual density matrix is
        larger by a given factor than the initial one. If the factor is set to
        0.0_dp, this feature is disbled.
        """
        self._name = "SCREENING"
        self._keywords = [('Eps_schwarz', 'EPS_SCHWARZ'), ('Eps_schwarz_forces', 'EPS_SCHWARZ_FORCES'), ('Screen_p_forces', 'SCREEN_P_FORCES'), ('Screen_on_initial_p', 'SCREEN_ON_INITIAL_P'), ('P_screen_correction_factor', 'P_SCREEN_CORRECTION_FACTOR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _screening1(printable):
    """
    Setup parameters for the tapering of the Coulomb/Exchange Screening in
    KDSO-D integral scheme,
    """
    def __init__(self):
        self.Rc_taper = None
        """
        Atomic Cutoff Radius Cutoff for Tapering the screening term.
        """
        self.Rc_range = None
        """
        Range of cutoff switch function (tapering):
        0.5*(1-TANH((r-r0)/RC_RANGE)), where r0=2*RC_TAPER-20*RC_RANGE.
        """
        self._name = "SCREENING"
        self._keywords = [('Rc_taper', 'RC_TAPER'), ('Rc_range', 'RC_RANGE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _screening2(printable):
    """
    Sets up screening parameters if requested
    """
    def __init__(self):
        self.Eps_schwarz = None
        """
        Screens the near field part of the electronic repulsion integrals
        using the Schwarz inequality for the given threshold.
        """
        self.Eps_schwarz_forces = None
        """
        Screens the near field part of the electronic repulsion integrals
        using the Schwarz inequality for the given threshold. This will be
        approximately the accuracy of the forces,  and should normally be
        similar to EPS_SCF
        """
        self.Screen_p_forces = None
        """
        Screens the electronic repulsion integrals for the forces using the
        density matrix. This results in a significant speedup for large
        systems, but might require a somewhat tigher EPS_SCHWARZ_FORCES.
        """
        self.Screen_on_initial_p = None
        """
        Screen on an initial density matrix. For the first MD step this matrix
        must be provided by a Restart File.
        """
        self.P_screen_correction_factor = None
        """
        Recalculates integrals on the fly if the actual density matrix is
        larger by a given factor than the initial one. If the factor is set to
        0.0_dp, this feature is disbled.
        """
        self._name = "SCREENING"
        self._keywords = [('Eps_schwarz', 'EPS_SCHWARZ'), ('Eps_schwarz_forces', 'EPS_SCHWARZ_FORCES'), ('Screen_p_forces', 'SCREEN_P_FORCES'), ('Screen_on_initial_p', 'SCREEN_ON_INITIAL_P'), ('P_screen_correction_factor', 'P_SCREEN_CORRECTION_FACTOR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _angle_plane_plane4(printable):
    """
    This section defines the angle between two planes as a collective
    variables.
    """
    def __init__(self):
        self.list_PLANE = []
        self.list_POINT = []
        self._name = "ANGLE_PLANE_PLANE"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('PLANE', '_plane4'), ('POINT', '_point62')]

    def add_PLANE(self):
        new_section = _plane4()
        self.list_PLANE.append(new_section)
        return new_section

    def add_POINT(self):
        new_section = _point62()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _neighbor_lists3(printable):
    """
    Activates the printing of the neighbor lists used for the periodic SE
    calculations.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.EACH = _each108()
        self._name = "NEIGHBOR_LISTS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _helium1(printable):
    """
    The section that controls optional helium solvent environment (highly
    experimental, not for general use yet)
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Whether or not to actually use this section
        """
        self.Helium_only = None
        """
        Simulate helium solvent only, disregard solute entirely
        """
        self.Num_env = None
        """
        Number of independent helium environments (only for restarts, do not
        set explicitly)
        """
        self.Potential_file_name = None
        """
        Name of the Helium interaction potential file
        """
        self.Natoms = None
        """
        Number of helium atoms
        """
        self.Nbeads = None
        """
        Number of helium path integral beads
        """
        self.Inorot = None
        """
        Number of MC iterations at the same time slice(s)
        """
        self.Irot = None
        """
        how often to reselect the time slice(s) to work on
        """
        self.Bisection = None
        """
        how many time slices to change at once (+1). Must be a power of 2
        currently
        """
        self.Max_perm_cycle = None
        """
        how large cyclic permutations to try
        """
        self.Periodic = None
        """
        Use periodic boundary conditions for helium
        """
        self.Cell_size = None
        """
        PBC unit cell size (NOTE 1: density, number of atoms and volume are
        interdependent - give only two of them; NOTE 2: for small cell sizes
        specify NATOMS instead)
        """
        self.Cell_shape = None
        """
        PBC unit cell shape for helium

        Available values:
            CUBE
            OCTAHEDRON
        """
        self.Density = None
        """
        trial density of helium for determining the helium box size
        """
        self.Presample = None
        """
        Presample He coordinates before first PIMD step
        """
        self.Drop_unused_envs = None
        """
        Drop He environments if N_restart > N_runtime (Warning: this will
        cause data loss in the restart file!)
        """
        self.M_SAMPLING = _m_sampling1()
        self.RDF = _rdf1()
        self.RHO = _rho1()
        self.COORD = _coord8()
        self.PERM = _perm1()
        self.FORCE = _force6()
        self.RNG_STATE = _rng_state1()
        self.PRINT = _print14()
        self._name = "HELIUM"
        self._keywords = [('Helium_only', 'HELIUM_ONLY'), ('Num_env', 'NUM_ENV'), ('Potential_file_name', 'POTENTIAL_FILE_NAME'), ('Natoms', 'NATOMS'), ('Nbeads', 'NBEADS'), ('Inorot', 'INOROT'), ('Irot', 'IROT'), ('Bisection', 'BISECTION'), ('Max_perm_cycle', 'MAX_PERM_CYCLE'), ('Periodic', 'PERIODIC'), ('Cell_size', 'CELL_SIZE'), ('Cell_shape', 'CELL_SHAPE'), ('Density', 'DENSITY'), ('Presample', 'PRESAMPLE'), ('Drop_unused_envs', 'DROP_UNUSED_ENVS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('M_SAMPLING', 'M-SAMPLING'), ('RDF', 'RDF'), ('RHO', 'RHO'), ('COORD', 'COORD'), ('PERM', 'PERM'), ('FORCE', 'FORCE'), ('RNG_STATE', 'RNG_STATE'), ('PRINT', 'PRINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _neighbor_lists2(printable):
    """
    This section specifies the input parameters for the construction of
    neighbor lists.
    """
    def __init__(self):
        self.Verlet_skin = None
        """
        Defines the Verlet Skin for the generation of the neighbor lists
        """
        self.Neighbor_lists_from_scratch = None
        """
        This keyword enables the building of the neighbouring list from
        scratch.
        """
        self.Geo_check = None
        """
        This keyword enables the check that two atoms are never below the
        minimum value used to construct the splines during the construction of
        the neighbouring list. Disabling this keyword avoids CP2K to abort in
        case two atoms are below the minimum  value of the radius used to
        generate the splines.
        """
        self._name = "NEIGHBOR_LISTS"
        self._keywords = [('Verlet_skin', 'VERLET_SKIN'), ('Neighbor_lists_from_scratch', 'NEIGHBOR_LISTS_FROM_SCRATCH'), ('Geo_check', 'GEO_CHECK')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _xc_functional3(printable):
    """
    The xc functional to use
    """
    def __init__(self):
        self.Section_parameters = None
        """
        shorcut for the most commont functionals combinations

        Available values:
            B3LYP
            PBE0
            BLYP
            BP
            PADE
            PBE
            TPSS
            HCTH120
            OLYP
            NO_SHORTCUT
            NONE
        """
        self.BECKE88 = _becke883()
        self.LYP_ADIABATIC = _lyp_adiabatic3()
        self.BECKE88_LR_ADIABATIC = _becke88_lr_adiabatic3()
        self.BECKE88_LR = _becke88_lr3()
        self.LYP = _lyp3()
        self.PADE = _pade3()
        self.list_HCTH = []
        self.OPTX = _optx3()
        self.LIBXC = _libxc3()
        self.KE_LIBXC = _ke_libxc3()
        self.CS1 = _cs13()
        self.list_XGGA = []
        self.list_KE_GGA = []
        self.P86C = _p86c3()
        self.list_PW92 = []
        self.list_PZ81 = []
        self.TFW = _tfw3()
        self.TF = _tf3()
        self.VWN = _vwn3()
        self.list_XALPHA = []
        self.TPSS = _tpss3()
        self.PBE = _pbe3()
        self.XWPBE = _xwpbe3()
        self.BECKE97 = _becke973()
        self.BECKE_ROUSSEL = _becke_roussel3()
        self.LDA_HOLE_T_C_LR = _lda_hole_t_c_lr3()
        self.PBE_HOLE_T_C_LR = _pbe_hole_t_c_lr3()
        self.GV09 = _gv093()
        self._name = "XC_FUNCTIONAL"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('BECKE88', 'BECKE88'), ('LYP_ADIABATIC', 'LYP_ADIABATIC'), ('BECKE88_LR_ADIABATIC', 'BECKE88_LR_ADIABATIC'), ('BECKE88_LR', 'BECKE88_LR'), ('LYP', 'LYP'), ('PADE', 'PADE'), ('OPTX', 'OPTX'), ('LIBXC', 'LIBXC'), ('KE_LIBXC', 'KE_LIBXC'), ('CS1', 'CS1'), ('P86C', 'P86C'), ('TFW', 'TFW'), ('TF', 'TF'), ('VWN', 'VWN'), ('TPSS', 'TPSS'), ('PBE', 'PBE'), ('XWPBE', 'XWPBE'), ('BECKE97', 'BECKE97'), ('BECKE_ROUSSEL', 'BECKE_ROUSSEL'), ('LDA_HOLE_T_C_LR', 'LDA_HOLE_T_C_LR'), ('PBE_HOLE_T_C_LR', 'PBE_HOLE_T_C_LR'), ('GV09', 'GV09')]
        self._repeated_subsections = [('HCTH', '_hcth3'), ('XGGA', '_xgga3'), ('KE_GGA', '_ke_gga3'), ('PW92', '_pw923'), ('PZ81', '_pz813'), ('XALPHA', '_xalpha3')]

    def add_HCTH(self):
        new_section = _hcth3()
        self.list_HCTH.append(new_section)
        return new_section

    def add_XGGA(self):
        new_section = _xgga3()
        self.list_XGGA.append(new_section)
        return new_section

    def add_KE_GGA(self):
        new_section = _ke_gga3()
        self.list_KE_GGA.append(new_section)
        return new_section

    def add_PW92(self):
        new_section = _pw923()
        self.list_PW92.append(new_section)
        return new_section

    def add_PZ81(self):
        new_section = _pz813()
        self.list_PZ81.append(new_section)
        return new_section

    def add_XALPHA(self):
        new_section = _xalpha3()
        self.list_XALPHA.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _xc_functional2(printable):
    """
    The xc functional to use
    """
    def __init__(self):
        self.Section_parameters = None
        """
        shorcut for the most commont functionals combinations

        Available values:
            B3LYP
            PBE0
            BLYP
            BP
            PADE
            PBE
            TPSS
            HCTH120
            OLYP
            NO_SHORTCUT
            NONE
        """
        self.BECKE88 = _becke882()
        self.LYP_ADIABATIC = _lyp_adiabatic2()
        self.BECKE88_LR_ADIABATIC = _becke88_lr_adiabatic2()
        self.BECKE88_LR = _becke88_lr2()
        self.LYP = _lyp2()
        self.PADE = _pade2()
        self.list_HCTH = []
        self.OPTX = _optx2()
        self.LIBXC = _libxc2()
        self.KE_LIBXC = _ke_libxc2()
        self.CS1 = _cs12()
        self.list_XGGA = []
        self.list_KE_GGA = []
        self.P86C = _p86c2()
        self.list_PW92 = []
        self.list_PZ81 = []
        self.TFW = _tfw2()
        self.TF = _tf2()
        self.VWN = _vwn2()
        self.list_XALPHA = []
        self.TPSS = _tpss2()
        self.PBE = _pbe2()
        self.XWPBE = _xwpbe2()
        self.BECKE97 = _becke972()
        self.BECKE_ROUSSEL = _becke_roussel2()
        self.LDA_HOLE_T_C_LR = _lda_hole_t_c_lr2()
        self.PBE_HOLE_T_C_LR = _pbe_hole_t_c_lr2()
        self.GV09 = _gv092()
        self._name = "XC_FUNCTIONAL"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('BECKE88', 'BECKE88'), ('LYP_ADIABATIC', 'LYP_ADIABATIC'), ('BECKE88_LR_ADIABATIC', 'BECKE88_LR_ADIABATIC'), ('BECKE88_LR', 'BECKE88_LR'), ('LYP', 'LYP'), ('PADE', 'PADE'), ('OPTX', 'OPTX'), ('LIBXC', 'LIBXC'), ('KE_LIBXC', 'KE_LIBXC'), ('CS1', 'CS1'), ('P86C', 'P86C'), ('TFW', 'TFW'), ('TF', 'TF'), ('VWN', 'VWN'), ('TPSS', 'TPSS'), ('PBE', 'PBE'), ('XWPBE', 'XWPBE'), ('BECKE97', 'BECKE97'), ('BECKE_ROUSSEL', 'BECKE_ROUSSEL'), ('LDA_HOLE_T_C_LR', 'LDA_HOLE_T_C_LR'), ('PBE_HOLE_T_C_LR', 'PBE_HOLE_T_C_LR'), ('GV09', 'GV09')]
        self._repeated_subsections = [('HCTH', '_hcth2'), ('XGGA', '_xgga2'), ('KE_GGA', '_ke_gga2'), ('PW92', '_pw922'), ('PZ81', '_pz812'), ('XALPHA', '_xalpha2')]

    def add_HCTH(self):
        new_section = _hcth2()
        self.list_HCTH.append(new_section)
        return new_section

    def add_XGGA(self):
        new_section = _xgga2()
        self.list_XGGA.append(new_section)
        return new_section

    def add_KE_GGA(self):
        new_section = _ke_gga2()
        self.list_KE_GGA.append(new_section)
        return new_section

    def add_PW92(self):
        new_section = _pw922()
        self.list_PW92.append(new_section)
        return new_section

    def add_PZ81(self):
        new_section = _pz812()
        self.list_PZ81.append(new_section)
        return new_section

    def add_XALPHA(self):
        new_section = _xalpha2()
        self.list_XALPHA.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _xc_functional1(printable):
    """
    The xc functional to use
    """
    def __init__(self):
        self.Section_parameters = None
        """
        shorcut for the most commont functionals combinations

        Available values:
            B3LYP
            PBE0
            BLYP
            BP
            PADE
            PBE
            TPSS
            HCTH120
            OLYP
            NO_SHORTCUT
            NONE
        """
        self.BECKE88 = _becke881()
        self.LYP_ADIABATIC = _lyp_adiabatic1()
        self.BECKE88_LR_ADIABATIC = _becke88_lr_adiabatic1()
        self.BECKE88_LR = _becke88_lr1()
        self.LYP = _lyp1()
        self.PADE = _pade1()
        self.list_HCTH = []
        self.OPTX = _optx1()
        self.LIBXC = _libxc1()
        self.KE_LIBXC = _ke_libxc1()
        self.CS1 = _cs11()
        self.list_XGGA = []
        self.list_KE_GGA = []
        self.P86C = _p86c1()
        self.list_PW92 = []
        self.list_PZ81 = []
        self.TFW = _tfw1()
        self.TF = _tf1()
        self.VWN = _vwn1()
        self.list_XALPHA = []
        self.TPSS = _tpss1()
        self.PBE = _pbe1()
        self.XWPBE = _xwpbe1()
        self.BECKE97 = _becke971()
        self.BECKE_ROUSSEL = _becke_roussel1()
        self.LDA_HOLE_T_C_LR = _lda_hole_t_c_lr1()
        self.PBE_HOLE_T_C_LR = _pbe_hole_t_c_lr1()
        self.GV09 = _gv091()
        self._name = "XC_FUNCTIONAL"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('BECKE88', 'BECKE88'), ('LYP_ADIABATIC', 'LYP_ADIABATIC'), ('BECKE88_LR_ADIABATIC', 'BECKE88_LR_ADIABATIC'), ('BECKE88_LR', 'BECKE88_LR'), ('LYP', 'LYP'), ('PADE', 'PADE'), ('OPTX', 'OPTX'), ('LIBXC', 'LIBXC'), ('KE_LIBXC', 'KE_LIBXC'), ('CS1', 'CS1'), ('P86C', 'P86C'), ('TFW', 'TFW'), ('TF', 'TF'), ('VWN', 'VWN'), ('TPSS', 'TPSS'), ('PBE', 'PBE'), ('XWPBE', 'XWPBE'), ('BECKE97', 'BECKE97'), ('BECKE_ROUSSEL', 'BECKE_ROUSSEL'), ('LDA_HOLE_T_C_LR', 'LDA_HOLE_T_C_LR'), ('PBE_HOLE_T_C_LR', 'PBE_HOLE_T_C_LR'), ('GV09', 'GV09')]
        self._repeated_subsections = [('HCTH', '_hcth1'), ('XGGA', '_xgga1'), ('KE_GGA', '_ke_gga1'), ('PW92', '_pw921'), ('PZ81', '_pz811'), ('XALPHA', '_xalpha1')]

    def add_HCTH(self):
        new_section = _hcth1()
        self.list_HCTH.append(new_section)
        return new_section

    def add_XGGA(self):
        new_section = _xgga1()
        self.list_XGGA.append(new_section)
        return new_section

    def add_KE_GGA(self):
        new_section = _ke_gga1()
        self.list_KE_GGA.append(new_section)
        return new_section

    def add_PW92(self):
        new_section = _pw921()
        self.list_PW92.append(new_section)
        return new_section

    def add_PZ81(self):
        new_section = _pz811()
        self.list_PZ81.append(new_section)
        return new_section

    def add_XALPHA(self):
        new_section = _xalpha1()
        self.list_XALPHA.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _nose1(printable):
    """
    paramameters of the Nose Hoover thermostat chain
    """
    def __init__(self):
        self.Length = None
        """
        length of the Nose-Hoover chain
        """
        self.Yoshida = None
        """
        order of the yoshida integretor usef for the thermostat
        """
        self.Timecon = None
        """
        timeconstant of the thermostat chain
        """
        self.Mts = None
        """
        number of multiple timesteps to be used for the NoseHoover chain
        """
        self.COORD = _coord1()
        self.VELOCITY = _velocity2()
        self.MASS = _mass2()
        self.FORCE = _force1()
        self._name = "NOSE"
        self._keywords = [('Length', 'LENGTH'), ('Yoshida', 'YOSHIDA'), ('Timecon', 'TIMECON'), ('Mts', 'MTS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('COORD', 'COORD'), ('VELOCITY', 'VELOCITY'), ('MASS', 'MASS'), ('FORCE', 'FORCE')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Multiple_time_steps(self):
        """
        See documentation for Mts
        """
        return self.Mts

    @property
    def Mult_t_steps(self):
        """
        See documentation for Mts
        """
        return self.Mts

    @Multiple_time_steps.setter
    def Multiple_time_steps(self, value):
        self.Mts = value

    @Mult_t_steps.setter
    def Mult_t_steps(self, value):
        self.Mts = value



class _nose2(printable):
    """
    paramameters of the Nose Hoover thermostat chain
    """
    def __init__(self):
        self.Length = None
        """
        length of the Nose-Hoover chain
        """
        self.Yoshida = None
        """
        order of the yoshida integretor usef for the thermostat
        """
        self.Timecon = None
        """
        timeconstant of the thermostat chain
        """
        self.Mts = None
        """
        number of multiple timesteps to be used for the NoseHoover chain
        """
        self.COORD = _coord2()
        self.VELOCITY = _velocity3()
        self.MASS = _mass4()
        self.FORCE = _force2()
        self._name = "NOSE"
        self._keywords = [('Length', 'LENGTH'), ('Yoshida', 'YOSHIDA'), ('Timecon', 'TIMECON'), ('Mts', 'MTS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('COORD', 'COORD'), ('VELOCITY', 'VELOCITY'), ('MASS', 'MASS'), ('FORCE', 'FORCE')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Multiple_time_steps(self):
        """
        See documentation for Mts
        """
        return self.Mts

    @property
    def Mult_t_steps(self):
        """
        See documentation for Mts
        """
        return self.Mts

    @Multiple_time_steps.setter
    def Multiple_time_steps(self, value):
        self.Mts = value

    @Mult_t_steps.setter
    def Mult_t_steps(self, value):
        self.Mts = value



class _gold4(printable):
    """
    Provides parameters to tune the line search for the gold search.
    """
    def __init__(self):
        self.Initial_step = None
        """
        Initial step size used, e.g. for bracketing or minimizers. Might need
        to be reduced for systems with close contacts
        """
        self.Brack_limit = None
        """
        Limit in 1D bracketing during line search in Conjugate Gradients
        Optimization.
        """
        self.Brent_tol = None
        """
        Tolerance requested during Brent line search in Conjugate Gradients
        Optimization.
        """
        self.Brent_max_iter = None
        """
        Maximum number of iterations in brent algorithm (used for the line
        search in Conjugated Gradients Optimization)
        """
        self._name = "GOLD"
        self._keywords = [('Initial_step', 'INITIAL_STEP'), ('Brack_limit', 'BRACK_LIMIT'), ('Brent_tol', 'BRENT_TOL'), ('Brent_max_iter', 'BRENT_MAX_ITER')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _nose3(printable):
    """
    paramameters of the Nose Hoover thermostat chain
    """
    def __init__(self):
        self.Length = None
        """
        length of the Nose-Hoover chain
        """
        self.Yoshida = None
        """
        order of the yoshida integretor usef for the thermostat
        """
        self.Timecon = None
        """
        timeconstant of the thermostat chain
        """
        self.Mts = None
        """
        number of multiple timesteps to be used for the NoseHoover chain
        """
        self.COORD = _coord3()
        self.VELOCITY = _velocity4()
        self.MASS = _mass6()
        self.FORCE = _force3()
        self._name = "NOSE"
        self._keywords = [('Length', 'LENGTH'), ('Yoshida', 'YOSHIDA'), ('Timecon', 'TIMECON'), ('Mts', 'MTS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('COORD', 'COORD'), ('VELOCITY', 'VELOCITY'), ('MASS', 'MASS'), ('FORCE', 'FORCE')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Multiple_time_steps(self):
        """
        See documentation for Mts
        """
        return self.Mts

    @property
    def Mult_t_steps(self):
        """
        See documentation for Mts
        """
        return self.Mts

    @Multiple_time_steps.setter
    def Multiple_time_steps(self, value):
        self.Mts = value

    @Mult_t_steps.setter
    def Mult_t_steps(self, value):
        self.Mts = value



class _gold1(printable):
    """
    Provides parameters to tune the line search for the gold search.
    """
    def __init__(self):
        self.Initial_step = None
        """
        Initial step size used, e.g. for bracketing or minimizers. Might need
        to be reduced for systems with close contacts
        """
        self.Brack_limit = None
        """
        Limit in 1D bracketing during line search in Conjugate Gradients
        Optimization.
        """
        self.Brent_tol = None
        """
        Tolerance requested during Brent line search in Conjugate Gradients
        Optimization.
        """
        self.Brent_max_iter = None
        """
        Maximum number of iterations in brent algorithm (used for the line
        search in Conjugated Gradients Optimization)
        """
        self._name = "GOLD"
        self._keywords = [('Initial_step', 'INITIAL_STEP'), ('Brack_limit', 'BRACK_LIMIT'), ('Brent_tol', 'BRENT_TOL'), ('Brent_max_iter', 'BRENT_MAX_ITER')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _dft1(printable):
    """
    parameter needed by dft programs
    """
    def __init__(self):
        self.list_Basis_set_file_name = []
        self.Potential_file_name = None
        """
        Name of the pseudo potential file, may include a path
        """
        self.Geminal_file_name = None
        """
        Name of the geminal basis set file, may include a path
        """
        self.Wfn_restart_file_name = None
        """
        Name of the wavefunction restart file, may include a path. If no file
        is specified, the default is to open the file as generated by the wfn
        restart print key.
        """
        self.Uks = None
        """
        Requests a spin-polarized calculation using alpha and beta orbitals,
        i.e. no spin restriction is applied
        """
        self.Roks = None
        """
        Requests a restricted open Kohn-Sham calculation
        """
        self.Multiplicity = None
        """
        Two times the total spin plus one. Specify 3 for a triplet, 4 for a
        quartet, and so on. Default is 1 (singlet) for an even number and 2
        (doublet) for an odd number of electrons.
        """
        self.Charge = None
        """
        The total charge of the system
        """
        self.Excitations = None
        """
        If excitations should be calculated

        Available values:
            NONE
            TDLR
            TDDFPT
        """
        self.Plus_u_method = None
        """
        Method employed for the calculation of the DFT+U contribution

        Available values:
            LOWDIN
                Method based on Lowdin population analysis (computationally expensive,
                since the diagonalization of the overlap matrix is required, but
                possibly more robust than Mulliken)
            MULLIKEN
                Method based on Mulliken population analysis using the net AO and
                overlap populations (computationally cheap method)
            MULLIKEN_CHARGES
                Method based on Mulliken gross orbital populations (GOP)
        """
        self.Relax_multiplicity = None
        """
        Do not enforce the occupation of alpha and beta MOs due to the
        initially defined multiplicity, but rather follow an Aufbau principle.
        A threshold value greater than zero activates this option. Larger
        threshold values increase the probability for a spin flip. This option
        is only valid for unrestricted (i.e. spin polarised) Kohn-Sham (UKS)
        calculations.
        """
        self.Subcells = None
        """
        Read the grid size for subcell generation in the construction of
        neighbor lists.
        """
        self.SCF = _scf1()
        self.LS_SCF = _ls_scf1()
        self.KG_METHOD = _kg_method1()
        self.SCP = _scp1()
        self.AUXILIARY_DENSITY_MATRIX_METHOD = _auxiliary_density_matrix_method1()
        self.QS = _qs1()
        self.TDDFPT = _tddfpt1()
        self.MGRID = _mgrid1()
        self.XC = _xc2()
        self.RELATIVISTIC = _relativistic1()
        self.SIC = _sic2()
        self.LOW_SPIN_ROKS = _low_spin_roks1()
        self.list_EFIELD = []
        self.list_PERIODIC_EFIELD = []
        self.EXTERNAL_POTENTIAL = _external_potential2()
        self.POISSON = _poisson1()
        self.SCRF = _scrf1()
        self.DENSITY_FITTING = _density_fitting1()
        self.XAS = _xas1()
        self.LOCALIZE = _localize2()
        self.REAL_TIME_PROPAGATION = _real_time_propagation1()
        self.PRINT = _print34()
        self._name = "DFT"
        self._keywords = [('Potential_file_name', 'POTENTIAL_FILE_NAME'), ('Geminal_file_name', 'GEMINAL_FILE_NAME'), ('Wfn_restart_file_name', 'WFN_RESTART_FILE_NAME'), ('Uks', 'UKS'), ('Roks', 'ROKS'), ('Multiplicity', 'MULTIPLICITY'), ('Charge', 'CHARGE'), ('Excitations', 'EXCITATIONS'), ('Plus_u_method', 'PLUS_U_METHOD'), ('Relax_multiplicity', 'RELAX_MULTIPLICITY'), ('Subcells', 'SUBCELLS')]
        self._repeated_keywords = [('Basis_set_file_name', 'BASIS_SET_FILE_NAME')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('SCF', 'SCF'), ('LS_SCF', 'LS_SCF'), ('KG_METHOD', 'KG_METHOD'), ('SCP', 'SCP'), ('AUXILIARY_DENSITY_MATRIX_METHOD', 'AUXILIARY_DENSITY_MATRIX_METHOD'), ('QS', 'QS'), ('TDDFPT', 'TDDFPT'), ('MGRID', 'MGRID'), ('XC', 'XC'), ('RELATIVISTIC', 'RELATIVISTIC'), ('SIC', 'SIC'), ('LOW_SPIN_ROKS', 'LOW_SPIN_ROKS'), ('EXTERNAL_POTENTIAL', 'EXTERNAL_POTENTIAL'), ('POISSON', 'POISSON'), ('SCRF', 'SCRF'), ('DENSITY_FITTING', 'DENSITY_FITTING'), ('XAS', 'XAS'), ('LOCALIZE', 'LOCALIZE'), ('REAL_TIME_PROPAGATION', 'REAL_TIME_PROPAGATION'), ('PRINT', 'PRINT')]
        self._repeated_subsections = [('EFIELD', '_efield1'), ('PERIODIC_EFIELD', '_periodic_efield1')]

    def add_EFIELD(self):
        new_section = _efield1()
        self.list_EFIELD.append(new_section)
        return new_section

    def add_PERIODIC_EFIELD(self):
        new_section = _periodic_efield1()
        self.list_PERIODIC_EFIELD.append(new_section)
        return new_section

    def add_Basis_set_file_name(self, value):
        self.list_Basis_set_file_name.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Restart_file_name(self):
        """
        See documentation for Wfn_restart_file_name
        """
        return self.Wfn_restart_file_name

    @property
    def Unrestricted_kohn_sham(self):
        """
        See documentation for Uks
        """
        return self.Uks

    @property
    def Lsd(self):
        """
        See documentation for Uks
        """
        return self.Uks

    @property
    def Spin_polarized(self):
        """
        See documentation for Uks
        """
        return self.Uks

    @property
    def Restricted_open_kohn_sham(self):
        """
        See documentation for Roks
        """
        return self.Roks

    @property
    def Multip(self):
        """
        See documentation for Multiplicity
        """
        return self.Multiplicity

    @property
    def Relax_multip(self):
        """
        See documentation for Relax_multiplicity
        """
        return self.Relax_multiplicity

    @Restart_file_name.setter
    def Restart_file_name(self, value):
        self.Wfn_restart_file_name = value

    @Unrestricted_kohn_sham.setter
    def Unrestricted_kohn_sham(self, value):
        self.Uks = value

    @Lsd.setter
    def Lsd(self, value):
        self.Uks = value

    @Spin_polarized.setter
    def Spin_polarized(self, value):
        self.Uks = value

    @Restricted_open_kohn_sham.setter
    def Restricted_open_kohn_sham(self, value):
        self.Roks = value

    @Multip.setter
    def Multip(self, value):
        self.Multiplicity = value

    @Relax_multip.setter
    def Relax_multip(self, value):
        self.Relax_multiplicity = value



class _gold3(printable):
    """
    Provides parameters to tune the line search for the gold search.
    """
    def __init__(self):
        self.Initial_step = None
        """
        Initial step size used, e.g. for bracketing or minimizers. Might need
        to be reduced for systems with close contacts
        """
        self.Brack_limit = None
        """
        Limit in 1D bracketing during line search in Conjugate Gradients
        Optimization.
        """
        self.Brent_tol = None
        """
        Tolerance requested during Brent line search in Conjugate Gradients
        Optimization.
        """
        self.Brent_max_iter = None
        """
        Maximum number of iterations in brent algorithm (used for the line
        search in Conjugated Gradients Optimization)
        """
        self._name = "GOLD"
        self._keywords = [('Initial_step', 'INITIAL_STEP'), ('Brack_limit', 'BRACK_LIMIT'), ('Brent_tol', 'BRENT_TOL'), ('Brent_max_iter', 'BRENT_MAX_ITER')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _gold2(printable):
    """
    Provides parameters to tune the line search for the gold search.
    """
    def __init__(self):
        self.Initial_step = None
        """
        Initial step size used, e.g. for bracketing or minimizers. Might need
        to be reduced for systems with close contacts
        """
        self.Brack_limit = None
        """
        Limit in 1D bracketing during line search in Conjugate Gradients
        Optimization.
        """
        self.Brent_tol = None
        """
        Tolerance requested during Brent line search in Conjugate Gradients
        Optimization.
        """
        self.Brent_max_iter = None
        """
        Maximum number of iterations in brent algorithm (used for the line
        search in Conjugated Gradients Optimization)
        """
        self._name = "GOLD"
        self._keywords = [('Initial_step', 'INITIAL_STEP'), ('Brack_limit', 'BRACK_LIMIT'), ('Brent_tol', 'BRENT_TOL'), ('Brent_max_iter', 'BRENT_MAX_ITER')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _force_eval2(printable):
    """
    parameters needed to calculate energy and forces and describe the
    system you want to analyze.
    """
    def __init__(self):
        self.Method = None
        """
        Which method should be used to compute forces

        Available values:
            QS
                Electronic structure methods (DFT, ...)
            FIST
                Molecular Mechanics
            QMMM
                Hybrid quantum classical
            EIP
                Empirical Interatomic Potential
            QUICKSTEP
                Electronic structure methods (DFT, ...)
            EP
                Non-orthogonal perturbation
            MIXED
                Use a combination of two of the above
        """
        self.Stress_tensor = None
        """
        Controls the calculation of the stress tensor. The combinations
        defined below are not implemented for all methods.

        Available values:
            NONE
                Do not compute stress tensor
            ANALYTICAL
                Compute the stress tensor analytical (if available).
            NUMERICAL
                Compute the stress tensor numerically.
            DIAGONAL_ANALYTICAL
                Compute the diagonal part only of the stress tensor analytical (if
                available).
            DIAGONAL_NUMERICAL
                Compute the diagonal part only of the stress tensor numerically
        """
        self.list_EXTERNAL_POTENTIAL = []
        self.RESCALE_FORCES = _rescale_forces1()
        self.MIXED = _mixed1()
        self.DFT = _dft1()
        self.MM = _mm1()
        self.QMMM = _qmmm1()
        self.EP = _ep1()
        self.EIP = _eip1()
        self.BSSE = _bsse1()
        self.SUBSYS = _subsys1()
        self.PROPERTIES = _properties1()
        self.PRINT = _print60()
        self._name = "FORCE_EVAL"
        self._keywords = [('Method', 'METHOD'), ('Stress_tensor', 'STRESS_TENSOR')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('RESCALE_FORCES', 'RESCALE_FORCES'), ('MIXED', 'MIXED'), ('DFT', 'DFT'), ('MM', 'MM'), ('QMMM', 'QMMM'), ('EP', 'EP'), ('EIP', 'EIP'), ('BSSE', 'BSSE'), ('SUBSYS', 'SUBSYS'), ('PROPERTIES', 'PROPERTIES'), ('PRINT', 'PRINT')]
        self._repeated_subsections = [('EXTERNAL_POTENTIAL', '_external_potential1')]

    def add_EXTERNAL_POTENTIAL(self):
        new_section = _external_potential1()
        self.list_EXTERNAL_POTENTIAL.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _force_eval1(printable):
    """
    Defines the fragments and the mapping for each force_eval (an integer
    index (ID) needs to be provided as parameter)
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Defines the index of the force_eval for which fragments and mappings
        are provided
        """
        self.Define_fragments = None
        """
        Specify the fragments definition of the force_eval through the
        fragments of the force_eval_mixed. This avoids the pedantic definition
        of the fragments for the force_eval, assuming the order of the
        fragments for the specified force_eval is the same as the sequence  of
        integers provided. Easier to USE should be preferred to the
        specification of the single fragments.
        """
        self.list_FRAGMENT = []
        self._name = "FORCE_EVAL"
        self._keywords = [('Define_fragments', 'DEFINE_FRAGMENTS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('FRAGMENT', '_fragment2')]

    def add_FRAGMENT(self):
        new_section = _fragment2()
        self.list_FRAGMENT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _thermostat_energy2(printable):
    """
    Information to initialize the CSVR thermostat energy.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify an initial thermostat energy  for CSVR thermostat.
        """
        self._name = "THERMOSTAT_ENERGY"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _thermostat_energy3(printable):
    """
    Information to initialize the CSVR thermostat energy.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify an initial thermostat energy  for CSVR thermostat.
        """
        self._name = "THERMOSTAT_ENERGY"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _thermostat_energy1(printable):
    """
    Information to initialize the CSVR thermostat energy.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify an initial thermostat energy  for CSVR thermostat.
        """
        self._name = "THERMOSTAT_ENERGY"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _thermostat_energy6(printable):
    """
    Information to initialize the CSVR thermostat energy.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify an initial thermostat energy  for CSVR thermostat.
        """
        self._name = "THERMOSTAT_ENERGY"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _thermostat_energy7(printable):
    """
    Information to initialize the CSVR thermostat energy.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify an initial thermostat energy  for CSVR thermostat.
        """
        self._name = "THERMOSTAT_ENERGY"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _thermostat_energy4(printable):
    """
    Information to initialize the CSVR thermostat energy.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify an initial thermostat energy  for CSVR thermostat.
        """
        self._name = "THERMOSTAT_ENERGY"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _thermostat_energy5(printable):
    """
    Information to initialize the CSVR thermostat energy.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specify an initial thermostat energy  for CSVR thermostat.
        """
        self._name = "THERMOSTAT_ENERGY"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _frame1(printable):
    """
    Specify coordinates of the frame (number of frames can be either 1 or
    2)
    """
    def __init__(self):
        self.Coord_file_name = None
        """
        Name of the xyz file with coordinates (alternative to &COORD section)
        """
        self.COORD = _coord11()
        self._name = "FRAME"
        self._keywords = [('Coord_file_name', 'COORD_FILE_NAME')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('COORD', 'COORD')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _frame3(printable):
    """
    Specify coordinates of the frame
    """
    def __init__(self):
        self.Coord_file_name = None
        """
        Name of the xyz file with coordinates (alternative to &COORD section)
        """
        self.COORD = _coord13()
        self._name = "FRAME"
        self._keywords = [('Coord_file_name', 'COORD_FILE_NAME')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('COORD', 'COORD')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _frame2(printable):
    """
    Specify coordinates of the frame (number of frames can be either 1 or
    2)
    """
    def __init__(self):
        self.Coord_file_name = None
        """
        Name of the xyz file with coordinates (alternative to &COORD section)
        """
        self.COORD = _coord12()
        self._name = "FRAME"
        self._keywords = [('Coord_file_name', 'COORD_FILE_NAME')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('COORD', 'COORD')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _frame5(printable):
    """
    Specify coordinates of the frame
    """
    def __init__(self):
        self.Coord_file_name = None
        """
        Name of the xyz file with coordinates (alternative to &COORD section)
        """
        self.COORD = _coord15()
        self._name = "FRAME"
        self._keywords = [('Coord_file_name', 'COORD_FILE_NAME')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('COORD', 'COORD')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _frame4(printable):
    """
    Specify coordinates of the frame (number of frames can be either 1 or
    2)
    """
    def __init__(self):
        self.Coord_file_name = None
        """
        Name of the xyz file with coordinates (alternative to &COORD section)
        """
        self.COORD = _coord14()
        self._name = "FRAME"
        self._keywords = [('Coord_file_name', 'COORD_FILE_NAME')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('COORD', 'COORD')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _frame6(printable):
    """
    Specify coordinates of the frame (number of frames can be either 1 or
    2)
    """
    def __init__(self):
        self.Coord_file_name = None
        """
        Name of the xyz file with coordinates (alternative to &COORD section)
        """
        self.COORD = _coord16()
        self._name = "FRAME"
        self._keywords = [('Coord_file_name', 'COORD_FILE_NAME')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('COORD', 'COORD')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _g4x61(printable):
    """
    This section is used to set 4x6 (4 atoms and 6 distances) constraints.
    """
    def __init__(self):
        self.Molecule = None
        """
        Specifies the molecule number on which constraint will be applied.
        MOLECULE and MOLNAME keyword exclude themself mutually.
        """
        self.Molname = None
        """
        Specifies the name of the molecule on which the constraint will be
        applied.
        """
        self.Intermolecular = None
        """
        Specify if the constraint/restraint is intermolecular.
        """
        self.Atoms = None
        """
        Atoms' index on which apply the constraint
        """
        self.Distances = None
        """
        The constrained distances' values.
        """
        self.Exclude_qm = None
        """
        Does not apply the constraint to the QM region within a QM/MM
        calculation
        """
        self.Exclude_mm = None
        """
        Does not apply the constraint to the MM region within a QM/MM
        calculation
        """
        self.RESTRAINT = _restraint3()
        self._name = "G4X6"
        self._keywords = [('Molecule', 'MOLECULE'), ('Molname', 'MOLNAME'), ('Intermolecular', 'INTERMOLECULAR'), ('Atoms', 'ATOMS'), ('Distances', 'DISTANCES'), ('Exclude_qm', 'EXCLUDE_QM'), ('Exclude_mm', 'EXCLUDE_MM')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('RESTRAINT', 'RESTRAINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Mol(self):
        """
        See documentation for Molecule
        """
        return self.Molecule

    @property
    def Segname(self):
        """
        See documentation for Molname
        """
        return self.Molname

    @Mol.setter
    def Mol(self, value):
        self.Molecule = value

    @Segname.setter
    def Segname(self, value):
        self.Molname = value



class _ls_scf1(printable):
    """
    Specifies the parameters of the linear scaling SCF routines
    """
    def __init__(self):
        self.Max_scf = None
        """
        Maximum number of SCF iteration to be performed for one optimization
        """
        self.Eps_scf = None
        """
        target accuracy for the scf convergence. Change of the total energy
        per electron
        """
        self.Mixing_fraction = None
        """
        Mixing density matrices uses the specified fraction in the SCF
        procedure.
        """
        self.Eps_filter = None
        """
        Threshold used for filtering matrix operations.
        """
        self.Eps_lanczos = None
        """
        Threshold used for lanczos estimates.
        """
        self.Max_iter_lanczos = None
        """
        Maximum number of lanczos iterations.
        """
        self.Mu = None
        """
        Value (or initial guess) for the chemical potential, i.e. some
        suitable energy between HOMO and LUMO energy.
        """
        self.Fixed_mu = None
        """
        Should the calculation be performed at fixed chemical potential, or
        should it be found fixing the number of electrons
        """
        self.Extrapolation_order = None
        """
        Number of previous matrices used for the ASPC extrapolation of the
        initial guess. 0 implies that an atomic guess is used at each step.
        low (1-2) will result in a drift of the constant of motion during MD.
        high (>5) might be somewhat unstable, leading to more SCF iterations.
        """
        self.S_preconditioner = None
        """
        Preconditions S with some appropriate form.

        Available values:
            NONE
                No preconditioner
            ATOMIC
                Using atomic blocks
            MOLECULAR
                Using molecular sub-blocks. Recommended if molecules are defined and
                not too large.
        """
        self.Purification_method = None
        """
        Scheme used to purify the Kohn-Sham matrix into the density matrix.

        Available values:
            SIGN_MATRIX
                Newton-Schulz sign matrix iteration.
            TRS4
                Trace resetting 4th order scheme
        """
        self.Dynamic_threshold = None
        """
        Should the threshold for the purification be chosen dynamically
        """
        self.Matrix_cluster_type = None
        """
        Specify how atomic blocks should be clustered in the used matrices, in
        order to improve flop rate, and possibly speedup the matrix multiply.
        Note that the atomic s_preconditioner can not be used.Furthermore,
        since screening is on matrix blocks, slightly more accurate results
        can be expected with molecular.

        Available values:
            ATOMIC
                Using atomic blocks
            MOLECULAR
                Using molecular blocks.
        """
        self.Single_precision_matrices = None
        """
        Matrices used within the LS code can be either double or single
        precision.
        """
        self.Restart_write = None
        """
        Write the density matrix at the end of the SCF (currently requires
        EXTRAPOLATION_ORDER>0). Files might be rather large.
        """
        self.Restart_read = None
        """
        Read the density matrix before the (first) SCF.
        """
        self.S_inversion = None
        """
        Method used to compute the inverse of S.

        Available values:
            SIGN_SQRT
                Using the inverse sqrt as obtained from sign function iterations.
            HOTELLING
                Using the Hotellign iteration.
        """
        self.Sign_sqrt_order = None
        """
        Order of the sqrt iteration, should be 2..5, 3 or 5 recommended
        """
        self.Report_all_sparsities = None
        """
        Run the sparsity report at the end of the SCF
        """
        self.Perform_mu_scan = None
        """
        Do a scan of the chemical potential after the SCF
        """
        self.CURVY_STEPS = _curvy_steps1()
        self.CHEBYSHEV = _chebyshev1()
        self._name = "LS_SCF"
        self._keywords = [('Max_scf', 'MAX_SCF'), ('Eps_scf', 'EPS_SCF'), ('Mixing_fraction', 'MIXING_FRACTION'), ('Eps_filter', 'EPS_FILTER'), ('Eps_lanczos', 'EPS_LANCZOS'), ('Max_iter_lanczos', 'MAX_ITER_LANCZOS'), ('Mu', 'MU'), ('Fixed_mu', 'FIXED_MU'), ('Extrapolation_order', 'EXTRAPOLATION_ORDER'), ('S_preconditioner', 'S_PRECONDITIONER'), ('Purification_method', 'PURIFICATION_METHOD'), ('Dynamic_threshold', 'DYNAMIC_THRESHOLD'), ('Matrix_cluster_type', 'MATRIX_CLUSTER_TYPE'), ('Single_precision_matrices', 'SINGLE_PRECISION_MATRICES'), ('Restart_write', 'RESTART_WRITE'), ('Restart_read', 'RESTART_READ'), ('S_inversion', 'S_INVERSION'), ('Sign_sqrt_order', 'SIGN_SQRT_ORDER'), ('Report_all_sparsities', 'REPORT_ALL_SPARSITIES'), ('Perform_mu_scan', 'PERFORM_MU_SCAN')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('CURVY_STEPS', 'CURVY_STEPS'), ('CHEBYSHEV', 'CHEBYSHEV')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _total_densities1(printable):
    """
    Controls the printing of total densities.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each99()
        self._name = "TOTAL_DENSITIES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _restart_info1(printable):
    """
    This section provides information about old force-mixing indices and
    labels, for restarts.
    """
    def __init__(self):
        self.list_Indices = []
        self.list_Labels = []
        self._name = "RESTART_INFO"
        self._keywords = []
        self._repeated_keywords = [('Indices', 'INDICES'), ('Labels', 'LABELS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Indices(self, value):
        self.list_Indices.append(value)

    def add_Labels(self, value):
        self.list_Labels.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _periodic8(printable):
    """
    Sets up periodic boundary condition parameters if requested
    """
    def __init__(self):
        self.Number_of_shells = None
        """
        Number of shells taken into account for periodicity. By default, cp2k
        tries to automatically evaluate this number. This algorithm might be
        to conservative, resulting in some overhead. You can try to adjust
        this number in order to make a calculation cheaper.
        """
        self._name = "PERIODIC"
        self._keywords = [('Number_of_shells', 'NUMBER_OF_SHELLS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _periodic9(printable):
    """
    Sets up periodic boundary condition parameters if requested
    """
    def __init__(self):
        self.Number_of_shells = None
        """
        Number of shells taken into account for periodicity. By default, cp2k
        tries to automatically evaluate this number. This algorithm might be
        to conservative, resulting in some overhead. You can try to adjust
        this number in order to make a calculation cheaper.
        """
        self._name = "PERIODIC"
        self._keywords = [('Number_of_shells', 'NUMBER_OF_SHELLS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _periodic6(printable):
    """
    Sets up periodic boundary condition parameters if requested
    """
    def __init__(self):
        self.Number_of_shells = None
        """
        Number of shells taken into account for periodicity. By default, cp2k
        tries to automatically evaluate this number. This algorithm might be
        to conservative, resulting in some overhead. You can try to adjust
        this number in order to make a calculation cheaper.
        """
        self._name = "PERIODIC"
        self._keywords = [('Number_of_shells', 'NUMBER_OF_SHELLS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _periodic7(printable):
    """
    Sets up periodic boundary condition parameters if requested
    """
    def __init__(self):
        self.Number_of_shells = None
        """
        Number of shells taken into account for periodicity. By default, cp2k
        tries to automatically evaluate this number. This algorithm might be
        to conservative, resulting in some overhead. You can try to adjust
        this number in order to make a calculation cheaper.
        """
        self._name = "PERIODIC"
        self._keywords = [('Number_of_shells', 'NUMBER_OF_SHELLS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _buffer_non_adaptive1(printable):
    """
    List of atoms always in buffer region, non-adaptively, and any needed
    LINK sections
    """
    def __init__(self):
        self.list_QM_KIND = []
        self.list_LINK = []
        self._name = "BUFFER_NON_ADAPTIVE"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('QM_KIND', '_qm_kind2'), ('LINK', '_link1')]

    def add_QM_KIND(self):
        new_section = _qm_kind2()
        self.list_QM_KIND.append(new_section)
        return new_section

    def add_LINK(self):
        new_section = _link1()
        self.list_LINK.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _periodic5(printable):
    """
    Specify parameters for QM/MM periodic boundary conditions calculations
    """
    def __init__(self):
        self.Gmax = None
        """
        Specifies the maximum value of G in the reciprocal space over which
        perform the Ewald sum.
        """
        self.Replica = None
        """
        Specifies the number of replica to take into consideration for the
        real part of the calculation. Default is letting the qmmm module
        decide how many replica you really need.
        """
        self.Ngrids = None
        """
        Specifies the number of grid points used for the Interpolation of the
        G-space term
        """
        self.MULTIPOLE = _multipole3()
        self.INTERPOLATOR = _interpolator6()
        self.CHECK_SPLINE = _check_spline4()
        self._name = "PERIODIC"
        self._keywords = [('Gmax', 'GMAX'), ('Replica', 'REPLICA'), ('Ngrids', 'NGRIDS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('MULTIPOLE', 'MULTIPOLE'), ('INTERPOLATOR', 'INTERPOLATOR'), ('CHECK_SPLINE', 'CHECK_SPLINE')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _periodic2(printable):
    """
    Sets up periodic boundary condition parameters if requested
    """
    def __init__(self):
        self.Number_of_shells = None
        """
        Number of shells taken into account for periodicity. By default, cp2k
        tries to automatically evaluate this number. This algorithm might be
        to conservative, resulting in some overhead. You can try to adjust
        this number in order to make a calculation cheaper.
        """
        self._name = "PERIODIC"
        self._keywords = [('Number_of_shells', 'NUMBER_OF_SHELLS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _periodic3(printable):
    """
    Sets up periodic boundary condition parameters if requested
    """
    def __init__(self):
        self.Number_of_shells = None
        """
        Number of shells taken into account for periodicity. By default, cp2k
        tries to automatically evaluate this number. This algorithm might be
        to conservative, resulting in some overhead. You can try to adjust
        this number in order to make a calculation cheaper.
        """
        self._name = "PERIODIC"
        self._keywords = [('Number_of_shells', 'NUMBER_OF_SHELLS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _periodic1(printable):
    """
    Sets up periodic boundary condition parameters if requested
    """
    def __init__(self):
        self.Number_of_shells = None
        """
        Number of shells taken into account for periodicity. By default, cp2k
        tries to automatically evaluate this number. This algorithm might be
        to conservative, resulting in some overhead. You can try to adjust
        this number in order to make a calculation cheaper.
        """
        self._name = "PERIODIC"
        self._keywords = [('Number_of_shells', 'NUMBER_OF_SHELLS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _shell_opt1(printable):
    """
    This section sets the environment for the optimization of the shell-
    core distances that might turn to be necessary along a MD run using a
    shell-model potential.  The optimization procedure is activated when
    at least one of the shell-core pairs becomes too elongated,  i.e. when
    the assumption of point dipole is not longer valid.
    """
    def __init__(self):
        self.Optimizer = None
        """
        Specify which method to use to perform a geometry optimization.

        Available values:
            BFGS
                Most efficient minimizer, but only for 'small' systems, as it relies
                on diagonalization of a full Hessian matrix
            LBFGS
                Limit memory variant of the above, can also be applied to large
                systems, not as well fine-tuned
            CG
                conjugate gradients, robust minimizer (depending on the line search)
                also OK for large systems
        """
        self.Max_iter = None
        """
        Specifies the maximum number of geometry optimization steps. One step
        might imply several force evaluations for the CG and LBFGS optimizers.
        """
        self.Max_dr = None
        """
        Convergence criterium for the maximum geometry change between the
        current and the last optimizer iteration.
        """
        self.Max_force = None
        """
        Convergence criterium for the maximum force component of the current
        configuration.
        """
        self.Rms_dr = None
        """
        Convergence criterium for the root mean square (RMS) geometry change
        between the current and the last optimizer iteration.
        """
        self.Rms_force = None
        """
        Convergence criterium for the root mean square (RMS) force of the
        current configuration.
        """
        self.Step_start_val = None
        """
        The starting step value for the SHELL_OPT module.
        """
        self.LBFGS = _lbfgs4()
        self.CG = _cg4()
        self.BFGS = _bfgs4()
        self.list_PRINT = []
        self._name = "SHELL_OPT"
        self._keywords = [('Optimizer', 'OPTIMIZER'), ('Max_iter', 'MAX_ITER'), ('Max_dr', 'MAX_DR'), ('Max_force', 'MAX_FORCE'), ('Rms_dr', 'RMS_DR'), ('Rms_force', 'RMS_FORCE'), ('Step_start_val', 'STEP_START_VAL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('LBFGS', 'LBFGS'), ('CG', 'CG'), ('BFGS', 'BFGS')]
        self._repeated_subsections = [('PRINT', '_print5')]

    def add_PRINT(self):
        new_section = _print5()
        self.list_PRINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Minimizer(self):
        """
        See documentation for Optimizer
        """
        return self.Optimizer

    @Minimizer.setter
    def Minimizer(self, value):
        self.Optimizer = value



class _each358(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each359(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each354(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _distribution2d1(printable):
    """
    Controls the printing of the distribution of matrix blocks,...
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each340()
        self._name = "DISTRIBUTION2D"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each356(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each357(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each350(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each351(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each352(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each353(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each174(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each175(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each176(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each177(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each170(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each171(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each172(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each173(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each178(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each179(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _rng_state1(printable):
    """
    Random number generator state for all processors
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Three real arrays of DIMENSION(3,2) times two RNG streams - 36 real
        values per processor
        """
        self._name = "RNG_STATE"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _fit_density1(printable):
    """
    Fit the total electronic density to a linear combination of Gaussian
    functions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Num_gto = None
        """
        Number of Gaussian type functions for density fit
        """
        self.EACH = _each358()
        self._name = "FIT_DENSITY"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Num_gto', 'NUM_GTO')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _gth_potential1(printable):
    """
    Section used to specify Potentials.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        CP2K Pseudo Potential Standard Format (GTH, ALL or KG)
        """
        self._name = "GTH_POTENTIAL"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _banner2(printable):
    """
    Controls the printing of the vibrational analysis banner
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each350()
        self._name = "BANNER"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _banner1(printable):
    """
    Controls the printing of the BAND banner
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each71()
        self._name = "BANNER"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _point47(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point46(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _interaction_potential7(printable):
    """
    Sets up interaction potential if requested
    """
    def __init__(self):
        self.Potential_type = None
        """
        Which interaction potential should be used (Coulomb, longrange or
        shortrange).

        Available values:
            COULOMB
                Coulomb potential: 1/r
            SHORTRANGE
                Shortrange potential: erfc(omega*r)/r
            LONGRANGE
                Longrange potential: erf(omega*r)/r
            MIX_CL
                Mix coulomb and longrange potential: 1/r + erf(omega*r)/r
            GAUSSIAN
                Damped Gaussian potential: exp(-omega^2*r^2)
            MIX_LG
                Mix Gaussian and longrange potential: erf(omega*r)/r +
                exp(-omega^2*r^2)
            IDENTITY
                Overlap
            TRUNCATED
                Truncated coulomb potential: if(r<R_c) 1/r else 0
            MIX_CL_TRUNC
                Truncated Mix coulomb and longrange potential, assumes/requires that
                the erf has fully decayed at R_c
        """
        self.Omega = None
        """
        Parameter for short/longrange interaction
        """
        self.Scale_coulomb = None
        """
        Scales Hartree-Fock contribution arising from a coulomb potential.
        Only valid when doing a mixed potential calculation
        """
        self.Scale_longrange = None
        """
        Scales Hartree-Fock contribution arising from a longrange potential.
        Only valid when doing a mixed potential calculation
        """
        self.Scale_gaussian = None
        """
        Scales Hartree-Fock contribution arising from a gaussian potential.
        Only valid when doing a mixed potential calculation
        """
        self.Cutoff_radius = None
        """
        Determines cutoff radius for the truncated 1/r potential. Only valid
        when doing truncated calculation
        """
        self.T_c_g_data = None
        """
        Location of the file t_c_g.dat that contains the data for the
        evaluation of the truncated gamma function
        """
        self._name = "INTERACTION_POTENTIAL"
        self._keywords = [('Potential_type', 'POTENTIAL_TYPE'), ('Omega', 'OMEGA'), ('Scale_coulomb', 'SCALE_COULOMB'), ('Scale_longrange', 'SCALE_LONGRANGE'), ('Scale_gaussian', 'SCALE_GAUSSIAN'), ('Cutoff_radius', 'CUTOFF_RADIUS'), ('T_c_g_data', 'T_C_G_DATA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _references1(printable):
    """
    Controls the printing of the references relevant to the calculations
    performed
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each2()
        self._name = "REFERENCES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _optimize_geminals1(printable):
    """
    Optimize the parameters of the geminal basis set
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each216()
        self.POWELL = _powell1()
        self._name = "OPTIMIZE_GEMINALS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH'), ('POWELL', 'POWELL')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _qm_kind3(printable):
    """
    Information about the qm kind in the qm/mm scheme
    """
    def __init__(self):
        self.Section_parameters = None
        """
        The qm kind
        """
        self.list_Mm_index = []
        self._name = "QM_KIND"
        self._keywords = []
        self._repeated_keywords = [('Mm_index', 'MM_INDEX')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Mm_index(self, value):
        self.list_Mm_index.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _qm_kind2(printable):
    """
    Information about the qm kind in the qm/mm scheme
    """
    def __init__(self):
        self.Section_parameters = None
        """
        The qm kind
        """
        self.list_Mm_index = []
        self._name = "QM_KIND"
        self._keywords = []
        self._repeated_keywords = [('Mm_index', 'MM_INDEX')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Mm_index(self, value):
        self.list_Mm_index.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _qm_kind1(printable):
    """
    Information about the qm kind in the qm/mm scheme
    """
    def __init__(self):
        self.Section_parameters = None
        """
        The qm kind
        """
        self.list_Mm_index = []
        self._name = "QM_KIND"
        self._keywords = []
        self._repeated_keywords = [('Mm_index', 'MM_INDEX')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Mm_index(self, value):
        self.list_Mm_index.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point43(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _g3x31(printable):
    """
    This section is used to set 3x3 (3 atoms and 3 distances) constraints.
    """
    def __init__(self):
        self.Molecule = None
        """
        Specifies the molecule kind number on which constraint will be
        applied. MOLECULE and MOLNAME keyword exclude themself mutually.
        """
        self.Molname = None
        """
        Specifies the name of the molecule on which the constraint will be
        applied.
        """
        self.Intermolecular = None
        """
        Specify if the constraint/restraint is intermolecular.
        """
        self.Atoms = None
        """
        Atoms' index on which apply the constraint
        """
        self.Distances = None
        """
        The constrained distances' values.
        """
        self.Exclude_qm = None
        """
        Does not apply the constraint to the QM region within a QM/MM
        calculation
        """
        self.Exclude_mm = None
        """
        Does not apply the constraint to the MM region within a QM/MM
        calculation
        """
        self.RESTRAINT = _restraint2()
        self._name = "G3X3"
        self._keywords = [('Molecule', 'MOLECULE'), ('Molname', 'MOLNAME'), ('Intermolecular', 'INTERMOLECULAR'), ('Atoms', 'ATOMS'), ('Distances', 'DISTANCES'), ('Exclude_qm', 'EXCLUDE_QM'), ('Exclude_mm', 'EXCLUDE_MM')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('RESTRAINT', 'RESTRAINT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Mol(self):
        """
        See documentation for Molecule
        """
        return self.Molecule

    @property
    def Segname(self):
        """
        See documentation for Molname
        """
        return self.Molname

    @Mol.setter
    def Mol(self, value):
        self.Molecule = value

    @Segname.setter
    def Segname(self, value):
        self.Molname = value



class _wfn_mix1(printable):
    """
    A section that allows manipulation of the MO coeffs, e.g. for changing
    a ground state into an excited state.Starting from a copy of the
    original MOs, changes can be madeby adding linear combinations of
    HOMO/LUMO of the original MOs to the result MOs
    """
    def __init__(self):
        self.Overwrite_mos = None
        """
        If the keyword is active molecular orbitals in memory will be replaced
        by the mixed wfn. In combination with RTP or EMD no restart will be
        required to use the mixed wfn.
        """
        self.list_UPDATE = []
        self._name = "WFN_MIX"
        self._keywords = [('Overwrite_mos', 'OVERWRITE_MOS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('UPDATE', '_update1')]

    def add_UPDATE(self):
        new_section = _update1()
        self.list_UPDATE.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _accepts1(printable):
    """
    Controls the output of the helium acceptance data
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each56()
        self._name = "ACCEPTS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _becke_restraint_b1(printable):
    """
    Use DDAPC charges in a restraint (check code for details), section can
    be repeated, but only one constraint is possible at the moment.
    """
    def __init__(self):
        self.Strength = None
        """
        force constant of the restraint
        """
        self.Type_of_density = None
        """
        Specifies the type of density used for the fitting

        Available values:
            FULL
                Full density
            SPIN
                Spin density
        """
        self.Target = None
        """
        target value of the restraint
        """
        self.Atoms = None
        """
        Specifies the list of atoms that is summed in the restraint
        """
        self.Coeff = None
        """
        Defines the the coefficient of the atom in the atom list (default is
        one), currently DDAPC only
        """
        self.Functional_form = None
        """
        Specifies the functional form of the term added

        Available values:
            RESTRAINT
                Harmonic potential: s*(q-t)**2
            CONSTRAINT
                Constraint form: s*(q-t)
        """
        self.PROGRAM_RUN_INFO = _program_run_info46()
        self._name = "BECKE_RESTRAINT_B"
        self._keywords = [('Strength', 'STRENGTH'), ('Type_of_density', 'TYPE_OF_DENSITY'), ('Target', 'TARGET'), ('Atoms', 'ATOMS'), ('Coeff', 'COEFF'), ('Functional_form', 'FUNCTIONAL_FORM')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _interaction_potential2(printable):
    """
    Sets up interaction potential if requested
    """
    def __init__(self):
        self.Potential_type = None
        """
        Which interaction potential should be used (Coulomb, longrange or
        shortrange).

        Available values:
            COULOMB
                Coulomb potential: 1/r
            SHORTRANGE
                Shortrange potential: erfc(omega*r)/r
            LONGRANGE
                Longrange potential: erf(omega*r)/r
            MIX_CL
                Mix coulomb and longrange potential: 1/r + erf(omega*r)/r
            GAUSSIAN
                Damped Gaussian potential: exp(-omega^2*r^2)
            MIX_LG
                Mix Gaussian and longrange potential: erf(omega*r)/r +
                exp(-omega^2*r^2)
            IDENTITY
                Overlap
            TRUNCATED
                Truncated coulomb potential: if(r<R_c) 1/r else 0
            MIX_CL_TRUNC
                Truncated Mix coulomb and longrange potential, assumes/requires that
                the erf has fully decayed at R_c
        """
        self.Omega = None
        """
        Parameter for short/longrange interaction
        """
        self.Scale_coulomb = None
        """
        Scales Hartree-Fock contribution arising from a coulomb potential.
        Only valid when doing a mixed potential calculation
        """
        self.Scale_longrange = None
        """
        Scales Hartree-Fock contribution arising from a longrange potential.
        Only valid when doing a mixed potential calculation
        """
        self.Scale_gaussian = None
        """
        Scales Hartree-Fock contribution arising from a gaussian potential.
        Only valid when doing a mixed potential calculation
        """
        self.Cutoff_radius = None
        """
        Determines cutoff radius for the truncated 1/r potential. Only valid
        when doing truncated calculation
        """
        self.T_c_g_data = None
        """
        Location of the file t_c_g.dat that contains the data for the
        evaluation of the truncated gamma function
        """
        self._name = "INTERACTION_POTENTIAL"
        self._keywords = [('Potential_type', 'POTENTIAL_TYPE'), ('Omega', 'OMEGA'), ('Scale_coulomb', 'SCALE_COULOMB'), ('Scale_longrange', 'SCALE_LONGRANGE'), ('Scale_gaussian', 'SCALE_GAUSSIAN'), ('Cutoff_radius', 'CUTOFF_RADIUS'), ('T_c_g_data', 'T_C_G_DATA')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _damping1(printable):
    """
    This section specifies optional electric field damping for the
    polarizable atoms.
    """
    def __init__(self):
        self.Atom = None
        """
        Defines the atomic kind for this damping function.
        """
        self.Type = None
        """
        Defines the damping type.
        """
        self.Order = None
        """
        Defines the order for this damping.
        """
        self.Bij = None
        """
        Defines the BIJ parameter for this damping.
        """
        self.Cij = None
        """
        Defines the CIJ parameter for this damping.
        """
        self._name = "DAMPING"
        self._keywords = [('Atom', 'ATOM'), ('Type', 'TYPE'), ('Order', 'ORDER'), ('Bij', 'BIJ'), ('Cij', 'CIJ')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _stress1(printable):
    """
    Controls the output of the stress tensor
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each85()
        self._name = "STRESS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _forcefield2(printable):
    """
    Specify information on the QM/MM forcefield
    """
    def __init__(self):
        self.Multiple_potential = None
        """
        Enables the possibility to define NONBONDED and NONBONDED14 as a sum
        of different kinds of potential. Useful for piecewise defined
        potentials.
        """
        self.list_NONBONDED = []
        self.NONBONDED14 = _nonbonded142()
        self._name = "FORCEFIELD"
        self._keywords = [('Multiple_potential', 'MULTIPLE_POTENTIAL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('NONBONDED14', 'NONBONDED14')]
        self._repeated_subsections = [('NONBONDED', '_nonbonded2')]

    def add_NONBONDED(self):
        new_section = _nonbonded2()
        self.list_NONBONDED.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info41(printable):
    """
    Controls the printing of information on the HFX RI approximation
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each316()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info40(printable):
    """
    Controls the printing of information on the HFX RI approximation
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each310()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info43(printable):
    """
    Controls the printing basic info about the method
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each324()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info42(printable):
    """
    Controls the printing of basic iteration information during the LINRES
    calculation
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each322()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info45(printable):
    """
    Controls the printing basic info about the method
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each326()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info44(printable):
    """
    Controls the printing basic info about the method
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each325()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info47(printable):
    """
    Controls the printing basic info about the method
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each328()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info46(printable):
    """
    Controls the printing basic info about the method
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each327()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_run_info49(printable):
    """
    Controls the printing of basic information generated by force_eval
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each335()
        self._name = "PROGRAM_RUN_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _md1(printable):
    """
    This section defines the whole set of parameters needed perform an MD
    run.
    """
    def __init__(self):
        self.Ensemble = None
        """
        The ensemble/integrator that you want to use for MD propagation

        Available values:
            NVE
                constant energy (microcanonical)
            NVT
                constant temperature and volume (canonical)
            NPT_I
                constant temperature and pressure using an isotropic cell
            NPT_F
                constant temperature and pressure using a flexible cell
            MSST
                simulate steady shock (uniaxial)
            MSST_DAMPED
                simulate steady shock (uniaxial) with extra viscosity
            HYDROSTATICSHOCK
                simulate steady shock with hydrostatic pressure
            ISOKIN
                constant kinetic energy
            REFTRAJ
                reading frames from a file called reftraj.xyz (e.g. for property
                calculation)
            LANGEVIN
                langevin dynamics (constant temperature)
            NPE_F
                constant pressure ensemble (no thermostat)
            NPE_I
                constant pressure ensemble using an isotropic cell (no thermostat)
            NVT_ADIABATIC
                adiabatic dynamics in constant temperature and volume ensemble (CAFES)
        """
        self.Steps = None
        """
        The number of MD steps to perform
        """
        self.Timestep = None
        """
        The length of an integration step (in case RESPA the large TIMESTEP)
        """
        self.Step_start_val = None
        """
        The starting step value for the MD
        """
        self.Time_start_val = None
        """
        The starting timer value for the MD
        """
        self.Econs_start_val = None
        """
        The starting  value of the conserved quantity
        """
        self.Temperature = None
        """
        The temperature in K used to initialize the velocities with init and
        pos restart, and in the NPT/NVT simulations
        """
        self.Temp_tol = None
        """
        The maximum accepted deviation of the (global) temperaturefrom the
        desired target temperature before a rescaling of the velocites is
        performed. If it is 0 no rescaling is performed. NOTE: This keyword is
        obsolescent; Using a CSVR thermostat with a short timeconstant is
        recommended as a better alternative.
        """
        self.Temp_kind = None
        """
        Compute the temperature per each kind separately
        """
        self.Scale_temp_kind = None
        """
        When necessary rescale the temperature per each kind separately
        """
        self.Comvel_tol = None
        """
        The maximum accepted velocity of the center of mass. With Shell-Model,
        comvel may drift if MD%THERMOSTAT%REGION /= GLOBAL
        """
        self.Angvel_tol = None
        """
        The maximum accepted angular velocity. This option is ignored when the
        system is periodic. Removes the components of the velocities
        thatproject on the external rotational degrees of freedom.
        """
        self.Angvel_zero = None
        """
        Set the initial angular velocity to zero. This option is ignored when
        the system is periodic or when initial velocities are defined.
        Technically, the part of the random initial velocities that projects
        on the external rotational degrees of freedom is subtracted.
        """
        self.Annealing = None
        """
        Specifies the rescaling factor for annealing velocities. Automatically
        enables the annealing procedure. This scheme works only for ensembles
        that do not have thermostats on particles.
        """
        self.Annealing_cell = None
        """
        Specifies the rescaling factor for annealing velocities of the CELL
        Automatically enables the annealing procedure for the CELL. This
        scheme works only for ensambles that do not have thermostat on CELLS
        velocities.
        """
        self.Displacement_tol = None
        """
        This keyword sets a maximum atomic displacement  in each Cartesian
        direction.The maximum velocity is evaluated and if it is too large to
        remainwithin the assigned limit, the time step is rescaled
        accordingly,and the first half step of the velocity verlet is
        repeated.
        """
        self.LANGEVIN = _langevin1()
        self.MSST = _msst1()
        self.BAROSTAT = _barostat1()
        self.THERMOSTAT = _thermostat2()
        self.RESPA = _respa1()
        self.SHELL = _shell1()
        self.ADIABATIC_DYNAMICS = _adiabatic_dynamics1()
        self.REFTRAJ = _reftraj1()
        self.AVERAGES = _averages1()
        self.THERMAL_REGION = _thermal_region1()
        self.PRINT = _print12()
        self.CASCADE = _cascade1()
        self._name = "MD"
        self._keywords = [('Ensemble', 'ENSEMBLE'), ('Steps', 'STEPS'), ('Timestep', 'TIMESTEP'), ('Step_start_val', 'STEP_START_VAL'), ('Time_start_val', 'TIME_START_VAL'), ('Econs_start_val', 'ECONS_START_VAL'), ('Temperature', 'TEMPERATURE'), ('Temp_tol', 'TEMP_TOL'), ('Temp_kind', 'TEMP_KIND'), ('Scale_temp_kind', 'SCALE_TEMP_KIND'), ('Comvel_tol', 'COMVEL_TOL'), ('Angvel_tol', 'ANGVEL_TOL'), ('Angvel_zero', 'ANGVEL_ZERO'), ('Annealing', 'ANNEALING'), ('Annealing_cell', 'ANNEALING_CELL'), ('Displacement_tol', 'DISPLACEMENT_TOL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('LANGEVIN', 'LANGEVIN'), ('MSST', 'MSST'), ('BAROSTAT', 'BAROSTAT'), ('THERMOSTAT', 'THERMOSTAT'), ('RESPA', 'RESPA'), ('SHELL', 'SHELL'), ('ADIABATIC_DYNAMICS', 'ADIABATIC_DYNAMICS'), ('REFTRAJ', 'REFTRAJ'), ('AVERAGES', 'AVERAGES'), ('THERMAL_REGION', 'THERMAL_REGION'), ('PRINT', 'PRINT'), ('CASCADE', 'CASCADE')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Temp_to(self):
        """
        See documentation for Temp_tol
        """
        return self.Temp_tol

    @property
    def Temperature_tolerance(self):
        """
        See documentation for Temp_tol
        """
        return self.Temp_tol

    @Temp_to.setter
    def Temp_to(self, value):
        self.Temp_tol = value

    @Temperature_tolerance.setter
    def Temperature_tolerance(self, value):
        self.Temp_tol = value



class _md2(printable):
    """
    Activate the MD based optimization procedure for BAND
    """
    def __init__(self):
        self.Max_steps = None
        """
        Specify the maximum number of MD steps
        """
        self.Timestep = None
        """
        The length of an integration step
        """
        self.Temperature = None
        """
        Specify the initial temperature
        """
        self.TEMP_CONTROL = _temp_control1()
        self.VEL_CONTROL = _vel_control1()
        self._name = "MD"
        self._keywords = [('Max_steps', 'MAX_STEPS'), ('Timestep', 'TIMESTEP'), ('Temperature', 'TEMPERATURE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('TEMP_CONTROL', 'TEMP_CONTROL'), ('VEL_CONTROL', 'VEL_CONTROL')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _cubes8(printable):
    """
    Controls the printing of cube files
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Stride = None
        """
        The stride (X,Y,Z) used to write the cube file (larger values result
        in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1
        number valid for all components.
        """
        self.EACH = _each296()
        self._name = "CUBES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Stride', 'STRIDE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _shell_velocities1(printable):
    """
    Controls the output of the velocities of shells when the shell model
    is used
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Unit = None
        """
        Specify the unit of measurement for the quantity in output. All
        available CP2K units can be used.
        """
        self.Format = None
        """
        Specifies the format of the output file for the velocities of shells.

        Available values:
            ATOMIC
                Write only the coordinates X,Y,Z without element symbols to a
                formatted file
            DCD
                Write the coordinates (no element labels) and the cell information to
                a binary file
            XMOL
                Mostly known as XYZ format, provides in a formatted file:
                element_symbol X Y Z
            XYZ
                Alias name for XMOL
        """
        self.EACH = _each77()
        self._name = "SHELL_VELOCITIES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Unit', 'UNIT'), ('Format', 'FORMAT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _charge1(printable):
    """
    Controls the printing of the approximated charge in the RI calculation
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each117()
        self._name = "CHARGE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _charge3(printable):
    """
    Controls the printing of the approximated charge in the RI calculation
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each130()
        self._name = "CHARGE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _charge2(printable):
    """
    Controls the printing of the approximated charge in the RI calculation
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each123()
        self._name = "CHARGE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _charge5(printable):
    """
    This section specifies the charge of the MM atoms
    """
    def __init__(self):
        self.Atom = None
        """
        Defines the atomic kind of the charge.
        """
        self.Charge = None
        """
        Defines the charge of the MM atom in electron charge unit.
        """
        self._name = "CHARGE"
        self._keywords = [('Atom', 'ATOM'), ('Charge', 'CHARGE')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _charge4(printable):
    """
    Controls the printing of the approximated charge in the RI calculation
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each136()
        self._name = "CHARGE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _charge7(printable):
    """
    Controls the printing of the approximated charge in the RI calculation
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each318()
        self._name = "CHARGE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _charge6(printable):
    """
    Controls the printing of the approximated charge in the RI calculation
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each312()
        self._name = "CHARGE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _charge9(printable):
    """
    Controls the printing of the approximated charge in the RI calculation
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each375()
        self._name = "CHARGE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _charge8(printable):
    """
    Controls the printing of the approximated charge in the RI calculation
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each369()
        self._name = "CHARGE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_banner2(printable):
    """
    Controls the printing of the banner of the MM program
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each228()
        self._name = "PROGRAM_BANNER"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_banner3(printable):
    """
    Controls the printing of the banner of the MM program
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each245()
        self._name = "PROGRAM_BANNER"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_banner1(printable):
    """
    Controls the printing of the banner of the MM program
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each179()
        self._name = "PROGRAM_BANNER"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _program_banner4(printable):
    """
    Controls the printing of the banner of the ATOM program
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each354()
        self._name = "PROGRAM_BANNER"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _temperature_colvar1(printable):
    """
    Controls the printing of the temperature of COLVARS in an extended
    lagrangian scheme.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each42()
        self._name = "TEMPERATURE_COLVAR"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _point37(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point34(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point35(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point32(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point33(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point30(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point31(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point38(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _point39(printable):
    """
    Enables the possibility to use geometrical centers instead of single
    atoms to define colvars
    """
    def __init__(self):
        self.Type = None
        """
        Chooses the type of geometrical point

        Available values:
            GEO_CENTER
                Conmputes the geometrical center of the listed atoms
            FIX_POINT
                Defines a fixed point in space
        """
        self.list_Atoms = []
        self.list_Weights = []
        self.Xyz = None
        """
        Specifies the xyz of the fixed point (if the case)
        """
        self._name = "POINT"
        self._keywords = [('Type', 'TYPE'), ('Xyz', 'XYZ')]
        self._repeated_keywords = [('Atoms', 'ATOMS'), ('Weights', 'WEIGHTS')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_Atoms(self, value):
        self.list_Atoms.append(value)

    def add_Weights(self, value):
        self.list_Weights.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _smear2(printable):
    """
    Define the smearing of the MO occupation numbers
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Controls the activation of smearing
        """
        self.Method = None
        """
        Smearing method to be applied

        Available values:
            FERMI_DIRAC
                Fermi-Dirac distribution defined by the keyword ELECTRONIC_TEMPERATURE
            ENERGY_WINDOW
                Energy window defined by the keyword WINDOW_SIZE
            LIST
                Use a fixed list of occupations
        """
        self.List = None
        """
        A list of fractional occupations to use. Must match the number of
        states and sum up to the correct number of electrons
        """
        self.Electronic_temperature = None
        """
        Electronic temperature in the case of Fermi-Dirac smearing
        """
        self.Eps_fermi_dirac = None
        """
        Accuracy checks on occupation numbers use this as a tolerance
        """
        self.Window_size = None
        """
        Size of the energy window centred at the Fermi level
        """
        self.Fixed_magnetic_moment = None
        """
        Imposed difference between the numbers of electrons of spin up and
        spin down: m = n(up) - n(down). A negative value (default) allows for
        a change of the magnetic moment. -1 specifically keeps an integer
        number of spin up and spin down electrons.
        """
        self._name = "SMEAR"
        self._keywords = [('Method', 'METHOD'), ('List', 'LIST'), ('Electronic_temperature', 'ELECTRONIC_TEMPERATURE'), ('Eps_fermi_dirac', 'EPS_FERMI_DIRAC'), ('Window_size', 'WINDOW_SIZE'), ('Fixed_magnetic_moment', 'FIXED_MAGNETIC_MOMENT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Elec_temp(self):
        """
        See documentation for Electronic_temperature
        """
        return self.Electronic_temperature

    @property
    def Telec(self):
        """
        See documentation for Electronic_temperature
        """
        return self.Electronic_temperature

    @Elec_temp.setter
    def Elec_temp(self, value):
        self.Electronic_temperature = value

    @Telec.setter
    def Telec(self, value):
        self.Electronic_temperature = value



class _wannier_states4(printable):
    """
    Controls printing of molecular states
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Cube_eval_range = None
        """
        only write cubes if the eigenvalues of the corresponding molecular
        states lie in the given interval. Default is all states.
        """
        self.list_Mark_states = []
        self.EACH = _each295()
        self.CUBES = _cubes8()
        self._name = "WANNIER_STATES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Cube_eval_range', 'CUBE_EVAL_RANGE')]
        self._repeated_keywords = [('Mark_states', 'MARK_STATES')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH'), ('CUBES', 'CUBES')]
        self._repeated_subsections = []

    def add_Mark_states(self, value):
        self.list_Mark_states.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _wannier_states2(printable):
    """
    Controls printing of molecular states
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Cube_eval_range = None
        """
        only write cubes if the eigenvalues of the corresponding molecular
        states lie in the given interval. Default is all states.
        """
        self.list_Mark_states = []
        self.EACH = _each174()
        self.CUBES = _cubes4()
        self._name = "WANNIER_STATES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Cube_eval_range', 'CUBE_EVAL_RANGE')]
        self._repeated_keywords = [('Mark_states', 'MARK_STATES')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH'), ('CUBES', 'CUBES')]
        self._repeated_subsections = []

    def add_Mark_states(self, value):
        self.list_Mark_states.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _wannier_states3(printable):
    """
    Controls printing of molecular states
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Cube_eval_range = None
        """
        only write cubes if the eigenvalues of the corresponding molecular
        states lie in the given interval. Default is all states.
        """
        self.list_Mark_states = []
        self.EACH = _each206()
        self.CUBES = _cubes6()
        self._name = "WANNIER_STATES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Cube_eval_range', 'CUBE_EVAL_RANGE')]
        self._repeated_keywords = [('Mark_states', 'MARK_STATES')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH'), ('CUBES', 'CUBES')]
        self._repeated_subsections = []

    def add_Mark_states(self, value):
        self.list_Mark_states.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _wannier_states1(printable):
    """
    Controls printing of molecular states
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Cube_eval_range = None
        """
        only write cubes if the eigenvalues of the corresponding molecular
        states lie in the given interval. Default is all states.
        """
        self.list_Mark_states = []
        self.EACH = _each153()
        self.CUBES = _cubes2()
        self._name = "WANNIER_STATES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Cube_eval_range', 'CUBE_EVAL_RANGE')]
        self._repeated_keywords = [('Mark_states', 'MARK_STATES')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH'), ('CUBES', 'CUBES')]
        self._repeated_subsections = []

    def add_Mark_states(self, value):
        self.list_Mark_states.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _xyz_diag4(printable):
    """
    Section to define the distance of an atom from its starting position
    (X-X(0)^2+Y-Y(0)^2+Z-Z(0)^2) or part of its components as a collective
    variable.
    """
    def __init__(self):
        self.Atom = None
        """
        Specifies the index of the atom/point.
        """
        self.Component = None
        """
        Define the component of the position vector which will be used as a
        colvar.

        Available values:
            XYZ
            X
            Y
            Z
            XY
            XZ
            YZ
        """
        self.Pbc = None
        """
        Whether periodic boundary conditions should be applied on the atomic
        position before computing the colvar or not.
        """
        self.list_POINT = []
        self._name = "XYZ_DIAG"
        self._keywords = [('Atom', 'ATOM'), ('Component', 'COMPONENT'), ('Pbc', 'PBC')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point67')]

    def add_POINT(self):
        new_section = _point67()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Point(self):
        """
        See documentation for Atom
        """
        return self.Atom

    @Point.setter
    def Point(self, value):
        self.Atom = value



class _xyz_diag1(printable):
    """
    Section to define the distance of an atom from its starting position
    (X-X(0)^2+Y-Y(0)^2+Z-Z(0)^2) or part of its components as a collective
    variable.
    """
    def __init__(self):
        self.Atom = None
        """
        Specifies the index of the atom/point.
        """
        self.Component = None
        """
        Define the component of the position vector which will be used as a
        colvar.

        Available values:
            XYZ
            X
            Y
            Z
            XY
            XZ
            YZ
        """
        self.Pbc = None
        """
        Whether periodic boundary conditions should be applied on the atomic
        position before computing the colvar or not.
        """
        self.list_POINT = []
        self._name = "XYZ_DIAG"
        self._keywords = [('Atom', 'ATOM'), ('Component', 'COMPONENT'), ('Pbc', 'PBC')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point13')]

    def add_POINT(self):
        new_section = _point13()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Point(self):
        """
        See documentation for Atom
        """
        return self.Atom

    @Point.setter
    def Point(self, value):
        self.Atom = value



class _xyz_diag2(printable):
    """
    Section to define the distance of an atom from its starting position
    (X-X(0)^2+Y-Y(0)^2+Z-Z(0)^2) or part of its components as a collective
    variable.
    """
    def __init__(self):
        self.Atom = None
        """
        Specifies the index of the atom/point.
        """
        self.Component = None
        """
        Define the component of the position vector which will be used as a
        colvar.

        Available values:
            XYZ
            X
            Y
            Z
            XY
            XZ
            YZ
        """
        self.Pbc = None
        """
        Whether periodic boundary conditions should be applied on the atomic
        position before computing the colvar or not.
        """
        self.list_POINT = []
        self._name = "XYZ_DIAG"
        self._keywords = [('Atom', 'ATOM'), ('Component', 'COMPONENT'), ('Pbc', 'PBC')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point31')]

    def add_POINT(self):
        new_section = _point31()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Point(self):
        """
        See documentation for Atom
        """
        return self.Atom

    @Point.setter
    def Point(self, value):
        self.Atom = value



class _xyz_diag3(printable):
    """
    Section to define the distance of an atom from its starting position
    (X-X(0)^2+Y-Y(0)^2+Z-Z(0)^2) or part of its components as a collective
    variable.
    """
    def __init__(self):
        self.Atom = None
        """
        Specifies the index of the atom/point.
        """
        self.Component = None
        """
        Define the component of the position vector which will be used as a
        colvar.

        Available values:
            XYZ
            X
            Y
            Z
            XY
            XZ
            YZ
        """
        self.Pbc = None
        """
        Whether periodic boundary conditions should be applied on the atomic
        position before computing the colvar or not.
        """
        self.list_POINT = []
        self._name = "XYZ_DIAG"
        self._keywords = [('Atom', 'ATOM'), ('Component', 'COMPONENT'), ('Pbc', 'PBC')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('POINT', '_point49')]

    def add_POINT(self):
        new_section = _point49()
        self.list_POINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)
    @property
    def Point(self):
        """
        See documentation for Atom
        """
        return self.Atom

    @Point.setter
    def Point(self, value):
        self.Atom = value



class _orbitals1(printable):
    """
    Controls the printing of the optimized orbitals information
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each361()
        self._name = "ORBITALS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _electric_field_gradient1(printable):
    """
    Calculate and print the electric field gradientsat atomic positions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Interpolation = None
        """
        Use interpolation method from real space grid
        """
        self.Gspace_smoothing = None
        """
        Use a G-space smoothing function
        """
        self.Debug = None
        """
        Print additional debug output
        """
        self.EACH = _each212()
        self.INTERPOLATOR = _interpolator3()
        self._name = "ELECTRIC_FIELD_GRADIENT"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Interpolation', 'INTERPOLATION'), ('Gspace_smoothing', 'GSPACE_SMOOTHING'), ('Debug', 'DEBUG')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH'), ('INTERPOLATOR', 'INTERPOLATOR')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _basis_molopt_quantities1(printable):
    """
    Print the two quantities needed in the basis molopt generation: total
    energy and condition number of the overlap matrix (S matrix)
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each214()
        self._name = "BASIS_MOLOPT_QUANTITIES"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _translation_vector1(printable):
    """
    Dumps the translation vector applied along an MD (if any). Useful for
    postprocessing of QMMM trajectories in which the QM fragment is
    continuously centered in the QM box
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each88()
        self._name = "TRANSLATION_VECTOR"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _optimize_input1(printable):
    """
    describes an input optimization job, in which parameters in input
    files get optimized.
    """
    def __init__(self):
        self.Method = None
        """
        What kind of input optimization to perform.

        Available values:
            FORCE_MATCHING
                Perform a force matching minimization.
        """
        self.Accuracy = None
        """
        Final accuracy requested in optimization (RHOEND)
        """
        self.Step_size = None
        """
        Initial step size for search algorithm (RHOBEG)
        """
        self.Max_fun = None
        """
        Maximum number of function evaluations
        """
        self.Iter_start_val = None
        """
        Used for restarting, starting value of the iteration
        """
        self.Randomize_variables = None
        """
        Percentage randomization of the free variables applied initially
        """
        self.list_VARIABLE = []
        self.list_FORCE_MATCHING = []
        self.HISTORY = _history1()
        self.RESTART = _restart12()
        self._name = "OPTIMIZE_INPUT"
        self._keywords = [('Method', 'METHOD'), ('Accuracy', 'ACCURACY'), ('Step_size', 'STEP_SIZE'), ('Max_fun', 'MAX_FUN'), ('Iter_start_val', 'ITER_START_VAL'), ('Randomize_variables', 'RANDOMIZE_VARIABLES')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('HISTORY', 'HISTORY'), ('RESTART', 'RESTART')]
        self._repeated_subsections = [('VARIABLE', '_variable1'), ('FORCE_MATCHING', '_force_matching1')]

    def add_VARIABLE(self):
        new_section = _variable1()
        self.list_VARIABLE.append(new_section)
        return new_section

    def add_FORCE_MATCHING(self):
        new_section = _force_matching1()
        self.list_FORCE_MATCHING.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _et_coupling1(printable):
    """
    specifies the two constraints/restraints for extracting ET coupling
    elements
    """
    def __init__(self):
        self.Type_of_constraint = None
        """
        Specifies the type of constraint

        Available values:
            NONE
                NONE
            DDAPC
                ddapc_restraint
            BECKE
                Sperical potential
        """
        self.DDAPC_RESTRAINT_A = _ddapc_restraint_a1()
        self.DDAPC_RESTRAINT_B = _ddapc_restraint_b1()
        self.BECKE_RESTRAINT_A = _becke_restraint_a1()
        self.BECKE_RESTRAINT_B = _becke_restraint_b1()
        self.PROGRAM_RUN_INFO = _program_run_info47()
        self._name = "ET_COUPLING"
        self._keywords = [('Type_of_constraint', 'TYPE_OF_CONSTRAINT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('DDAPC_RESTRAINT_A', 'DDAPC_RESTRAINT_A'), ('DDAPC_RESTRAINT_B', 'DDAPC_RESTRAINT_B'), ('BECKE_RESTRAINT_A', 'BECKE_RESTRAINT_A'), ('BECKE_RESTRAINT_B', 'BECKE_RESTRAINT_B'), ('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _projectors1(printable):
    """
    If the printkey is activated controls if information on the projectors
    is printed.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each188()
        self._name = "PROJECTORS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _k_matrix1(printable):
    """
    Controls the printing of the indirect spin-spin matrix
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.list_Atoms_list = []
        self.EACH = _each304()
        self._name = "K_MATRIX"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = [('Atoms_list', 'ATOMS_LIST')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def add_Atoms_list(self, value):
        self.list_Atoms_list.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _replica_info1(printable):
    """
    Controls the printing of each replica info during a BAND run
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each69()
        self._name = "REPLICA_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _iteration_info1(printable):
    """
    Controls the printing of basic iteration information during the scf.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Time_cumul = None
        """
        If the printkey is activated switches the printing of timings to
        cumulative (over the scf).
        """
        self.EACH = _each93()
        self._name = "ITERATION_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Time_cumul', 'TIME_CUMUL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _iteration_info2(printable):
    """
    Controls the printing of basic iteration information during the xas
    scf.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Time_cumul = None
        """
        If the printkey is activated switches the printing of timings to
        cumulative (over the scf).
        """
        self.EACH = _each159()
        self._name = "ITERATION_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Time_cumul', 'TIME_CUMUL')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _gle1(printable):
    """
    paramameters of the gle thermostat. This section can be generated
    from http://gle4md.berlios.de/compose.php?page=matrix
    """
    def __init__(self):
        self.Ndim = None
        """
        Size of the gle matrix
        """
        self.A_scale = None
        """
        scaling factor for matrix A (for generic matrix A, depends on the
        characteristic frequency of the system).
        """
        self.list_A_list = []
        self.list_C_list = []
        self.THERMOSTAT_ENERGY = _thermostat_energy2()
        self.RNG_INIT = _rng_init2()
        self.S = _s1()
        self._name = "GLE"
        self._keywords = [('Ndim', 'NDIM'), ('A_scale', 'A_SCALE')]
        self._repeated_keywords = [('A_list', 'A_LIST'), ('C_list', 'C_LIST')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('THERMOSTAT_ENERGY', 'THERMOSTAT_ENERGY'), ('RNG_INIT', 'RNG_INIT'), ('S', 'S')]
        self._repeated_subsections = []

    def add_A_list(self, value):
        self.list_A_list.append(value)

    def add_C_list(self, value):
        self.list_C_list.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _gle2(printable):
    """
    paramameters of the gle thermostat. This section can be generated
    from http://gle4md.berlios.de/compose.php?page=matrix
    """
    def __init__(self):
        self.Ndim = None
        """
        Size of the gle matrix
        """
        self.A_scale = None
        """
        scaling factor for matrix A (for generic matrix A, depends on the
        characteristic frequency of the system).
        """
        self.list_A_list = []
        self.list_C_list = []
        self.THERMOSTAT_ENERGY = _thermostat_energy4()
        self.RNG_INIT = _rng_init4()
        self.S = _s2()
        self._name = "GLE"
        self._keywords = [('Ndim', 'NDIM'), ('A_scale', 'A_SCALE')]
        self._repeated_keywords = [('A_list', 'A_LIST'), ('C_list', 'C_LIST')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('THERMOSTAT_ENERGY', 'THERMOSTAT_ENERGY'), ('RNG_INIT', 'RNG_INIT'), ('S', 'S')]
        self._repeated_subsections = []

    def add_A_list(self, value):
        self.list_A_list.append(value)

    def add_C_list(self, value):
        self.list_C_list.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _gle3(printable):
    """
    paramameters of the gle thermostat. This section can be generated
    from http://gle4md.berlios.de/compose.php?page=matrix
    """
    def __init__(self):
        self.Ndim = None
        """
        Size of the gle matrix
        """
        self.A_scale = None
        """
        scaling factor for matrix A (for generic matrix A, depends on the
        characteristic frequency of the system).
        """
        self.list_A_list = []
        self.list_C_list = []
        self.THERMOSTAT_ENERGY = _thermostat_energy6()
        self.RNG_INIT = _rng_init6()
        self.S = _s3()
        self._name = "GLE"
        self._keywords = [('Ndim', 'NDIM'), ('A_scale', 'A_SCALE')]
        self._repeated_keywords = [('A_list', 'A_LIST'), ('C_list', 'C_LIST')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('THERMOSTAT_ENERGY', 'THERMOSTAT_ENERGY'), ('RNG_INIT', 'RNG_INIT'), ('S', 'S')]
        self._repeated_subsections = []

    def add_A_list(self, value):
        self.list_A_list.append(value)

    def add_C_list(self, value):
        self.list_C_list.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _xc_potential4(printable):
    """
    The xc potential to use (CAREFUL: xc potential here refers to
    potentials that are not derived from an xc functional, but rather are
    modelled directly. Therefore there is no consistent xc energy
    available. To still get an energy expression, see ENERGY below
    """
    def __init__(self):
        self.Energy = None
        """
        How to determine the total energy.

        Available values:
            NONE
            XC_FUNCTIONAL
            FUNCTIONAL
            SUM_EIGENVALUES
            SOE
        """
        self.list_SAOP = []
        self._name = "XC_POTENTIAL"
        self._keywords = [('Energy', 'ENERGY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('SAOP', '_saop4')]

    def add_SAOP(self):
        new_section = _saop4()
        self.list_SAOP.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _xc_potential3(printable):
    """
    The xc potential to use (CAREFUL: xc potential here refers to
    potentials that are not derived from an xc functional, but rather are
    modelled directly. Therefore there is no consistent xc energy
    available. To still get an energy expression, see ENERGY below
    """
    def __init__(self):
        self.Energy = None
        """
        How to determine the total energy.

        Available values:
            NONE
            XC_FUNCTIONAL
            FUNCTIONAL
            SUM_EIGENVALUES
            SOE
        """
        self.list_SAOP = []
        self._name = "XC_POTENTIAL"
        self._keywords = [('Energy', 'ENERGY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('SAOP', '_saop3')]

    def add_SAOP(self):
        new_section = _saop3()
        self.list_SAOP.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _xc_potential2(printable):
    """
    The xc potential to use (CAREFUL: xc potential here refers to
    potentials that are not derived from an xc functional, but rather are
    modelled directly. Therefore there is no consistent xc energy
    available. To still get an energy expression, see ENERGY below
    """
    def __init__(self):
        self.Energy = None
        """
        How to determine the total energy.

        Available values:
            NONE
            XC_FUNCTIONAL
            FUNCTIONAL
            SUM_EIGENVALUES
            SOE
        """
        self.list_SAOP = []
        self._name = "XC_POTENTIAL"
        self._keywords = [('Energy', 'ENERGY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('SAOP', '_saop2')]

    def add_SAOP(self):
        new_section = _saop2()
        self.list_SAOP.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _xc_potential1(printable):
    """
    The xc potential to use (CAREFUL: xc potential here refers to
    potentials that are not derived from an xc functional, but rather are
    modelled directly. Therefore there is no consistent xc energy
    available. To still get an energy expression, see ENERGY below
    """
    def __init__(self):
        self.Energy = None
        """
        How to determine the total energy.

        Available values:
            NONE
            XC_FUNCTIONAL
            FUNCTIONAL
            SUM_EIGENVALUES
            SOE
        """
        self.list_SAOP = []
        self._name = "XC_POTENTIAL"
        self._keywords = [('Energy', 'ENERGY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = [('SAOP', '_saop1')]

    def add_SAOP(self):
        new_section = _saop1()
        self.list_SAOP.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _csvr1(printable):
    """
    Parameters of the canonical sampling through velocity rescaling
    thermostat.
    """
    def __init__(self):
        self.Timecon = None
        """
        Time constant of the CSVR thermostat. A small time constant will
        result in strong thermostatting (useful for initial equilibrations)
        and a large time constant would be adequate to get weak thermostatting
        in production runs.
        """
        self.THERMOSTAT_ENERGY = _thermostat_energy1()
        self.RNG_INIT = _rng_init1()
        self._name = "CSVR"
        self._keywords = [('Timecon', 'TIMECON')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('THERMOSTAT_ENERGY', 'THERMOSTAT_ENERGY'), ('RNG_INIT', 'RNG_INIT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _csvr3(printable):
    """
    Parameters of the canonical sampling through velocity rescaling
    thermostat.
    """
    def __init__(self):
        self.Timecon = None
        """
        Time constant of the CSVR thermostat. A small time constant will
        result in strong thermostatting (useful for initial equilibrations)
        and a large time constant would be adequate to get weak thermostatting
        in production runs.
        """
        self.THERMOSTAT_ENERGY = _thermostat_energy5()
        self.RNG_INIT = _rng_init5()
        self._name = "CSVR"
        self._keywords = [('Timecon', 'TIMECON')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('THERMOSTAT_ENERGY', 'THERMOSTAT_ENERGY'), ('RNG_INIT', 'RNG_INIT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _csvr2(printable):
    """
    Parameters of the canonical sampling through velocity rescaling
    thermostat.
    """
    def __init__(self):
        self.Timecon = None
        """
        Time constant of the CSVR thermostat. A small time constant will
        result in strong thermostatting (useful for initial equilibrations)
        and a large time constant would be adequate to get weak thermostatting
        in production runs.
        """
        self.THERMOSTAT_ENERGY = _thermostat_energy3()
        self.RNG_INIT = _rng_init3()
        self._name = "CSVR"
        self._keywords = [('Timecon', 'TIMECON')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('THERMOSTAT_ENERGY', 'THERMOSTAT_ENERGY'), ('RNG_INIT', 'RNG_INIT')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _mo_magnitude1(printable):
    """
    Prints the min/max eigenvalues of the overlap of the MOs without S (CT
    C).
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each96()
        self._name = "MO_MAGNITUDE"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each349(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each348(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each347(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each346(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each345(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each344(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each343(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each342(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each341(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each340(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _method_info1(printable):
    """
    Controls the printing of method information
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each355()
        self._name = "METHOD_INFO"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each167(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each166(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each165(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each164(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each163(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each162(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each161(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each160(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _ms_restart1(printable):
    """
    Controls the printing of the Mode Selective Restart file.
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each349()
        self._name = "MS_RESTART"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _ad_langevin1(printable):
    """
    Parameters of the adaptive-Langevin thermostat.
    """
    def __init__(self):
        self.Timecon_nh = None
        """
        Time constant of the Nose-Hoover part of the AD_LANGEVIN thermostat. A
        small time constant will result in strong thermostatting (useful for
        initial equilibrations) and a large time constant would be adequate to
        get weak thermostatting in production runs.
        """
        self.Timecon_langevin = None
        """
        Time constant of the Langevin part of the AD_LANGEVIN thermostat. A
        small time constant will result in strong thermostatting (useful for
        initial equilibrations) and a large time constant would be adequate to
        get weak thermostatting in production runs.
        """
        self.CHI = _chi1()
        self.MASS = _mass3()
        self._name = "AD_LANGEVIN"
        self._keywords = [('Timecon_nh', 'TIMECON_NH'), ('Timecon_langevin', 'TIMECON_LANGEVIN')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('CHI', 'CHI'), ('MASS', 'MASS')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _ad_langevin2(printable):
    """
    Parameters of the adaptive-Langevin thermostat.
    """
    def __init__(self):
        self.Timecon_nh = None
        """
        Time constant of the Nose-Hoover part of the AD_LANGEVIN thermostat. A
        small time constant will result in strong thermostatting (useful for
        initial equilibrations) and a large time constant would be adequate to
        get weak thermostatting in production runs.
        """
        self.Timecon_langevin = None
        """
        Time constant of the Langevin part of the AD_LANGEVIN thermostat. A
        small time constant will result in strong thermostatting (useful for
        initial equilibrations) and a large time constant would be adequate to
        get weak thermostatting in production runs.
        """
        self.CHI = _chi2()
        self.MASS = _mass5()
        self._name = "AD_LANGEVIN"
        self._keywords = [('Timecon_nh', 'TIMECON_NH'), ('Timecon_langevin', 'TIMECON_LANGEVIN')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('CHI', 'CHI'), ('MASS', 'MASS')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _ad_langevin3(printable):
    """
    Parameters of the adaptive-Langevin thermostat.
    """
    def __init__(self):
        self.Timecon_nh = None
        """
        Time constant of the Nose-Hoover part of the AD_LANGEVIN thermostat. A
        small time constant will result in strong thermostatting (useful for
        initial equilibrations) and a large time constant would be adequate to
        get weak thermostatting in production runs.
        """
        self.Timecon_langevin = None
        """
        Time constant of the Langevin part of the AD_LANGEVIN thermostat. A
        small time constant will result in strong thermostatting (useful for
        initial equilibrations) and a large time constant would be adequate to
        get weak thermostatting in production runs.
        """
        self.CHI = _chi3()
        self.MASS = _mass7()
        self._name = "AD_LANGEVIN"
        self._keywords = [('Timecon_nh', 'TIMECON_NH'), ('Timecon_langevin', 'TIMECON_LANGEVIN')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('CHI', 'CHI'), ('MASS', 'MASS')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each169(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _each168(printable):
    """
    This section specifies how often this proprety is printed.Each keyword
    inside this section is mapping to a specific iteration level and the
    value of each of these keywords is matched with the iteration level
    during the calculation. How to handle the last iteration is treated
    separately in ADD_LAST (this mean that each iteration level (MD,
    GEO_OPT, etc..), though equal to 0, might print the last iteration).
    If an iteration level is specified that is not present in the flow of
    the calculation it is just ignored.
    """
    def __init__(self):
        self.Just_energy = None
        """
        Iteration level for an ENERGY/ENERGY_FORCE calculation.
        """
        self.Powell_opt = None
        """
        Iteration level for POWELL based optimization steps.
        """
        self.Qs_scf = None
        """
        Iteration level for the SCF Steps.
        """
        self.Xas_scf = None
        """
        Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        """
        self.Md = None
        """
        Iteration level for the MD steps.
        """
        self.Metadynamics = None
        """
        Iteration level for the METADYNAMICS steps (number of hills added).
        """
        self.Geo_opt = None
        """
        Iteration level for the Geometry optimization steps.
        """
        self.Rot_opt = None
        """
        Iteration level for the Rotational optimization steps in the Dimer
        Calculation.
        """
        self.Cell_opt = None
        """
        Iteration level for the Cell optimization steps.
        """
        self.Band = None
        """
        Iteration level for the Band Calculation Steps
        """
        self.Ep_lin_solver = None
        """
        Iteration level for the Energy Perturbation (EP) linear solver
        """
        self.Spline_find_coeffs = None
        """
        Iteration level for the solution of the coefficients of the splines
        """
        self.Replica_eval = None
        """
        Iteration level for the evaluation of the Replica Environment
        """
        self.Bsse = None
        """
        Iteration level for the Basis Set Superposition Error (BSSE)
        Calculation
        """
        self.Shell_opt = None
        """
        Iteration level for the Shell-Core distances optimization steps
        """
        self._name = "EACH"
        self._keywords = [('Just_energy', 'JUST_ENERGY'), ('Powell_opt', 'POWELL_OPT'), ('Qs_scf', 'QS_SCF'), ('Xas_scf', 'XAS_SCF'), ('Md', 'MD'), ('Metadynamics', 'METADYNAMICS'), ('Geo_opt', 'GEO_OPT'), ('Rot_opt', 'ROT_OPT'), ('Cell_opt', 'CELL_OPT'), ('Band', 'BAND'), ('Ep_lin_solver', 'EP_LIN_SOLVER'), ('Spline_find_coeffs', 'SPLINE_FIND_COEFFS'), ('Replica_eval', 'REPLICA_EVAL'), ('Bsse', 'BSSE'), ('Shell_opt', 'SHELL_OPT')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _xes_spectrum1(printable):
    """
    Controls the dumping of the CLS output files containing the emission
    spectra
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each161()
        self._name = "XES_SPECTRUM"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _center_of_mass1(printable):
    """
    Controls the printing of COM velocity during an MD
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.EACH = _each37()
        self._name = "CENTER_OF_MASS"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _ext_lagrange_fs1(printable):
    """
    Colvar force within an extended Lagrangian formalism.Used for RESTART.
    """
    def __init__(self):
        self.list_Default_keyword = []
        """
        Specified the theta
        """
        self._name = "EXT_LAGRANGE_FS"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _shell_coord1(printable):
    """
    The shell coordinates for the shell-model potentials xyz format with
    an additional column for the index of the corresponding particle
    """
    def __init__(self):
        self.Unit = None
        """
        Specify the unit of measurement for the coordinates in inputAll
        available CP2K units can be used.
        """
        self.Scaled = None
        """
        Specify if the coordinateds in input are scaled.
        """
        self.list_Default_keyword = []
        """
        The shell coordinates in xyz format.
        """
        self._name = "SHELL_COORD"
        self._keywords = [('Unit', 'UNIT'), ('Scaled', 'SCALED')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = [('Default_keyword', 'DEFAULT_KEYWORD')]
        self._subsections = []
        self._repeated_subsections = []

    def add_Default_keyword(self, value):
        self.list_Default_keyword.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _ldos1(printable):
    """
    Controls the printing of local PDOS, projected on subsets of atoms
    given through lists
    """
    def __init__(self):
        self.Components = None
        """
        Print out pdos distinguishing all angular momentum components.
        """
        self.list_List = []
        self._name = "LDOS"
        self._keywords = [('Components', 'COMPONENTS')]
        self._repeated_keywords = [('List', 'LIST')]
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def add_List(self, value):
        self.list_List.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class _multipole3(printable):
    """
    This section is used to set up the decoupling of QM periodic images
    with the use of density derived atomic point charges.
    """
    def __init__(self):
        self.Rcut = None
        """
        Real space cutoff for the Ewald sum.
        """
        self.Ewald_precision = None
        """
        Precision achieved in the Ewald sum.
        """
        self.Analytical_gterm = None
        """
        Evaluates the Gterm in the Ewald Scheme analytically instead of using
        Splines.
        """
        self.Ngrids = None
        """
        Specifies the number of grid points used for the Interpolation of the
        G-space term
        """
        self.INTERPOLATOR = _interpolator5()
        self.CHECK_SPLINE = _check_spline3()
        self.PROGRAM_RUN_INFO = _program_run_info32()
        self._name = "MULTIPOLE"
        self._keywords = [('Rcut', 'RCUT'), ('Ewald_precision', 'EWALD_PRECISION'), ('Analytical_gterm', 'ANALYTICAL_GTERM'), ('Ngrids', 'NGRIDS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('INTERPOLATOR', 'INTERPOLATOR'), ('CHECK_SPLINE', 'CHECK_SPLINE'), ('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _multipole2(printable):
    """
    This section is used to set up the decoupling of QM periodic images
    with the use of density derived atomic point charges.
    """
    def __init__(self):
        self.Rcut = None
        """
        Real space cutoff for the Ewald sum.
        """
        self.Ewald_precision = None
        """
        Precision achieved in the Ewald sum.
        """
        self.Analytical_gterm = None
        """
        Evaluates the Gterm in the Ewald Scheme analytically instead of using
        Splines.
        """
        self.Ngrids = None
        """
        Specifies the number of grid points used for the Interpolation of the
        G-space term
        """
        self.INTERPOLATOR = _interpolator4()
        self.CHECK_SPLINE = _check_spline2()
        self.PROGRAM_RUN_INFO = _program_run_info29()
        self._name = "MULTIPOLE"
        self._keywords = [('Rcut', 'RCUT'), ('Ewald_precision', 'EWALD_PRECISION'), ('Analytical_gterm', 'ANALYTICAL_GTERM'), ('Ngrids', 'NGRIDS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('INTERPOLATOR', 'INTERPOLATOR'), ('CHECK_SPLINE', 'CHECK_SPLINE'), ('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _multipole1(printable):
    """
    This section is used to set up the decoupling of QM periodic images
    with the use of density derived atomic point charges.
    """
    def __init__(self):
        self.Rcut = None
        """
        Real space cutoff for the Ewald sum.
        """
        self.Ewald_precision = None
        """
        Precision achieved in the Ewald sum.
        """
        self.Analytical_gterm = None
        """
        Evaluates the Gterm in the Ewald Scheme analytically instead of using
        Splines.
        """
        self.Ngrids = None
        """
        Specifies the number of grid points used for the Interpolation of the
        G-space term
        """
        self.INTERPOLATOR = _interpolator2()
        self.CHECK_SPLINE = _check_spline1()
        self.PROGRAM_RUN_INFO = _program_run_info21()
        self._name = "MULTIPOLE"
        self._keywords = [('Rcut', 'RCUT'), ('Ewald_precision', 'EWALD_PRECISION'), ('Analytical_gterm', 'ANALYTICAL_GTERM'), ('Ngrids', 'NGRIDS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('INTERPOLATOR', 'INTERPOLATOR'), ('CHECK_SPLINE', 'CHECK_SPLINE'), ('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _becke_restraint_a1(printable):
    """
    Use DDAPC charges in a restraint (check code for details), section can
    be repeated, but only one constraint is possible at the moment.
    """
    def __init__(self):
        self.Strength = None
        """
        force constant of the restraint
        """
        self.Type_of_density = None
        """
        Specifies the type of density used for the fitting

        Available values:
            FULL
                Full density
            SPIN
                Spin density
        """
        self.Target = None
        """
        target value of the restraint
        """
        self.Atoms = None
        """
        Specifies the list of atoms that is summed in the restraint
        """
        self.Coeff = None
        """
        Defines the the coefficient of the atom in the atom list (default is
        one), currently DDAPC only
        """
        self.Functional_form = None
        """
        Specifies the functional form of the term added

        Available values:
            RESTRAINT
                Harmonic potential: s*(q-t)**2
            CONSTRAINT
                Constraint form: s*(q-t)
        """
        self.PROGRAM_RUN_INFO = _program_run_info45()
        self._name = "BECKE_RESTRAINT_A"
        self._keywords = [('Strength', 'STRENGTH'), ('Type_of_density', 'TYPE_OF_DENSITY'), ('Target', 'TARGET'), ('Atoms', 'ATOMS'), ('Coeff', 'COEFF'), ('Functional_form', 'FUNCTIONAL_FORM')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _becke881(printable):
    """
    Uses the Becke 88 exchange functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self._name = "BECKE88"
        self._keywords = [('Scale_x', 'SCALE_X')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _becke882(printable):
    """
    Uses the Becke 88 exchange functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self._name = "BECKE88"
        self._keywords = [('Scale_x', 'SCALE_X')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _becke883(printable):
    """
    Uses the Becke 88 exchange functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self._name = "BECKE88"
        self._keywords = [('Scale_x', 'SCALE_X')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _becke884(printable):
    """
    Uses the Becke 88 exchange functional
    """
    def __init__(self):
        self.Section_parameters = None
        """
        activates the functional
        """
        self.Scale_x = None
        """
        scales the exchange part of the functional
        """
        self._name = "BECKE88"
        self._keywords = [('Scale_x', 'SCALE_X')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = []
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class _motion1(printable):
    """
    This section defines a set of tool connected with the motion of the
    nuclei.
    """
    def __init__(self):
        self.GEO_OPT = _geo_opt1()
        self.CELL_OPT = _cell_opt1()
        self.SHELL_OPT = _shell_opt1()
        self.MD = _md1()
        self.FREE_ENERGY = _free_energy1()
        self.CONSTRAINT = _constraint1()
        self.FLEXIBLE_PARTITIONING = _flexible_partitioning1()
        self.MC = _mc1()
        self.PINT = _pint1()
        self.BAND = _band1()
        self.list_PRINT = []
        self._name = "MOTION"
        self._keywords = []
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('GEO_OPT', 'GEO_OPT'), ('CELL_OPT', 'CELL_OPT'), ('SHELL_OPT', 'SHELL_OPT'), ('MD', 'MD'), ('FREE_ENERGY', 'FREE_ENERGY'), ('CONSTRAINT', 'CONSTRAINT'), ('FLEXIBLE_PARTITIONING', 'FLEXIBLE_PARTITIONING'), ('MC', 'MC'), ('PINT', 'PINT'), ('BAND', 'BAND')]
        self._repeated_subsections = [('PRINT', '_print16')]

    def add_PRINT(self):
        new_section = _print16()
        self.list_PRINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class _hyperfine_coupling_tensor1(printable):
    """
    Calculate and print the EPR hyperfine coupling tensor at atomic
    positions
    """
    def __init__(self):
        self.Section_parameters = None
        """
        Level starting at which this proprety is printed

        Available values:
            ON
            OFF
            SILENT
            LOW
            MEDIUM
            HIGH
            DEBUG
        """
        self.Add_last = None
        """
        If the last iteration should be added, and if it should be marked
        symbolically (with l) or with the iteration number.Not every iteration
        level is able to identify the last iteration early enough to be able
        to output. When this keyword is activated all iteration levels are
        checked for the last iteration step.

        Available values:
            NO
            NUMERIC
            SYMBOLIC
        """
        self.Common_iteration_levels = None
        """
        How many iterations levels should be written in the same file (no
        extra information about the actual iteration level is written to the
        file)
        """
        self.Filename = None
        """
         controls part of the filename for output.  use __STD_OUT__ (exactly
        as written here) for the screen or standard logger.  use filename to
        obtain projectname-filename.  use ./filename to get filename. A middle
        name (if present), iteration numbers and extension are always added to
        the filename. if you want to avoid it use =filename, in this case the
        filename is always exactly as typed. Please note that this can lead to
        clashes of filenames.
        """
        self.Log_print_key = None
        """
        This keywords enables the logger for the print_key (a message is
        printed on screen everytime data, controlled by this print_key, are
        written)
        """
        self.Interaction_radius = None
        """
        Radius of interaction for EPR hyperfine tensor calculation
        """
        self.EACH = _each215()
        self._name = "HYPERFINE_COUPLING_TENSOR"
        self._keywords = [('Add_last', 'ADD_LAST'), ('Common_iteration_levels', 'COMMON_ITERATION_LEVELS'), ('Filename', 'FILENAME'), ('Log_print_key', 'LOG_PRINT_KEY'), ('Interaction_radius', 'INTERACTION_RADIUS')]
        self._repeated_keywords = []
        self._default_keywords = []
        self._repeated_default_keywords = []
        self._subsections = [('EACH', 'EACH')]
        self._repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)
