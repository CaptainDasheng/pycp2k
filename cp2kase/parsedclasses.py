#! /usr/bin/env python
# -*- coding: utf-8 -*-

"""This module holds all the classes parsed from xml file created with command
cp2k --xml"""

from printable import printable


class vdw_potential1(printable):
    """This section combines all possible additional dispersion corrections to the normal XC functionals. This can be more functionals or simple empirical pair potentials."""
    def __init__(self):
        self._POTENTIAL_TYPE = None    # Type of dispersion/vdW functional or potential to use
        self._DISPERSION_FUNCTIONAL = self._POTENTIAL_TYPE
        self.listPAIR_POTENTIAL = []
        self.PAIR_POTENTIAL = pair_potential1()
        self.listNON_LOCAL = []
        self.NON_LOCAL = non_local1()
        self.name = "VDW_POTENTIAL"
        self.keywords = [('_POTENTIAL_TYPE', 'POTENTIAL_TYPE'), ('_DISPERSION_FUNCTIONAL', 'DISPERSION_FUNCTIONAL')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('PAIR_POTENTIAL', 'pair_potential1'), ('NON_LOCAL', 'non_local1')]

    def addPAIR_POTENTIAL(self):
        new_section = pair_potential1()
        self.listPAIR_POTENTIAL.append(new_section)
        return new_section

    def addNON_LOCAL(self):
        new_section = non_local1()
        self.listNON_LOCAL.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class iteration_info2(printable):
    """Controls the printing of basic iteration information during the xas scf."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._TIME_CUMUL = None    # If the printkey is activated switches the printing of timings to cumulative (over the scf).
        self.EACH = each1()
        self.name = "ITERATION_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_TIME_CUMUL', 'TIME_CUMUL')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class quadrupoles1(printable):
    """Specifies the quadrupoles of the particles."""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # The quadrupole components for each atom.
        self.name = "QUADRUPOLES"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class count1(printable):
    """Controls the printing of the number of function calls."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "COUNT"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class quadratic1(printable):
    """Parameters controlling the quadratic wall"""
    def __init__(self):
        self._DIRECTION = None    # Specify the direction of the wall.
        self._K = None    # Specify the value of the quadratic potential constant: K*(CV-POS)^2
        self.name = "QUADRATIC"
        self.keywords = [('_DIRECTION', 'DIRECTION'), ('_K', 'K')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class update1(printable):
    """update a result MO with with a linear combination of of original MOs. This section can be repeated to build arbitrary linear combinations using repeatedly y=a*y+b*x."""
    def __init__(self):
        self._RESULT_MO_INDEX = None    # Index of the MO (y) to be modified. Counting down in energy with HOMO=1
        self._RESULT_MARKED_STATE = None    # Specifies the MO according to the marks set in MOLECULAR_STATES. The value corresponds to the repetition  of MARK_STATES in MOLECULAR_STATES
        self._RESULT_SPIN_INDEX = None    # Spin of the MO (y) to be modified.
        self._RESULT_SCALE = None    # Scaling factor of the result variable (a).
        self._ORIG_MO_INDEX = None    # Index of the original MO (x). Counting down in energy with HOMO=1 or up from LUMO=1, depending on ORIG_IS_VIRTUAL.
        self._ORIG_MARKED_STATE = None    # Specifies the MO according to the marks set in MOLECULAR_STATES. The value corresponds to the repetition  of MARK_STATES in MOLECULAR_STATES
        self._ORIG_SPIN_INDEX = None    # Spin of the MO (x) to be modified.
        self._ORIG_SCALE = None    # Scaling factor of the result variable (b).
        self._ORIG_IS_VIRTUAL = None    # The original MO (x) is a LUMO.
        self.name = "UPDATE"
        self.keywords = [('_RESULT_MO_INDEX', 'RESULT_MO_INDEX'), ('_RESULT_MARKED_STATE', 'RESULT_MARKED_STATE'), ('_RESULT_SPIN_INDEX', 'RESULT_SPIN_INDEX'), ('_RESULT_SCALE', 'RESULT_SCALE'), ('_ORIG_MO_INDEX', 'ORIG_MO_INDEX'), ('_ORIG_MARKED_STATE', 'ORIG_MARKED_STATE'), ('_ORIG_SPIN_INDEX', 'ORIG_SPIN_INDEX'), ('_ORIG_SCALE', 'ORIG_SCALE'), ('_ORIG_IS_VIRTUAL', 'ORIG_IS_VIRTUAL')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class bond1(printable):
    """Specifies the bond potential"""
    def __init__(self):
        self._ATOMS = None    # Defines the atomic kinds involved in the bond.
        self._KIND = None    # Define the kind of Bondpotential.
        self._K = None    # Defines the force constant of the potential. For QUARTIC potentials three numbers are expected.
        self._CS = None    # Defines the cubic stretch term.
        self._R0 = None    # Defines the equilibrium distance.
        self.name = "BOND"
        self.keywords = [('_ATOMS', 'ATOMS'), ('_KIND', 'KIND'), ('_K', 'K'), ('_CS', 'CS'), ('_R0', 'R0')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class program_run_info18(printable):
    """Controls the printing of information regarding the run."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PROGRAM_RUN_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class program_run_info19(printable):
    """Controls the printing of basic information during colvar setup."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PROGRAM_RUN_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class program_run_info10(printable):
    """Controls the printing of basic information during the SCF"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PROGRAM_RUN_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class program_run_info11(printable):
    """Controls the printing of basic information during the run"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PROGRAM_RUN_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class program_run_info12(printable):
    """Controls the printing basic info about the method"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PROGRAM_RUN_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class program_run_info13(printable):
    """Controls the printing of information on the HFX RI approximation"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PROGRAM_RUN_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class program_run_info14(printable):
    """controls the printing of ewald setup"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PROGRAM_RUN_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class program_run_info15(printable):
    """Controls the printing of basic information during the run"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._CONDITION_NUMBER = None    # Prints information regarding the condition numbers of the A matrix (to be inverted)
        self.EACH = each1()
        self.name = "PROGRAM_RUN_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_CONDITION_NUMBER', 'CONDITION_NUMBER')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class program_run_info16(printable):
    """Controls the printing of basic iteration information in CLS"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PROGRAM_RUN_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class program_run_info17(printable):
    """Controls the printing within real time propagation and Eherenfest dynamics"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PROGRAM_RUN_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class goodwin1(printable):
    """This section specifies the input parameters for GOODWIN potential type.Functional form: V(r) = EXP(M*(-(r/DC)**MC+(D/DC)**MC))*VR0*(D/r)**M."""
    def __init__(self):
        self._ATOMS = None    # Defines the atomic kind involved in the nonbond potential
        self._VR0 = None    # Defines the VR0 parameter of the Goodwin potential
        self._D = None    # Defines the D parameter of the Goodwin potential
        self._DC = None    # Defines the DC parameter of the Goodwin potential
        self._M = None    # Defines the M parameter of the Goodwin potential
        self._MC = None    # Defines the MC parameter of the Goodwin potential
        self._RCUT = None    # Defines the cutoff parameter of the Goodwin potential
        self._RMIN = None    # Defines the lower bound of the potential. If not set the range is the full range generate by the spline
        self._RMAX = None    # Defines the upper bound of the potential. If not set the range is the full range generate by the spline
        self.name = "GOODWIN"
        self.keywords = [('_ATOMS', 'ATOMS'), ('_VR0', 'VR0'), ('_D', 'D'), ('_DC', 'DC'), ('_M', 'M'), ('_MC', 'MC'), ('_RCUT', 'RCUT'), ('_RMIN', 'RMIN'), ('_RMAX', 'RMAX')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class radii1(printable):
    """controls the output of radii information"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._UNIT = None    # Specify the unit of measurement for the quantity in output. All available CP2K units can be used.
        self._CORE_CHARGES_RADII = None    # If the printkey is activated controls the printing of the radii of the core charges
        self._PGF_RADII = None    # If the printkey is activated controls the printing of the core gaussian radii
        self._SET_RADII = None    # If the printkey is activated controls the printing of the set_radii
        self._KIND_RADII = None    # If the printkey is activated controls the printing of the kind_radii
        self._CORE_CHARGE_RADII = None    # If the printkey is activated controls the printing of the core_charge_radii
        self._GTH_PPL_RADII = None    # If the printkey is activated controls the printing of the gth pseudo potential local radii
        self._GTH_PPNL_RADII = None    # If the printkey is activated controls the printing of the gth pseudo potential non local radii
        self._GAPW_PRJ_RADII = None    # If the printkey is activated controls the printing of the gapw projector radii
        self.EACH = each1()
        self.name = "RADII"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_UNIT', 'UNIT'), ('_CORE_CHARGES_RADII', 'CORE_CHARGES_RADII'), ('_PGF_RADII', 'PGF_RADII'), ('_SET_RADII', 'SET_RADII'), ('_KIND_RADII', 'KIND_RADII'), ('_CORE_CHARGE_RADII', 'CORE_CHARGE_RADII'), ('_GTH_PPL_RADII', 'GTH_PPL_RADII'), ('_GTH_PPNL_RADII', 'GTH_PPNL_RADII'), ('_GAPW_PRJ_RADII', 'GAPW_PRJ_RADII')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class program_run_info8(printable):
    """Controls the printing basic info about the BAND run"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._INITIAL_CONFIGURATION_INFO = None    # Print information for the setup of the initial configuration.
        self.EACH = each1()
        self.name = "PROGRAM_RUN_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_INITIAL_CONFIGURATION_INFO', 'INITIAL_CONFIGURATION_INFO')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class program_run_info9(printable):
    """Controls the printing of information during the evaluation of the mixed environment."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PROGRAM_RUN_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class program_run_info6(printable):
    """Controls the printing of basic and summary information during the Molecular Dynamics"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PROGRAM_RUN_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class program_run_info7(printable):
    """Controls the printing of basic and summary information during metadynamics."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PROGRAM_RUN_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class program_run_info4(printable):
    """Controls the printing of basic information during the Geometry Optimization"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PROGRAM_RUN_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class program_run_info5(printable):
    """Controls the printing of basic information during the Optimization"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PROGRAM_RUN_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class program_run_info2(printable):
    """controls the printing of tests output"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PROGRAM_RUN_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class program_run_info3(printable):
    """controls the printing of DEBUG specific output"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PROGRAM_RUN_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class program_run_info1(printable):
    """controls the printing of  initialization controlled by the global section"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PROGRAM_RUN_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class ep_rho_cube1(printable):
    """Prints out a cube file with the calculated rho"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._RHO0 = None    # print the cube of rho0,the psi0 derived density matrix
        self._RHO1 = None    # print the value of the blocs of rho1, the psi1 (and psi0) derived density matrix
        self._STRIDE = None    # The stride (X,Y,Z) used to write the cube file (larger values result in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1 number valid for all components.
        self._MO_S_INV = None    # print the value of the inverse of the mo overlap matrix
        self.EACH = each1()
        self.name = "EP_RHO_CUBE"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_RHO0', 'RHO0'), ('_RHO1', 'RHO1'), ('_STRIDE', 'STRIDE'), ('_MO_S_INV', 'MO_S_INV')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class conv_info1(printable):
    """if convergence information about the linear solver of the spline methods should be printed"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "CONV_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class merge_molecules1(printable):
    """Enables the creation of connecting bridges (bonds, angles, torsions, impropers) between the two or more molecules defined with independent connectivity."""
    def __init__(self):
        self.BONDS = bonds1()
        self.ANGLES = angles1()
        self.TORSIONS = torsions1()
        self.IMPROPERS = impropers1()
        self.name = "MERGE_MOLECULES"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('BONDS', 'BONDS'), ('ANGLES', 'ANGLES'), ('TORSIONS', 'TORSIONS'), ('IMPROPERS', 'IMPROPERS')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class msd_molecule1(printable):
    """Controls the output of msd per molecule kind"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "MSD_MOLECULE"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class rot_opt1(printable):
    """This section sets the environment for the optimization of the rotation of the Dimer."""
    def __init__(self):
        self._OPTIMIZER = None    # Specify which method to use to perform a geometry optimization.
        self._MINIMIZER = self._OPTIMIZER
        self._MAX_ITER = None    # Specifies the maximum number of geometry optimization steps. One step might imply several force evaluations for the CG and LBFGS optimizers.
        self._MAX_DR = None    # Convergence criterium for the maximum geometry change between the current and the last optimizer iteration.
        self._MAX_FORCE = None    # Convergence criterium for the maximum force component of the current configuration.
        self._RMS_DR = None    # Convergence criterium for the root mean square (RMS) geometry change between the current and the last optimizer iteration.
        self._RMS_FORCE = None    # Convergence criterium for the root mean square (RMS) force of the current configuration.
        self._STEP_START_VAL = None    # The starting step value for the ROT_OPT module.
        self.LBFGS = lbfgs1()
        self.CG = cg1()
        self.BFGS = bfgs1()
        self.listPRINT = []
        self.PRINT = print2()
        self.name = "ROT_OPT"
        self.keywords = [('_OPTIMIZER', 'OPTIMIZER'), ('_MINIMIZER', 'MINIMIZER'), ('_MAX_ITER', 'MAX_ITER'), ('_MAX_DR', 'MAX_DR'), ('_MAX_FORCE', 'MAX_FORCE'), ('_RMS_DR', 'RMS_DR'), ('_RMS_FORCE', 'RMS_FORCE'), ('_STEP_START_VAL', 'STEP_START_VAL')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('LBFGS', 'LBFGS'), ('CG', 'CG'), ('BFGS', 'BFGS')]
        self.repeated_subsections = [('PRINT', 'print2')]

    def addPRINT(self):
        new_section = print2()
        self.listPRINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class localize1(printable):
    """Use one of the available methods to define the localization  and possibly to optimize it to a minimum or a maximum."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._MAX_ITER = None    # Maximum number of iterations used for localization methods
        self._MAX_CRAZY_ANGLE = None    # Largest allowed angle for the crazy rotations algorithm (smaller is slower but more stable).
        self._CRAZY_SCALE = None    # scale angles
        self._CRAZY_USE_DIAG = None    # Use diagonalization (slow) or pade based calculation of matrix exponentials.
        self._USE_HISTORY = None    # Generate an improved initial guess based on a history of results, which is useful during MD.Will only work if the number of states to be localized remains constant.
        self._EPS_OCCUPATION = None    # Tolerance in the occupation number to select only fully occupied orbitals for the rotation
        self._OUT_ITER_EACH = None    # Every how many iterations of the localization algorithm(Jacobi) the tolerance value is printed out
        self._EPS_LOCALIZATION = None    # Tolerance used in the convergence criterium of the localization methods.
        self._MIN_OR_MAX = None    # Requires the maximization of the spread of the wfn
        self._METHOD = None    # Method of optimization if any
        self._JACOBI_FALLBACK = None    # Use Jacobi method in case no convergence was achieved by using the crazy rotations method.
        self._RESTART = None    # Restart the localization from a set of orbitals read from a localization restart file.
        self._LOCHOMO_RESTART_FILE_NAME = None    # File name where to read the MOS fromwhich to restart the localization procedure for occupied states
        self._LOCLUMO_RESTART_FILE_NAME = None    # File name where to read the MOS fromwhich to restart the localization procedure for unoccupied states
        self._OPERATOR = None    # Type of opertator which defines the spread functional
        self.list_LIST = []
        self._LIST = None
    # Indexes of the occupied wfn to be localizedThis keyword can be repeated several times(useful if you have to specify many indexes).
        self.list_LIST_UNOCCUPIED = []
        self._LIST_UNOCCUPIED = None
    # Indexes of the unoccupied states to be localized, up to now only valid in combination with GPW. This keyword has to be present if unoccupied states should be localized. This keyword can be repeated several times(useful if you have to specify many indexes).
        self._STATES = None    # Which states to localize, LUMO up to now only available in GPW
        self._ENERGY_RANGE = None    # Select the orbitals to be localized within the given energy range.This type of selection cannot be added on top of the selection through a LIST. It reads to reals that are lower and higher boundaries of the energy range.
        self.PRINT = print22()
        self.name = "LOCALIZE"
        self.keywords = [('_MAX_ITER', 'MAX_ITER'), ('_MAX_CRAZY_ANGLE', 'MAX_CRAZY_ANGLE'), ('_CRAZY_SCALE', 'CRAZY_SCALE'), ('_CRAZY_USE_DIAG', 'CRAZY_USE_DIAG'), ('_USE_HISTORY', 'USE_HISTORY'), ('_EPS_OCCUPATION', 'EPS_OCCUPATION'), ('_OUT_ITER_EACH', 'OUT_ITER_EACH'), ('_EPS_LOCALIZATION', 'EPS_LOCALIZATION'), ('_MIN_OR_MAX', 'MIN_OR_MAX'), ('_METHOD', 'METHOD'), ('_JACOBI_FALLBACK', 'JACOBI_FALLBACK'), ('_RESTART', 'RESTART'), ('_LOCHOMO_RESTART_FILE_NAME', 'LOCHOMO_RESTART_FILE_NAME'), ('_LOCLUMO_RESTART_FILE_NAME', 'LOCLUMO_RESTART_FILE_NAME'), ('_OPERATOR', 'OPERATOR'), ('_STATES', 'STATES'), ('_ENERGY_RANGE', 'ENERGY_RANGE')]
        self.repeated_keywords = [('_LIST', 'LIST'), ('_LIST_UNOCCUPIED', 'LIST_UNOCCUPIED')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PRINT', 'PRINT')]
        self.repeated_subsections = []

    def add_LIST(self, value):
        self.list_LIST.append(value)

    def add_LIST_UNOCCUPIED(self, value):
        self.list_LIST_UNOCCUPIED.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class coordination1(printable):
    """Section to define the coordination number as a collective variable."""
    def __init__(self):
        self.list_ATOMS_FROM = []
        self._ATOMS_FROM = None
    # Specify indexes of atoms/points building the coordination variable.
        self._POINTS_FROM = self._ATOMS_FROM
        self.list_POINTS_FROM = self.list_ATOMS_FROM
        self.list_ATOMS_TO = []
        self._ATOMS_TO = None
    # Specify indexes of atoms/points building the coordination variable.
        self._POINTS_TO = self._ATOMS_TO
        self.list_POINTS_TO = self.list_ATOMS_TO
        self.list_ATOMS_TO_B = []
        self._ATOMS_TO_B = None
    # For the CV given by the multiplication of two coorination numbers, here specify indexes of the third set of atoms/points.
        self._POINTS_TO_B = self._ATOMS_TO_B
        self.list_POINTS_TO_B = self.list_ATOMS_TO_B
        self.list_KINDS_FROM = []
        self._KINDS_FROM = None
    # Specify alternatively kinds of atoms building the coordination variable.
        self.list_KINDS_TO = []
        self._KINDS_TO = None
    # Specify alternatively kinds of atoms building the coordination variable.
        self.list_KINDS_TO_B = []
        self._KINDS_TO_B = None
    # For the CV given by the multiplication of two coorination numbers, here specify alternatively kinds of atoms building the coordination variable.
        self._R0 = None    # Specify the R0 parameter in the coordination function.
        self._R_0 = self._R0
        self._NN = None    # Sets the value of the numerator of the exponential factorin the coordination FUNCTION.
        self._EXPON_NUMERATOR = self._NN
        self._ND = None    # Sets the value of the denominator of the exponential factorin the coordination FUNCTION.
        self._EXPON_DENOMINATOR = self._ND
        self._R0_B = None    # For the CV given by the multiplication of two coorination numbers, specify the R0 parameter in the second coordination function.
        self._R_0_B = self._R0_B
        self._NN_B = None    # For the CV given by the multiplication of two coorination numbers,Sets the value of the numerator of the exponential factorin the coordination FUNCTION.
        self._EXPON_NUMERATOR_B = self._NN_B
        self._ND_B = None    # For the CV given by the multiplication of two coorination numbers,Sets the value of the denominator of the exponential factorin the coordination FUNCTION.
        self._EXPON_DENOMINATOR_B = self._ND_B
        self.listPOINT = []
        self.POINT = point1()
        self.name = "COORDINATION"
        self.keywords = [('_R0', 'R0'), ('_R_0', 'R_0'), ('_NN', 'NN'), ('_EXPON_NUMERATOR', 'EXPON_NUMERATOR'), ('_ND', 'ND'), ('_EXPON_DENOMINATOR', 'EXPON_DENOMINATOR'), ('_R0_B', 'R0_B'), ('_R_0_B', 'R_0_B'), ('_NN_B', 'NN_B'), ('_EXPON_NUMERATOR_B', 'EXPON_NUMERATOR_B'), ('_ND_B', 'ND_B'), ('_EXPON_DENOMINATOR_B', 'EXPON_DENOMINATOR_B')]
        self.repeated_keywords = [('_ATOMS_FROM', 'ATOMS_FROM'), ('_POINTS_FROM', 'POINTS_FROM'), ('_ATOMS_TO', 'ATOMS_TO'), ('_POINTS_TO', 'POINTS_TO'), ('_ATOMS_TO_B', 'ATOMS_TO_B'), ('_POINTS_TO_B', 'POINTS_TO_B'), ('_KINDS_FROM', 'KINDS_FROM'), ('_KINDS_TO', 'KINDS_TO'), ('_KINDS_TO_B', 'KINDS_TO_B')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('POINT', 'point1')]

    def addPOINT(self):
        new_section = point1()
        self.listPOINT.append(new_section)
        return new_section

    def add_ATOMS_FROM(self, value):
        self.list_ATOMS_FROM.append(value)

    def add_POINTS_FROM(self, value):
        self.list_POINTS_FROM.append(value)

    def add_ATOMS_TO(self, value):
        self.list_ATOMS_TO.append(value)

    def add_POINTS_TO(self, value):
        self.list_POINTS_TO.append(value)

    def add_ATOMS_TO_B(self, value):
        self.list_ATOMS_TO_B.append(value)

    def add_POINTS_TO_B(self, value):
        self.list_POINTS_TO_B.append(value)

    def add_KINDS_FROM(self, value):
        self.list_KINDS_FROM.append(value)

    def add_KINDS_TO(self, value):
        self.list_KINDS_TO.append(value)

    def add_KINDS_TO_B(self, value):
        self.list_KINDS_TO_B.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class fixed_atoms1(printable):
    """This section is used to constraint the overall atomic position (X,Y,Z). In case a restraint is specified the value of the TARGET is considered to be the value of the coordinates at the beginning of the run or alternatively the corresponding value in the section: FIX_ATOM_RESTART."""
    def __init__(self):
        self._COMPONENTS_TO_FIX = None    # Specify which components (X,Y,Z or combinations) of the atoms specified in the sectionwill be constrained/restrained.
        self.list_LIST = []
        self._LIST = None
    # Specifies a list of atoms to freeze.
        self.list_MOLNAME = []
        self._MOLNAME = None
    # Specifies the name of the molecule to fix
        self._SEGNAME = self._MOLNAME
        self.list_SEGNAME = self.list_MOLNAME
        self._MM_SUBSYS = None    # In a QM/MM run all  MM atoms are fixed according to the argument.
        self._PROTEIN = self._MM_SUBSYS
        self._QM_SUBSYS = None    # In a QM/MM run all QM atoms are fixed according to the argument.
        self._EXCLUDE_QM = None    # Does not apply the constraint to the QM region within a QM/MM calculation. This keyword is active only together with MOLNAME
        self._EXCLUDE_MM = None    # Does not apply the constraint to the MM region within a QM/MM calculation. This keyword is active only together with MOLNAME
        self.RESTRAINT = restraint1()
        self.name = "FIXED_ATOMS"
        self.keywords = [('_COMPONENTS_TO_FIX', 'COMPONENTS_TO_FIX'), ('_MM_SUBSYS', 'MM_SUBSYS'), ('_PROTEIN', 'PROTEIN'), ('_QM_SUBSYS', 'QM_SUBSYS'), ('_EXCLUDE_QM', 'EXCLUDE_QM'), ('_EXCLUDE_MM', 'EXCLUDE_MM')]
        self.repeated_keywords = [('_LIST', 'LIST'), ('_MOLNAME', 'MOLNAME'), ('_SEGNAME', 'SEGNAME')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('RESTRAINT', 'RESTRAINT')]
        self.repeated_subsections = []

    def add_LIST(self, value):
        self.list_LIST.append(value)

    def add_MOLNAME(self, value):
        self.list_MOLNAME.append(value)

    def add_SEGNAME(self, value):
        self.list_SEGNAME.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class ke_gga1(printable):
    """Uses one of the KE_GGA functionals (optimized versions of some of these functionals might be available outside this section)."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._FUNCTIONAL = None    # Which one of the KE_GGA functionals should be used
        self.name = "KE_GGA"
        self.keywords = [('_FUNCTIONAL', 'FUNCTIONAL')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class stress_tensor1(printable):
    """Controls the printing of the stress tensor"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._NDIGITS = None    # Specifies the number of digits used for the printing of the stress tensor
        self.EACH = each1()
        self.name = "STRESS_TENSOR"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_NDIGITS', 'NDIGITS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print11(printable):
    """Controls the printing properties during an metadynamics run"""
    def __init__(self):
        self.PROGRAM_RUN_INFO = program_run_info7()
        self.TEMPERATURE_COLVAR = temperature_colvar1()
        self.COLVAR = colvar1()
        self.HILLS = hills1()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('TEMPERATURE_COLVAR', 'TEMPERATURE_COLVAR'), ('COLVAR', 'COLVAR'), ('HILLS', 'HILLS')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class mhypminsampling1(printable):
    """Permutation cycle length sampling settings"""
    def __init__(self):
        self._MHYPMINVALUE = None    # Value of m treated in a special way
        self._MHYPMINRATIO = None    # Probability ratio betw M-VALUE and other cycle lengths
        self.name = "M-SAMPLING"
        self.keywords = [('_MHYPMINVALUE', 'M-VALUE'), ('_MHYPMINRATIO', 'M-RATIO')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class vibrational_analysis1(printable):
    """Section to setup parameters to perform a Normal Modes analysis."""
    def __init__(self):
        self._DX = None    # Specify the increment to be used to construct the HESSIAN with finite difference method
        self._NPROC_REP = None    # Specify the number of processors to be used per replica environment (for parallel runs). In case of mode selective calculations more than one replica will start a block Davidson algorithm to track more than only one frequency
        self._PROC_DIST_TYPE = None    # Specify the topology of the mapping of processors into replicas.
        self._FULLY_PERIODIC = None    # Avoids to clean rotations from the Hessian matrix.
        self._INTENSITIES = None    # Calculation of the IR-Intensities. Calculation of dipols has to be specified explicitly
        self.MODE_SELECTIVE = mode_selective1()
        self.PRINT = print44()
        self.name = "VIBRATIONAL_ANALYSIS"
        self.keywords = [('_DX', 'DX'), ('_NPROC_REP', 'NPROC_REP'), ('_PROC_DIST_TYPE', 'PROC_DIST_TYPE'), ('_FULLY_PERIODIC', 'FULLY_PERIODIC'), ('_INTENSITIES', 'INTENSITIES')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('MODE_SELECTIVE', 'MODE_SELECTIVE'), ('PRINT', 'PRINT')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class spawned_hills_height1(printable):
    """The height of the spawned hills during metadynamics.Used for RESTART."""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Specify the spawned hills
        self.name = "SPAWNED_HILLS_HEIGHT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class chebyshev1(printable):
    """Specifies the parameters needed for the chebyshev expansion based properties."""
    def __init__(self):
        self._N_CHEBYSHEV = None    # Order of the polynomial expansion.
        self.DOS = dos1()
        self.PRINT_SPECIFIC_E_DENSITY_CUBE = print_specific_e_density_cube1()
        self.name = "CHEBYSHEV"
        self.keywords = [('_N_CHEBYSHEV', 'N_CHEBYSHEV')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('DOS', 'DOS'), ('PRINT_SPECIFIC_E_DENSITY_CUBE', 'PRINT_SPECIFIC_E_DENSITY_CUBE')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class becke_restraint1(printable):
    """Use Becke weight population in a restraint/constraint"""
    def __init__(self):
        self._STRENGTH = None    # force constant of the restraint
        self._TARGET = None    # target value of the restraint
        self._ATOMS = None    # Specifies the list of atoms that is summed in the restraint
        self._COEFF = None    # Defines the the coefficient of the atom in the atom list (default is one)
        self._FUNCTIONAL_FORM = None    # Specifies the functional form of the term added
        self._TYPE_OF_DENSITY = None    # Specifies the type of density used for the fitting
        self.PROGRAM_RUN_INFO = program_run_info12()
        self.name = "BECKE_RESTRAINT"
        self.keywords = [('_STRENGTH', 'STRENGTH'), ('_TARGET', 'TARGET'), ('_ATOMS', 'ATOMS'), ('_COEFF', 'COEFF'), ('_FUNCTIONAL_FORM', 'FUNCTIONAL_FORM'), ('_TYPE_OF_DENSITY', 'TYPE_OF_DENSITY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class mp2_info1(printable):
    """Controls the printing basic info about MP2 method"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "MP2_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class distribution1d1(printable):
    """Each node prints out its distribution info ..."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "DISTRIBUTION1D"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class colvar_func_info1(printable):
    """Specify further data possibly used by colvars, depending on the starting geometry, for computing the functions value."""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Colvar function data. The order is an internal order. So if you decide to edit/modify/add these values by hand you should know very well what you are doing.!
        self.name = "COLVAR_FUNC_INFO"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class coord_var1(printable):
    """Controls the printing of the variance of the coordination number."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "COORD_VAR"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class quadrupole1(printable):
    """This section specifies that we will perform an SCF quadrupole calculation of the MM atoms. Needs KEYWORD POL_SCF in POISSON secton"""
    def __init__(self):
        self._ATOM = None    # Defines the atomic kind of the scf quadrupole.
        self._CPOL = None    # Defines the isotropic polarizability of the MM atom.
        self.name = "QUADRUPOLE"
        self.keywords = [('_ATOM', 'ATOM'), ('_CPOL', 'CPOL')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print43(printable):
    """Controls the printing mode selective vibrational analysis"""
    def __init__(self):
        self.MS_RESTART = ms_restart1()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('MS_RESTART', 'MS_RESTART')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class fit_charge1(printable):
    """This section is used to print the density derived atomic point charges.The fit of the charges is controlled through the DENSITY_FITTING section"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._TYPE_OF_DENSITY = None    # Specifies the type of density used for the fitting
        self.EACH = each1()
        self.name = "FIT_CHARGE"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_TYPE_OF_DENSITY', 'TYPE_OF_DENSITY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class hyperfine_coupling_tensor1(printable):
    """Calculate and print the EPR hyperfine coupling tensor at atomic positions"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._INTERACTION_RADIUS = None    # Radius of interaction for EPR hyperfine tensor calculation
        self.EACH = each1()
        self.name = "HYPERFINE_COUPLING_TENSOR"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_INTERACTION_RADIUS', 'INTERACTION_RADIUS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class debug1(printable):
    """Section to setup parameters for debug runs."""
    def __init__(self):
        self._DEBUG_FORCES = None    # Enables  the debug of the forces.
        self._DEBUG_STRESS_TENSOR = None    # Enables the debug of the stress tensor
        self._DX = None    #  Setup the DX parameter to evaluate numerical derivatives
        self.PROGRAM_RUN_INFO = program_run_info3()
        self.name = "DEBUG"
        self.keywords = [('_DEBUG_FORCES', 'DEBUG_FORCES'), ('_DEBUG_STRESS_TENSOR', 'DEBUG_STRESS_TENSOR'), ('_DX', 'DX')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class angle_plane_plane1(printable):
    """This section defines the angle between two planes as a collective variables."""
    def __init__(self):
        self.listPLANE = []
        self.PLANE = plane1()
        self.listPOINT = []
        self.POINT = point1()
        self.name = "ANGLE_PLANE_PLANE"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('PLANE', 'plane1'), ('POINT', 'point1')]

    def addPLANE(self):
        new_section = plane1()
        self.listPLANE.append(new_section)
        return new_section

    def addPOINT(self):
        new_section = point1()
        self.listPOINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class reaction_path1(printable):
    """Section defining a one dimensional reaction path in an Q-dimensional space of colvars. Constraining this colvar, allows to sample the space orthogonal to the reaction path, both in the Q-dimensional colvar and 3N-Q remaining coordinates. For the details of the function see cited literature."""
    def __init__(self):
        self._DISTANCES_RMSD = None
        self._RMSD = None
        self._SUBSET_TYPE = None    # Define the subsytem used to compute the RMSD
        self._ALIGN_FRAMES = None    # Whether the reference frames should be aligned to minimize the RMSD
        self.list_ATOMS = []
        self._ATOMS = None
    # Specify indexes of atoms building the subset.
        self.list_FUNCTION = []
        self._FUNCTION = None
    # Specifies the ith element of the vector valued function that defines the reaction path. This keyword needs to repeat exactly Q times, and the order must match the order of the colvars. The VARIABLE (e.g. T) which parametrises the curve can be used as the target of a constraint.
        self._VARIABLE = None    # Specifies the name of the variable that parametrises the FUNCTION defining the reaction path.
        self._LAMBDA = None    # Specifies the exponent of the Gaussian used in the integral representation of the colvar.The shape of the space orthogonal to the reaction path is defined by this choice. In the limit of large values, it is given by the plane orthogonal to the path.In practice, modest values are required for stable numerical integration.
        self._STEP_SIZE = None    # Step size in the numerical integration, a few thousand points are common, and the proper number also depends on LAMBDA.
        self._RANGE = None    # The range of VARIABLE used for the parametrisation.
        self.listCOLVAR = []
        self.COLVAR = colvar2()
        self.listFRAME = []
        self.FRAME = frame2()
        self.MAP = map1()
        self.name = "REACTION_PATH"
        self.keywords = [('_DISTANCES_RMSD', 'DISTANCES_RMSD'), ('_RMSD', 'RMSD'), ('_SUBSET_TYPE', 'SUBSET_TYPE'), ('_ALIGN_FRAMES', 'ALIGN_FRAMES'), ('_VARIABLE', 'VARIABLE'), ('_LAMBDA', 'LAMBDA'), ('_STEP_SIZE', 'STEP_SIZE'), ('_RANGE', 'RANGE')]
        self.repeated_keywords = [('_ATOMS', 'ATOMS'), ('_FUNCTION', 'FUNCTION')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('MAP', 'MAP')]
        self.repeated_subsections = [('COLVAR', 'colvar2'), ('FRAME', 'frame2')]

    def addCOLVAR(self):
        new_section = colvar2()
        self.listCOLVAR.append(new_section)
        return new_section

    def addFRAME(self):
        new_section = frame2()
        self.listFRAME.append(new_section)
        return new_section

    def add_ATOMS(self, value):
        self.list_ATOMS.append(value)

    def add_FUNCTION(self, value):
        self.list_FUNCTION.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class xray_diffraction_spectrum1(printable):
    """Calculate and print the coherent X-ray diffraction spectrum"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._Q_MAX = None    # Maximum Q value calculated for the spectrum
        self._Q_MAXIMUM = self._Q_MAX
        self.EACH = each1()
        self.name = "XRAY_DIFFRACTION_SPECTRUM"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_Q_MAX', 'Q_MAX'), ('_Q_MAXIMUM', 'Q_MAXIMUM')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class harris1(printable):
    """This section specifies the flags for the calculation of the harris functional"""
    def __init__(self):
        self._ACTIVATE = None    # Activates the harris functional.
        self._HARRIS_ENERGY = None    # Overrides the QS Energy.
        self.name = "HARRIS"
        self.keywords = [('_ACTIVATE', 'ACTIVATE'), ('_HARRIS_ENERGY', 'HARRIS_ENERGY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class efield_cube1(printable):
    """Controls the printing of cube files with electric  field generated by the total density (electrons+ions). It is  valid only for QS with GPW formalism ."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._STRIDE = None    # The stride (X,Y,Z) used to write the cube file (larger values result in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1 number valid for all components.
        self._APPEND = None    # append the cube files when they already exist
        self.EACH = each1()
        self.name = "EFIELD_CUBE"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_STRIDE', 'STRIDE'), ('_APPEND', 'APPEND')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class stm1(printable):
    """Controls the printing of cubes for the generation of STM images."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._STRIDE = None    # The stride (X,Y,Z) used to write the cube file (larger values result in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1 number valid for all components.
        self._NLUMO = None    # If the printkey is activated controls the number of additional lumos that are computed to be able to reproduce STM images obtained  from positive bias (imaging unoccupied states)
        self._BIAS = None    # Bias energy for scanning tunneling microscopy (STM) image generation.Orbital densities are summed according to the bias energy.For negative values, states in the range ]EF+bias,EF] are summed,While positive values sum states in the range [EF,EF+bias[.If postive biases are used, sufficiently many unoccupied stated (see ADDED_MOS and NLUMO ) should be computed.
        self.list_TH_TORB = []
        self._TH_TORB = None
    # Tip orbital symmetry in Tersoff-Hamann approximation to compute STM images
        self._REF_ENERGY = None    # By default the reference energy is the Fermi energy. In order to compare with STS experiments, where specific energy ranges are addressed, here  one can set a different reference energy. The energy range is anyway controlled by the BIAS
        self._APPEND = None    # append the cube files when they already exist
        self.EACH = each1()
        self.name = "STM"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_STRIDE', 'STRIDE'), ('_NLUMO', 'NLUMO'), ('_BIAS', 'BIAS'), ('_REF_ENERGY', 'REF_ENERGY'), ('_APPEND', 'APPEND')]
        self.repeated_keywords = [('_TH_TORB', 'TH_TORB')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def add_TH_TORB(self, value):
        self.list_TH_TORB.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class farming1(printable):
    """describes a farming job, in which multiple inputs are executed"""
    def __init__(self):
        self._MASTER_SLAVE = None    # If a master-slave setup should be employed, in which one process is used to distribute the tasks. This is most useful to load-balance if not all jobs have the same length, and a lot of CPUs/groups are availabe.
        self._NGROUPS = None    # Gives the preferred number of working groups.
        self._NGROUP = self._NGROUPS
        self._GROUP_SIZE = None    # Gives the preferred size of a working group, groups will always be equal or larger than this size.
        self._GROUP_PARTITION = None    # gives the exact number of processors for each group.
        self._MAX_JOBS_PER_GROUP = None    # maximum number of jobs executed per group
        self._MAX_JOBS = self._MAX_JOBS_PER_GROUP
        self._CYCLE = None    # If farming should process all jobs in a cyclic way, stopping only if MAX_JOBS_PER_GROUP is exceeded.
        self._WAIT_TIME = None    # Time to wait [s] for a new task if no task is currently available, make this zero if no clock is available
        self._DO_RESTART = None    # Restart a farming job (and should pick up where the previous left off)
        self._RESTART_FILE_NAME = None    # Name of the restart file to use for restarting a FARMING run. If not specified the name is determined from PROJECT name.
        self.listJOB = []
        self.JOB = job1()
        self.PROGRAM_RUN_INFO = program_run_info22()
        self.RESTART = restart8()
        self.name = "FARMING"
        self.keywords = [('_MASTER_SLAVE', 'MASTER_SLAVE'), ('_NGROUPS', 'NGROUPS'), ('_NGROUP', 'NGROUP'), ('_GROUP_SIZE', 'GROUP_SIZE'), ('_GROUP_PARTITION', 'GROUP_PARTITION'), ('_MAX_JOBS_PER_GROUP', 'MAX_JOBS_PER_GROUP'), ('_MAX_JOBS', 'MAX_JOBS'), ('_CYCLE', 'CYCLE'), ('_WAIT_TIME', 'WAIT_TIME'), ('_DO_RESTART', 'DO_RESTART'), ('_RESTART_FILE_NAME', 'RESTART_FILE_NAME')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('RESTART', 'RESTART')]
        self.repeated_subsections = [('JOB', 'job1')]

    def addJOB(self):
        new_section = job1()
        self.listJOB.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class symmetry1(printable):
    """controls the output of symmetry information"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._MOLECULE = None    # Assume the system is an isolated molecule
        self._EPS_GEO = None    # Accuracy required for symmetry detection
        self._STANDARD_ORIENTATION = None    # Print molecular coordinates in standard orientation
        self._INERTIA = None    # Print molecular inertia tensor
        self._SYMMETRY_ELEMENTS = None    # Print symmetry elements
        self._ALL = None    # Print all symmetry information
        self._ROTATION_MATRICES = None    # All the rotation matrices of the point group
        self._CHECK_SYMMETRY = None    # Check if calculated symmetry has expected value. Use either Schoenfliess or Hermann-Maugin symbols
        self.EACH = each1()
        self.name = "SYMMETRY"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_MOLECULE', 'MOLECULE'), ('_EPS_GEO', 'EPS_GEO'), ('_STANDARD_ORIENTATION', 'STANDARD_ORIENTATION'), ('_INERTIA', 'INERTIA'), ('_SYMMETRY_ELEMENTS', 'SYMMETRY_ELEMENTS'), ('_ALL', 'ALL'), ('_ROTATION_MATRICES', 'ROTATION_MATRICES'), ('_CHECK_SYMMETRY', 'CHECK_SYMMETRY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class external_potential1(printable):
    """Section controlling the presence of an external potential dependent  on the atomic positions (X,Y,Z)"""
    def __init__(self):
        self.list_ATOMS_LIST = []
        self._ATOMS_LIST = None
    # Specifies the atoms on which the external potential will act
        self._FUNCTION = None    # Specifies the functional form in mathematical notation. Variables must be the atomic coordinates (X,Y,Z).
        self.list_PARAMETERS = []
        self._PARAMETERS = None
    # Defines the parameters of the functional form
        self.list_VALUES = []
        self._VALUES = None
    # Defines the values of  parameter of the functional form
        self.list_UNITS = []
        self._UNITS = None
    # Optionally, allows to define valid CP2K unit strings for each parameter value. It is assumed that the corresponding parameter value is specified in this unit.
        self._DX = None    # Parameter used for computing the derivative with the Ridders method.
        self._ERROR_LIMIT = None    # Checks that the error in computing the derivative is not larger than the value set. In case prints a warning message.
        self.name = "EXTERNAL_POTENTIAL"
        self.keywords = [('_FUNCTION', 'FUNCTION'), ('_DX', 'DX'), ('_ERROR_LIMIT', 'ERROR_LIMIT')]
        self.repeated_keywords = [('_ATOMS_LIST', 'ATOMS_LIST'), ('_PARAMETERS', 'PARAMETERS'), ('_VALUES', 'VALUES'), ('_UNITS', 'UNITS')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def add_ATOMS_LIST(self, value):
        self.list_ATOMS_LIST.append(value)

    def add_PARAMETERS(self, value):
        self.list_PARAMETERS.append(value)

    def add_VALUES(self, value):
        self.list_VALUES.append(value)

    def add_UNITS(self, value):
        self.list_UNITS.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class e_density_cube1(printable):
    """Controls the printing of cube files with the electronic density and, for LSD calculations, the spin density"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._STRIDE = None    # The stride (X,Y,Z) used to write the cube file (larger values result in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1 number valid for all components.
        self._TOTAL_DENSITY = None    # Print the total electronic density in the case of a GAPW run. This keyword has only an effect, if PAW atoms are present. The default is to print only the soft part of the electronic density and to ignore the hard part. NOTE: The total density in real space might exhibit unphysical features like spikes due to the finite and thus truncated g vector expansion
        self._APPEND = None    # append the cube files when they already exist
        self._XRD_INTERFACE = None    # It activates the print out of exponents and coefficients for the  Gaussian expansion of the core densities, based on atom calculations for each kind. The resulting core dansities are needed to compute the form factors. If GAPW the local densities are also given in terms of a Gaussian expansion, by fitting the difference between local-fhard and local-soft density for each atom. In this case the keyword TOTAL_DENSITY is set to FALSE
        self._NGAUSS = None    # Number of Gaussian functions used in the expansion of atomic (core) density
        self.EACH = each1()
        self.name = "E_DENSITY_CUBE"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_STRIDE', 'STRIDE'), ('_TOTAL_DENSITY', 'TOTAL_DENSITY'), ('_APPEND', 'APPEND'), ('_XRD_INTERFACE', 'XRD_INTERFACE'), ('_NGAUSS', 'NGAUSS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class external_potential2(printable):
    """Section controlling the presence of an electrostatic external potential dependent on the atomic positions (X,Y,Z)"""
    def __init__(self):
        self._FUNCTION = None    # Specifies the functional form in mathematical notation. Variables must be the atomic coordinates (X,Y,Z) of the grid.
        self.list_PARAMETERS = []
        self._PARAMETERS = None
    # Defines the parameters of the functional form
        self.list_VALUES = []
        self._VALUES = None
    # Defines the values of parameter of the functional form
        self.list_UNITS = []
        self._UNITS = None
    # Optionally, allows to define valid CP2K unit strings for each parameter value. It is assumed that the corresponding parameter value is specified in this unit.
        self._STATIC = None    # Specifies the external potential as STATIC or time dependent. At the moment only static potentials are implemented.
        self._DX = None    # Parameter used for computing the derivative with the Ridders method.
        self._ERROR_LIMIT = None    # Checks that the error in computing the derivative is not larger than the value set. In case prints a warning message.
        self.name = "EXTERNAL_POTENTIAL"
        self.keywords = [('_FUNCTION', 'FUNCTION'), ('_STATIC', 'STATIC'), ('_DX', 'DX'), ('_ERROR_LIMIT', 'ERROR_LIMIT')]
        self.repeated_keywords = [('_PARAMETERS', 'PARAMETERS'), ('_VALUES', 'VALUES'), ('_UNITS', 'UNITS')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def add_PARAMETERS(self, value):
        self.list_PARAMETERS.append(value)

    def add_VALUES(self, value):
        self.list_VALUES.append(value)

    def add_UNITS(self, value):
        self.list_UNITS.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class dump_psf1(printable):
    """controls the dumping of the PSF connectivity"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "DUMP_PSF"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class CP2K_INPUT1(printable):
    """"""
    def __init__(self):
        self.GLOBAL = global1()
        self.TEST = test1()
        self.DEBUG = debug1()
        self.MOTION = motion1()
        self.MULTIPLE_FORCE_EVALS = multiple_force_evals1()
        self.listFORCE_EVAL = []
        self.FORCE_EVAL = force_eval2()
        self.FARMING = farming1()
        self.OPTIMIZE_INPUT = optimize_input1()
        self.OPTIMIZE_BASIS = optimize_basis1()
        self.EXT_RESTART = ext_restart1()
        self.VIBRATIONAL_ANALYSIS = vibrational_analysis1()
        self.ATOM = atom1()
        self.name = "CP2K_INPUT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('GLOBAL', 'GLOBAL'), ('TEST', 'TEST'), ('DEBUG', 'DEBUG'), ('MOTION', 'MOTION'), ('MULTIPLE_FORCE_EVALS', 'MULTIPLE_FORCE_EVALS'), ('FARMING', 'FARMING'), ('OPTIMIZE_INPUT', 'OPTIMIZE_INPUT'), ('OPTIMIZE_BASIS', 'OPTIMIZE_BASIS'), ('EXT_RESTART', 'EXT_RESTART'), ('VIBRATIONAL_ANALYSIS', 'VIBRATIONAL_ANALYSIS'), ('ATOM', 'ATOM')]
        self.repeated_subsections = [('FORCE_EVAL', 'force_eval2')]

    def addFORCE_EVAL(self):
        new_section = force_eval2()
        self.listFORCE_EVAL.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class mgrid1(printable):
    """multigrid information"""
    def __init__(self):
        self._NGRIDS = None    # The number of multigrids to use
        self._CUTOFF = None    # The cutoff of the finest grid level. Default value for SE or DFTB calculation is 1.0 [Ry].
        self._PROGRESSION_FACTOR = None    # Factor used to find the cutoff of the multigrids that where not given explicitly
        self._COMMENSURATE = None    # If the grids should be commensurate. If true overrides the progression factor and the cutoffs of the sub grids
        self._REALSPACE = None    # If both rho and rho_gspace are needed
        self._REL_CUTOFF = None    # Determines the grid at which a Gaussian is mapped, giving the cutoff used for a gaussian with alpha=1. A value 50+-10Ry might be required for highly accurate results,  Or for simulations with a variable cell. Versions prior to 2.3 used a default of 30Ry.
        self._RELATIVE_CUTOFF = self._REL_CUTOFF
        self._MULTIGRID_SET = None    # Activate a manual setting of the multigrids
        self._SKIP_LOAD_BALANCE_DISTRIBUTED = None    # Skip load balancing on distributed multigrids, which might be memory intensive.If not explicitly specified, runs using more than 1024 MPI tasks will default to .TRUE.
        self._MULTIGRID_CUTOFF = None    # List of cutoff values to set up multigrids manually
        self._CUTOFF_LIST = self._MULTIGRID_CUTOFF
        self.listRS_GRID = []
        self.RS_GRID = rs_grid1()
        self.INTERPOLATOR = interpolator1()
        self.name = "MGRID"
        self.keywords = [('_NGRIDS', 'NGRIDS'), ('_CUTOFF', 'CUTOFF'), ('_PROGRESSION_FACTOR', 'PROGRESSION_FACTOR'), ('_COMMENSURATE', 'COMMENSURATE'), ('_REALSPACE', 'REALSPACE'), ('_REL_CUTOFF', 'REL_CUTOFF'), ('_RELATIVE_CUTOFF', 'RELATIVE_CUTOFF'), ('_MULTIGRID_SET', 'MULTIGRID_SET'), ('_SKIP_LOAD_BALANCE_DISTRIBUTED', 'SKIP_LOAD_BALANCE_DISTRIBUTED'), ('_MULTIGRID_CUTOFF', 'MULTIGRID_CUTOFF'), ('_CUTOFF_LIST', 'CUTOFF_LIST')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('INTERPOLATOR', 'INTERPOLATOR')]
        self.repeated_subsections = [('RS_GRID', 'rs_grid1')]

    def addRS_GRID(self):
        new_section = rs_grid1()
        self.listRS_GRID.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class buck4ranges1(printable):
    """This section specifies the input parameters for Buckingham 4 ranges potential type.Functional form: (r<r1) V(r) = A* EXP(-B*r); (r1<r<r2) V(r) = SUM_n POLY1(n)*R^n;(r2<r<r3) V(r) = SUM_n POLY2(n)*R^n; (r>r3) V(r) = -C/r^6"""
    def __init__(self):
        self._ATOMS = None    # Defines the atomic kind involved in the nonbond potential
        self._A = None    # Defines the A parameter of the Buckingham potential
        self._B = None    # Defines the B parameter of the Buckingham potential
        self._C = None    # Defines the C parameter of the Buckingham  potential
        self._R1 = None    # Defines the upper bound of the first range
        self._R2 = None    # Defines the upper bound of the second range
        self._R3 = None    # Defines the upper bound of the third range
        self.list_POLY1 = []
        self._POLY1 = None
    # Coefficients of the polynomial used in the second rangeThis keyword can be repeated several times.
        self.list_POLY2 = []
        self._POLY2 = None
    # Coefficients of the polynomial used in the third rangeThis keyword can be repeated several times.
        self._RCUT = None    # Defines the cutoff parameter of the Buckingham potential
        self._RMIN = None    # Defines the lower bound of the potential. If not set the range is the full range generate by the spline
        self._RMAX = None    # Defines the upper bound of the potential. If not set the range is the full range generate by the spline
        self.name = "BUCK4RANGES"
        self.keywords = [('_ATOMS', 'ATOMS'), ('_A', 'A'), ('_B', 'B'), ('_C', 'C'), ('_R1', 'R1'), ('_R2', 'R2'), ('_R3', 'R3'), ('_RCUT', 'RCUT'), ('_RMIN', 'RMIN'), ('_RMAX', 'RMAX')]
        self.repeated_keywords = [('_POLY1', 'POLY1'), ('_POLY2', 'POLY2')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def add_POLY1(self, value):
        self.list_POLY1.append(value)

    def add_POLY2(self, value):
        self.list_POLY2.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class auxiliary_density_matrix_method1(printable):
    """Parameters needed to set wavefunction fitting"""
    def __init__(self):
        self._METHOD = None    # Method that shall be used for wavefunction fitting. Use BASIS_PROJECTION for MD.
        self._ADMM_PURIFICATION_METHOD = None    # Method that shall be used for wavefunction fitting. Use MO_DIAG for MD.
        self.BLOCK_DENSITY_MATRIX_METHOD = block_density_matrix_method1()
        self.name = "AUXILIARY_DENSITY_MATRIX_METHOD"
        self.keywords = [('_METHOD', 'METHOD'), ('_ADMM_PURIFICATION_METHOD', 'ADMM_PURIFICATION_METHOD')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('BLOCK_DENSITY_MATRIX_METHOD', 'BLOCK_DENSITY_MATRIX_METHOD')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class projectors1(printable):
    """If the printkey is activated controls if information on the projectors is printed."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PROJECTORS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class rng_state1(printable):
    """Random number generator state for all processors"""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Three real arrays of DIMENSION(3,2) times two RNG streams - 36 real values per processor
        self.name = "RNG_STATE"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class improper1(printable):
    """Specifies the improper torsion potential of the MM system."""
    def __init__(self):
        self._ATOMS = None    # Defines the atomic kinds involved in the improper tors.
        self._KIND = None    # Define the kind of improper torsion potential
        self._K = None    # Defines the force constant of the potential
        self._PHI0 = None    # Defines the phase of the potential.
        self.name = "IMPROPER"
        self.keywords = [('_ATOMS', 'ATOMS'), ('_KIND', 'KIND'), ('_K', 'K'), ('_PHI0', 'PHI0')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class torsion1(printable):
    """Specifies the torsion potential of the MM system."""
    def __init__(self):
        self._ATOMS = None    # Defines the atomic kinds involved in the tors.
        self._KIND = None    # Define the kind of torsion potential
        self._K = None    # Defines the force constant of the potential
        self._PHI0 = None    # Defines the phase of the potential.
        self._M = None    # Defines the multiplicity of the potential.
        self.name = "TORSION"
        self.keywords = [('_ATOMS', 'ATOMS'), ('_KIND', 'KIND'), ('_K', 'K'), ('_PHI0', 'PHI0'), ('_M', 'M')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class torsion2(printable):
    """Section used to add/remove torsion in the connectivity. Useful for systems with a complex connectivity, difficult to find out automatically."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self.list_ATOMS = []
        self._ATOMS = None
    # Specifies two atomic index united by a covalent bond
        self.name = "TORSION"
        self.keywords = []
        self.repeated_keywords = [('_ATOMS', 'ATOMS')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def add_ATOMS(self, value):
        self.list_ATOMS.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class geminal_basis1(printable):
    """Controls the printing of the Geminal basis functions"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "GEMINAL_BASIS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class gold1(printable):
    """Provides parameters to tune the line search for the gold search."""
    def __init__(self):
        self._INITIAL_STEP = None    # Initial step size used, e.g. for bracketing or minimizers. Might need to be reduced for systems with close contacts
        self._BRACK_LIMIT = None    # Limit in 1D bracketing during line search in Conjugate Gradients Optimization.
        self._BRENT_TOL = None    # Tolerance requested during Brent line search in Conjugate Gradients Optimization.
        self._BRENT_MAX_ITER = None    # Maximum number of iterations in brent algorithm (used for the line search in Conjugated Gradients Optimization)
        self.name = "GOLD"
        self.keywords = [('_INITIAL_STEP', 'INITIAL_STEP'), ('_BRACK_LIMIT', 'BRACK_LIMIT'), ('_BRENT_TOL', 'BRENT_TOL'), ('_BRENT_MAX_ITER', 'BRENT_MAX_ITER')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class sphere1(printable):
    """Treats the implicit solvent environment like a sphere"""
    def __init__(self):
        self._RADIUS = None    # Value of the spherical cavity in the dielectric medium
        self.CENTER = center1()
        self.name = "SPHERE"
        self.keywords = [('_RADIUS', 'RADIUS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('CENTER', 'CENTER')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class ri_mp21(printable):
    """Parameters influencing the RI MP2 method"""
    def __init__(self):
        self._BLOCK_SIZE = None    # Determines the blocking used for communication in RI-MP2. Larger BLOCK_SIZE reduces communication but requires more memory. The default (-1) is automatic.
        self._MESSAGE_SIZE = self._BLOCK_SIZE
        self.name = "RI_MP2"
        self.keywords = [('_BLOCK_SIZE', 'BLOCK_SIZE'), ('_MESSAGE_SIZE', 'MESSAGE_SIZE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class becke88_lr1(printable):
    """Uses the Becke 88 longrange exchange functional"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._SCALE_X = None    # scales the exchange part of the functional
        self._OMEGA = None    # Potential parameter in erf(omega*r)/r
        self.name = "BECKE88_LR"
        self.keywords = [('_SCALE_X', 'SCALE_X'), ('_OMEGA', 'OMEGA')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class restart7(printable):
    """Controls the dumping of restart file of the response wavefunction.For each set of response functions, i.e. for each perturbation,one different restart file is dumped. These restart files should beemployed only to restart the same type of LINRES calculation, i.e. with the same perturbation."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "RESTART"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class grid_information1(printable):
    """Controls the printing of information regarding the PW and RS grid structures (ONLY for TEST run)."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "GRID_INFORMATION"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class grid_information2(printable):
    """Controls the printing of information regarding the PW grid structures for PERIODIC qm/mm calculations."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "GRID_INFORMATION"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class grid_information3(printable):
    """Controls the printing of information regarding the PW and RS grid structures."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "GRID_INFORMATION"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class restart4(printable):
    """Controls the dumping of MO restart file during the scfof a Core-Level-Spectroscopy calculation. For each new excited atom,one different restart file is dumped. These restart files should beemployed only to restart the same type of CLS calculation, i.e. with the same core potential."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "RESTART"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class lbfgs1(printable):
    """Provides parameters to tune the limited memory BFGS (LBFGS) optimization"""
    def __init__(self):
        self._MAX_H_RANK = None    # Maximum rank (and consequently size) of the approximate Hessian matrix used by the LBFGS optimizer. Larger values (e.g. 30) will accelerate the convergence behaviour at the cost of a larger memory consumption.
        self._MAX_F_PER_ITER = None    # Maximum number of force evaluations per iteration(used for the line search)
        self._WANTED_PROJ_GRADIENT = None    # Convergence criterium (overrides the general ones):Requested norm threshold of the gradient multiplied by the approximate Hessian.
        self._WANTED_REL_F_ERROR = None    # Convergence criterium (overrides the general ones):Requested relative error on the objective functionof the optimizer (the energy)
        self.name = "LBFGS"
        self.keywords = [('_MAX_H_RANK', 'MAX_H_RANK'), ('_MAX_F_PER_ITER', 'MAX_F_PER_ITER'), ('_WANTED_PROJ_GRADIENT', 'WANTED_PROJ_GRADIENT'), ('_WANTED_REL_F_ERROR', 'WANTED_REL_F_ERROR')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class fit_pseudo1(printable):
    """Controls the printing of FIT PSEUDO task"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "FIT_PSEUDO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class interpolator1(printable):
    """kind of interpolation used between the multigrids"""
    def __init__(self):
        self._KIND = None    # the interpolator to use
        self._SAFE_COMPUTATION = None    # if a non unrolled calculation is to be performed in parallel
        self._AINT_PRECOND = None    # the approximate inverse to use to get the starting point for the linear solver of the spline3 methods
        self._PRECOND = None    # The preconditioner used for the linear solver of the spline3 methods
        self._EPS_X = None    # accuracy on the solution for spline3 the interpolators
        self._EPS_R = None    # accuracy on the residual for spline3 the interpolators
        self._MAX_ITER = None    # the maximum number of iterations
        self._MAXITER = self._MAX_ITER
        self.CONV_INFO = conv_info1()
        self.name = "INTERPOLATOR"
        self.keywords = [('_KIND', 'KIND'), ('_SAFE_COMPUTATION', 'SAFE_COMPUTATION'), ('_AINT_PRECOND', 'AINT_PRECOND'), ('_PRECOND', 'PRECOND'), ('_EPS_X', 'EPS_X'), ('_EPS_R', 'EPS_R'), ('_MAX_ITER', 'MAX_ITER'), ('_MAXITER', 'MAXITER')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('CONV_INFO', 'CONV_INFO')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class eigensolver1(printable):
    """Benchmark and test the eigensolver routines."""
    def __init__(self):
        self._N = None    # Dimension of the square matrix
        self._N_LOOP = None    # Number of operations being timed (useful for small matrices).
        self._DIAG_METHOD = None    # Diagonalization strategy
        self._EIGENVALUES = None    # number of eigenvalues to be computed (all=<0)
        self._INIT_METHOD = None    # Initialization approach
        self.name = "EIGENSOLVER"
        self.keywords = [('_N', 'N'), ('_N_LOOP', 'N_LOOP'), ('_DIAG_METHOD', 'DIAG_METHOD'), ('_EIGENVALUES', 'EIGENVALUES'), ('_INIT_METHOD', 'INIT_METHOD')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class references1(printable):
    """Controls the printing of the references relevant to the calculations performed"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "REFERENCES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class rs_pw_transfer1(printable):
    """Describes how to benchmark the rs_pw_transfer routines."""
    def __init__(self):
        self._GRID = None    # Specify the number of grid points (not all grid points are allowed)
        self._HALO_SIZE = None    # number of grid points of the halo
        self._N_LOOP = None    # Number of rs_pw_transfers being timed
        self._RS2PW = None    # should the direction be rs2pw (pw2rs otherwise)
        self.listRS_GRID = []
        self.RS_GRID = rs_grid1()
        self.name = "RS_PW_TRANSFER"
        self.keywords = [('_GRID', 'GRID'), ('_HALO_SIZE', 'HALO_SIZE'), ('_N_LOOP', 'N_LOOP'), ('_RS2PW', 'RS2PW')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('RS_GRID', 'rs_grid1')]

    def addRS_GRID(self):
        new_section = rs_grid1()
        self.listRS_GRID.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class coord_avg1(printable):
    """Controls the printing of the average coordination number."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "COORD_AVG"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class xes_spectrum1(printable):
    """Controls the dumping of the CLS output files containing the emission spectra"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "XES_SPECTRUM"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class plength1(printable):
    """Controls the output of the helium permutation length"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PLENGTH"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class normalmode1(printable):
    """Controls the normal mode transformation"""
    def __init__(self):
        self._Q_CENTROID = None    # Value of the thermostat mass of centroid degree of freedom
        self._Q_BEAD = None    # Value of the thermostat mass of non-centroid degrees of freedom
        self._MODEFACTOR = None    # mass scale factor for non-centroid degrees of freedom
        self.name = "NORMALMODE"
        self.keywords = [('_Q_CENTROID', 'Q_CENTROID'), ('_Q_BEAD', 'Q_BEAD'), ('_MODEFACTOR', 'MODEFACTOR')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class becke881(printable):
    """Uses the Becke 88 exchange functional"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._SCALE_X = None    # scales the exchange part of the functional
        self.name = "BECKE88"
        self.keywords = [('_SCALE_X', 'SCALE_X')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class fit_kind1(printable):
    """specicifies the atomic kinds to be fitted and the basis sets associated with the kind."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._BASIS_SET = None    # The name of the basis set for the kind. Has to be specified in BASIS_TEMPLATE_FILE.
        self._INITIAL_DEGREES_OF_FREEDOM = None    # Specifies the initial degrees of freedom in the basis optimization.This can be used to make further specifications easier
        self.list_SWITCH_COEFF_STATE = []
        self._SWITCH_COEFF_STATE = None
    # Allows to switch the state of a given coefficient from current state (varibale/fixed)) to the opposite state. The three integers indicate the set number, the angular momentum i'th contraction and i'th coefficient
        self.list_SWITCH_CONTRACTION_STATE = []
        self._SWITCH_CONTRACTION_STATE = None
    # Allows to switch the state of a given contraction from current state (varibale/fixed)) to the opposite state. The three integers indicate the set number, the angular momentum and i'th contraction
        self.list_SWITCH_EXP_STATE = []
        self._SWITCH_EXP_STATE = None
    # Allows to switch the state of a given exponent from current state (varibale/fixed)) to the opposite state. The two integers indicate the set number and i'th exponent
        self.list_SWITCH_SET_STATE = []
        self._SWITCH_SET_STATE = None
    # Allows to switch the states of in a set from current state (varibale/fixed)) to the opposite state. The two integers indicate the affected part (0=ALL,1=EXPS,2=COEFF) and i'th set
        self.listCONSTRAIN_EXPONENTS = []
        self.CONSTRAIN_EXPONENTS = constrain_exponents1()
        self.listDERIVED_BASIS_SETS = []
        self.DERIVED_BASIS_SETS = derived_basis_sets1()
        self.name = "FIT_KIND"
        self.keywords = [('_BASIS_SET', 'BASIS_SET'), ('_INITIAL_DEGREES_OF_FREEDOM', 'INITIAL_DEGREES_OF_FREEDOM')]
        self.repeated_keywords = [('_SWITCH_COEFF_STATE', 'SWITCH_COEFF_STATE'), ('_SWITCH_CONTRACTION_STATE', 'SWITCH_CONTRACTION_STATE'), ('_SWITCH_EXP_STATE', 'SWITCH_EXP_STATE'), ('_SWITCH_SET_STATE', 'SWITCH_SET_STATE')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('CONSTRAIN_EXPONENTS', 'constrain_exponents1'), ('DERIVED_BASIS_SETS', 'derived_basis_sets1')]

    def addCONSTRAIN_EXPONENTS(self):
        new_section = constrain_exponents1()
        self.listCONSTRAIN_EXPONENTS.append(new_section)
        return new_section

    def addDERIVED_BASIS_SETS(self):
        new_section = derived_basis_sets1()
        self.listDERIVED_BASIS_SETS.append(new_section)
        return new_section

    def add_SWITCH_COEFF_STATE(self, value):
        self.list_SWITCH_COEFF_STATE.append(value)

    def add_SWITCH_CONTRACTION_STATE(self, value):
        self.list_SWITCH_CONTRACTION_STATE.append(value)

    def add_SWITCH_EXP_STATE(self, value):
        self.list_SWITCH_EXP_STATE.append(value)

    def add_SWITCH_SET_STATE(self, value):
        self.list_SWITCH_SET_STATE.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class print_dftd1(printable):
    """Controls the printing of some info about DFTD contributions"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PRINT_DFTD"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class core_forces1(printable):
    """controls the output of the forces on cores when shell-model is used"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._UNIT = None    # Specify the unit of measurement for the quantity in output. All available CP2K units can be used.
        self._FORMAT = None    # Specifies the format of the output file for the forces on cores.
        self.EACH = each1()
        self.name = "CORE_FORCES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_UNIT', 'UNIT'), ('_FORMAT', 'FORMAT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class uvar1(printable):
    """This section specify the nature of the collective variables used in computing the free energy."""
    def __init__(self):
        self._COLVAR = None    # Specifies the colvar used to compute free energy
        self.name = "UVAR"
        self.keywords = [('_COLVAR', 'COLVAR')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class lowdin1(printable):
    """Controls the printing of the Lowdin (spin) population analysis"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._PRINT_GOP = None    # Print the orbital populations in addition to the atomic populations and net charges
        self._PRINT_ALL = None    # Print all information including the full symmetrically orthogonalised density matrix
        self.EACH = each1()
        self.name = "LOWDIN"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_PRINT_GOP', 'PRINT_GOP'), ('_PRINT_ALL', 'PRINT_ALL')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class population1(printable):
    """Section to define the population of specie as a collective variable."""
    def __init__(self):
        self.list_ATOMS_FROM = []
        self._ATOMS_FROM = None
    # Specify indexes of atoms/points building the coordination variable.
        self._POINTS_FROM = self._ATOMS_FROM
        self.list_POINTS_FROM = self.list_ATOMS_FROM
        self.list_ATOMS_TO = []
        self._ATOMS_TO = None
    # Specify indexes of atoms/points building the coordination variable.
        self._POINTS_TO = self._ATOMS_TO
        self.list_POINTS_TO = self.list_ATOMS_TO
        self.list_KINDS_FROM = []
        self._KINDS_FROM = None
    # Specify alternatively kinds of atoms building the coordination variable.
        self.list_KINDS_TO = []
        self._KINDS_TO = None
    # Specify alternatively kinds of atoms building the coordination variable.
        self._R0 = None    # Specify the R0 parameter in the coordination function.
        self._R_0 = self._R0
        self._NN = None    # Sets the value of the numerator of the exponential factorin the coordination FUNCTION.
        self._EXPON_NUMERATOR = self._NN
        self._ND = None    # Sets the value of the denominator of the exponential factorin the coordination FUNCTION.
        self._EXPON_DENOMINATOR = self._ND
        self._N0 = None    # Specify the n0 parameter that sets the coordination of the species.
        self._N_0 = self._N0
        self._SIGMA = None    # Specify the gaussian width of used to build the population istogram.
        self.listPOINT = []
        self.POINT = point1()
        self.name = "POPULATION"
        self.keywords = [('_R0', 'R0'), ('_R_0', 'R_0'), ('_NN', 'NN'), ('_EXPON_NUMERATOR', 'EXPON_NUMERATOR'), ('_ND', 'ND'), ('_EXPON_DENOMINATOR', 'EXPON_DENOMINATOR'), ('_N0', 'N0'), ('_N_0', 'N_0'), ('_SIGMA', 'SIGMA')]
        self.repeated_keywords = [('_ATOMS_FROM', 'ATOMS_FROM'), ('_POINTS_FROM', 'POINTS_FROM'), ('_ATOMS_TO', 'ATOMS_TO'), ('_POINTS_TO', 'POINTS_TO'), ('_KINDS_FROM', 'KINDS_FROM'), ('_KINDS_TO', 'KINDS_TO')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('POINT', 'point1')]

    def addPOINT(self):
        new_section = point1()
        self.listPOINT.append(new_section)
        return new_section

    def add_ATOMS_FROM(self, value):
        self.list_ATOMS_FROM.append(value)

    def add_POINTS_FROM(self, value):
        self.list_POINTS_FROM.append(value)

    def add_ATOMS_TO(self, value):
        self.list_ATOMS_TO.append(value)

    def add_POINTS_TO(self, value):
        self.list_POINTS_TO.append(value)

    def add_KINDS_FROM(self, value):
        self.list_KINDS_FROM.append(value)

    def add_KINDS_TO(self, value):
        self.list_KINDS_TO.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class xgga1(printable):
    """Uses one of the XGGA functionals (optimized versions of some of these functionals might be available outside this section)."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._FUNCTIONAL = None    # Which one of the XGGA functionals should be used
        self.name = "XGGA"
        self.keywords = [('_FUNCTIONAL', 'FUNCTIONAL')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class elf_cube1(printable):
    """Controls printing of cube files with the electron localization function (ELF). Note that the value of ELF is defined between 0 and 1:  Pauli kinetic energy density normalized  by the kinetic energy density of a uniform el. gas of same density."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._STRIDE = None    # The stride (X,Y,Z) used to write the cube file (larger values result in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1 number valid for all components.
        self._APPEND = None    # append the cube files when they already exist
        self._DENSITY_CUTOFF = None
        self.EACH = each1()
        self.name = "ELF_CUBE"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_STRIDE', 'STRIDE'), ('_APPEND', 'APPEND'), ('_DENSITY_CUTOFF', 'DENSITY_CUTOFF')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class staging1(printable):
    """The section that controls the staging transformation"""
    def __init__(self):
        self._J = None    # Value of the j parameter for the staging transformation
        self._Q_END = None    # Value of the nose-hoover mass for the endbead (Q_end)
        self.name = "STAGING"
        self.keywords = [('_J', 'J'), ('_Q_END', 'Q_END')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class r_ldos1(printable):
    """Controls the printing of local PDOS, projected on 3D volume in real space, the volume is defined in terms of position with respect to atoms in the lists"""
    def __init__(self):
        self.list_LIST = []
        self._LIST = None
    # Specifies a list of indexes of atoms used to define the real space volume
        self._XRANGE = None    # range of positions in Cartesian direction x: all grid points within  this range from at least one atom of the list are considered
        self._YRANGE = None    # range of positions in Cartesian direction y: all grid points within  this range from at least one atom of the list are considered
        self._ZRANGE = None    # range of positions in Cartesian direction z: all grid points within  this range from at least one atom of the list are considered
        self._ERANGE = None    # only project states with the eigenvalues in the given interval. Default is all states.
        self.name = "R_LDOS"
        self.keywords = [('_XRANGE', 'XRANGE'), ('_YRANGE', 'YRANGE'), ('_ZRANGE', 'ZRANGE'), ('_ERANGE', 'ERANGE')]
        self.repeated_keywords = [('_LIST', 'LIST')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def add_LIST(self, value):
        self.list_LIST.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class damping1(printable):
    """This section specifies optional electric field damping for the polarizable atoms."""
    def __init__(self):
        self._ATOM = None    # Defines the atomic kind for this damping function.
        self._TYPE = None    # Defines the damping type.
        self._ORDER = None    # Defines the order for this damping.
        self._BIJ = None    # Defines the BIJ parameter for this damping.
        self._CIJ = None    # Defines the CIJ parameter for this damping.
        self.name = "DAMPING"
        self.keywords = [('_ATOM', 'ATOM'), ('_TYPE', 'TYPE'), ('_ORDER', 'ORDER'), ('_BIJ', 'BIJ'), ('_CIJ', 'CIJ')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class localization1(printable):
    """Collects all printing options related to the Wannier centers and properties computed with Wannier centers."""
    def __init__(self):
        self.WANNIER_CUBES = wannier_cubes1()
        self.WANNIER_CENTERS = wannier_centers1()
        self.WANNIER_SPREADS = wannier_spreads1()
        self.LOC_RESTART = loc_restart1()
        self.TOTAL_DIPOLE = total_dipole1()
        self.MOLECULAR_DIPOLES = molecular_dipoles1()
        self.MOLECULAR_STATES = molecular_states1()
        self.WANNIER_STATES = wannier_states1()
        self.name = "LOCALIZATION"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('WANNIER_CUBES', 'WANNIER_CUBES'), ('WANNIER_CENTERS', 'WANNIER_CENTERS'), ('WANNIER_SPREADS', 'WANNIER_SPREADS'), ('LOC_RESTART', 'LOC_RESTART'), ('TOTAL_DIPOLE', 'TOTAL_DIPOLE'), ('MOLECULAR_DIPOLES', 'MOLECULAR_DIPOLES'), ('MOLECULAR_STATES', 'MOLECULAR_STATES'), ('WANNIER_STATES', 'WANNIER_STATES')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class poisson1(printable):
    """Sets up the poisson resolutor."""
    def __init__(self):
        self._POISSON_SOLVER = None    # Specify which kind of solver to use to solve the Poisson equation.
        self._POISSON = self._POISSON_SOLVER
        self._PSOLVER = self._POISSON_SOLVER
        self._PERIODIC = None    # Specify the directions on wich apply PBC. Important notice,  this only applies to the electrostatics. See the CELL section to specify the periodicity used for e.g. the pair lists. Typically the settings should be the same.
        self.MT = mt1()
        self.WAVELET = wavelet1()
        self.MULTIPOLE = multipole1()
        self.EWALD = ewald1()
        self.name = "POISSON"
        self.keywords = [('_POISSON_SOLVER', 'POISSON_SOLVER'), ('_POISSON', 'POISSON'), ('_PSOLVER', 'PSOLVER'), ('_PERIODIC', 'PERIODIC')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('MT', 'MT'), ('WAVELET', 'WAVELET'), ('MULTIPOLE', 'MULTIPOLE'), ('EWALD', 'EWALD')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class g_tensor1(printable):
    """Controls the printing of the g tensor"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._GAPW_MAX_ALPHA = None    # Maximum alpha of GTH potentials allowed on the soft grids
        self._SOO_RHO_HARD = None    # Whether or not to include the atomic parts of the density in the SOO part of the g tensor
        self.EACH = each1()
        self.XC = xc1()
        self.name = "G_TENSOR"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_GAPW_MAX_ALPHA', 'GAPW_MAX_ALPHA'), ('_SOO_RHO_HARD', 'SOO_RHO_HARD')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH'), ('XC', 'XC')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class temperature2(printable):
    """Controls output of temperature per region."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "TEMPERATURE"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class tpss1(printable):
    """Uses the TPSS functional"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._SCALE_X = None    # scales the exchange part of the functional
        self._SCALE_C = None    # scales the correlation part of the functional
        self.name = "TPSS"
        self.keywords = [('_SCALE_X', 'SCALE_X'), ('_SCALE_C', 'SCALE_C')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class temperature1(printable):
    """Controls the output of the temperatures of the regions corresponding to the present thermostat"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "TEMPERATURE"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class optimize_basis1(printable):
    """describes a basis optimization job, in which an ADMM like approach is used to find the best exponents and/or coefficients to match a given training set."""
    def __init__(self):
        self._BASIS_TEMPLATE_FILE = None    # Name of the basis set file, containing the structure of the new basis set
        self._BASIS_WORK_FILE = None    # Name of the basis set file which is created to be read as initial guess
        self._BASIS_OUTPUT_FILE = None    # Name of the basis set file containing the optimized basis
        self._WRITE_FREQUENCY = None    # Frequency at which the intermediate results should be written
        self._USE_CONDITION_NUMBER = None    # Determines whether condition number should be part of optimization or not
        self.list_BASIS_COMBINATIONS = []
        self._BASIS_COMBINATIONS = None
    # If multiple atomic kinds are fitted at the same time, this keyword allows to specify which basis sets should be used together in optimization (underived set ID=0). If skipped all combinations are used. The order is taken as the kinds and sets are specified in the input
        self.list_RESIDUUM_WEIGHT = []
        self._RESIDUUM_WEIGHT = None
    # This keyword allows to give different weight factors to the residuum of the different basis combinations. The first entry corresponds to the original basis sets. Every further value is assigned to the combinations in the order given for BASIS_COMBINATIONS.
        self.list_CONDITION_WEIGHT = []
        self._CONDITION_WEIGHT = None
    # This keyword allows to give different weight factors to the condition number of different basis combinations (LOG(cond) is used). The first entry corresponds to the original basis sets. Every further value is assigned to the combinations in the order given for BASIS_COMBINATIONS.
        self.list_GROUP_PARTITION = []
        self._GROUP_PARTITION = None
    # Allows the specification of the group mpi group sizes in parallel runs. If less Groups than tasks are speciefied, consecutive calculations  Will be assigned to one group (derived basis sets and then training sets) If keyword is skipped, equal group sizes will be generated trying to fit all calculations.
        self.listFIT_KIND = []
        self.FIT_KIND = fit_kind1()
        self.listTRAINING_FILES = []
        self.TRAINING_FILES = training_files1()
        self.OPTIMIZATION = optimization1()
        self.name = "OPTIMIZE_BASIS"
        self.keywords = [('_BASIS_TEMPLATE_FILE', 'BASIS_TEMPLATE_FILE'), ('_BASIS_WORK_FILE', 'BASIS_WORK_FILE'), ('_BASIS_OUTPUT_FILE', 'BASIS_OUTPUT_FILE'), ('_WRITE_FREQUENCY', 'WRITE_FREQUENCY'), ('_USE_CONDITION_NUMBER', 'USE_CONDITION_NUMBER')]
        self.repeated_keywords = [('_BASIS_COMBINATIONS', 'BASIS_COMBINATIONS'), ('_RESIDUUM_WEIGHT', 'RESIDUUM_WEIGHT'), ('_CONDITION_WEIGHT', 'CONDITION_WEIGHT'), ('_GROUP_PARTITION', 'GROUP_PARTITION')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('OPTIMIZATION', 'OPTIMIZATION')]
        self.repeated_subsections = [('FIT_KIND', 'fit_kind1'), ('TRAINING_FILES', 'training_files1')]

    def addFIT_KIND(self):
        new_section = fit_kind1()
        self.listFIT_KIND.append(new_section)
        return new_section

    def addTRAINING_FILES(self):
        new_section = training_files1()
        self.listTRAINING_FILES.append(new_section)
        return new_section

    def add_BASIS_COMBINATIONS(self, value):
        self.list_BASIS_COMBINATIONS.append(value)

    def add_RESIDUUM_WEIGHT(self, value):
        self.list_RESIDUUM_WEIGHT.append(value)

    def add_CONDITION_WEIGHT(self, value):
        self.list_CONDITION_WEIGHT.append(value)

    def add_GROUP_PARTITION(self, value):
        self.list_GROUP_PARTITION.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class print1(printable):
    """controls the printing of physical and mathematical constants"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._BASIC_DATA_TYPES = None    # Controls the printing of the basic data types.
        self._PHYSCON = None    # if the printkey is active prints the physical constants
        self._SPHERICAL_HARMONICS = None    # if the printkey is active prints the spherical harmonics
        self._RNG_MATRICES = None    # Prints the transformation matrices used by the  random number generator
        self._RNG_CHECK = None    # Performs a check of the global (pseudo)random number generator (RNG) and prints the result
        self._GLOBAL_GAUSSIAN_RNG = None    # Prints the initial status of the global Gaussian (pseudo)random number stream which is mostly used for the velocity initialization
        self._HPM = None    # if the keyword is active controls the printing of the hpm info (if linked as external library, on IBM only)
        self.EACH = each1()
        self.name = "PRINT"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_BASIC_DATA_TYPES', 'BASIC_DATA_TYPES'), ('_PHYSCON', 'PHYSCON'), ('_SPHERICAL_HARMONICS', 'SPHERICAL_HARMONICS'), ('_RNG_MATRICES', 'RNG_MATRICES'), ('_RNG_CHECK', 'RNG_CHECK'), ('_GLOBAL_GAUSSIAN_RNG', 'GLOBAL_GAUSSIAN_RNG'), ('_HPM', 'HPM')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print3(printable):
    """Controls the printing properties during a geometry optimization run"""
    def __init__(self):
        self.PROGRAM_RUN_INFO = program_run_info4()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print2(printable):
    """Controls the printing properties during the dimer rotation optimization run"""
    def __init__(self):
        self.PROGRAM_RUN_INFO = program_run_info4()
        self.ROTATIONAL_INFO = rotational_info1()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('ROTATIONAL_INFO', 'ROTATIONAL_INFO')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print5(printable):
    """Controls the printing properties during a shell-core optimization procedure"""
    def __init__(self):
        self.PROGRAM_RUN_INFO = program_run_info5()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class libxc1(printable):
    """Uses functionals from LIBXC, see also http://www.tddft.org/programs/octopus/wiki/index.php/Libxc"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._FUNCTIONAL = None    # names of the functionals, see also http://www.tddft.org/programs/octopus/wiki/index.php/Libxc:manual .The precise list of available functionals depends on the version of libxc interfaced (currently 2.0.1).
        self._SCALE = None    # scaling factors of the functionals
        self._PARAMETERS = None    # parameters of the functionals
        self.name = "LIBXC"
        self.keywords = [('_FUNCTIONAL', 'FUNCTIONAL'), ('_SCALE', 'SCALE'), ('_PARAMETERS', 'PARAMETERS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print7(printable):
    """Collects all print_keys for barostat"""
    def __init__(self):
        self.ENERGY = energy2()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('ENERGY', 'ENERGY')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print6(printable):
    """Collects all print_keys for thermostat"""
    def __init__(self):
        self.THERMOSTAT_INFO = thermostat_info1()
        self.TEMPERATURE = temperature1()
        self.ENERGY = energy1()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('THERMOSTAT_INFO', 'THERMOSTAT_INFO'), ('TEMPERATURE', 'TEMPERATURE'), ('ENERGY', 'ENERGY')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print9(printable):
    """Collects all print_keys for thermal_regions"""
    def __init__(self):
        self.TEMPERATURE = temperature2()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('TEMPERATURE', 'TEMPERATURE')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print8(printable):
    """The section that controls the output of a reftraj run"""
    def __init__(self):
        self.MSD_KIND = msd_kind1()
        self.MSD_MOLECULE = msd_molecule1()
        self.DISPLACED_ATOM = displaced_atom1()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('MSD_KIND', 'MSD_KIND'), ('MSD_MOLECULE', 'MSD_MOLECULE'), ('DISPLACED_ATOM', 'DISPLACED_ATOM')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class gyration_radius1(printable):
    """Section to define the gyration radius as a collective variable."""
    def __init__(self):
        self.list_ATOMS = []
        self._ATOMS = None
    # Specify indexes of atoms/points defyining the gyration radius variable.
        self._POINTS = self._ATOMS
        self.list_POINTS = self.list_ATOMS
        self.list_KINDS = []
        self._KINDS = None
    # Specify alternatively kinds of atoms defining the gyration radius.
        self.listPOINT = []
        self.POINT = point1()
        self.name = "GYRATION_RADIUS"
        self.keywords = []
        self.repeated_keywords = [('_ATOMS', 'ATOMS'), ('_POINTS', 'POINTS'), ('_KINDS', 'KINDS')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('POINT', 'point1')]

    def addPOINT(self):
        new_section = point1()
        self.listPOINT.append(new_section)
        return new_section

    def add_ATOMS(self, value):
        self.list_ATOMS.append(value)

    def add_POINTS(self, value):
        self.list_POINTS.append(value)

    def add_KINDS(self, value):
        self.list_KINDS.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class xas1(printable):
    """Sets the method of choice to calculate core-level excitation spectra. The occupied states from  which we calculate the excitation should be specified. Localization of the orbitals may be useful."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._METHOD = None    # Method to be used to calculate core-level excitation spectra
        self._XAS_METHOD = self._METHOD
        self._XES_CORE = None    # occupation of the core state in XES calculation by TP_VAL.The homo is emptied by the same amount
        self._DIPOLE_FORM = None    # Type of integral to get the oscillator strengths in the diipole approximation
        self._DIP_FORM = self._DIPOLE_FORM
        self._SCF_OPTIMIZER = None    # Optimization algorithm: diagonalization or OT
        self._MAXSTEP = None    # Max # of steps in the cls-scf for one excitation
        self._CONVERGENCE = None    # Convergence criterion for the xas-scf
        self._CONV = self._CONVERGENCE
        self._EPS_DIIS = None    # treshold on the convergence to start using DIAG/DIIS for the cls-scfif default, the scf_control value is used
        self._STATE_TYPE = None    # Type of the orbitas that are excited for the xas spectra calculation
        self._TYPE = self._STATE_TYPE
        self._STATE_SEARCH = None    # # of states where to look for the one to be excited
        self.list_ATOMS_LIST = []
        self._ATOMS_LIST = None
    # Indexes of the atoms to be excitedThis keyword can be repeated several times(useful if you have to specify many indexes).
        self._AT_LIST = self._ATOMS_LIST
        self.list_AT_LIST = self.list_ATOMS_LIST
        self._ADDED_MOS = None    # Number of additional MOS added spin up only
        self._MAX_ITER_ADDED = None    # maximum number of iteration in calculation of added orbitals
        self._EPS_ADDED = None    # target accuracy incalculation of the added orbitals
        self._NGAUSS = None    # Number of gto's for the expansion of the stoof the type given by STATE_TYPE
        self._RESTART = None    # Restart the excited state if the restart file exists
        self._WFN_RESTART_FILE_NAME = None    # Root of the file names where to read the MOS fromwhich to restart the calculation of the core level excited states
        self._RESTART_FILE_NAME = self._WFN_RESTART_FILE_NAME
        self.LOCALIZE = localize1()
        self.PRINT = print23()
        self.MIXING = mixing1()
        self.SMEAR = smear1()
        self.name = "XAS"
        self.keywords = [('_METHOD', 'METHOD'), ('_XAS_METHOD', 'XAS_METHOD'), ('_XES_CORE', 'XES_CORE'), ('_DIPOLE_FORM', 'DIPOLE_FORM'), ('_DIP_FORM', 'DIP_FORM'), ('_SCF_OPTIMIZER', 'SCF_OPTIMIZER'), ('_MAXSTEP', 'MAXSTEP'), ('_CONVERGENCE', 'CONVERGENCE'), ('_CONV', 'CONV'), ('_EPS_DIIS', 'EPS_DIIS'), ('_STATE_TYPE', 'STATE_TYPE'), ('_TYPE', 'TYPE'), ('_STATE_SEARCH', 'STATE_SEARCH'), ('_ADDED_MOS', 'ADDED_MOS'), ('_MAX_ITER_ADDED', 'MAX_ITER_ADDED'), ('_EPS_ADDED', 'EPS_ADDED'), ('_NGAUSS', 'NGAUSS'), ('_RESTART', 'RESTART'), ('_WFN_RESTART_FILE_NAME', 'WFN_RESTART_FILE_NAME'), ('_RESTART_FILE_NAME', 'RESTART_FILE_NAME')]
        self.repeated_keywords = [('_ATOMS_LIST', 'ATOMS_LIST'), ('_AT_LIST', 'AT_LIST')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('LOCALIZE', 'LOCALIZE'), ('PRINT', 'PRINT'), ('MIXING', 'MIXING'), ('SMEAR', 'SMEAR')]
        self.repeated_subsections = []

    def add_ATOMS_LIST(self, value):
        self.list_ATOMS_LIST.append(value)

    def add_AT_LIST(self, value):
        self.list_AT_LIST.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class ls_scf1(printable):
    """Specifies the parameters of the linear scaling SCF routines"""
    def __init__(self):
        self._MAX_SCF = None    # Maximum number of SCF iteration to be performed for one optimization
        self._EPS_SCF = None    # target accuracy for the scf convergence. Change of the total energy per electron
        self._MIXING_FRACTION = None    # Mixing density matrices uses the specified fraction in the SCF procedure.
        self._EPS_FILTER = None    # Threshold used for filtering matrix operations.
        self._EPS_LANCZOS = None    # Threshold used for lanczos estimates.
        self._MAX_ITER_LANCZOS = None    # Maximum number of lanczos iterations.
        self._MU = None    # Value (or initial guess) for the chemical potential, i.e. some suitable energy between HOMO and LUMO energy.
        self._FIXED_MU = None    # Should the calculation be performed at fixed chemical potential, or should it be found fixing the number of electrons
        self._EXTRAPOLATION_ORDER = None    # Number of previous matrices used for the ASPC extrapolation of the initial guess. 0 implies that an atomic guess is used at each step. low (1-2) will result in a drift of the constant of motion during MD. high (>5) might be somewhat unstable, leading to more SCF iterations.
        self._S_PRECONDITIONER = None    # Preconditions S with some appropriate form.
        self._PURIFICATION_METHOD = None    # Scheme used to purify the Kohn-Sham matrix into the density matrix.
        self._DYNAMIC_THRESHOLD = None    # Should the threshold for the purification be chosen dynamically
        self._MATRIX_CLUSTER_TYPE = None    # Specify how atomic blocks should be clustered in the used matrices, in order to improve flop rate, and possibly speedup the matrix multiply. Note that the atomic s_preconditioner can not be used.Furthermore, since screening is on matrix blocks, slightly more accurate results can be expected with molecular.
        self._SINGLE_PRECISION_MATRICES = None    # Matrices used within the LS code can be either double or single precision.
        self._RESTART_WRITE = None    # Write the density matrix at the end of the SCF (currently requires EXTRAPOLATION_ORDER>0). Files might be rather large.
        self._RESTART_READ = None    # Read the density matrix before the (first) SCF.
        self._S_INVERSION = None    # Method used to compute the inverse of S.
        self._SIGN_SQRT_ORDER = None    # Order of the sqrt iteration, should be 2..5, 3 or 5 recommended
        self._REPORT_ALL_SPARSITIES = None    # Run the sparsity report at the end of the SCF
        self._PERFORM_MU_SCAN = None    # Do a scan of the chemical potential after the SCF
        self.CURVY_STEPS = curvy_steps1()
        self.CHEBYSHEV = chebyshev1()
        self.name = "LS_SCF"
        self.keywords = [('_MAX_SCF', 'MAX_SCF'), ('_EPS_SCF', 'EPS_SCF'), ('_MIXING_FRACTION', 'MIXING_FRACTION'), ('_EPS_FILTER', 'EPS_FILTER'), ('_EPS_LANCZOS', 'EPS_LANCZOS'), ('_MAX_ITER_LANCZOS', 'MAX_ITER_LANCZOS'), ('_MU', 'MU'), ('_FIXED_MU', 'FIXED_MU'), ('_EXTRAPOLATION_ORDER', 'EXTRAPOLATION_ORDER'), ('_S_PRECONDITIONER', 'S_PRECONDITIONER'), ('_PURIFICATION_METHOD', 'PURIFICATION_METHOD'), ('_DYNAMIC_THRESHOLD', 'DYNAMIC_THRESHOLD'), ('_MATRIX_CLUSTER_TYPE', 'MATRIX_CLUSTER_TYPE'), ('_SINGLE_PRECISION_MATRICES', 'SINGLE_PRECISION_MATRICES'), ('_RESTART_WRITE', 'RESTART_WRITE'), ('_RESTART_READ', 'RESTART_READ'), ('_S_INVERSION', 'S_INVERSION'), ('_SIGN_SQRT_ORDER', 'SIGN_SQRT_ORDER'), ('_REPORT_ALL_SPARSITIES', 'REPORT_ALL_SPARSITIES'), ('_PERFORM_MU_SCAN', 'PERFORM_MU_SCAN')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('CURVY_STEPS', 'CURVY_STEPS'), ('CHEBYSHEV', 'CHEBYSHEV')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class metadyn1(printable):
    """This section sets parameters to set up a calculation of metadynamics."""
    def __init__(self):
        self._USE_PLUMED = None    # Specify whether to use plumed as an external metadynamics driver.
        self._PLUMED_INPUT_FILE = None    # Specify the file name of the external plumed input file
        self._MIN_NT_HILLS = None    # Specify the minimum MD step interval between spawning two hills. If specified, it must be >= than NT_HILLS. In case MIN_DISP is used, if MIN_DISP is satisfied before MIN_NT_HILLS MD steps have been performed, the MD will continue without any spawning until MIN_NT_HILLS is reached. The default value has the net effect of skipping this check.
        self._NT_HILLS = None    # Specify the maximum MD step interval between spawning two hills. When negative, no new hills are spawned and only the hills read from SPAWNED_HILLS_* are in effect. The latteris useful when one wants to add a custom constant bias potential.
        self._TEMPERATURE = None    # If a Lagrangian scheme is used the temperature for the collective variables is specified.
        self._MIN_DISP = None    # Minimum displacement between hills before placing a new hill.
        self._OLD_HILL_NUMBER = None    # Index of the last hill spawned for this walker.Needed to calculate MIN_DISP
        self._OLD_HILL_STEP = None    # Timestep of the last hill spawned for this walker.Needed to calculate MIN_DISP
        self._HILL_TAIL_CUTOFF = None    # By setting this variable larger than 0 the tail of the Gaussian hill  is damped to zero faster. The Gaussian function is multiplied by a cutoff function that becomes active at |x-X0|>HILL_TAIL_CUTOFF*SCALE, where X0 is the location of the Gaussian and SCALE is the width of the Gaussian. For more than one METAVAR X0 and SCALE are METAVAR-dependent.  (1-(|x-X0|/HILL_TAIL_CUTOFF*SCALE)^P_EXP)/(1-(|x-X0|/HILL_TAIL_CUTOFF*SCALE)^Q_EXP)
        self._P_EXPONENT = None    # Exponent at the numerator of the cutoff function to damp the tail of the Gaussian.
        self._Q_EXPONENT = None    # Exponent at the denominator of the cutoff function to damp the tail of the Gaussian.
        self._SLOW_GROWTH = None    # Let the last hill grow slowly over NT_HILLS.
        self._TEMP_TOL = None    # If a Lagrangian scheme is used the temperature tolerance for the collective variables is specified.
        self._LANGEVIN = None    # If a Lagrangian scheme is used the eq. motion of the COLVARS are integrated with a LANGEVIN scheme.
        self._WW = None    # Specifies the height of the gaussian to spawn. Default 0.1 .
        self._DO_HILLS = None    # This keyword enables the spawning of the hills. Default .FALSE.
        self._WELL_TEMPERED = None    # This keyword enables Well-tempered metadynamics. Default .FALSE.
        self._DELTA_T = None    # If Well-tempered metaD is used, the temperature parameter must be specified.
        self._WTGAMMA = None    # If Well-tempered metaD is used, the gamma parameter must be specified if not DELTA_T.
        self._LAGRANGE = None    # Specifies whether an extended-lagrangian should be used. Default .FALSE.
        self._STEP_START_VAL = None    # The starting step value for metadynamics
        self._NHILLS_START_VAL = None    # The starting value of previously spawned hills
        self._COLVAR_AVG_TEMPERATURE_RESTART = None    # COLVAR average temperature. Only for restarting purposes.
        self._TAMCSTEPS = None    # Number of sampling points for z
        self._TIMESTEP = None    # The length of an integration step for colvars (TAMC only)
        self.listMETAVAR = []
        self.METAVAR = metavar1()
        self.MULTIPLE_WALKERS = multiple_walkers1()
        self.listPRINT = []
        self.PRINT = print11()
        self.SPAWNED_HILLS_POS = spawned_hills_pos1()
        self.SPAWNED_HILLS_SCALE = spawned_hills_scale1()
        self.SPAWNED_HILLS_HEIGHT = spawned_hills_height1()
        self.SPAWNED_HILLS_INVDT = spawned_hills_invdt1()
        self.EXT_LAGRANGE_SS0 = ext_lagrange_ss01()
        self.EXT_LAGRANGE_VVP = ext_lagrange_vvp1()
        self.EXT_LAGRANGE_SS = ext_lagrange_ss1()
        self.EXT_LAGRANGE_FS = ext_lagrange_fs1()
        self.name = "METADYN"
        self.keywords = [('_USE_PLUMED', 'USE_PLUMED'), ('_PLUMED_INPUT_FILE', 'PLUMED_INPUT_FILE'), ('_MIN_NT_HILLS', 'MIN_NT_HILLS'), ('_NT_HILLS', 'NT_HILLS'), ('_TEMPERATURE', 'TEMPERATURE'), ('_MIN_DISP', 'MIN_DISP'), ('_OLD_HILL_NUMBER', 'OLD_HILL_NUMBER'), ('_OLD_HILL_STEP', 'OLD_HILL_STEP'), ('_HILL_TAIL_CUTOFF', 'HILL_TAIL_CUTOFF'), ('_P_EXPONENT', 'P_EXPONENT'), ('_Q_EXPONENT', 'Q_EXPONENT'), ('_SLOW_GROWTH', 'SLOW_GROWTH'), ('_TEMP_TOL', 'TEMP_TOL'), ('_LANGEVIN', 'LANGEVIN'), ('_WW', 'WW'), ('_DO_HILLS', 'DO_HILLS'), ('_WELL_TEMPERED', 'WELL_TEMPERED'), ('_DELTA_T', 'DELTA_T'), ('_WTGAMMA', 'WTGAMMA'), ('_LAGRANGE', 'LAGRANGE'), ('_STEP_START_VAL', 'STEP_START_VAL'), ('_NHILLS_START_VAL', 'NHILLS_START_VAL'), ('_COLVAR_AVG_TEMPERATURE_RESTART', 'COLVAR_AVG_TEMPERATURE_RESTART'), ('_TAMCSTEPS', 'TAMCSTEPS'), ('_TIMESTEP', 'TIMESTEP')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('MULTIPLE_WALKERS', 'MULTIPLE_WALKERS'), ('SPAWNED_HILLS_POS', 'SPAWNED_HILLS_POS'), ('SPAWNED_HILLS_SCALE', 'SPAWNED_HILLS_SCALE'), ('SPAWNED_HILLS_HEIGHT', 'SPAWNED_HILLS_HEIGHT'), ('SPAWNED_HILLS_INVDT', 'SPAWNED_HILLS_INVDT'), ('EXT_LAGRANGE_SS0', 'EXT_LAGRANGE_SS0'), ('EXT_LAGRANGE_VVP', 'EXT_LAGRANGE_VVP'), ('EXT_LAGRANGE_SS', 'EXT_LAGRANGE_SS'), ('EXT_LAGRANGE_FS', 'EXT_LAGRANGE_FS')]
        self.repeated_subsections = [('METAVAR', 'metavar1'), ('PRINT', 'print11')]

    def addMETAVAR(self):
        new_section = metavar1()
        self.listMETAVAR.append(new_section)
        return new_section

    def addPRINT(self):
        new_section = print11()
        self.listPRINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class print15(printable):
    """Section of possible print options in MIXED env."""
    def __init__(self):
        self.PROGRAM_RUN_INFO = program_run_info9()
        self.DIPOLE = dipole1()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('DIPOLE', 'DIPOLE')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print14(printable):
    """Controls the printing properties during an MD run"""
    def __init__(self):
        self.TRAJECTORY = trajectory1()
        self.SHELL_TRAJECTORY = shell_trajectory1()
        self.CORE_TRAJECTORY = core_trajectory1()
        self.CELL = cell2()
        self.VELOCITIES = velocities1()
        self.SHELL_VELOCITIES = shell_velocities1()
        self.CORE_VELOCITIES = core_velocities1()
        self.STRUCTURE_DATA = structure_data1()
        self.FORCE_MIXING_LABELS = force_mixing_labels1()
        self.FORCES = forces2()
        self.SHELL_FORCES = shell_forces1()
        self.CORE_FORCES = core_forces1()
        self.MIXED_ENERGIES = mixed_energies1()
        self.STRESS = stress1()
        self.RESTART = restart2()
        self.RESTART_HISTORY = restart_history1()
        self.TRANSLATION_VECTOR = translation_vector1()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('TRAJECTORY', 'TRAJECTORY'), ('SHELL_TRAJECTORY', 'SHELL_TRAJECTORY'), ('CORE_TRAJECTORY', 'CORE_TRAJECTORY'), ('CELL', 'CELL'), ('VELOCITIES', 'VELOCITIES'), ('SHELL_VELOCITIES', 'SHELL_VELOCITIES'), ('CORE_VELOCITIES', 'CORE_VELOCITIES'), ('STRUCTURE_DATA', 'STRUCTURE_DATA'), ('FORCE_MIXING_LABELS', 'FORCE_MIXING_LABELS'), ('FORCES', 'FORCES'), ('SHELL_FORCES', 'SHELL_FORCES'), ('CORE_FORCES', 'CORE_FORCES'), ('MIXED_ENERGIES', 'MIXED_ENERGIES'), ('STRESS', 'STRESS'), ('RESTART', 'RESTART'), ('RESTART_HISTORY', 'RESTART_HISTORY'), ('TRANSLATION_VECTOR', 'TRANSLATION_VECTOR')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print17(printable):
    """Print section"""
    def __init__(self):
        self.NEIGHBOR_LISTS = neighbor_lists1()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('NEIGHBOR_LISTS', 'NEIGHBOR_LISTS')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print16(printable):
    """printing of information during the scf"""
    def __init__(self):
        self.RESTART = restart3()
        self.RESTART_HISTORY = restart_history2()
        self.ITERATION_INFO = iteration_info1()
        self.PROGRAM_RUN_INFO = program_run_info10()
        self.MO_ORTHONORMALITY = mo_orthonormality1()
        self.MO_MAGNITUDE = mo_magnitude1()
        self.DETAILED_ENERGY = detailed_energy1()
        self.DIIS_INFO = diis_info2()
        self.TOTAL_DENSITIES = total_densities1()
        self.LANCZOS = lanczos1()
        self.DIAG_SUB_SCF = diag_sub_scf2()
        self.DAVIDSON = davidson2()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('RESTART', 'RESTART'), ('RESTART_HISTORY', 'RESTART_HISTORY'), ('ITERATION_INFO', 'ITERATION_INFO'), ('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('MO_ORTHONORMALITY', 'MO_ORTHONORMALITY'), ('MO_MAGNITUDE', 'MO_MAGNITUDE'), ('DETAILED_ENERGY', 'DETAILED_ENERGY'), ('DIIS_INFO', 'DIIS_INFO'), ('TOTAL_DENSITIES', 'TOTAL_DENSITIES'), ('LANCZOS', 'LANCZOS'), ('DIAG_SUB_SCF', 'DIAG_SUB_SCF'), ('DAVIDSON', 'DAVIDSON')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class averages1(printable):
    """Controls the calculation of the averages during an MD run."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ACQUISITION_START_TIME = None    # Setup up the simulation time when the acquisition process to compute  averages is started.
        self._AVERAGE_COLVAR = None    # Switch for computing the averages of COLVARs.
        self.PRINT_AVERAGES = print_averages1()
        self.RESTART_AVERAGES = restart_averages1()
        self.name = "AVERAGES"
        self.keywords = [('_ACQUISITION_START_TIME', 'ACQUISITION_START_TIME'), ('_AVERAGE_COLVAR', 'AVERAGE_COLVAR')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PRINT_AVERAGES', 'PRINT_AVERAGES'), ('RESTART_AVERAGES', 'RESTART_AVERAGES')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print10(printable):
    """Controls the printing properties during an MD run"""
    def __init__(self):
        self._FORCE_LAST = None    # Print the output and restart file if walltime is reached or if an external EXIT command is given. It still requires the keyword LAST to be present for the specific print key (in case the last step should not match with the print_key iteration number).
        self.ENERGY = energy3()
        self.SHELL_ENERGY = shell_energy1()
        self.TEMP_KIND = temp_kind1()
        self.TEMP_SHELL_KIND = temp_shell_kind1()
        self.CENTER_OF_MASS = center_of_mass1()
        self.COEFFICIENTS = coefficients1()
        self.ROTATIONAL_INFO = rotational_info2()
        self.PROGRAM_RUN_INFO = program_run_info6()
        self.name = "PRINT"
        self.keywords = [('_FORCE_LAST', 'FORCE_LAST')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('ENERGY', 'ENERGY'), ('SHELL_ENERGY', 'SHELL_ENERGY'), ('TEMP_KIND', 'TEMP_KIND'), ('TEMP_SHELL_KIND', 'TEMP_SHELL_KIND'), ('CENTER_OF_MASS', 'CENTER_OF_MASS'), ('COEFFICIENTS', 'COEFFICIENTS'), ('ROTATIONAL_INFO', 'ROTATIONAL_INFO'), ('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print13(printable):
    """Controls the path integral-specific output"""
    def __init__(self):
        self.ENERGY = energy5()
        self.CENTROID_POS = centroid_pos1()
        self.CENTROID_VEL = centroid_vel1()
        self.CENTROID_GYR = centroid_gyr1()
        self.COM = com1()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('ENERGY', 'ENERGY'), ('CENTROID_POS', 'CENTROID_POS'), ('CENTROID_VEL', 'CENTROID_VEL'), ('CENTROID_GYR', 'CENTROID_GYR'), ('COM', 'COM')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print12(printable):
    """The section that controls the output of the helium code"""
    def __init__(self):
        self.ENERGY = energy4()
        self.SDENSITY = sdensity1()
        self.COORDINATES = coordinates1()
        self.RDF = rdf2()
        self.RHO = rho2()
        self.PLENGTH = plength1()
        self.ACCEPTS = accepts1()
        self.PERM = perm2()
        self.FORCES = forces1()
        self.FORCES_INST = forces_inst1()
        self.WNUMBER = wnumber1()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('ENERGY', 'ENERGY'), ('SDENSITY', 'SDENSITY'), ('COORDINATES', 'COORDINATES'), ('RDF', 'RDF'), ('RHO', 'RHO'), ('PLENGTH', 'PLENGTH'), ('ACCEPTS', 'ACCEPTS'), ('PERM', 'PERM'), ('FORCES', 'FORCES'), ('FORCES_INST', 'FORCES_INST'), ('WNUMBER', 'WNUMBER')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print19(printable):
    """Controls the printing of info about load balance"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._LOAD_BALANCE_INFO = None    # Activates the printing of load balance information
        self.EACH = each1()
        self.name = "PRINT"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_LOAD_BALANCE_INFO', 'LOAD_BALANCE_INFO')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print18(printable):
    """Section of possible print options in SE code."""
    def __init__(self):
        self.NEIGHBOR_LISTS = neighbor_lists3()
        self.SUBCELL = subcell1()
        self.EWALD_INFO = ewald_info1()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('NEIGHBOR_LISTS', 'NEIGHBOR_LISTS'), ('SUBCELL', 'SUBCELL'), ('EWALD_INFO', 'EWALD_INFO')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class configuration1(printable):
    """Specify additional parameters for the combinatorial configurations."""
    def __init__(self):
        self._GLB_CONF = None    # Specifies the global configuration using 1 or 0.
        self._SUB_CONF = None    # Specifies the subconfiguration using 1 or 0 belonging to the global configuration.
        self._MULTIPLICITY = None    # Specify for each fragment the multiplicity. Two times the total spin plus one. Specify 3 for a triplet, 4 for a quartet,and so on. Default is 1 (singlet) for an even number and 2 (doublet) for an odd number of electrons.
        self._MULTIP = self._MULTIPLICITY
        self._CHARGE = None    # The total charge for each fragment.
        self.name = "CONFIGURATION"
        self.keywords = [('_GLB_CONF', 'GLB_CONF'), ('_SUB_CONF', 'SUB_CONF'), ('_MULTIPLICITY', 'MULTIPLICITY'), ('_MULTIP', 'MULTIP'), ('_CHARGE', 'CHARGE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class bonds1(printable):
    """Defines new bonds"""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Two integer indexes per line defining the new bond. Indexes must be relative to the full system and not to the single molecules
        self.name = "BONDS"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class restraint2(printable):
    """Restraint between two force_eval: E = E1 + k*(E1-E2-t)**2"""
    def __init__(self):
        self._RESTRAINT_TARGET = None    # Target value of the restraint (t)
        self._RESTRAINT_STRENGTH = None    # Strength of the restraint (k) in k*(E1-E2-t)**2
        self.name = "RESTRAINT"
        self.keywords = [('_RESTRAINT_TARGET', 'RESTRAINT_TARGET'), ('_RESTRAINT_STRENGTH', 'RESTRAINT_STRENGTH')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class restraint3(printable):
    """specifies a restraint on the fitted charges.This can be used to restrain values to zero.s*(sum over atom_list q_i - t)**2"""
    def __init__(self):
        self._TARGET = None    # the target value for the restraint
        self._STRENGTH = None    # the target value for the constraint
        self.list_ATOM_LIST = []
        self._ATOM_LIST = None
    # Defines the list of atoms involved in this restraint
        self._ATOM_COEF = None    # Defines the coefficient of the atom in this linear restraint. If given, the restraint will be: s*(sum over atom_list c_i * q_i - t)**2
        self.name = "RESTRAINT"
        self.keywords = [('_TARGET', 'TARGET'), ('_STRENGTH', 'STRENGTH'), ('_ATOM_COEF', 'ATOM_COEF')]
        self.repeated_keywords = [('_ATOM_LIST', 'ATOM_LIST')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def add_ATOM_LIST(self, value):
        self.list_ATOM_LIST.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class restraint1(printable):
    """Activate and specify information on restraint instead of constraint"""
    def __init__(self):
        self._K = None    # Specifies the force constant for the harmonic restraint. The functional form for the restraint is: K*(X-TARGET)^2.
        self.name = "RESTRAINT"
        self.keywords = [('_K', 'K')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class interaction_potential2(printable):
    """Parameters the interaction potential in computing the biel integrals"""
    def __init__(self):
        self._POTENTIAL_TYPE = None    # Which interaction potential should be used (Coulomb, TShPSC operator).
        self._TRUNCATION_RADIUS = None    # Determines truncation radius for the truncated TShPSC potential. Only valid when doing truncated calculation
        self._TSHPSC_DATA = None    # Location of the file TShPSC.dat that contains the data for the evaluation of the TShPSC G0
        self.name = "INTERACTION_POTENTIAL"
        self.keywords = [('_POTENTIAL_TYPE', 'POTENTIAL_TYPE'), ('_TRUNCATION_RADIUS', 'TRUNCATION_RADIUS'), ('_TSHPSC_DATA', 'TSHPSC_DATA')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class interaction_potential1(printable):
    """Sets up interaction potential if requested"""
    def __init__(self):
        self._POTENTIAL_TYPE = None    # Which interaction potential should be used (Coulomb, longrange or shortrange).
        self._OMEGA = None    # Parameter for short/longrange interaction
        self._SCALE_COULOMB = None    # Scales Hartree-Fock contribution arising from a coulomb potential. Only valid when doing a mixed potential calculation
        self._SCALE_LONGRANGE = None    # Scales Hartree-Fock contribution arising from a longrange potential. Only valid when doing a mixed potential calculation
        self._SCALE_GAUSSIAN = None    # Scales Hartree-Fock contribution arising from a gaussian potential. Only valid when doing a mixed potential calculation
        self._CUTOFF_RADIUS = None    # Determines cutoff radius for the truncated 1/r potential. Only valid when doing truncated calculation
        self._T_C_G_DATA = None    # Location of the file t_c_g.dat that contains the data for the evaluation of the truncated gamma function
        self.name = "INTERACTION_POTENTIAL"
        self.keywords = [('_POTENTIAL_TYPE', 'POTENTIAL_TYPE'), ('_OMEGA', 'OMEGA'), ('_SCALE_COULOMB', 'SCALE_COULOMB'), ('_SCALE_LONGRANGE', 'SCALE_LONGRANGE'), ('_SCALE_GAUSSIAN', 'SCALE_GAUSSIAN'), ('_CUTOFF_RADIUS', 'CUTOFF_RADIUS'), ('_T_C_G_DATA', 'T_C_G_DATA')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class quartic1(printable):
    """Parameters controlling the quartic wall"""
    def __init__(self):
        self._DIRECTION = None    # Specify the direction of the wall.
        self._K = None    # Specify the value of the quartic potential constant: K*(CV-(POS+/-(1/K^(1/4))))^4
        self.name = "QUARTIC"
        self.keywords = [('_DIRECTION', 'DIRECTION'), ('_K', 'K')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class block1(printable):
    """Specify the atom number belonging to this fragment."""
    def __init__(self):
        self._LIST = None    # Specifies a list of atoms.
        self.name = "BLOCK"
        self.keywords = [('_LIST', 'LIST')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class image_charge_info1(printable):
    """Prints image charge coefficients and detailed energy info"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "IMAGE_CHARGE_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class coordinates1(printable):
    """Controls the output of helium coordinates"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._FORMAT = None    # Output file format for the coordinates
        self.EACH = each1()
        self.name = "COORDINATES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_FORMAT', 'FORMAT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class saop1(printable):
    """Uses the SAOP potential"""
    def __init__(self):
        self._ALPHA = None    # Value of the alpha parameter (default = 1.19).
        self._BETA = None    # Value of the beta parameter (default = 0.01).
        self._K_RHO = None    # Value of the K_rho parameter (default = 0.42).
        self.name = "SAOP"
        self.keywords = [('_ALPHA', 'ALPHA'), ('_BETA', 'BETA'), ('_K_RHO', 'K_RHO')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class msd1(printable):
    """Loads an external trajectory file and performs analysis on the loaded snapshots."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._REF0_FILENAME = None    # Specify the filename where the initial reference configuration is stored.
        self._MSD_PER_KIND = None    # Set up the calculation of the MSD for each atomic kind
        self._MSD_PER_MOLKIND = None    # Set up the calculation of the MSD for each molecule kind.The position of the center of mass of the molecule is considered.
        self._MSD_PER_REGION = None    # Set up the calculation of the MSD for each defined region.
        self._DISPLACED_ATOM = None    # Identify the atoms that moved from their initialposition of a distance larger than a given tolerance (see msd%displacement_tol).
        self._DISPLACEMENT_TOL = None    # Lower limit to define displaced atoms
        self.listDEFINE_REGION = []
        self.DEFINE_REGION = define_region4()
        self.name = "MSD"
        self.keywords = [('_REF0_FILENAME', 'REF0_FILENAME'), ('_MSD_PER_KIND', 'MSD_PER_KIND'), ('_MSD_PER_MOLKIND', 'MSD_PER_MOLKIND'), ('_MSD_PER_REGION', 'MSD_PER_REGION'), ('_DISPLACED_ATOM', 'DISPLACED_ATOM'), ('_DISPLACEMENT_TOL', 'DISPLACEMENT_TOL')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('DEFINE_REGION', 'define_region4')]

    def addDEFINE_REGION(self):
        new_section = define_region4()
        self.listDEFINE_REGION.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class resp1(printable):
    """Requests a RESP fit of charges. When using a periodic Poisson solver and a periodic cell, the periodic RESP routines are used. If the Hartree potential matches with the one of an isolated system (i.e. isolated Poisson solver and big, nonperiodic cells), the nonperiodic RESP routines are automatically used. The subsections NONPERIODIC_SYS and PERIODIC_SYS do not request a nonperiodic or periodic solution, they only determine the sampling of the fitting points. All restraints are harmonic!"""
    def __init__(self):
        self._STRIDE = None    # The stride (X,Y,Z) used to write the cube file (larger values result in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1 number valid for all components.
        self._INTEGER_TOTAL_CHARGE = None    # Forces the total charge to be integer
        self._RESTRAIN_HEAVIES_TO_ZERO = None    # Restrain non-hydrogen atoms to zero.
        self._RESTRAIN_HEAVIES_STRENGTH = None    # If defined, enforce the restraint of non-hydrogen atoms to zero. Its value is the strength of the restraint on the heavy atoms.
        self._WIDTH = None    # Specifies the value of the width of the Gaussian charge distribution carried by each atom. Needs only to be specified when using a periodic Poisson solver.
        self.listCONSTRAINT = []
        self.CONSTRAINT = constraint2()
        self.listRESTRAINT = []
        self.RESTRAINT = restraint3()
        self.NONPERIODIC_SYS = nonperiodic_sys1()
        self.listPERIODIC_SYS = []
        self.PERIODIC_SYS = periodic_sys1()
        self.PRINT = print40()
        self.name = "RESP"
        self.keywords = [('_STRIDE', 'STRIDE'), ('_INTEGER_TOTAL_CHARGE', 'INTEGER_TOTAL_CHARGE'), ('_RESTRAIN_HEAVIES_TO_ZERO', 'RESTRAIN_HEAVIES_TO_ZERO'), ('_RESTRAIN_HEAVIES_STRENGTH', 'RESTRAIN_HEAVIES_STRENGTH'), ('_WIDTH', 'WIDTH')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('NONPERIODIC_SYS', 'NONPERIODIC_SYS'), ('PRINT', 'PRINT')]
        self.repeated_subsections = [('CONSTRAINT', 'constraint2'), ('RESTRAINT', 'restraint3'), ('PERIODIC_SYS', 'periodic_sys1')]

    def addCONSTRAINT(self):
        new_section = constraint2()
        self.listCONSTRAINT.append(new_section)
        return new_section

    def addRESTRAINT(self):
        new_section = restraint3()
        self.listRESTRAINT.append(new_section)
        return new_section

    def addPERIODIC_SYS(self):
        new_section = periodic_sys1()
        self.listPERIODIC_SYS.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class sdensity1(printable):
    """Controls the output of the helium superfluid density"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "SDENSITY"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class hcth1(printable):
    """Uses the HCTH class of functionals"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._PARAMETER_SET = None    # Which version of the parameters should be used
        self.name = "HCTH"
        self.keywords = [('_PARAMETER_SET', 'PARAMETER_SET')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class cp_dbcsr1(printable):
    """Benchmark and test the cp_dbcsr routines"""
    def __init__(self):
        self._N_LOOP = None    # Number of operations being timed (useful for small matrices).
        self._DATA_TYPE = None    # Data type of the matrices
        self._M = None    # Dimension 1 of C
        self._N = None    # Dimension 2 of C
        self._K = None    # Inner dimension M
        self._TRANSA = None    # Transpose matrix A
        self._TRANSB = None    # Transpose matrix B
        self._BS_M = None    # Row block sizes of C
        self._BS_N = None    # Column block sizes of C
        self._BS_K = None    # Block sizes of inner dimension
        self._ATYPE = None    # Matrix A type
        self._BTYPE = None    # Matrix B type
        self._CTYPE = None    # Matrix C type
        self._NPROC = None    # Number of processors to test
        self._KEEPSPARSE = None    # Keep product sparse
        self._ASPARSITY = None    # Sparsity of A matrix
        self._BSPARSITY = None    # Sparsity of B matrix
        self._CSPARSITY = None    # Sparsity of C matrix
        self._ALPHA = None    # Multiplication factor
        self._BETA = None    # Product premultiplication factor
        self._FILTER_EPS = None    # Threshold for on-the-fly and final filtering.
        self._DETERMINISTIC = None    # Attempt deterministic behavior (turn off for speed).
        self.name = "CP_DBCSR"
        self.keywords = [('_N_LOOP', 'N_LOOP'), ('_DATA_TYPE', 'DATA_TYPE'), ('_M', 'M'), ('_N', 'N'), ('_K', 'K'), ('_TRANSA', 'TRANSA'), ('_TRANSB', 'TRANSB'), ('_BS_M', 'BS_M'), ('_BS_N', 'BS_N'), ('_BS_K', 'BS_K'), ('_ATYPE', 'ATYPE'), ('_BTYPE', 'BTYPE'), ('_CTYPE', 'CTYPE'), ('_NPROC', 'NPROC'), ('_KEEPSPARSE', 'KEEPSPARSE'), ('_ASPARSITY', 'ASPARSITY'), ('_BSPARSITY', 'BSPARSITY'), ('_CSPARSITY', 'CSPARSITY'), ('_ALPHA', 'ALPHA'), ('_BETA', 'BETA'), ('_FILTER_EPS', 'FILTER_EPS'), ('_DETERMINISTIC', 'DETERMINISTIC')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class nose2(printable):
    """Controls the Nose-Hoover thermostats"""
    def __init__(self):
        self._NNOS = None    # length of nose-hoover chain. 0 means no thermostat
        self.COORD = coord3()
        self.VELOCITY = velocity4()
        self.name = "NOSE"
        self.keywords = [('_NNOS', 'NNOS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('COORD', 'COORD'), ('VELOCITY', 'VELOCITY')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class nose1(printable):
    """paramameters of the Nose Hoover thermostat chain"""
    def __init__(self):
        self._LENGTH = None    # length of the Nose-Hoover chain
        self._YOSHIDA = None    # order of the yoshida integretor usef for the thermostat
        self._TIMECON = None    # timeconstant of the thermostat chain
        self._MTS = None    # number of multiple timesteps to be used for the NoseHoover chain
        self._MULTIPLE_TIME_STEPS = self._MTS
        self._MULT_T_STEPS = self._MTS
        self.COORD = coord1()
        self.VELOCITY = velocity2()
        self.MASS = mass2()
        self.FORCE = force1()
        self.name = "NOSE"
        self.keywords = [('_LENGTH', 'LENGTH'), ('_YOSHIDA', 'YOSHIDA'), ('_TIMECON', 'TIMECON'), ('_MTS', 'MTS'), ('_MULTIPLE_TIME_STEPS', 'MULTIPLE_TIME_STEPS'), ('_MULT_T_STEPS', 'MULT_T_STEPS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('COORD', 'COORD'), ('VELOCITY', 'VELOCITY'), ('MASS', 'MASS'), ('FORCE', 'FORCE')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class hf1(printable):
    """Sets up the Hartree-Fock parameters if requested"""
    def __init__(self):
        self._FRACTION = None    # The fraction of Hartree-Fock to add to the total energy. 1.0 implies standard Hartree-Fock if used with XC_FUNCTIONAL NONE. NOTE: In a mixed potential calculation this should be set to 1.0, otherwise all parts are multiplied with this factor.
        self._TREAT_LSD_IN_CORE = None    # Determines how spin denisities are taken into account. If true, the beta spin density is included via a second in core call. If false, alpha and beta spins are done in one shot
        self._PW_HFX = None    # Compute the Hartree-Fock energy also in the plane wave basis.The value is ignored, and intended for debugging only.
        self._PW_HFX_BLOCKSIZE = None    # Improve the performance of pw_hfx at the cost of some additional memory by storing the realspace representation of PW_HFX_BLOCKSIZE states.
        self.HF_INFO = hf_info1()
        self.PERIODIC = periodic1()
        self.SCREENING = screening2()
        self.INTERACTION_POTENTIAL = interaction_potential1()
        self.LOAD_BALANCE = load_balance1()
        self.MEMORY = memory2()
        self.HFX_RI = hfx_ri1()
        self.name = "HF"
        self.keywords = [('_FRACTION', 'FRACTION'), ('_TREAT_LSD_IN_CORE', 'TREAT_LSD_IN_CORE'), ('_PW_HFX', 'PW_HFX'), ('_PW_HFX_BLOCKSIZE', 'PW_HFX_BLOCKSIZE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('HF_INFO', 'HF_INFO'), ('PERIODIC', 'PERIODIC'), ('SCREENING', 'SCREENING'), ('INTERACTION_POTENTIAL', 'INTERACTION_POTENTIAL'), ('LOAD_BALANCE', 'LOAD_BALANCE'), ('MEMORY', 'MEMORY'), ('HFX_RI', 'HFX_RI')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class s1(printable):
    """The s variable for GLE used for restart"""
    def __init__(self):
        self._DEFAULT_KEYWORD = None    # Specify s variable for GLE thermostat
        self.name = "S"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []
        pass

    def print_input(self, level):
        return printable.print_input(self, level)


class distance_point_plane1(printable):
    """Section to define the distance of a point from a plane as a collective variables."""
    def __init__(self):
        self._PBC = None    # Whether periodic boundary conditions should be applied on the atomic position before computing the colvar or not.
        self._ATOMS_PLANE = None    # Specifies the indexes of atoms/points defining the plane.
        self._POINTS_PLANE = self._ATOMS_PLANE
        self._ATOM_POINT = None    # Specifies the atom/point index defining the point.
        self._POINT_POINT = self._ATOM_POINT
        self.listPOINT = []
        self.POINT = point1()
        self.name = "DISTANCE_POINT_PLANE"
        self.keywords = [('_PBC', 'PBC'), ('_ATOMS_PLANE', 'ATOMS_PLANE'), ('_POINTS_PLANE', 'POINTS_PLANE'), ('_ATOM_POINT', 'ATOM_POINT'), ('_POINT_POINT', 'POINT_POINT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('POINT', 'point1')]

    def addPOINT(self):
        new_section = point1()
        self.listPOINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class pp_basis1(printable):
    """Section of basis set information for pseudopotential calculations."""
    def __init__(self):
        self._BASIS_TYPE = None    # Basis set type
        self._NUM_GTO = None    # Number of Gaussian type functions for s, p, d, ...
        self._NUM_SLATER = None    # Number of Slater type functions for s, p, d, ...
        self._START_INDEX = None    # Starting index for Geometrical Basis sets
        self._S_EXPONENTS = None    # Exponents for s functions
        self._P_EXPONENTS = None    # Exponents for p functions
        self._D_EXPONENTS = None    # Exponents for d functions
        self._F_EXPONENTS = None    # Exponents for f functions
        self._S_QUANTUM_NUMBERS = None    # Main quantum numbers for s functions
        self._P_QUANTUM_NUMBERS = None    # Main quantum numbers for p functions
        self._D_QUANTUM_NUMBERS = None    # Main quantum numbers for d functions
        self._F_QUANTUM_NUMBERS = None    # Main quantum numbers for f functions
        self._GEOMETRICAL_FACTOR = None    # Geometrical basis: factor C in a*C^k
        self._GEO_START_VALUE = None    # Geometrical basis: starting value a in a*C^k
        self._BASIS_SET_FILE_NAME = None    # Name of the basis set file, may include a path
        self._BASIS_SET = None    # The contracted Gaussian basis set
        self._ORBITAL_BASIS_SET = self._BASIS_SET
        self._ORB_BASIS = self._BASIS_SET
        self._QUADRATURE = None    # Algorithm to construct the atomic radial grids
        self._GRID_POINTS = None    # Number of radial grid points
        self._EPS_EIGENVALUE = None    # Cutoff of overlap matrix eigenvalues included into basis
        self.BASIS = basis1()
        self.name = "PP_BASIS"
        self.keywords = [('_BASIS_TYPE', 'BASIS_TYPE'), ('_NUM_GTO', 'NUM_GTO'), ('_NUM_SLATER', 'NUM_SLATER'), ('_START_INDEX', 'START_INDEX'), ('_S_EXPONENTS', 'S_EXPONENTS'), ('_P_EXPONENTS', 'P_EXPONENTS'), ('_D_EXPONENTS', 'D_EXPONENTS'), ('_F_EXPONENTS', 'F_EXPONENTS'), ('_S_QUANTUM_NUMBERS', 'S_QUANTUM_NUMBERS'), ('_P_QUANTUM_NUMBERS', 'P_QUANTUM_NUMBERS'), ('_D_QUANTUM_NUMBERS', 'D_QUANTUM_NUMBERS'), ('_F_QUANTUM_NUMBERS', 'F_QUANTUM_NUMBERS'), ('_GEOMETRICAL_FACTOR', 'GEOMETRICAL_FACTOR'), ('_GEO_START_VALUE', 'GEO_START_VALUE'), ('_BASIS_SET_FILE_NAME', 'BASIS_SET_FILE_NAME'), ('_BASIS_SET', 'BASIS_SET'), ('_ORBITAL_BASIS_SET', 'ORBITAL_BASIS_SET'), ('_ORB_BASIS', 'ORB_BASIS'), ('_QUADRATURE', 'QUADRATURE'), ('_GRID_POINTS', 'GRID_POINTS'), ('_EPS_EIGENVALUE', 'EPS_EIGENVALUE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('BASIS', 'BASIS')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class shielding_tensor1(printable):
    """Controls the printing of the chemical shift"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._ATOMS_LU_BOUNDS = None    # The lower and upper atomic index for which the tensor is printed
        self._ATOMS_LU = self._ATOMS_LU_BOUNDS
        self.list_ATOMS_LIST = []
        self._ATOMS_LIST = None
    # list of atoms for which the shift is printed into a file
        self.EACH = each1()
        self.name = "SHIELDING_TENSOR"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_ATOMS_LU_BOUNDS', 'ATOMS_LU_BOUNDS'), ('_ATOMS_LU', 'ATOMS_LU')]
        self.repeated_keywords = [('_ATOMS_LIST', 'ATOMS_LIST')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def add_ATOMS_LIST(self, value):
        self.list_ATOMS_LIST.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class kinds1(printable):
    """controls the output of information on the kinds"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._POTENTIAL = None    # If the printkey is activated controls the printing of the fist_potential, gth_potential or all electron potential information
        self._BASIS_SET = None    # If the printkey is activated controls the printing of basis set information
        self._SE_PARAMETERS = None    # If the printkey is activated controls the printing of the semi-empirical parameters.
        self.EACH = each1()
        self.name = "KINDS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_POTENTIAL', 'POTENTIAL'), ('_BASIS_SET', 'BASIS_SET'), ('_SE_PARAMETERS', 'SE_PARAMETERS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class dipole2(printable):
    """This section specifies that we will perform an SCF dipole calculation of the MM atoms. Needs KEYWORD POL_SCF in POISSON secton"""
    def __init__(self):
        self._ATOM = None    # Defines the atomic kind of the scf dipole.
        self._APOL = None    # Defines the isotropic polarizability of the MM atom.
        self.listDAMPING = []
        self.DAMPING = damping1()
        self.name = "DIPOLE"
        self.keywords = [('_ATOM', 'ATOM'), ('_APOL', 'APOL')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('DAMPING', 'damping1')]

    def addDAMPING(self):
        new_section = damping1()
        self.listDAMPING.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class impropers1(printable):
    """Defines new impropers"""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Four integer indexes per line defining the new improper Indexes must be relative to the full system and not to the single molecules
        self.name = "IMPROPERS"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class derivatives2(printable):
    """Controls the printing of derivatives."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "DERIVATIVES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class eam1(printable):
    """This section specifies the input parameters for EAM potential type."""
    def __init__(self):
        self._ATOMS = None    # Defines the atomic kind involved in the nonbond potential
        self._PARM_FILE_NAME = None    # Specifies the filename that contains the tabulated EAM potential. File structure: the first line of the potential file contains a title. The second line contains: atomic number, mass and lattice constant. These information are parsed but not used in CP2K. The third line contains: dr: increment of r for the tabulated values of density and phi (assuming r starts in 0) [angstrom]; drho: increment of density for the tabulated values of the embedding function (assuming rho starts in 0) [au_c]; cutoff: cutoff of the EAM potential; npoints: number of points in tabulated. Follow in order npoints lines for rho [au_c] and its derivative [au_c*angstrom^-1]; npoints lines for PHI [ev] and its derivative [ev*angstrom^-1] and npoint lines for the embedded function [ev] and its derivative [ev*au_c^-1].
        self._PARMFILE = self._PARM_FILE_NAME
        self.name = "EAM"
        self.keywords = [('_ATOMS', 'ATOMS'), ('_PARM_FILE_NAME', 'PARM_FILE_NAME'), ('_PARMFILE', 'PARMFILE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class derivatives1(printable):
    """Print all derivatives after the DFT calculation"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._NDIGITS = None    # Specify the number of digits used to print derivatives
        self.EACH = each1()
        self.name = "DERIVATIVES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_NDIGITS', 'NDIGITS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class tersoff1(printable):
    """This section specifies the input parameters for Tersoff potential type."""
    def __init__(self):
        self._ATOMS = None    # Defines the atomic kind involved in the nonbond potential
        self._A = None    # Defines the A parameter of Tersoff potential
        self._B = None    # Defines the B parameter of Tersoff potential
        self._LAMBDA1 = None    # Defines the lambda1 parameter of Tersoff potential
        self._LAMBDA2 = None    # Defines the lambda2 parameter of Tersoff potential
        self._ALPHA = None    # Defines the alpha parameter of Tersoff potential
        self._BETA = None    # Defines the beta parameter of Tersoff potential
        self._N = None    # Defines the n parameter of Tersoff potential
        self._C = None    # Defines the c parameter of Tersoff potential
        self._D = None    # Defines the d parameter of Tersoff potential
        self._H = None    # Defines the h parameter of Tersoff potential
        self._LAMBDA3 = None    # Defines the lambda3 parameter of Tersoff potential
        self._BIGR = None    # Defines the bigR parameter of Tersoff potential
        self._BIGD = None    # Defines the D parameter of Tersoff potential
        self._RCUT = None    # Defines the cutoff parameter of the tersoff potential.  This parameter is in principle already defined by the values of  bigD and bigR. But it is necessary to define it when using the tersoff  in conjuction with other potentials (for the same atomic pair) in order to have the same consistent definition of RCUT for all potentials.
        self.name = "TERSOFF"
        self.keywords = [('_ATOMS', 'ATOMS'), ('_A', 'A'), ('_B', 'B'), ('_LAMBDA1', 'LAMBDA1'), ('_LAMBDA2', 'LAMBDA2'), ('_ALPHA', 'ALPHA'), ('_BETA', 'BETA'), ('_N', 'N'), ('_C', 'C'), ('_D', 'D'), ('_H', 'H'), ('_LAMBDA3', 'LAMBDA3'), ('_BIGR', 'BIGR'), ('_BIGD', 'BIGD'), ('_RCUT', 'RCUT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class pint1(printable):
    """The section that controls a path integral run"""
    def __init__(self):
        self._P = None    # Specify number beads to use
        self._PROC_PER_REPLICA = None    # Specify number of processors to use for each replica
        self._NUM_STEPS = None    # Number of steps (if MAX_STEP is not explicitly given the program will perform this number of steps)
        self._MAX_STEP = None    # Maximum step number (the program will stop if ITERATION >= MAX_STEP even if NUM_STEPS has not been reached)
        self._ITERATION = None    # Specify the iteration number from which it should be counted
        self._TEMP = None    # The temperature you want to simulate
        self._T_TOL = None    # threshold for the oscillations of the temperature excedeed which the temperature is rescaled. 0 means no rescaling.
        self._TEMP_TO = self._T_TOL
        self._DT = None    # timestep (might be subdivised in nrespa subtimesteps
        self._NRESPA = None    # number of respa steps for the bead for each md step
        self._TRANSFORMATION = None    # Specifies the coordinate transformation to use
        self._FIX_CENTROID_POS = None    # Propagate all DOF but the centroid - useful for equilibration of the non-centroid modes (activated only if TRANSFORMATION==NORMAL)
        self.NORMALMODE = normalmode1()
        self.STAGING = staging1()
        self.BEADS = beads1()
        self.NOSE = nose2()
        self.GLE = gle1()
        self.INIT = init1()
        self.HELIUM = helium1()
        self.PRINT = print13()
        self.name = "PINT"
        self.keywords = [('_P', 'P'), ('_PROC_PER_REPLICA', 'PROC_PER_REPLICA'), ('_NUM_STEPS', 'NUM_STEPS'), ('_MAX_STEP', 'MAX_STEP'), ('_ITERATION', 'ITERATION'), ('_TEMP', 'TEMP'), ('_T_TOL', 'T_TOL'), ('_TEMP_TO', 'TEMP_TO'), ('_DT', 'DT'), ('_NRESPA', 'NRESPA'), ('_TRANSFORMATION', 'TRANSFORMATION'), ('_FIX_CENTROID_POS', 'FIX_CENTROID_POS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('NORMALMODE', 'NORMALMODE'), ('STAGING', 'STAGING'), ('BEADS', 'BEADS'), ('NOSE', 'NOSE'), ('GLE', 'GLE'), ('INIT', 'INIT'), ('HELIUM', 'HELIUM'), ('PRINT', 'PRINT')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class geo_opt1(printable):
    """This section sets the environment of the geometry optimizer."""
    def __init__(self):
        self._TYPE = None    # Specify which kind of geometry optimization to perform
        self._OPTIMIZER = None    # Specify which method to use to perform a geometry optimization.
        self._MINIMIZER = self._OPTIMIZER
        self._MAX_ITER = None    # Specifies the maximum number of geometry optimization steps. One step might imply several force evaluations for the CG and LBFGS optimizers.
        self._MAX_DR = None    # Convergence criterium for the maximum geometry change between the current and the last optimizer iteration.
        self._MAX_FORCE = None    # Convergence criterium for the maximum force component of the current configuration.
        self._RMS_DR = None    # Convergence criterium for the root mean square (RMS) geometry change between the current and the last optimizer iteration.
        self._RMS_FORCE = None    # Convergence criterium for the root mean square (RMS) force of the current configuration.
        self._STEP_START_VAL = None    # The starting step value for the GEO_OPT module.
        self.LBFGS = lbfgs1()
        self.CG = cg1()
        self.BFGS = bfgs1()
        self.TRANSITION_STATE = transition_state1()
        self.listPRINT = []
        self.PRINT = print3()
        self.name = "GEO_OPT"
        self.keywords = [('_TYPE', 'TYPE'), ('_OPTIMIZER', 'OPTIMIZER'), ('_MINIMIZER', 'MINIMIZER'), ('_MAX_ITER', 'MAX_ITER'), ('_MAX_DR', 'MAX_DR'), ('_MAX_FORCE', 'MAX_FORCE'), ('_RMS_DR', 'RMS_DR'), ('_RMS_FORCE', 'RMS_FORCE'), ('_STEP_START_VAL', 'STEP_START_VAL')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('LBFGS', 'LBFGS'), ('CG', 'CG'), ('BFGS', 'BFGS'), ('TRANSITION_STATE', 'TRANSITION_STATE')]
        self.repeated_subsections = [('PRINT', 'print3')]

    def addPRINT(self):
        new_section = print3()
        self.listPRINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class perm2(printable):
    """Controls the output of the helium permutation state"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PERM"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class perm1(printable):
    """Permutation state used for restart"""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Specify particle index permutation for every helium atom
        self.name = "PERM"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class chi1(printable):
    """Information to initialize the Ad-Langevin thermostat DOF CHI"""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Specify an initial thermostat DOF CHI for Ad-Langevin thermostat.
        self.name = "CHI"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class xc1(printable):
    """parameters needed calculate the xc potential"""
    def __init__(self):
        self._DENSITY_CUTOFF = None    # The cutoff on the density used by the xc calculation
        self._GRADIENT_CUTOFF = None    # The cutoff on the gradient of the density used by the xc calculation
        self._DENSITY_SMOOTH_CUTOFF_RANGE = None    # Parameter for the smoothing procedure inxc calculation
        self._TAU_CUTOFF = None    # The cutoff on tau used by the xc calculation
        self._FUNCTIONAL_ROUTINE = None    # Select the code for xc calculation
        self.XC_GRID = xc_grid1()
        self.XC_FUNCTIONAL = xc_functional1()
        self.listHF = []
        self.HF = hf1()
        self.listWF_CORRELATION = []
        self.WF_CORRELATION = wf_correlation1()
        self.ADIABATIC_RESCALING = adiabatic_rescaling1()
        self.XC_POTENTIAL = xc_potential1()
        self.VDW_POTENTIAL = vdw_potential1()
        self.name = "XC"
        self.keywords = [('_DENSITY_CUTOFF', 'DENSITY_CUTOFF'), ('_GRADIENT_CUTOFF', 'GRADIENT_CUTOFF'), ('_DENSITY_SMOOTH_CUTOFF_RANGE', 'DENSITY_SMOOTH_CUTOFF_RANGE'), ('_TAU_CUTOFF', 'TAU_CUTOFF'), ('_FUNCTIONAL_ROUTINE', 'FUNCTIONAL_ROUTINE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('XC_GRID', 'XC_GRID'), ('XC_FUNCTIONAL', 'XC_FUNCTIONAL'), ('ADIABATIC_RESCALING', 'ADIABATIC_RESCALING'), ('XC_POTENTIAL', 'XC_POTENTIAL'), ('VDW_POTENTIAL', 'VDW_POTENTIAL')]
        self.repeated_subsections = [('HF', 'hf1'), ('WF_CORRELATION', 'wf_correlation1')]

    def addHF(self):
        new_section = hf1()
        self.listHF.append(new_section)
        return new_section

    def addWF_CORRELATION(self):
        new_section = wf_correlation1()
        self.listWF_CORRELATION.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class coulomb1(printable):
    """Setup parameters for the evaluation of the COULOMB term in SE calculations."""
    def __init__(self):
        self._CUTOFF = None    # Atomic Cutoff Radius Cutoff for the evaluation of the  Coulomb integrals. For non-periodic calculation the default value is exactly the full cell dimension, in order to evaluate all pair interactions. Instead, for periodic calculations the default numerical value is used.
        self._RC_TAPER = None    # Atomic Cutoff Radius Cutoff for Tapering Coulomb integrals. If not specified it assumes the same value specified for the CUTOFF.
        self._RC_RANGE = None    # Range of cutoff switch function (tapering): 0.5*(1-TANH((r-r0)/RC_RANGE)), where r0=2.0*RC_TAPER-20.0*RC_RANGE.
        self.name = "COULOMB"
        self.keywords = [('_CUTOFF', 'CUTOFF'), ('_RC_TAPER', 'RC_TAPER'), ('_RC_RANGE', 'RC_RANGE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class ewald_info2(printable):
    """Controls the printing of Ewald energy components during the evaluation of the electrostatics."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "EWALD_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class ewald_info1(printable):
    """Activates the printing of the information for Ewald multipole summation in periodic SE."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "EWALD_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class memory1(printable):
    """Sets up memory parameters for the storage of the integrals"""
    def __init__(self):
        self._EPS_STORAGE = None    # Storage threshold for compression is EPS_STORAGE
        self._MAX_MEMORY = None    # Defines the maximum amount of memory [MB] used to store precomputed (possibly compressed) two-electron two-center integrals
        self._COMPRESS = None    # Enables the compression of the integrals in memory.
        self.name = "MEMORY"
        self.keywords = [('_EPS_STORAGE', 'EPS_STORAGE'), ('_MAX_MEMORY', 'MAX_MEMORY'), ('_COMPRESS', 'COMPRESS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class memory2(printable):
    """Sets up memory parameters for the storage of the ERI's if requested"""
    def __init__(self):
        self._EPS_STORAGE_SCALING = None    # Scaling factor to scale eps_schwarz. Storage threshold for compression will be EPS_SCHWARZ*EPS_STORAGE_SCALING.
        self._EPS_STORAGE = self._EPS_STORAGE_SCALING
        self._MAX_MEMORY = None    # Defines the maximum amount of memory [MB] to be consumed by the full HFX module. All temporary buffers and helper arrays are subtracted from this number. What remains will be used for storage of integrals. NOTE: This number is assumed to represent the memory available to one MPI process. When running a threaded version, cp2k automatically takes care of distributing the memory among all involved sub-processes.
        self._STORAGE_LOCATION = None    # Loaction where ERI's are stored if MAX_DISK_SPACE /=0 Expects a path to a directory.
        self._MAX_DISK_SPACE = None    # Defines the maximum amount of disk space [MB] used to store precomputed compressed four-center integrals. If 0, nothing is stored to disk
        self._TREAT_FORCES_IN_CORE = None    # Determines whether the derivative ERI's should be stored to RAM or not. Only meaningful when performing Ehrenfest MD. Memory usage is defined via MAX_MEMORY, i.e. the memory is shared wit the energy ERI's.
        self.name = "MEMORY"
        self.keywords = [('_EPS_STORAGE_SCALING', 'EPS_STORAGE_SCALING'), ('_EPS_STORAGE', 'EPS_STORAGE'), ('_MAX_MEMORY', 'MAX_MEMORY'), ('_STORAGE_LOCATION', 'STORAGE_LOCATION'), ('_MAX_DISK_SPACE', 'MAX_DISK_SPACE'), ('_TREAT_FORCES_IN_CORE', 'TREAT_FORCES_IN_CORE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class et_coupling1(printable):
    """specifies the two constraints/restraints for extracting ET coupling elements"""
    def __init__(self):
        self._TYPE_OF_CONSTRAINT = None    # Specifies the type of constraint
        self.DDAPC_RESTRAINT_A = ddapc_restraint_a1()
        self.DDAPC_RESTRAINT_B = ddapc_restraint_b1()
        self.BECKE_RESTRAINT_A = becke_restraint_a1()
        self.BECKE_RESTRAINT_B = becke_restraint_b1()
        self.PROGRAM_RUN_INFO = program_run_info12()
        self.name = "ET_COUPLING"
        self.keywords = [('_TYPE_OF_CONSTRAINT', 'TYPE_OF_CONSTRAINT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('DDAPC_RESTRAINT_A', 'DDAPC_RESTRAINT_A'), ('DDAPC_RESTRAINT_B', 'DDAPC_RESTRAINT_B'), ('BECKE_RESTRAINT_A', 'BECKE_RESTRAINT_A'), ('BECKE_RESTRAINT_B', 'BECKE_RESTRAINT_B'), ('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class torsion3(printable):
    """Section to define the torsion as a collective variables."""
    def __init__(self):
        self._ATOMS = None    # Specifies the indexes of atoms/points defining the torsion.
        self._POINTS = self._ATOMS
        self.listPOINT = []
        self.POINT = point1()
        self.name = "TORSION"
        self.keywords = [('_ATOMS', 'ATOMS'), ('_POINTS', 'POINTS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('POINT', 'point1')]

    def addPOINT(self):
        new_section = point1()
        self.listPOINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class becke_restraint_a1(printable):
    """Use DDAPC charges in a restraint (check code for details), section can be repeated, but only one constraint is possible at the moment."""
    def __init__(self):
        self._STRENGTH = None    # force constant of the restraint
        self._TYPE_OF_DENSITY = None    # Specifies the type of density used for the fitting
        self._TARGET = None    # target value of the restraint
        self._ATOMS = None    # Specifies the list of atoms that is summed in the restraint
        self._COEFF = None    # Defines the the coefficient of the atom in the atom list (default is one), currently DDAPC only
        self._FUNCTIONAL_FORM = None    # Specifies the functional form of the term added
        self.PROGRAM_RUN_INFO = program_run_info12()
        self.name = "BECKE_RESTRAINT_A"
        self.keywords = [('_STRENGTH', 'STRENGTH'), ('_TYPE_OF_DENSITY', 'TYPE_OF_DENSITY'), ('_TARGET', 'TARGET'), ('_ATOMS', 'ATOMS'), ('_COEFF', 'COEFF'), ('_FUNCTIONAL_FORM', 'FUNCTIONAL_FORM')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class nablavks_cubes1(printable):
    """Controls the printing of the components of nabla v_ks"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._STRIDE = None    # The stride (X,Y,Z) used to write the cube file (larger values result in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1 number valid for all components.
        self._APPEND = None    # append the cube files when they already exist
        self.EACH = each1()
        self.name = "NABLAVKS_CUBES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_STRIDE', 'STRIDE'), ('_APPEND', 'APPEND')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class map1(printable):
    """Activating this print key will print once a file with the values of the FUNCTION on a grid of COLVAR values in a specified range. GRID_SPACING and RANGE for every COLVAR has to be specified again in the same order as they are in the input."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.list_RANGE = []
        self._RANGE = None
    # The range of of the grid of the COLVAR.
        self.list_GRID_SPACING = []
        self._GRID_SPACING = None
    # Distance between two gridpoints for the grid on the COLVAR
        self.EACH = each1()
        self.name = "MAP"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = [('_RANGE', 'RANGE'), ('_GRID_SPACING', 'GRID_SPACING')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def add_RANGE(self, value):
        self.list_RANGE.append(value)

    def add_GRID_SPACING(self, value):
        self.list_GRID_SPACING.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class detailed_energy1(printable):
    """Controls the printing of detailed energy information."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "DETAILED_ENERGY"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class pw921(printable):
    """Uses the PerdewWang correlation functional."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._SCALE = None    # Scaling of the energy functional
        self._PARAMETRIZATION = None    # Which one of parametrizations should be used
        self.name = "PW92"
        self.keywords = [('_SCALE', 'SCALE'), ('_PARAMETRIZATION', 'PARAMETRIZATION')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class ri_rpa1(printable):
    """Parameters influencing the RI RPA method"""
    def __init__(self):
        self._QUADRATURE_POINTS = None    # Number of quadrature points for the numerical integration in the RI-RPA method.
        self._RPA_NUM_QUAD_POINTS = self._QUADRATURE_POINTS
        self._SIZE_FREQ_INTEG_GROUP = None    # Group size for frequency integration, that is the number of processes involved in the computation of each integration point. SIZE_FREQ_INTEG_GROUP has to be a multiple of GROUP_SIZE in the WF_CORRELATION section. The default (-1) is automatic.
        self._RPA_GROUP_SIZE = self._SIZE_FREQ_INTEG_GROUP
        self.listHF = []
        self.HF = hf1()
        self.name = "RI_RPA"
        self.keywords = [('_QUADRATURE_POINTS', 'QUADRATURE_POINTS'), ('_RPA_NUM_QUAD_POINTS', 'RPA_NUM_QUAD_POINTS'), ('_SIZE_FREQ_INTEG_GROUP', 'SIZE_FREQ_INTEG_GROUP'), ('_RPA_GROUP_SIZE', 'RPA_GROUP_SIZE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('HF', 'hf1')]

    def addHF(self):
        new_section = hf1()
        self.listHF.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class spawned_hills_pos1(printable):
    """The position of the spawned hills during metadynamics.Used for RESTART."""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Specify the spawned hills
        self.name = "SPAWNED_HILLS_POS"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class response_function_cubes1(printable):
    """Controls the printing of the response functions (not working yet)."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._STRIDE = None    # The stride (X,Y,Z) used to write the cube file (larger values result in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1 number valid for all components (not working yet).
        self._CUBES_LU_BOUNDS = None    # The lower and upper index of the states to be printed as cube (not working yet).
        self._CUBES_LU = self._CUBES_LU_BOUNDS
        self.list_CUBES_LIST = []
        self._CUBES_LIST = None
    # Indexes of the states to be printed as cube filesThis keyword can be repeated several times(useful if you have to specify many indexes) (not working yet).
        self._APPEND = None    # append the cube files when they already exist
        self.EACH = each1()
        self.name = "RESPONSE_FUNCTION_CUBES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_STRIDE', 'STRIDE'), ('_CUBES_LU_BOUNDS', 'CUBES_LU_BOUNDS'), ('_CUBES_LU', 'CUBES_LU'), ('_APPEND', 'APPEND')]
        self.repeated_keywords = [('_CUBES_LIST', 'CUBES_LIST')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def add_CUBES_LIST(self, value):
        self.list_CUBES_LIST.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class response_function_cubes2(printable):
    """Controls the printing of the response functions"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._STRIDE = None    # The stride (X,Y,Z) used to write the cube file (larger values result in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1 number valid for all components.
        self._CUBES_LU_BOUNDS = None    # The lower and upper index of the states to be printed as cube
        self._CUBES_LU = self._CUBES_LU_BOUNDS
        self.list_CUBES_LIST = []
        self._CUBES_LIST = None
    # Indexes of the states to be printed as cube filesThis keyword can be repeated several times(useful if you have to specify many indexes).
        self._APPEND = None    # append the cube files when they already exist
        self.EACH = each1()
        self.name = "RESPONSE_FUNCTION_CUBES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_STRIDE', 'STRIDE'), ('_CUBES_LU_BOUNDS', 'CUBES_LU_BOUNDS'), ('_CUBES_LU', 'CUBES_LU'), ('_APPEND', 'APPEND')]
        self.repeated_keywords = [('_CUBES_LIST', 'CUBES_LIST')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def add_CUBES_LIST(self, value):
        self.list_CUBES_LIST.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class cp_fm_gemm1(printable):
    """Benchmark and test the cp_fm_gemm routines by multiplying C=A*B"""
    def __init__(self):
        self._N_LOOP = None    # Number of cp_fm_gemm operations being timed (useful for small matrices).
        self._K = None    # Dimension 1 of C
        self._M = None    # Inner dimension M
        self._N = None    # Dimension 2 of C
        self._NROW_BLOCK = None    # block_size for rows
        self._NCOL_BLOCK = None    # block_size for cols
        self._ROW_MAJOR = None    # Use a row major blacs grid
        self._FORCE_BLOCKSIZE = None    # Forces the blocksize, even if this implies that a few processes might have no data
        self._GRID_2D = None    # Explicitly set the blacs 2D processor layout. If the product differs from the number of MPI ranks, it is ignored and a default nearly square layout is used.
        self._TRANSA = None    # Transpose matrix A
        self._TRANSB = None    # Transpose matrix B
        self.name = "CP_FM_GEMM"
        self.keywords = [('_N_LOOP', 'N_LOOP'), ('_K', 'K'), ('_M', 'M'), ('_N', 'N'), ('_NROW_BLOCK', 'NROW_BLOCK'), ('_NCOL_BLOCK', 'NCOL_BLOCK'), ('_ROW_MAJOR', 'ROW_MAJOR'), ('_FORCE_BLOCKSIZE', 'FORCE_BLOCKSIZE'), ('_GRID_2D', 'GRID_2D'), ('_TRANSA', 'TRANSA'), ('_TRANSB', 'TRANSB')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class efield1(printable):
    """parameters for finite, time dependent, nonperiodic electric fields"""
    def __init__(self):
        self._INTENSITY = None    # Intensity of the electric field in W*cm-2 which corresponds to a maximal amplitude in a.u. of sqrt(I/(3.50944*10^16))
        self._POLARISATION = None    # Polarisation vector of electric field
        self._WAVELENGTH = None    # Wavelength of efield field
        self._PHASE = None    # phase offset of the cosine given in multiples of pi
        self._ENVELOP = None    # Shape of the efield pulse
        self.listCONSTANT_ENV = []
        self.CONSTANT_ENV = constant_env1()
        self.listRAMP_ENV = []
        self.RAMP_ENV = ramp_env1()
        self.listGAUSSIAN_ENV = []
        self.GAUSSIAN_ENV = gaussian_env1()
        self.name = "EFIELD"
        self.keywords = [('_INTENSITY', 'INTENSITY'), ('_POLARISATION', 'POLARISATION'), ('_WAVELENGTH', 'WAVELENGTH'), ('_PHASE', 'PHASE'), ('_ENVELOP', 'ENVELOP')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('CONSTANT_ENV', 'constant_env1'), ('RAMP_ENV', 'ramp_env1'), ('GAUSSIAN_ENV', 'gaussian_env1')]

    def addCONSTANT_ENV(self):
        new_section = constant_env1()
        self.listCONSTANT_ENV.append(new_section)
        return new_section

    def addRAMP_ENV(self):
        new_section = ramp_env1()
        self.listRAMP_ENV.append(new_section)
        return new_section

    def addGAUSSIAN_ENV(self):
        new_section = gaussian_env1()
        self.listGAUSSIAN_ENV.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class wall1(printable):
    """Controls the activation of walls on COLVAR during a metadynamic run."""
    def __init__(self):
        self._TYPE = None    # Specify the type of wall
        self._POSITION = None    # Specify the value of the colvar for the wall position
        self.REFLECTIVE = reflective1()
        self.QUADRATIC = quadratic1()
        self.QUARTIC = quartic1()
        self.GAUSSIAN = gaussian1()
        self.name = "WALL"
        self.keywords = [('_TYPE', 'TYPE'), ('_POSITION', 'POSITION')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('REFLECTIVE', 'REFLECTIVE'), ('QUADRATIC', 'QUADRATIC'), ('QUARTIC', 'QUARTIC'), ('GAUSSIAN', 'GAUSSIAN')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class qmmm_matrix1(printable):
    """Controls the printing of the QMMM 1 electron Hamiltonian Matrix for methods like semiempirical and DFTB"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "QMMM_MATRIX"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class init1(printable):
    """Controls the initialization if the beads are not present"""
    def __init__(self):
        self._LEVY_POS_SAMPLE = None    # Sample bead positions assuming free particle behavior (performs a Levy random walk of length P around the classical position of each atom at the physical temperature defined in PINT%TEMP)
        self._LEVY_CORRELATED = None    # Use the same Levy path for all atoms, though with mass-dependent variances (might help at very low T)
        self._LEVY_TEMP_FACTOR = None    # Multiplicative correction factor for the temperature at which the Levy walk is performed (correction is due to the interactions that modify the spread of a free particle)
        self._LEVY_SEED = None    # Initial seed for the (pseudo)random number generator that controls Levy walk for bead positions.
        self._RANDOMIZE_POS = None    # add gaussian noise to the positions of the beads
        self._CENTROID_SPEED = None    # adds random velocity component to the centroid modes (useful to correct for the averaging out of the speed of various beads)
        self._VELOCITY_QUENCH = None    # set the initial velocities to zero
        self._VELOCITY_SCALE = None    # scale initial velocities to the temperature given in MOTION%PINT%TEMP
        self.name = "INIT"
        self.keywords = [('_LEVY_POS_SAMPLE', 'LEVY_POS_SAMPLE'), ('_LEVY_CORRELATED', 'LEVY_CORRELATED'), ('_LEVY_TEMP_FACTOR', 'LEVY_TEMP_FACTOR'), ('_LEVY_SEED', 'LEVY_SEED'), ('_RANDOMIZE_POS', 'RANDOMIZE_POS'), ('_CENTROID_SPEED', 'CENTROID_SPEED'), ('_VELOCITY_QUENCH', 'VELOCITY_QUENCH'), ('_VELOCITY_SCALE', 'VELOCITY_SCALE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class current_cubes1(printable):
    """Controls the printing of the induced current density (not working yet)."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._STRIDE = None    # The stride (X,Y,Z) used to write the cube file (larger values result in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1 number valid for all components (not working yet).
        self._APPEND = None    # append the cube files when they already exist
        self.EACH = each1()
        self.name = "CURRENT_CUBES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_STRIDE', 'STRIDE'), ('_APPEND', 'APPEND')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class xc_grid1(printable):
    """The xc parameters used when calculating the xc on the grid"""
    def __init__(self):
        self._XC_SMOOTH_RHO = None    # The density smoothing used for the xc calculation
        self._XC_DERIV = None    # The method used to compute the derivatives
        self._USE_FINER_GRID = None    # Uses a finer grid only to calculate the xc
        self.name = "XC_GRID"
        self.keywords = [('_XC_SMOOTH_RHO', 'XC_SMOOTH_RHO'), ('_XC_DERIV', 'XC_DERIV'), ('_USE_FINER_GRID', 'USE_FINER_GRID')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class iter_info1(printable):
    """Activates the printing of iteration info during the self-consistent calculation of a polarizable forcefield."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "ITER_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class shell_energy1(printable):
    """Controls the output of the shell-energy file (only if shell-model)"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "SHELL_ENERGY"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class tot_density_cube1(printable):
    """Controls printing of cube files with the total density (electrons+atomic core). Note that the value of the total density is positive where the electron density dominates and negative where the core is."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._STRIDE = None    # The stride (X,Y,Z) used to write the cube file (larger values result in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1 number valid for all components.
        self._APPEND = None    # append the cube files when they already exist
        self.EACH = each1()
        self.name = "TOT_DENSITY_CUBE"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_STRIDE', 'STRIDE'), ('_APPEND', 'APPEND')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class spline1(printable):
    """specifies parameters to set up the splines used in the nonboned interactions (both pair body potential and many body potential)"""
    def __init__(self):
        self._R0_NB = None    # Specify the minimum value of the distance interval  that brackets the value of emax_spline.
        self._RCUT_NB = None    # Cutoff radius for nonbonded interactions. This value overrides  the value specified in the potential definition and is global for all potentials.
        self._EMAX_SPLINE = None    # Specify the maximum value of the potential up to which splines will be constructed
        self._EMAX_ACCURACY = None    # Specify the maximum value of energy used to check the accuracy requested through EPS_SPLINE. Energy values larger than EMAX_ACCURACY generally do not  satisfy the requested accuracy
        self._EPS_SPLINE = None    # Specify the threshold for the choice of the number of points used in the splines (comparing the splined value with the  analytically evaluated one)
        self._NPOINTS = None    # Override the default search for an accurate spline by specifying a fixed number of spline points.
        self._UNIQUE_SPLINE = None    # For few potentials (Lennard-Jones) one global optimal spline is generated instead of different optimal splines for each kind of potential
        self.name = "SPLINE"
        self.keywords = [('_R0_NB', 'R0_NB'), ('_RCUT_NB', 'RCUT_NB'), ('_EMAX_SPLINE', 'EMAX_SPLINE'), ('_EMAX_ACCURACY', 'EMAX_ACCURACY'), ('_EPS_SPLINE', 'EPS_SPLINE'), ('_NPOINTS', 'NPOINTS'), ('_UNIQUE_SPLINE', 'UNIQUE_SPLINE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class velocity2(printable):
    """The velocities for NOSE HOOVER used for restart"""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Specify velocities of the system
        self.name = "VELOCITY"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class xwpbe1(printable):
    """Uses the short range PBE functional"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._SCALE_X = None    # scales the exchange part of the functional
        self._SCALE_X0 = None    # scales the exchange part of the original hole PBE-functional
        self._OMEGA = None    # screening parameter
        self.name = "XWPBE"
        self.keywords = [('_SCALE_X', 'SCALE_X'), ('_SCALE_X0', 'SCALE_X0'), ('_OMEGA', 'OMEGA')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class velocity1(printable):
    """The velocities for BAROSTAT used for restart"""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Specify velocities of the system
        self.name = "VELOCITY"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class velocity6(printable):
    """The velocities for simple systems or the centroid mode in PI runs, xyz format by default"""
    def __init__(self):
        self._PINT_UNIT = None    # Specify the units of measurement for the velocities (currently works only for the path integral code). All available CP2K units can be used.
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # The atoms velocities in xyz format. The same order as the atom's order is assumed.
        self.name = "VELOCITY"
        self.keywords = [('_PINT_UNIT', 'PINT_UNIT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class dimer_vector1(printable):
    """Specifies the initial dimer vector (used frequently to restart DIMER calculations). If not provided the starting orientation of the dimer is chosen randomly."""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Specify on each line the components of the dimer vector.
        self.name = "DIMER_VECTOR"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class velocity4(printable):
    """The velocities for NOSE used for restart"""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Specify velocities of the system
        self.name = "VELOCITY"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class velocity5(printable):
    """The velocities for BAND used for restart"""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Specify velocities of the system
        self.name = "VELOCITY"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class response_basis1(printable):
    """Calculate a response basis set contraction scheme"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._DELTA_CHARGE = None    # Variation of charge used in finite difference calculation
        self._DERIVATIVES = None    # Number of wavefunction derivatives to calculate
        self.EACH = each1()
        self.name = "RESPONSE_BASIS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_DELTA_CHARGE', 'DELTA_CHARGE'), ('_DERIVATIVES', 'DERIVATIVES')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class nonbonded1(printable):
    """This section specifies the input parameters for NON-BONDED interactions."""
    def __init__(self):
        self.listLENNARD_JONES = []
        self.LENNARD_JONES = lennardhypminjones1()
        self.listWILLIAMS = []
        self.WILLIAMS = williams1()
        self.listEAM = []
        self.EAM = eam1()
        self.listGOODWIN = []
        self.GOODWIN = goodwin1()
        self.listIPBV = []
        self.IPBV = ipbv1()
        self.listBMHFT = []
        self.BMHFT = bmhft1()
        self.listBMHFTD = []
        self.BMHFTD = bmhftd1()
        self.listBUCK4RANGES = []
        self.BUCK4RANGES = buck4ranges1()
        self.listBUCKMORSE = []
        self.BUCKMORSE = buckmorse1()
        self.listGENPOT = []
        self.GENPOT = genpot1()
        self.listTERSOFF = []
        self.TERSOFF = tersoff1()
        self.listSIEPMANN = []
        self.SIEPMANN = siepmann1()
        self.name = "NONBONDED"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('LENNARD_JONES', 'lennardhypminjones1'), ('WILLIAMS', 'williams1'), ('EAM', 'eam1'), ('GOODWIN', 'goodwin1'), ('IPBV', 'ipbv1'), ('BMHFT', 'bmhft1'), ('BMHFTD', 'bmhftd1'), ('BUCK4RANGES', 'buck4ranges1'), ('BUCKMORSE', 'buckmorse1'), ('GENPOT', 'genpot1'), ('TERSOFF', 'tersoff1'), ('SIEPMANN', 'siepmann1')]

    def addLENNARD_JONES(self):
        new_section = lennardhypminjones1()
        self.listLENNARD_JONES.append(new_section)
        return new_section

    def addWILLIAMS(self):
        new_section = williams1()
        self.listWILLIAMS.append(new_section)
        return new_section

    def addEAM(self):
        new_section = eam1()
        self.listEAM.append(new_section)
        return new_section

    def addGOODWIN(self):
        new_section = goodwin1()
        self.listGOODWIN.append(new_section)
        return new_section

    def addIPBV(self):
        new_section = ipbv1()
        self.listIPBV.append(new_section)
        return new_section

    def addBMHFT(self):
        new_section = bmhft1()
        self.listBMHFT.append(new_section)
        return new_section

    def addBMHFTD(self):
        new_section = bmhftd1()
        self.listBMHFTD.append(new_section)
        return new_section

    def addBUCK4RANGES(self):
        new_section = buck4ranges1()
        self.listBUCK4RANGES.append(new_section)
        return new_section

    def addBUCKMORSE(self):
        new_section = buckmorse1()
        self.listBUCKMORSE.append(new_section)
        return new_section

    def addGENPOT(self):
        new_section = genpot1()
        self.listGENPOT.append(new_section)
        return new_section

    def addTERSOFF(self):
        new_section = tersoff1()
        self.listTERSOFF.append(new_section)
        return new_section

    def addSIEPMANN(self):
        new_section = siepmann1()
        self.listSIEPMANN.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class center1(printable):
    """Defines the center of the sphere."""
    def __init__(self):
        self._XYZ = None    # Coordinates of the center of the sphere
        self._ATOM_LIST = None    # Defines a list of atoms to define the center of the sphere
        self._WEIGHT = None    # Defines the weight used to define the center of the sphere (if ATOM_LIST is provided)
        self._FIXED = None    # Specify if the center of the sphere should be fixed or allowed to move
        self.name = "CENTER"
        self.keywords = [('_XYZ', 'XYZ'), ('_ATOM_LIST', 'ATOM_LIST'), ('_WEIGHT', 'WEIGHT'), ('_FIXED', 'FIXED')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class constraint1(printable):
    """Section specifying information regarding how to impose constraints on the system."""
    def __init__(self):
        self._SHAKE_TOLERANCE = None    # Set the tolerance for the shake/rattle constraint algorithm.
        self._SHAKE_TOL = self._SHAKE_TOLERANCE
        self._SHAKE = self._SHAKE_TOLERANCE
        self._ROLL_TOLERANCE = None    # Set the tolerance for the roll constraint algorithm.
        self._ROLL_TOL = self._ROLL_TOLERANCE
        self._ROLL = self._ROLL_TOLERANCE
        self._CONSTRAINT_INIT = None    # Apply constraints to the initial position and velocities. Default is to apply constraints only after the first MD step.
        self.HBONDS = hbonds1()
        self.listG3X3 = []
        self.G3X3 = g3x31()
        self.listG4X6 = []
        self.G4X6 = g4x61()
        self.listVIRTUAL_SITE = []
        self.VIRTUAL_SITE = virtual_site1()
        self.listCOLLECTIVE = []
        self.COLLECTIVE = collective1()
        self.listFIXED_ATOMS = []
        self.FIXED_ATOMS = fixed_atoms1()
        self.FIX_ATOM_RESTART = fix_atom_restart1()
        self.COLVAR_RESTART = colvar_restart1()
        self.CONSTRAINT_INFO = constraint_info1()
        self.LAGRANGE_MULTIPLIERS = lagrange_multipliers1()
        self.name = "CONSTRAINT"
        self.keywords = [('_SHAKE_TOLERANCE', 'SHAKE_TOLERANCE'), ('_SHAKE_TOL', 'SHAKE_TOL'), ('_SHAKE', 'SHAKE'), ('_ROLL_TOLERANCE', 'ROLL_TOLERANCE'), ('_ROLL_TOL', 'ROLL_TOL'), ('_ROLL', 'ROLL'), ('_CONSTRAINT_INIT', 'CONSTRAINT_INIT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('HBONDS', 'HBONDS'), ('FIX_ATOM_RESTART', 'FIX_ATOM_RESTART'), ('COLVAR_RESTART', 'COLVAR_RESTART'), ('CONSTRAINT_INFO', 'CONSTRAINT_INFO'), ('LAGRANGE_MULTIPLIERS', 'LAGRANGE_MULTIPLIERS')]
        self.repeated_subsections = [('G3X3', 'g3x31'), ('G4X6', 'g4x61'), ('VIRTUAL_SITE', 'virtual_site1'), ('COLLECTIVE', 'collective1'), ('FIXED_ATOMS', 'fixed_atoms1')]

    def addG3X3(self):
        new_section = g3x31()
        self.listG3X3.append(new_section)
        return new_section

    def addG4X6(self):
        new_section = g4x61()
        self.listG4X6.append(new_section)
        return new_section

    def addVIRTUAL_SITE(self):
        new_section = virtual_site1()
        self.listVIRTUAL_SITE.append(new_section)
        return new_section

    def addCOLLECTIVE(self):
        new_section = collective1()
        self.listCOLLECTIVE.append(new_section)
        return new_section

    def addFIXED_ATOMS(self):
        new_section = fixed_atoms1()
        self.listFIXED_ATOMS.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class temperature_colvar1(printable):
    """Controls the printing of the temperature of COLVARS in an extended lagrangian scheme."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "TEMPERATURE_COLVAR"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class molecules1(printable):
    """controls the output of information on the molecules"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "MOLECULES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class multiple_walkers1(printable):
    """Enables and configures the metadynamics using multiple walkers."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._WALKER_ID = None    # Sets the walker ID for the local metadynamics run.
        self._NUMBER_OF_WALKERS = None    # Sets the total number of walkers in the metadynamic run.
        self._WALKER_COMM_FREQUENCY = None    # Sets the frequency (in unit of spawned hills) for the communication between the several walkers, in order to update the local list of hills with the ones coming from the other walkers
        self._WALKERS_STATUS = None    # Stores the status of the several walkers in the local run.
        self.WALKERS_FILE_NAME = walkers_file_name1()
        self.name = "MULTIPLE_WALKERS"
        self.keywords = [('_WALKER_ID', 'WALKER_ID'), ('_NUMBER_OF_WALKERS', 'NUMBER_OF_WALKERS'), ('_WALKER_COMM_FREQUENCY', 'WALKER_COMM_FREQUENCY'), ('_WALKERS_STATUS', 'WALKERS_STATUS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('WALKERS_FILE_NAME', 'WALKERS_FILE_NAME')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class coefficients1(printable):
    """Controls the printing of coefficients during an MD run."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "COEFFICIENTS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class nonbonded2(printable):
    """Specify information on the QM/MM non-bonded forcefield"""
    def __init__(self):
        self.listLENNARD_JONES = []
        self.LENNARD_JONES = lennardhypminjones1()
        self.listWILLIAMS = []
        self.WILLIAMS = williams1()
        self.listGOODWIN = []
        self.GOODWIN = goodwin1()
        self.listGENPOT = []
        self.GENPOT = genpot1()
        self.name = "NONBONDED"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('LENNARD_JONES', 'lennardhypminjones1'), ('WILLIAMS', 'williams1'), ('GOODWIN', 'goodwin1'), ('GENPOT', 'genpot1')]

    def addLENNARD_JONES(self):
        new_section = lennardhypminjones1()
        self.listLENNARD_JONES.append(new_section)
        return new_section

    def addWILLIAMS(self):
        new_section = williams1()
        self.listWILLIAMS.append(new_section)
        return new_section

    def addGOODWIN(self):
        new_section = goodwin1()
        self.listGOODWIN.append(new_section)
        return new_section

    def addGENPOT(self):
        new_section = genpot1()
        self.listGENPOT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class gapw1(printable):
    """Controls the printing of some gapw related information (debug)."""
    def __init__(self):
        self.PROJECTORS = projectors1()
        self.RHO0_INFORMATION = rho0_information1()
        self.name = "GAPW"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PROJECTORS', 'PROJECTORS'), ('RHO0_INFORMATION', 'RHO0_INFORMATION')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class history1(printable):
    """writes a history of the function value and parameters"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "HISTORY"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class motion1(printable):
    """This section defines a set of tool connected with the motion of the nuclei."""
    def __init__(self):
        self.GEO_OPT = geo_opt1()
        self.CELL_OPT = cell_opt1()
        self.SHELL_OPT = shell_opt1()
        self.MD = md1()
        self.FREE_ENERGY = free_energy1()
        self.CONSTRAINT = constraint1()
        self.FLEXIBLE_PARTITIONING = flexible_partitioning1()
        self.MC = mc1()
        self.PINT = pint1()
        self.BAND = band1()
        self.listPRINT = []
        self.PRINT = print14()
        self.name = "MOTION"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('GEO_OPT', 'GEO_OPT'), ('CELL_OPT', 'CELL_OPT'), ('SHELL_OPT', 'SHELL_OPT'), ('MD', 'MD'), ('FREE_ENERGY', 'FREE_ENERGY'), ('CONSTRAINT', 'CONSTRAINT'), ('FLEXIBLE_PARTITIONING', 'FLEXIBLE_PARTITIONING'), ('MC', 'MC'), ('PINT', 'PINT'), ('BAND', 'BAND')]
        self.repeated_subsections = [('PRINT', 'print14')]

    def addPRINT(self):
        new_section = print14()
        self.listPRINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class hills1(printable):
    """Controls the printing of HILLS summary information during metadynamics. The file contains: instantaneous colvar value, width of  the spawned gaussian and height of the gaussian. According the value of  the EACH keyword this file may not be synchronized with the COLVAR file."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "HILLS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class rs_grid1(printable):
    """Set options that influence how the realspace grids are being distributed in parallel runs."""
    def __init__(self):
        self._DISTRIBUTION_TYPE = None    # Parallelization strategy.
        self._DISTRIBUTION_LAYOUT = None    # Specifies the number of slices in the x, y and z directions.-1 specifies that any number of slices is OK.If a given distribution can not be satisfied, a replicated grid will result.Also see LOCK_DISTRIBUTION.
        self._MAX_DISTRIBUTED_LEVEL = None    # If the multigrid-level of a grid is larger than the parameter, it will not be distributed in the automatic scheme.
        self._LOCK_DISTRIBUTION = None    # Expert use only, only basic QS deals correctly with a non-default value.If the distribution is locked, a grid will have the same distribution asthe next finer multigrid (provided it is distributed).If unlocked, all grids can be distributed freely.
        self._MEMORY_FACTOR = None    # A grid will only be distributed if the memory usage for that grid (including halo) is smaller than a replicated grid by this parameter.
        self._HALO_REDUCTION_FACTOR = None    # Can be used to reduce the halo of the distributed grid (experimental features).
        self.name = "RS_GRID"
        self.keywords = [('_DISTRIBUTION_TYPE', 'DISTRIBUTION_TYPE'), ('_DISTRIBUTION_LAYOUT', 'DISTRIBUTION_LAYOUT'), ('_MAX_DISTRIBUTED_LEVEL', 'MAX_DISTRIBUTED_LEVEL'), ('_LOCK_DISTRIBUTION', 'LOCK_DISTRIBUTION'), ('_MEMORY_FACTOR', 'MEMORY_FACTOR'), ('_HALO_REDUCTION_FACTOR', 'HALO_REDUCTION_FACTOR')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class ri_laplace1(printable):
    """Parameters influencing the RI-SOS-MP2-Laplace method"""
    def __init__(self):
        self._QUADRATURE_POINTS = None    # Number of quadrature points for the numerical integration in the RI-SOS-MP2-Laplace method.
        self._LAPLACE_NUM_QUAD_POINTS = self._QUADRATURE_POINTS
        self._SIZE_INTEG_GROUP = None    # Group size for the integration in the Laplace method, that is the number of processes involved in the computation of each integration point. SIZE_INTEG_GROUP has to be a multiple of GROUP_SIZE in the WF_CORRELATION section. The default (-1) is automatic.
        self._LAPLACE_GROUP_SIZE = self._SIZE_INTEG_GROUP
        self.name = "RI_LAPLACE"
        self.keywords = [('_QUADRATURE_POINTS', 'QUADRATURE_POINTS'), ('_LAPLACE_NUM_QUAD_POINTS', 'LAPLACE_NUM_QUAD_POINTS'), ('_SIZE_INTEG_GROUP', 'SIZE_INTEG_GROUP'), ('_LAPLACE_GROUP_SIZE', 'LAPLACE_GROUP_SIZE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class subsys1(printable):
    """a subsystem: coordinates, topology, molecules and cell"""
    def __init__(self):
        self.RNG_INIT = rng_init1()
        self.CELL = cell3()
        self.COORD = coord6()
        self.VELOCITY = velocity6()
        self.listKIND = []
        self.KIND = kind1()
        self.TOPOLOGY = topology1()
        self.listCOLVAR = []
        self.COLVAR = colvar3()
        self.MULTIPOLES = multipoles2()
        self.SHELL_COORD = shell_coord1()
        self.SHELL_VELOCITY = shell_velocity1()
        self.CORE_COORD = core_coord1()
        self.CORE_VELOCITY = core_velocity1()
        self.PRINT = print34()
        self.name = "SUBSYS"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('RNG_INIT', 'RNG_INIT'), ('CELL', 'CELL'), ('COORD', 'COORD'), ('VELOCITY', 'VELOCITY'), ('TOPOLOGY', 'TOPOLOGY'), ('MULTIPOLES', 'MULTIPOLES'), ('SHELL_COORD', 'SHELL_COORD'), ('SHELL_VELOCITY', 'SHELL_VELOCITY'), ('CORE_COORD', 'CORE_COORD'), ('CORE_VELOCITY', 'CORE_VELOCITY'), ('PRINT', 'PRINT')]
        self.repeated_subsections = [('KIND', 'kind1'), ('COLVAR', 'colvar3')]

    def addKIND(self):
        new_section = kind1()
        self.listKIND.append(new_section)
        return new_section

    def addCOLVAR(self):
        new_section = colvar3()
        self.listCOLVAR.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class reflective1(printable):
    """Parameters controlling the reflective wall"""
    def __init__(self):
        self._DIRECTION = None    # Specify the direction of the wall.
        self.name = "REFLECTIVE"
        self.keywords = [('_DIRECTION', 'DIRECTION')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class qmmm_link_info1(printable):
    """Print all information on QM/MM links"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "QMMM_LINK_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class bfgs1(printable):
    """Provides parameters to tune the BFGS optimization"""
    def __init__(self):
        self._TRUST_RADIUS = None    # Trust radius used in BFGS. Previously set to 0.1. Large values can lead to instabilities
        self._USE_MODEL_HESSIAN = None    # Uses a model Hessian as initial guess instead of a unit matrix. Should lead in general to improved convergence might be switched off for exotic cases
        self._USE_RAT_FUN_OPT = None    # Includes a rational function optimization to determine the step. Previously default but did not improve convergence in many cases
        self._RESTART_HESSIAN = None    # Controls the reading of the initial Hessian from file.
        self._RESTART_FILE_NAME = None    # Specifies the name of the file used to read the initial Hessian.
        self.RESTART = restart1()
        self.name = "BFGS"
        self.keywords = [('_TRUST_RADIUS', 'TRUST_RADIUS'), ('_USE_MODEL_HESSIAN', 'USE_MODEL_HESSIAN'), ('_USE_RAT_FUN_OPT', 'USE_RAT_FUN_OPT'), ('_RESTART_HESSIAN', 'RESTART_HESSIAN'), ('_RESTART_FILE_NAME', 'RESTART_FILE_NAME')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('RESTART', 'RESTART')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class metavar1(printable):
    """This section specify the nature of the collective variables."""
    def __init__(self):
        self._LAMBDA = None    # Specifies the lambda parameter of the collective variable in the extended lagrangian scheme.
        self._MASS = None    # Specifies the mass parameter of the collective variable in the extended lagrangian scheme.
        self._GAMMA = None    # Specifies the friction term in Langevin integration of the collective variable in the extended lagrangian scheme.
        self._SCALE = None    # Specifies the scale factor for the following collective variable. The history dependent term has the expression: WW * Sum_{j=1}^{nhills} Prod_{k=1}^{ncolvar} [EXP[-0.5*((ss-ss0(k,j))/SCALE(k))^2]], where ncolvar is the number of defined METAVAR and nhills is the number of spawned hills.
        self._WIDTH = self._SCALE
        self._COLVAR = None    # Specifies the colvar on which to apply metadynamics.
        self.listWALL = []
        self.WALL = wall1()
        self.name = "METAVAR"
        self.keywords = [('_LAMBDA', 'LAMBDA'), ('_MASS', 'MASS'), ('_GAMMA', 'GAMMA'), ('_SCALE', 'SCALE'), ('_WIDTH', 'WIDTH'), ('_COLVAR', 'COLVAR')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('WALL', 'wall1')]

    def addWALL(self):
        new_section = wall1()
        self.listWALL.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class opbend1(printable):
    """Specifies the out of plane bend potential of the MM system.(Only defined for atom quadruples which are also defined as an improper pattern in the topology.)"""
    def __init__(self):
        self._ATOMS = None    # Defines the atomic kinds involved in the opbend.
        self._KIND = None    # Define the kind of out of plane bend potential
        self._K = None    # Defines the force constant of the potential
        self._PHI0 = None    # Defines the phase of the potential.
        self.name = "OPBEND"
        self.keywords = [('_ATOMS', 'ATOMS'), ('_KIND', 'KIND'), ('_K', 'K'), ('_PHI0', 'PHI0')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class topology1(printable):
    """Section specifying information regarding how to handle the topology for classical runs."""
    def __init__(self):
        self._CHARGE_OCCUP = None    # Read MM charges from the OCCUP field of PDB file.
        self._CHARGE_O = self._CHARGE_OCCUP
        self._CHARGE_BETA = None    # Read MM charges from the BETA field of PDB file.
        self._CHARGE_B = self._CHARGE_BETA
        self._CHARGE_EXTENDED = None    # Read MM charges from the very last field of PDB file (starting from column 81). No limitations of number of digits.
        self._PARA_RES = None    # For a protein, each residue is now considered a molecule
        self._MOL_CHECK = None    # Check molecules have the same number of atom and names.
        self._USE_G96_VELOCITY = None    # Use the velocities in the G96 coordinate files as the starting velocity
        self._COORD_FILE_NAME = None    # Specifies the filename that contains coordinates.
        self._COORD_FILE = self._COORD_FILE_NAME
        self._COORD_FILE_FORMAT = None    # Set up the way in which coordinates will be read.
        self._COORDINATE = self._COORD_FILE_FORMAT
        self._NUMBER_OF_ATOMS = None    # Optionally define the number of atoms read from an external file (see COORD_FILE_NAME) if the COORD_FILE_FORMAT CP2K is used
        self._NATOMS = self._NUMBER_OF_ATOMS
        self._NATOM = self._NUMBER_OF_ATOMS
        self._CONN_FILE_NAME = None    # Specifies the filename that contains the molecular connectivity.
        self._CONN_FILE = self._CONN_FILE_NAME
        self._CONN_FILE_FORMAT = None    # Ways to determine and generate a molecules. Default is to use GENERATE
        self._CONNECTIVITY = self._CONN_FILE_FORMAT
        self._DISABLE_EXCLUSION_LISTS = None    # Do not build any exclusion lists.
        self._EXCLUDE_VDW = None    # Specifies which kind of Van der Waals interaction to skip.
        self._EXCLUDE_EI = None    # Specifies which kind of Electrostatic interaction to skip.
        self._AUTOGEN_EXCLUDE_LISTS = None    # When True, the exclude lists are solely based on the bond data in the topology. The (minimal) number of bonds between two atoms is used to determine if the atom pair is added to an exclusion list. When False, 1-2 exclusion is based on bonds in the topology, 1-3 exclusion is based on bonds and bends in the topology, 1-4 exclusion is based on bonds, bends and dihedrals in the topology. This implies that a missing dihedral in the topology will cause the corresponding 1-4 pair not to be in the exclusion list, in case 1-4 exclusion is requested for VDW or EI interactions.
        self._MULTIPLE_UNIT_CELL = None    # Specifies the numbers of repetition in space (X, Y, Z) of the defined cell, assuming it as a unit cell. This keyword affects only the coordinates specification. The same keyword in SUBSYS%CELL%MULTIPLE_UNIT_CELL should be modified in order to affect the cell specification.
        self._MEMORY_PROGRESSION_FACTOR = None    # This keyword is quite technical and should normally not be changed by the user. It affects the memory allocation during the construction of the topology. It does NOT affect the memory used once the topology is built.
        self.DUMP_PDB = dump_pdb1()
        self.DUMP_PSF = dump_psf1()
        self.EXCLUDE_VDW_LIST = exclude_vdw_list1()
        self.EXCLUDE_EI_LIST = exclude_ei_list1()
        self.CENTER_COORDINATES = center_coordinates1()
        self.listGENERATE = []
        self.GENERATE = generate1()
        self.MOL_SET = mol_set1()
        self.name = "TOPOLOGY"
        self.keywords = [('_CHARGE_OCCUP', 'CHARGE_OCCUP'), ('_CHARGE_O', 'CHARGE_O'), ('_CHARGE_BETA', 'CHARGE_BETA'), ('_CHARGE_B', 'CHARGE_B'), ('_CHARGE_EXTENDED', 'CHARGE_EXTENDED'), ('_PARA_RES', 'PARA_RES'), ('_MOL_CHECK', 'MOL_CHECK'), ('_USE_G96_VELOCITY', 'USE_G96_VELOCITY'), ('_COORD_FILE_NAME', 'COORD_FILE_NAME'), ('_COORD_FILE', 'COORD_FILE'), ('_COORD_FILE_FORMAT', 'COORD_FILE_FORMAT'), ('_COORDINATE', 'COORDINATE'), ('_NUMBER_OF_ATOMS', 'NUMBER_OF_ATOMS'), ('_NATOMS', 'NATOMS'), ('_NATOM', 'NATOM'), ('_CONN_FILE_NAME', 'CONN_FILE_NAME'), ('_CONN_FILE', 'CONN_FILE'), ('_CONN_FILE_FORMAT', 'CONN_FILE_FORMAT'), ('_CONNECTIVITY', 'CONNECTIVITY'), ('_DISABLE_EXCLUSION_LISTS', 'DISABLE_EXCLUSION_LISTS'), ('_EXCLUDE_VDW', 'EXCLUDE_VDW'), ('_EXCLUDE_EI', 'EXCLUDE_EI'), ('_AUTOGEN_EXCLUDE_LISTS', 'AUTOGEN_EXCLUDE_LISTS'), ('_MULTIPLE_UNIT_CELL', 'MULTIPLE_UNIT_CELL'), ('_MEMORY_PROGRESSION_FACTOR', 'MEMORY_PROGRESSION_FACTOR')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('DUMP_PDB', 'DUMP_PDB'), ('DUMP_PSF', 'DUMP_PSF'), ('EXCLUDE_VDW_LIST', 'EXCLUDE_VDW_LIST'), ('EXCLUDE_EI_LIST', 'EXCLUDE_EI_LIST'), ('CENTER_COORDINATES', 'CENTER_COORDINATES'), ('MOL_SET', 'MOL_SET')]
        self.repeated_subsections = [('GENERATE', 'generate1')]

    def addGENERATE(self):
        new_section = generate1()
        self.listGENERATE.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class tfw1(printable):
    """Uses the TFW functional"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self.name = "TFW"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []
        pass

    def print_input(self, level):
        return printable.print_input(self, level)


class gle1(printable):
    """paramameters of the gle thermostat. This section can be generated  from http://gle4md.berlios.de/compose.php?page=matrix"""
    def __init__(self):
        self._NDIM = None    # Size of the gle matrix
        self._A_SCALE = None    # scaling factor for matrix A (for generic matrix A, depends on the characteristic frequency of the system).
        self.list_A_LIST = []
        self._A_LIST = None
    # A matrix The defaults give optimal sampling for most cristalline and liquid compounds. Generated with the parameters set kv_4-4.acentered on w_0=40 cm^-1.
        self.list_C_LIST = []
        self._C_LIST = None
    # C matrix
        self.THERMOSTAT_ENERGY = thermostat_energy1()
        self.RNG_INIT = rng_init1()
        self.S = s1()
        self.name = "GLE"
        self.keywords = [('_NDIM', 'NDIM'), ('_A_SCALE', 'A_SCALE')]
        self.repeated_keywords = [('_A_LIST', 'A_LIST'), ('_C_LIST', 'C_LIST')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('THERMOSTAT_ENERGY', 'THERMOSTAT_ENERGY'), ('RNG_INIT', 'RNG_INIT'), ('S', 'S')]
        self.repeated_subsections = []

    def add_A_LIST(self, value):
        self.list_A_LIST.append(value)

    def add_C_LIST(self, value):
        self.list_C_LIST.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class xas_spectrum1(printable):
    """Controls the dumping of the CLS output files containing the absorption spectra"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "XAS_SPECTRUM"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class derivatives3(printable):
    """Print all derivatives after QM/MM calculation"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "DERIVATIVES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class rho2(printable):
    """Controls the output of the helium density (Gaussian cube file format)"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._BACKUP_COPIES = None    # Specifies the maximum number of backup copies.
        self.EACH = each1()
        self.name = "RHO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_BACKUP_COPIES', 'BACKUP_COPIES')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class rho1(printable):
    """Density distribution settings"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._NBIN = None    # Number of bins
        self._IWEIGHT = None    # Weight the restarted density should be given (number of MC steps used to average the restarted density, negative value - the same weight as the run-time density, usually should not be changed)
        self.CUBE_DATA = cube_data1()
        self.name = "RHO"
        self.keywords = [('_NBIN', 'NBIN'), ('_IWEIGHT', 'IWEIGHT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('CUBE_DATA', 'CUBE_DATA')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class free_energy_info1(printable):
    """Controls the printing of basic and summary information during the Free Energy calculation"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "FREE_ENERGY_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class fit_density1(printable):
    """Fit the total electronic density to a linear combination of Gaussian functions"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._NUM_GTO = None    # Number of Gaussian type functions for density fit
        self.EACH = each1()
        self.name = "FIT_DENSITY"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_NUM_GTO', 'NUM_GTO')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class qparm1(printable):
    """Section to define the Q parameter (crystalline order parameter) as a collective variable."""
    def __init__(self):
        self.list_ATOMS_FROM = []
        self._ATOMS_FROM = None
    # Specify indexes of atoms/points building the coordination variable.
        self._POINTS_FROM = self._ATOMS_FROM
        self.list_POINTS_FROM = self.list_ATOMS_FROM
        self.list_ATOMS_TO = []
        self._ATOMS_TO = None
    # Specify indexes of atoms/points building the coordination variable.
        self._POINTS_TO = self._ATOMS_TO
        self.list_POINTS_TO = self.list_ATOMS_TO
        self._RCUT = None    # Specifies the distance cutoff for neighbors.
        self._L = None    # Specifies the L spherical harmonics from Ylm.
        self._ALPHA = None    # Specifies the width of the Fermi-Dirac style smearing around RCUT.
        self.listPOINT = []
        self.POINT = point1()
        self.name = "QPARM"
        self.keywords = [('_RCUT', 'RCUT'), ('_L', 'L'), ('_ALPHA', 'ALPHA')]
        self.repeated_keywords = [('_ATOMS_FROM', 'ATOMS_FROM'), ('_POINTS_FROM', 'POINTS_FROM'), ('_ATOMS_TO', 'ATOMS_TO'), ('_POINTS_TO', 'POINTS_TO')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('POINT', 'point1')]

    def addPOINT(self):
        new_section = point1()
        self.listPOINT.append(new_section)
        return new_section

    def add_ATOMS_FROM(self, value):
        self.list_ATOMS_FROM.append(value)

    def add_POINTS_FROM(self, value):
        self.list_POINTS_FROM.append(value)

    def add_ATOMS_TO(self, value):
        self.list_ATOMS_TO.append(value)

    def add_POINTS_TO(self, value):
        self.list_POINTS_TO.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class scptb1(printable):
    """Parameters needed to set up the SCPTB methods"""
    def __init__(self):
        self._PARAMETER_FILE_NAME = None    # Specify file that contains the atomic parameters
        self._DISPERSION_PARAMETER_FILE = None    # Specify file that contains the atomic dispersion parameters
        self._DISPERSION = None    # Use dispersion correction
        self._DISPERSION_RADIUS = None    # Define radius of dispersion interaction
        self._COORDINATION_CUTOFF = None    # Define cutoff for coordination number calculation
        self._D3_SCALING = None    # Scaling parameters (s6,sr6,s8) for the D3 dispersion method,
        self._STO_NG = None    # Provides the order of the Slater orbital expansion of Gaussian-Type Orbitals.
        self._PAIR_CUTOFF = None    # Define cutoff for pair potential calculation
        self._DO_EWALD = None    # Use Ewald type method instead of direct sum for Coulomb interaction
        self._DO_SCC = None    # Use self consistent charge method. Can be used together with DO_SCP to get TB method
        self._DO_SCP = None    # Use SCP method. Can be used to switch off SCP to get a SCC-DFTB method
        self.name = "SCPTB"
        self.keywords = [('_PARAMETER_FILE_NAME', 'PARAMETER_FILE_NAME'), ('_DISPERSION_PARAMETER_FILE', 'DISPERSION_PARAMETER_FILE'), ('_DISPERSION', 'DISPERSION'), ('_DISPERSION_RADIUS', 'DISPERSION_RADIUS'), ('_COORDINATION_CUTOFF', 'COORDINATION_CUTOFF'), ('_D3_SCALING', 'D3_SCALING'), ('_STO_NG', 'STO_NG'), ('_PAIR_CUTOFF', 'PAIR_CUTOFF'), ('_DO_EWALD', 'DO_EWALD'), ('_DO_SCC', 'DO_SCC'), ('_DO_SCP', 'DO_SCP')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class energy3(printable):
    """Controls the output the ener file"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "ENERGY"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class energy2(printable):
    """Controls the output of kinetic energy, and potential energy  of the defined barostat."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "ENERGY"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class energy1(printable):
    """Controls the output of kinetic energy, and potential energy  of the defined thermostat."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "ENERGY"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class energy7(printable):
    """Controls the printing of the various energies"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "ENERGY"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class energy6(printable):
    """Controls the printing of the ENER file in a BAND run"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "ENERGY"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class energy5(printable):
    """Controls the output of the path integral energies"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "ENERGY"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class energy4(printable):
    """Controls the output of the helium energies (averaged over MC step)"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "ENERGY"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class link1(printable):
    """Specify information on the QM/MM link treatment"""
    def __init__(self):
        self._QM_INDEX = None    # Specifies the index of the QM atom involved in the QM/MM link
        self._QM = self._QM_INDEX
        self._QM_KIND = None    # Specifies the element of the QM capping atom involved in the QM/MM link
        self._MM_INDEX = None    # Specifies the index of the MM atom involved in the QM/MM link, Default hydrogen.
        self._MM = self._MM_INDEX
        self._RADIUS = None    # Overwrite the specification of the radius only for the MM atom involved in the link.Default is to use the same radius as for the specified type.
        self._CORR_RADIUS = None    # Overwrite the specification of the correction radius only for the MM atom involved in the link.Default is to use the same correction radius as for the specified type.
        self._LINK_TYPE = None    # Specifies the method to use to treat the defined QM/MM link
        self._LINK = self._LINK_TYPE
        self._TYPE = self._LINK_TYPE
        self._LTYPE = self._LINK_TYPE
        self._ALPHA_IMOMM = None    # Specifies the scaling factor to be used for projecting the forces on the capping hydrogen in the IMOMM QM/MM link scheme to the MM atom of the link. A good guess can be derived from the bond distances of the forcefield: alpha = r_eq(QM-MM) / r_eq(QM-H).
        self._ALPHA = self._ALPHA_IMOMM
        self._QMMM_SCALE_FACTOR = None    # Specifies the scaling factor for the MM charge involved in the link QM/MM. This keyword affects only the QM/MM potential, it doesn't affect the electrostatic in  the classical part of the code. Default 1.0 i.e. no charge rescaling of the MM atom of the QM/MM link bond.
        self._QMMM_CHARGE_SCALE = self._QMMM_SCALE_FACTOR
        self._QMMM_CHARGE_FACTOR = self._QMMM_SCALE_FACTOR
        self._QMMM_SCALE_CHARGE = self._QMMM_SCALE_FACTOR
        self._FIST_SCALE_FACTOR = None    # Specifies the scaling factor for the MM charge involved in the link QM/MM. This keyword modifies the MM charge in FIST. The modified charge will be used then also for the generation of the QM/MM potential. Default 1.0 i.e. no charge rescaling of the MM atom of the QM/MM link bond.
        self._FIST_CHARGE_SCALE = self._FIST_SCALE_FACTOR
        self._FIST_CHARGE_FACTOR = self._FIST_SCALE_FACTOR
        self._FIST_SCALE_CHARGE = self._FIST_SCALE_FACTOR
        self.listMOVE_MM_CHARGE = []
        self.MOVE_MM_CHARGE = move_mm_charge1()
        self.listADD_MM_CHARGE = []
        self.ADD_MM_CHARGE = add_mm_charge1()
        self.name = "LINK"
        self.keywords = [('_QM_INDEX', 'QM_INDEX'), ('_QM', 'QM'), ('_QM_KIND', 'QM_KIND'), ('_MM_INDEX', 'MM_INDEX'), ('_MM', 'MM'), ('_RADIUS', 'RADIUS'), ('_CORR_RADIUS', 'CORR_RADIUS'), ('_LINK_TYPE', 'LINK_TYPE'), ('_LINK', 'LINK'), ('_TYPE', 'TYPE'), ('_LTYPE', 'LTYPE'), ('_ALPHA_IMOMM', 'ALPHA_IMOMM'), ('_ALPHA', 'ALPHA'), ('_QMMM_SCALE_FACTOR', 'QMMM_SCALE_FACTOR'), ('_QMMM_CHARGE_SCALE', 'QMMM_CHARGE_SCALE'), ('_QMMM_CHARGE_FACTOR', 'QMMM_CHARGE_FACTOR'), ('_QMMM_SCALE_CHARGE', 'QMMM_SCALE_CHARGE'), ('_FIST_SCALE_FACTOR', 'FIST_SCALE_FACTOR'), ('_FIST_CHARGE_SCALE', 'FIST_CHARGE_SCALE'), ('_FIST_CHARGE_FACTOR', 'FIST_CHARGE_FACTOR'), ('_FIST_SCALE_CHARGE', 'FIST_SCALE_CHARGE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('MOVE_MM_CHARGE', 'move_mm_charge1'), ('ADD_MM_CHARGE', 'add_mm_charge1')]

    def addMOVE_MM_CHARGE(self):
        new_section = move_mm_charge1()
        self.listMOVE_MM_CHARGE.append(new_section)
        return new_section

    def addADD_MM_CHARGE(self):
        new_section = add_mm_charge1()
        self.listADD_MM_CHARGE.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class core_velocity1(printable):
    """The velocities of cores for shell-model potentials, in xyz format"""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # The core velocities in xyz format. The same order as the shell coordinate is assumed.
        self.name = "CORE_VELOCITY"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class williams1(printable):
    """This section specifies the input parameters for WILLIAMS potential type.Functional form: V(r) = A*EXP(-B*r) - C / r^6 ."""
    def __init__(self):
        self._ATOMS = None    # Defines the atomic kind involved in the nonbond potential
        self._A = None    # Defines the A parameter of the Williams potential
        self._B = None    # Defines the B parameter of the Williams potential
        self._C = None    # Defines the C parameter of the Williams potential
        self._RCUT = None    # Defines the cutoff parameter of the Williams potential
        self._RMIN = None    # Defines the lower bound of the potential. If not set the range is the full range generate by the spline
        self._RMAX = None    # Defines the upper bound of the potential. If not set the range is the full range generate by the spline
        self.name = "WILLIAMS"
        self.keywords = [('_ATOMS', 'ATOMS'), ('_A', 'A'), ('_B', 'B'), ('_C', 'C'), ('_RCUT', 'RCUT'), ('_RMIN', 'RMIN'), ('_RMAX', 'RMAX')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class weights1(printable):
    """Controls the printing of FP info during flexible partitioning simulations."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "WEIGHTS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class center_of_mass1(printable):
    """Controls the printing of COM velocity during an MD"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "CENTER_OF_MASS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class alpha1(printable):
    """alpha spin"""
    def __init__(self):
        self._NEL = None    # Orbital ccupation change per angular momentum quantum number.In unrestricted calculations applied to spin alpha.
        self._L = None    # Angular momentum quantum number of theorbitals whose occupation is changed
        self._L = None    # Angular momentum quantum number of theorbitals whose occupation is changed
        self._N = None    # Principal quantum number of theorbitals whose occupation is changed. Default is the first not occupied
        self._N = None    # Principal quantum number of theorbitals whose occupation is changed. Default is the first not occupied
        self.name = "ALPHA"
        self.keywords = [('_NEL', 'NEL'), ('_L', 'L'), ('_L', 'L'), ('_N', 'N'), ('_N', 'N')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class enforce_occupation1(printable):
    """Enforce and control a special (initial) orbital occupation. Note, this feature works only for the methods MULLIKEN and LOWDIN. It should only be used to prepare an initial configuration. An inadequate parameter choice can easily inhibit SCF convergence."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ORBITALS = None    # Select orbitals and occupation order. An input of 1 to 2*L+1 integer values in the range -L to L defining the M values of the spherical orbitals is expected.
        self._M = self._ORBITALS
        self._EPS_SCF = None    # The occupation constraint is enforced until this threshold value for the SCF convergence criterion is reached
        self._MAX_SCF = None    # The occupation constraint is applied for this number of initial SCF iterations
        self._SMEAR = None    # The occupation constraint is applied with smearing
        self.name = "ENFORCE_OCCUPATION"
        self.keywords = [('_ORBITALS', 'ORBITALS'), ('_M', 'M'), ('_EPS_SCF', 'EPS_SCF'), ('_MAX_SCF', 'MAX_SCF'), ('_SMEAR', 'SMEAR')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class mol_set1(printable):
    """Specify the connectivity of a full system specifying the connectivity of the fragments of the system."""
    def __init__(self):
        self.listMOLECULE = []
        self.MOLECULE = molecule1()
        self.MERGE_MOLECULES = merge_molecules1()
        self.name = "MOL_SET"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('MERGE_MOLECULES', 'MERGE_MOLECULES')]
        self.repeated_subsections = [('MOLECULE', 'molecule1')]

    def addMOLECULE(self):
        new_section = molecule1()
        self.listMOLECULE.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class lennardhypminjones1(printable):
    """This section specifies the input parameters for LENNARD-JONES potential type.Functional form: V(r) = 4.0 * EPSILON * [(SIGMA/r)^12-(SIGMA/r)^6]."""
    def __init__(self):
        self._ATOMS = None    # Defines the atomic kind involved in the nonbond potential
        self._EPSILON = None    # Defines the EPSILON parameter of the LJ potential
        self._SIGMA = None    # Defines the SIGMA parameter of the LJ potential
        self._RCUT = None    # Defines the cutoff parameter of the LJ potential
        self._RMIN = None    # Defines the lower bound of the potential. If not set the range is the full range generate by the spline
        self._RMAX = None    # Defines the upper bound of the potential. If not set the range is the full range generate by the spline
        self.name = "LENNARD-JONES"
        self.keywords = [('_ATOMS', 'ATOMS'), ('_EPSILON', 'EPSILON'), ('_SIGMA', 'SIGMA'), ('_RCUT', 'RCUT'), ('_RMIN', 'RMIN'), ('_RMAX', 'RMAX')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class image_charge1(printable):
    """Inclusion of polarization effects within the image charge approach for systems where QM molecules are physisorbed on e.g. metal surfaces described by MM. QM box size has to be equal to MM box size."""
    def __init__(self):
        self.list_MM_ATOM_LIST = []
        self._MM_ATOM_LIST = None
    # List of MM atoms carrying an induced Gaussian charge. If this keyword is not given, all MM atoms will carry an image charge.
        self._WIDTH = None    # Specifies the value of the width of the (induced) Gaussian charge distribution carried by each MM atom.
        self._EXT_POTENTIAL = None    # External potential applied to the metal electrode
        self._DETERM_COEFF = None    # Specifies how the coefficients are determined.
        self._RESTART_IMAGE_MATRIX = None    # Restart the image matrix. Useful when calculating coefficients iteratively (the image matrix is used as preconditioner in that case)
        self._IMAGE_RESTART_FILE_NAME = None    # File name where to read the image matrix used as preconditioner in the iterative scheme
        self.name = "IMAGE_CHARGE"
        self.keywords = [('_WIDTH', 'WIDTH'), ('_EXT_POTENTIAL', 'EXT_POTENTIAL'), ('_DETERM_COEFF', 'DETERM_COEFF'), ('_RESTART_IMAGE_MATRIX', 'RESTART_IMAGE_MATRIX'), ('_IMAGE_RESTART_FILE_NAME', 'IMAGE_RESTART_FILE_NAME')]
        self.repeated_keywords = [('_MM_ATOM_LIST', 'MM_ATOM_LIST')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def add_MM_ATOM_LIST(self, value):
        self.list_MM_ATOM_LIST.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class adiabatic_dynamics1(printable):
    """Parameters used in canonical adiabatic free energy sampling (CAFES)."""
    def __init__(self):
        self._TEMP_FAST = None    # Temperature in K used to control the fast degrees of freedom
        self._TEMP_SLOW = None    # Temperature in K used to control the slow degrees of freedom
        self._TEMP_TOL_FAST = None    # Maximum accepted temperature deviation from the expected value, for the fast motion.If 0, no rescaling is performed
        self._TEMP_TOL_SLOW = None    # Maximum accepted temperature deviation from the expected value, for the slow motion.If 0, no rescaling is performed
        self._N_RESP_FAST = None    # number of respa steps for fast degrees of freedom
        self.THERMOSTAT_FAST = thermostat_fast1()
        self.THERMOSTAT_SLOW = thermostat_slow1()
        self.name = "ADIABATIC_DYNAMICS"
        self.keywords = [('_TEMP_FAST', 'TEMP_FAST'), ('_TEMP_SLOW', 'TEMP_SLOW'), ('_TEMP_TOL_FAST', 'TEMP_TOL_FAST'), ('_TEMP_TOL_SLOW', 'TEMP_TOL_SLOW'), ('_N_RESP_FAST', 'N_RESP_FAST')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('THERMOSTAT_FAST', 'THERMOSTAT_FAST'), ('THERMOSTAT_SLOW', 'THERMOSTAT_SLOW')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class ci_neb1(printable):
    """Controls parameters for CI-NEB type calculation only."""
    def __init__(self):
        self._NSTEPS_IT = None    # Specify the number of steps of IT-NEB to perform before switching on the CI algorithm
        self.name = "CI_NEB"
        self.keywords = [('_NSTEPS_IT', 'NSTEPS_IT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print44(printable):
    """Section controlling the print information during a vibrational analysis."""
    def __init__(self):
        self.BANNER = banner2()
        self.PROGRAM_RUN_INFO = program_run_info23()
        self.MOLDEN_VIB = molden_vib1()
        self.ROTATIONAL_INFO = rotational_info1()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('BANNER', 'BANNER'), ('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('MOLDEN_VIB', 'MOLDEN_VIB'), ('ROTATIONAL_INFO', 'ROTATIONAL_INFO')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print45(printable):
    """Section of possible print options specific of the ATOM code."""
    def __init__(self):
        self.PROGRAM_BANNER = program_banner2()
        self.METHOD_INFO = method_info1()
        self.BASIS_SET = basis_set1()
        self.POTENTIAL = potential3()
        self.FIT_DENSITY = fit_density1()
        self.RESPONSE_BASIS = response_basis1()
        self.SCF_INFO = scf_info1()
        self.ORBITALS = orbitals1()
        self.FIT_PSEUDO = fit_pseudo1()
        self.FIT_BASIS = fit_basis1()
        self.UPF_FILE = upf_file1()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PROGRAM_BANNER', 'PROGRAM_BANNER'), ('METHOD_INFO', 'METHOD_INFO'), ('BASIS_SET', 'BASIS_SET'), ('POTENTIAL', 'POTENTIAL'), ('FIT_DENSITY', 'FIT_DENSITY'), ('RESPONSE_BASIS', 'RESPONSE_BASIS'), ('SCF_INFO', 'SCF_INFO'), ('ORBITALS', 'ORBITALS'), ('FIT_PSEUDO', 'FIT_PSEUDO'), ('FIT_BASIS', 'FIT_BASIS'), ('UPF_FILE', 'UPF_FILE')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print42(printable):
    """Properties that you want to output and that are common to all methods"""
    def __init__(self):
        self.PROGRAM_RUN_INFO = program_run_info21()
        self.FORCES = forces4()
        self.GRID_INFORMATION = grid_information3()
        self.TOTAL_NUMBERS = total_numbers1()
        self.DISTRIBUTION = distribution2()
        self.DISTRIBUTION2D = distribution2d1()
        self.DISTRIBUTION1D = distribution1d1()
        self.STRESS_TENSOR = stress_tensor1()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('FORCES', 'FORCES'), ('GRID_INFORMATION', 'GRID_INFORMATION'), ('TOTAL_NUMBERS', 'TOTAL_NUMBERS'), ('DISTRIBUTION', 'DISTRIBUTION'), ('DISTRIBUTION2D', 'DISTRIBUTION2D'), ('DISTRIBUTION1D', 'DISTRIBUTION1D'), ('STRESS_TENSOR', 'STRESS_TENSOR')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print_averages1(printable):
    """Controls the output the averaged quantities"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PRINT_AVERAGES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print40(printable):
    """Section of possible print options specific for the RESP code."""
    def __init__(self):
        self.PROGRAM_RUN_INFO = program_run_info18()
        self.COORD_FIT_POINTS = coord_fit_points1()
        self.RESP_CHARGES_TO_FILE = resp_charges_to_file1()
        self.V_RESP_CUBE = v_resp_cube1()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('COORD_FIT_POINTS', 'COORD_FIT_POINTS'), ('RESP_CHARGES_TO_FILE', 'RESP_CHARGES_TO_FILE'), ('V_RESP_CUBE', 'V_RESP_CUBE')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print41(printable):
    """Controls the printing of basic information during the run"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PRINT"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class diis_info2(printable):
    """Controls the printing of diis information."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "DIIS_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class diis_info1(printable):
    """Controls the printing of diis info during a BAND run"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "DIIS_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class bend1(printable):
    """Specifies the bend potential of the MM system."""
    def __init__(self):
        self._ATOMS = None    # Defines the atomic kinds involved in the bend.
        self._KIND = None    # Define the kind of bend potential
        self._K = None    # Defines the force constant of the potential
        self._CB = None    # Defines the the cubic force constant of the bend
        self._R012 = None    # Mixed bend stretch parameter
        self._R032 = None    # Mixed bend stretch parameter
        self._KBS12 = None    # Mixed bend stretch parameter
        self._KBS32 = None    # Mixed bend stretch parameter
        self._KSS = None    # Mixed bend stretch parameter
        self._THETA0 = None    # Defines the equilibrium angle.
        self.UB = ub1()
        self.name = "BEND"
        self.keywords = [('_ATOMS', 'ATOMS'), ('_KIND', 'KIND'), ('_K', 'K'), ('_CB', 'CB'), ('_R012', 'R012'), ('_R032', 'R032'), ('_KBS12', 'KBS12'), ('_KBS32', 'KBS32'), ('_KSS', 'KSS'), ('_THETA0', 'THETA0')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('UB', 'UB')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class ipbv1(printable):
    """This section specifies the input parameters for IPBV potential type.Functional form: Implicit table function."""
    def __init__(self):
        self._ATOMS = None    # Defines the atomic kind involved in the IPBV nonbond potential
        self._RCUT = None    # Defines the cutoff parameter of the IPBV potential
        self._RMIN = None    # Defines the lower bound of the potential. If not set the range is the full range generate by the spline
        self._RMAX = None    # Defines the upper bound of the potential. If not set the range is the full range generate by the spline
        self.name = "IPBV"
        self.keywords = [('_ATOMS', 'ATOMS'), ('_RCUT', 'RCUT'), ('_RMIN', 'RMIN'), ('_RMAX', 'RMAX')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class spawned_hills_invdt1(printable):
    """The inverse of the DELTA_T parameter used for Well-Tempered metadynamics.Used for RESTART."""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Specify the spawned hills
        self.name = "SPAWNED_HILLS_INVDT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class md2(printable):
    """Activate the MD based optimization procedure for BAND"""
    def __init__(self):
        self._MAX_STEPS = None    # Specify the maximum number of MD steps
        self._TIMESTEP = None    # The length of an integration step
        self._TEMPERATURE = None    # Specify the initial temperature
        self.TEMP_CONTROL = temp_control1()
        self.VEL_CONTROL = vel_control1()
        self.name = "MD"
        self.keywords = [('_MAX_STEPS', 'MAX_STEPS'), ('_TIMESTEP', 'TIMESTEP'), ('_TEMPERATURE', 'TEMPERATURE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('TEMP_CONTROL', 'TEMP_CONTROL'), ('VEL_CONTROL', 'VEL_CONTROL')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class md1(printable):
    """This section defines the whole set of parameters needed perform an MD run."""
    def __init__(self):
        self._ENSEMBLE = None    # The ensemble/integrator that you want to use for MD propagation
        self._STEPS = None    # The number of MD steps to perform
        self._TIMESTEP = None    # The length of an integration step (in case RESPA the large TIMESTEP)
        self._STEP_START_VAL = None    # The starting step value for the MD
        self._TIME_START_VAL = None    # The starting timer value for the MD
        self._ECONS_START_VAL = None    # The starting  value of the conserved quantity
        self._TEMPERATURE = None    # The temperature in K used to initialize the velocities with init and pos restart, and in the NPT/NVT simulations
        self._TEMP_TOL = None    # The maximum accepted deviation of the (global) temperaturefrom the desired target temperature before a rescaling of the velocites is performed. If it is 0 no rescaling is performed. NOTE: This keyword is obsolescent; Using a CSVR thermostat with a short timeconstant is recommended as a better alternative.
        self._TEMP_TO = self._TEMP_TOL
        self._TEMPERATURE_TOLERANCE = self._TEMP_TOL
        self._TEMP_KIND = None    # Compute the temperature per each kind separately
        self._SCALE_TEMP_KIND = None    # When necessary rescale the temperature per each kind separately
        self._COMVEL_TOL = None    # The maximum accepted velocity of the center of mass. With Shell-Model, comvel may drift if MD%THERMOSTAT%REGION /= GLOBAL
        self._ANGVEL_TOL = None    # The maximum accepted angular velocity. This option is ignored when the system is periodic. Removes the components of the velocities thatproject on the external rotational degrees of freedom.
        self._ANGVEL_ZERO = None    # Set the initial angular velocity to zero. This option is ignored when the system is periodic or when initial velocities are defined. Technically, the part of the random initial velocities that projects on the external rotational degrees of freedom is subtracted.
        self._ANNEALING = None    # Specifies the rescaling factor for annealing velocities. Automatically enables the annealing procedure. This scheme works only for ensembles that do not have thermostats on particles.
        self._ANNEALING_CELL = None    # Specifies the rescaling factor for annealing velocities of the CELL Automatically enables the annealing procedure for the CELL. This scheme works only for ensambles that do not have thermostat on CELLS velocities.
        self._DISPLACEMENT_TOL = None    # This keyword sets a maximum atomic displacement  in each Cartesian direction.The maximum velocity is evaluated and if it is too large to remainwithin the assigned limit, the time step is rescaled accordingly,and the first half step of the velocity verlet is repeated.
        self.LANGEVIN = langevin1()
        self.MSST = msst1()
        self.BAROSTAT = barostat1()
        self.THERMOSTAT = thermostat2()
        self.RESPA = respa1()
        self.SHELL = shell1()
        self.ADIABATIC_DYNAMICS = adiabatic_dynamics1()
        self.REFTRAJ = reftraj1()
        self.AVERAGES = averages1()
        self.THERMAL_REGION = thermal_region1()
        self.PRINT = print10()
        self.CASCADE = cascade1()
        self.name = "MD"
        self.keywords = [('_ENSEMBLE', 'ENSEMBLE'), ('_STEPS', 'STEPS'), ('_TIMESTEP', 'TIMESTEP'), ('_STEP_START_VAL', 'STEP_START_VAL'), ('_TIME_START_VAL', 'TIME_START_VAL'), ('_ECONS_START_VAL', 'ECONS_START_VAL'), ('_TEMPERATURE', 'TEMPERATURE'), ('_TEMP_TOL', 'TEMP_TOL'), ('_TEMP_TO', 'TEMP_TO'), ('_TEMPERATURE_TOLERANCE', 'TEMPERATURE_TOLERANCE'), ('_TEMP_KIND', 'TEMP_KIND'), ('_SCALE_TEMP_KIND', 'SCALE_TEMP_KIND'), ('_COMVEL_TOL', 'COMVEL_TOL'), ('_ANGVEL_TOL', 'ANGVEL_TOL'), ('_ANGVEL_ZERO', 'ANGVEL_ZERO'), ('_ANNEALING', 'ANNEALING'), ('_ANNEALING_CELL', 'ANNEALING_CELL'), ('_DISPLACEMENT_TOL', 'DISPLACEMENT_TOL')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('LANGEVIN', 'LANGEVIN'), ('MSST', 'MSST'), ('BAROSTAT', 'BAROSTAT'), ('THERMOSTAT', 'THERMOSTAT'), ('RESPA', 'RESPA'), ('SHELL', 'SHELL'), ('ADIABATIC_DYNAMICS', 'ADIABATIC_DYNAMICS'), ('REFTRAJ', 'REFTRAJ'), ('AVERAGES', 'AVERAGES'), ('THERMAL_REGION', 'THERMAL_REGION'), ('PRINT', 'PRINT'), ('CASCADE', 'CASCADE')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class force_matching1(printable):
    """Specify the force matching input."""
    def __init__(self):
        self._OPTIMIZE_FILE_NAME = None    # the filename of the input file which contains the parameters to be optimized
        self._REF_TRAJ_FILE_NAME = None    # the filename of the reference coordinates.
        self._REF_FORCE_FILE_NAME = None    # the filename of the reference forces, should also contain the energy
        self._REF_CELL_FILE_NAME = None    # the filename of the reference cell
        self._GROUP_SIZE = None    # Gives the preferred size of a working group, groups will always be equal or larger than this size.Usually this should take the number of cores per socket into account for good performance.
        self._FRAME_START = None    # starting frame to be used from the reference trajectory
        self._FRAME_STOP = None    # final frame to be used from the reference trajectory (all=-1)
        self._FRAME_STRIDE = None    # stride when using the reference trajectory
        self._FRAME_COUNT = None    # Use at most FRAME_COUNT frames from the reference trajectory, adjusting the stride to have them as fas apart as possible (all=-1).
        self._ENERGY_WEIGHT = None    # Relative weight of the energy RMSD vs the force RMSD
        self._SHIFT_AVERAGE = None    # Shift averages of the energies before computing energy RMSD.
        self._SHIFT_QM = None    # Shift of the reference energies applied before computing energy RMSD.
        self._SHIFT_MM = None    # Shift of the fit energies applied before computing energy RMSD.
        self.COMPARE_ENERGIES = compare_energies1()
        self.COMPARE_FORCES = compare_forces1()
        self.name = "FORCE_MATCHING"
        self.keywords = [('_OPTIMIZE_FILE_NAME', 'OPTIMIZE_FILE_NAME'), ('_REF_TRAJ_FILE_NAME', 'REF_TRAJ_FILE_NAME'), ('_REF_FORCE_FILE_NAME', 'REF_FORCE_FILE_NAME'), ('_REF_CELL_FILE_NAME', 'REF_CELL_FILE_NAME'), ('_GROUP_SIZE', 'GROUP_SIZE'), ('_FRAME_START', 'FRAME_START'), ('_FRAME_STOP', 'FRAME_STOP'), ('_FRAME_STRIDE', 'FRAME_STRIDE'), ('_FRAME_COUNT', 'FRAME_COUNT'), ('_ENERGY_WEIGHT', 'ENERGY_WEIGHT'), ('_SHIFT_AVERAGE', 'SHIFT_AVERAGE'), ('_SHIFT_QM', 'SHIFT_QM'), ('_SHIFT_MM', 'SHIFT_MM')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('COMPARE_ENERGIES', 'COMPARE_ENERGIES'), ('COMPARE_FORCES', 'COMPARE_FORCES')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class forces2(printable):
    """Controls the output of the forces"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._UNIT = None    # Specify the unit of measurement for the quantity in output. All available CP2K units can be used.
        self._FORMAT = None    # Specifies the format of the output file for the forces.
        self.EACH = each1()
        self.name = "FORCES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_UNIT', 'UNIT'), ('_FORMAT', 'FORMAT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class optimize_band1(printable):
    """Specify the optimization method for the band"""
    def __init__(self):
        self._OPT_TYPE = None    # Specifies the type optimizer used for the band
        self._OPTIMIZE_END_POINTS = None    # Performs also an optimization of the end points of the band.
        self.MD = md2()
        self.DIIS = diis1()
        self.name = "OPTIMIZE_BAND"
        self.keywords = [('_OPT_TYPE', 'OPT_TYPE'), ('_OPTIMIZE_END_POINTS', 'OPTIMIZE_END_POINTS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('MD', 'MD'), ('DIIS', 'DIIS')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class basis_set1(printable):
    """Controls the printing of the basis sets"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "BASIS_SET"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class forces1(printable):
    """Controls the output of the helium forces on the solute"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "FORCES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class multipoles2(printable):
    """Specifies the dipoles and quadrupoles for particles."""
    def __init__(self):
        self.DIPOLES = dipoles1()
        self.QUADRUPOLES = quadrupoles1()
        self.name = "MULTIPOLES"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('DIPOLES', 'DIPOLES'), ('QUADRUPOLES', 'QUADRUPOLES')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class multipoles1(printable):
    """Enables the use of multipoles in the treatment of the electrostatics."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._MAX_MULTIPOLE_EXPANSION = None    # Specify the maximum level of multipoles expansion used  for the electrostatics.
        self._POL_SCF = None    # Specify the method to obtain self consistent induced multipole moments.
        self._MAX_IPOL_ITER = None    # Specify the maximum number of iterations for induced dipoles
        self._EPS_POL = None    # Specify the rmsd threshold for the derivatives of the energy towards the Cartesian dipoles components
        self.name = "MULTIPOLES"
        self.keywords = [('_MAX_MULTIPOLE_EXPANSION', 'MAX_MULTIPOLE_EXPANSION'), ('_POL_SCF', 'POL_SCF'), ('_MAX_IPOL_ITER', 'MAX_IPOL_ITER'), ('_EPS_POL', 'EPS_POL')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class becke_restraint_b1(printable):
    """Use DDAPC charges in a restraint (check code for details), section can be repeated, but only one constraint is possible at the moment."""
    def __init__(self):
        self._STRENGTH = None    # force constant of the restraint
        self._TYPE_OF_DENSITY = None    # Specifies the type of density used for the fitting
        self._TARGET = None    # target value of the restraint
        self._ATOMS = None    # Specifies the list of atoms that is summed in the restraint
        self._COEFF = None    # Defines the the coefficient of the atom in the atom list (default is one), currently DDAPC only
        self._FUNCTIONAL_FORM = None    # Specifies the functional form of the term added
        self.PROGRAM_RUN_INFO = program_run_info12()
        self.name = "BECKE_RESTRAINT_B"
        self.keywords = [('_STRENGTH', 'STRENGTH'), ('_TYPE_OF_DENSITY', 'TYPE_OF_DENSITY'), ('_TARGET', 'TARGET'), ('_ATOMS', 'ATOMS'), ('_COEFF', 'COEFF'), ('_FUNCTIONAL_FORM', 'FUNCTIONAL_FORM')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class xc_functional1(printable):
    """The xc functional to use"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self.BECKE88 = becke881()
        self.LYP_ADIABATIC = lyp_adiabatic1()
        self.BECKE88_LR_ADIABATIC = becke88_lr_adiabatic1()
        self.BECKE88_LR = becke88_lr1()
        self.LYP = lyp1()
        self.PADE = pade1()
        self.listHCTH = []
        self.HCTH = hcth1()
        self.OPTX = optx1()
        self.LIBXC = libxc1()
        self.KE_LIBXC = ke_libxc1()
        self.CS1 = cs11()
        self.listXGGA = []
        self.XGGA = xgga1()
        self.listKE_GGA = []
        self.KE_GGA = ke_gga1()
        self.P86C = p86c1()
        self.listPW92 = []
        self.PW92 = pw921()
        self.listPZ81 = []
        self.PZ81 = pz811()
        self.TFW = tfw1()
        self.TF = tf1()
        self.VWN = vwn1()
        self.listXALPHA = []
        self.XALPHA = xalpha1()
        self.TPSS = tpss1()
        self.PBE = pbe1()
        self.XWPBE = xwpbe1()
        self.BECKE97 = becke971()
        self.BECKE_ROUSSEL = becke_roussel1()
        self.LDA_HOLE_T_C_LR = lda_hole_t_c_lr1()
        self.PBE_HOLE_T_C_LR = pbe_hole_t_c_lr1()
        self.GV09 = gv091()
        self.name = "XC_FUNCTIONAL"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('BECKE88', 'BECKE88'), ('LYP_ADIABATIC', 'LYP_ADIABATIC'), ('BECKE88_LR_ADIABATIC', 'BECKE88_LR_ADIABATIC'), ('BECKE88_LR', 'BECKE88_LR'), ('LYP', 'LYP'), ('PADE', 'PADE'), ('OPTX', 'OPTX'), ('LIBXC', 'LIBXC'), ('KE_LIBXC', 'KE_LIBXC'), ('CS1', 'CS1'), ('P86C', 'P86C'), ('TFW', 'TFW'), ('TF', 'TF'), ('VWN', 'VWN'), ('TPSS', 'TPSS'), ('PBE', 'PBE'), ('XWPBE', 'XWPBE'), ('BECKE97', 'BECKE97'), ('BECKE_ROUSSEL', 'BECKE_ROUSSEL'), ('LDA_HOLE_T_C_LR', 'LDA_HOLE_T_C_LR'), ('PBE_HOLE_T_C_LR', 'PBE_HOLE_T_C_LR'), ('GV09', 'GV09')]
        self.repeated_subsections = [('HCTH', 'hcth1'), ('XGGA', 'xgga1'), ('KE_GGA', 'ke_gga1'), ('PW92', 'pw921'), ('PZ81', 'pz811'), ('XALPHA', 'xalpha1')]

    def addHCTH(self):
        new_section = hcth1()
        self.listHCTH.append(new_section)
        return new_section

    def addXGGA(self):
        new_section = xgga1()
        self.listXGGA.append(new_section)
        return new_section

    def addKE_GGA(self):
        new_section = ke_gga1()
        self.listKE_GGA.append(new_section)
        return new_section

    def addPW92(self):
        new_section = pw921()
        self.listPW92.append(new_section)
        return new_section

    def addPZ81(self):
        new_section = pz811()
        self.listPZ81.append(new_section)
        return new_section

    def addXALPHA(self):
        new_section = xalpha1()
        self.listXALPHA.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class fit_basis1(printable):
    """Controls the printing of FIT BASIS task"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "FIT_BASIS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class structure_data1(printable):
    """Request the printing of special structure data during a structure optimization (in MOTION%PRINT) or when setting up a subsys (in SUBSYS%PRINT)."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._UNIT = None    # Specify the unit of measurement for the quantity in output. All available CP2K units can be used.
        self.list_POSITION = []
        self._POSITION = None
    # Print the position vectors in Cartesian coordinates of the atoms specified by a list of their indices
        self._POS = self._POSITION
        self.list_POS = self.list_POSITION
        self.list_POSITION_SCALED = []
        self._POSITION_SCALED = None
    # Print the position vectors in scaled coordinates of the atoms specified by a list of their indices
        self._POS_SCALED = self._POSITION_SCALED
        self.list_POS_SCALED = self.list_POSITION_SCALED
        self.list_DISTANCE = []
        self._DISTANCE = None
    # Print the distance between the atoms a and b specified by their indices
        self._DIS = self._DISTANCE
        self.list_DIS = self.list_DISTANCE
        self.list_ANGLE = []
        self._ANGLE = None
    # Print the angle formed by the atoms specified by their indices
        self._ANG = self._ANGLE
        self.list_ANG = self.list_ANGLE
        self.list_DIHEDRAL_ANGLE = []
        self._DIHEDRAL_ANGLE = None
    # Print the dihedral angle between the planes defined by the atoms (a,b,c) and the atoms (b,c,d) specified by their indices
        self._DIHEDRAL = self._DIHEDRAL_ANGLE
        self.list_DIHEDRAL = self.list_DIHEDRAL_ANGLE
        self._DIH = self._DIHEDRAL_ANGLE
        self.list_DIH = self.list_DIHEDRAL_ANGLE
        self.EACH = each1()
        self.name = "STRUCTURE_DATA"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_UNIT', 'UNIT')]
        self.repeated_keywords = [('_POSITION', 'POSITION'), ('_POS', 'POS'), ('_POSITION_SCALED', 'POSITION_SCALED'), ('_POS_SCALED', 'POS_SCALED'), ('_DISTANCE', 'DISTANCE'), ('_DIS', 'DIS'), ('_ANGLE', 'ANGLE'), ('_ANG', 'ANG'), ('_DIHEDRAL_ANGLE', 'DIHEDRAL_ANGLE'), ('_DIHEDRAL', 'DIHEDRAL'), ('_DIH', 'DIH')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def add_POSITION(self, value):
        self.list_POSITION.append(value)

    def add_POS(self, value):
        self.list_POS.append(value)

    def add_POSITION_SCALED(self, value):
        self.list_POSITION_SCALED.append(value)

    def add_POS_SCALED(self, value):
        self.list_POS_SCALED.append(value)

    def add_DISTANCE(self, value):
        self.list_DISTANCE.append(value)

    def add_DIS(self, value):
        self.list_DIS.append(value)

    def add_ANGLE(self, value):
        self.list_ANGLE.append(value)

    def add_ANG(self, value):
        self.list_ANG.append(value)

    def add_DIHEDRAL_ANGLE(self, value):
        self.list_DIHEDRAL_ANGLE.append(value)

    def add_DIHEDRAL(self, value):
        self.list_DIHEDRAL.append(value)

    def add_DIH(self, value):
        self.list_DIH.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class walls1(printable):
    """Enables Walls for the QM box. This can be used to avoid that QM  atoms move out of the QM box."""
    def __init__(self):
        self._WALL_SKIN = None    # Specify the value of the skin of the Wall in each dimension. The wall's effect is felt when atoms fall within the skin of the Wall.
        self._TYPE = None    # Specifies the type of wall
        self._K = None    # Specify the value of the the force constant for the quadratic wall
        self.name = "WALLS"
        self.keywords = [('_WALL_SKIN', 'WALL_SKIN'), ('_TYPE', 'TYPE'), ('_K', 'K')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class generic1(printable):
    """User driven coupling between two or more force_eval."""
    def __init__(self):
        self._MIXING_FUNCTION = None    # Specifies the mixing functional form in mathematical notation.
        self._VARIABLES = None    # Defines the variables of the functional form. To allow an efficient mapping the order of the energy variables will be considered identical to the order of the force_eval in the force_eval_order list.
        self.list_PARAMETERS = []
        self._PARAMETERS = None
    # Defines the parameters of the functional form
        self.list_VALUES = []
        self._VALUES = None
    # Defines the values of parameter of the functional form
        self.list_UNITS = []
        self._UNITS = None
    # Optionally, allows to define valid CP2K unit strings for each parameter value. It is assumed that the corresponding parameter value is specified in this unit.
        self._DX = None    # Parameter used for computing the derivative with the Ridders method.
        self._ERROR_LIMIT = None    # Checks that the error in computing the derivative is not larger than the value set. In case prints a warning message.
        self.name = "GENERIC"
        self.keywords = [('_MIXING_FUNCTION', 'MIXING_FUNCTION'), ('_VARIABLES', 'VARIABLES'), ('_DX', 'DX'), ('_ERROR_LIMIT', 'ERROR_LIMIT')]
        self.repeated_keywords = [('_PARAMETERS', 'PARAMETERS'), ('_VALUES', 'VALUES'), ('_UNITS', 'UNITS')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def add_PARAMETERS(self, value):
        self.list_PARAMETERS.append(value)

    def add_VALUES(self, value):
        self.list_VALUES.append(value)

    def add_UNITS(self, value):
        self.list_UNITS.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class cell_ref1(printable):
    """Input parameters needed to set up the CELL_REF."""
    def __init__(self):
        self._A = None    # Specify the Cartesian components for the cell vector A. This defines the first column of the h matrix.
        self._B = None    # Specify the Cartesian components for the cell vector B. This defines the second column of the h matrix.
        self._C = None    # Specify the Cartesian components for the cell vector C. This defines the third column of the h matrix.
        self._ABC = None    # Specify the lengths of the cell vectors A, B, and C, which defines the diagonal elements of h matrix for an orthorhombic cell. For non-orthorhombic cells it is possible either to specify the angles ALPHA, BETA, GAMMA via ALPHA_BETA_GAMMA keyword or alternatively use the keywords A, B, and C. The convention is that A lies along the X-axis, B is in the XY plane.
        self._ALPHA_BETA_GAMMA = None    # Specify the angles between the vectors A, B and C when using the ABC keyword. The convention is that A lies along the X-axis, B is in the XY plane. ALPHA is the angle between B and C, BETA is the angle between A and C and GAMMA the angle between A and B.
        self._ANGLES = self._ALPHA_BETA_GAMMA
        self._CELL_FILE_NAME = None    # Possibility to read the cell from an external file
        self._CELL_FILE_FORMAT = None    # Specify the format of the cell file (if used)
        self._PERIODIC = None    # Specify the directions for which periodic boundary conditions (PBC) will be applied. Important notice: This applies to the generation of the pair lists as well as to the application of the PBCs to positions. See the POISSON section to specify the periodicity used for the electrostatics. Typically the settings should be the same.
        self._MULTIPLE_UNIT_CELL = None    # Specifies the numbers of repetition in space (X, Y, Z) of the defined cell, assuming it as a unit cell. This keyword affects only the CELL specification. The same keyword in SUBSYS%TOPOLOGY%MULTIPLE_UNIT_CELL should be modified in order to affect the coordinates specification.
        self._SYMMETRY = None    # Imposes an initial cell symmetry.
        self.name = "CELL_REF"
        self.keywords = [('_A', 'A'), ('_B', 'B'), ('_C', 'C'), ('_ABC', 'ABC'), ('_ALPHA_BETA_GAMMA', 'ALPHA_BETA_GAMMA'), ('_ANGLES', 'ANGLES'), ('_CELL_FILE_NAME', 'CELL_FILE_NAME'), ('_CELL_FILE_FORMAT', 'CELL_FILE_FORMAT'), ('_PERIODIC', 'PERIODIC'), ('_MULTIPLE_UNIT_CELL', 'MULTIPLE_UNIT_CELL'), ('_SYMMETRY', 'SYMMETRY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class gaussian1(printable):
    """Parameters controlling the gaussian wall."""
    def __init__(self):
        self._WW = None    # Specify the height of the gaussian: WW*e^(-((CV-POS)/sigma)^2)
        self._SIGMA = None    # Specify the width of the gaussian: WW*e^(-((CV-POS)/sigma)^2)
        self.name = "GAUSSIAN"
        self.keywords = [('_WW', 'WW'), ('_SIGMA', 'SIGMA')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class properties1(printable):
    """This section is used to set up the PROPERTIES calculation."""
    def __init__(self):
        self.LINRES = linres1()
        self.ET_COUPLING = et_coupling1()
        self.RESP = resp1()
        self.ATOMIC = atomic1()
        self.FIT_CHARGE = fit_charge1()
        self.name = "PROPERTIES"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('LINRES', 'LINRES'), ('ET_COUPLING', 'ET_COUPLING'), ('RESP', 'RESP'), ('ATOMIC', 'ATOMIC'), ('FIT_CHARGE', 'FIT_CHARGE')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class ddapc_restraint1(printable):
    """Use DDAPC charges in a restraint (check code for details)"""
    def __init__(self):
        self._TYPE_OF_DENSITY = None    # Specifies the type of density used for the fitting
        self._STRENGTH = None    # force constant of the restraint
        self._TARGET = None    # target value of the restraint
        self._ATOMS = None    # Specifies the list of atoms that is summed in the restraint
        self._COEFF = None    # Defines the the coefficient of the atom in the atom list (default is one)
        self._FUNCTIONAL_FORM = None    # Specifies the functional form of the term added
        self.PROGRAM_RUN_INFO = program_run_info12()
        self.name = "DDAPC_RESTRAINT"
        self.keywords = [('_TYPE_OF_DENSITY', 'TYPE_OF_DENSITY'), ('_STRENGTH', 'STRENGTH'), ('_TARGET', 'TARGET'), ('_ATOMS', 'ATOMS'), ('_COEFF', 'COEFF'), ('_FUNCTIONAL_FORM', 'FUNCTIONAL_FORM')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class mt1(printable):
    """Sets up parameters of  Martyna-Tuckerman poisson solver. Note that exact results are only guaranteed if the unit cell is twice as large as charge density (and serious artefacts can result if the cell is much smaller)."""
    def __init__(self):
        self._ALPHA = None    # Convergence parameter ALPHA*RMIN. Default value 7.0
        self._REL_CUTOFF = None    # Specify the multiplicative factor for the CUTOFF keyword in MULTI_GRID  section. The result gives the cutoff at which the 1/r non-periodic FFT3D is evaluated.Default is 2.0
        self.name = "MT"
        self.keywords = [('_ALPHA', 'ALPHA'), ('_REL_CUTOFF', 'REL_CUTOFF')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class fix_atom_restart1(printable):
    """Specify restart position only for FIXED_ATOMS restraints."""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # The restarting position of fixed atoms for restraints. The order is an internal order. So if you decide to modify these values by hand first think what you're doing!
        self.name = "FIX_ATOM_RESTART"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class msd_kind1(printable):
    """Controls the output of msd per kind"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "MSD_KIND"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class wf_correlation1(printable):
    """Sets up the Wavefunction-based Correlation parameters if requested"""
    def __init__(self):
        self._METHOD = None    # Which method should be used to compute the MP2 energy
        self._MEMORY = None    # Maximum allowed total memory usage during MP2 methods [Mb].
        self._SCALE_S = None    # Scaling factor of the singlet energy component (opposite spin, OS).
        self._SCALE_T = None    # Scaling factor of the triplet energy component (same spin, SS).
        self._GROUP_SIZE = None    # Group size used in the computation of the integrals. Default is to use all processors (GROUP_SIZE=-1).A smaller group size (for example the node size), might a better choice if the actual MP2 time is large compared to integral computation time. This is usually the case if the total number of processors is not too large.
        self._NUMBER_PROC = self._GROUP_SIZE
        self._ROW_BLOCK = None    # Size of the row block used in the SCALAPACK block cyclic data distribution.Default is (ROW_BLOCK=-1) is automatic. A proper choice can speedup the parallel matrix multiplication in the case of RI-RPA and RI-SOS-MP2-Laplace.
        self._ROW_BLOCK_SIZE = self._ROW_BLOCK
        self._COL_BLOCK = None    # Size of the column block used in the SCALAPACK block cyclic data distribution.Default is (COL_BLOCK=-1) is automatic. A proper choice can speedup the parallel matrix multiplication in the case of RI-RPA and RI-SOS-MP2-Laplace.
        self._COL_BLOCK_SIZE = self._COL_BLOCK
        self._CALC_COND_NUM = None    # Calculate the condition number of the (P|Q) matrix for the RI methods.
        self._CALC_CONDITION_NUMBER = self._CALC_COND_NUM
        self.MP2_INFO = mp2_info1()
        self.DIRECT_CANONICAL = direct_canonical1()
        self.WFC_GPW = wfc_gpw1()
        self.RI_MP2 = ri_mp21()
        self.RI_RPA = ri_rpa1()
        self.RI_LAPLACE = ri_laplace1()
        self.INTERACTION_POTENTIAL = interaction_potential2()
        self.name = "WF_CORRELATION"
        self.keywords = [('_METHOD', 'METHOD'), ('_MEMORY', 'MEMORY'), ('_SCALE_S', 'SCALE_S'), ('_SCALE_T', 'SCALE_T'), ('_GROUP_SIZE', 'GROUP_SIZE'), ('_NUMBER_PROC', 'NUMBER_PROC'), ('_ROW_BLOCK', 'ROW_BLOCK'), ('_ROW_BLOCK_SIZE', 'ROW_BLOCK_SIZE'), ('_COL_BLOCK', 'COL_BLOCK'), ('_COL_BLOCK_SIZE', 'COL_BLOCK_SIZE'), ('_CALC_COND_NUM', 'CALC_COND_NUM'), ('_CALC_CONDITION_NUMBER', 'CALC_CONDITION_NUMBER')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('MP2_INFO', 'MP2_INFO'), ('DIRECT_CANONICAL', 'DIRECT_CANONICAL'), ('WFC_GPW', 'WFC_GPW'), ('RI_MP2', 'RI_MP2'), ('RI_RPA', 'RI_RPA'), ('RI_LAPLACE', 'RI_LAPLACE'), ('INTERACTION_POTENTIAL', 'INTERACTION_POTENTIAL')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class collective1(printable):
    """Used to constraint collective (general) degrees of freedom, writing langrangian multipliers to file."""
    def __init__(self):
        self._COLVAR = None    # Specifies the index (in input file order) of the type of colvar to constrain.
        self._MOLECULE = None    # Specifies the index of the molecule kind (in input file order)on which the constraint will be applied. MOLECULE and MOLNAME keyword exclude themself mutually.
        self._MOLNAME = None    # Specifies the name of the molecule on which the constraint will be applied.
        self._SEGNAME = self._MOLNAME
        self._INTERMOLECULAR = None    # Specify if the constraint/restraint is intermolecular.
        self._TARGET = None    # Specifies the target value of the constrained collective variable (units depend on the colvar).
        self._TARGET_GROWTH = None    # Specifies the growth speed of the target value of the constrained collective variable.
        self._TARGET_LIMIT = None    # Specifies the limit of the growth of the target value of the constrained collective variable. By default no limit at the colvar growth is set.
        self._EXCLUDE_QM = None    # Does not apply the constraint to the QM region within a QM/MM calculation
        self._EXCLUDE_MM = None    # Does not apply the constraint to the MM region within a QM/MM calculation
        self.RESTRAINT = restraint1()
        self.name = "COLLECTIVE"
        self.keywords = [('_COLVAR', 'COLVAR'), ('_MOLECULE', 'MOLECULE'), ('_MOLNAME', 'MOLNAME'), ('_SEGNAME', 'SEGNAME'), ('_INTERMOLECULAR', 'INTERMOLECULAR'), ('_TARGET', 'TARGET'), ('_TARGET_GROWTH', 'TARGET_GROWTH'), ('_TARGET_LIMIT', 'TARGET_LIMIT'), ('_EXCLUDE_QM', 'EXCLUDE_QM'), ('_EXCLUDE_MM', 'EXCLUDE_MM')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('RESTRAINT', 'RESTRAINT')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class tf1(printable):
    """Uses the TF functional"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self.name = "TF"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []
        pass

    def print_input(self, level):
        return printable.print_input(self, level)


class thermostat_fast1(printable):
    """Specify thermostat type and parameters controlling the thermostat."""
    def __init__(self):
        self._TYPE = None    # Specify the thermostat used for the constant temperature ensembles.
        self._REGION = None    # Determines the defined region for fast thermostat
        self.listDEFINE_REGION = []
        self.DEFINE_REGION = define_region2()
        self.NOSE = nose1()
        self.name = "THERMOSTAT_FAST"
        self.keywords = [('_TYPE', 'TYPE'), ('_REGION', 'REGION')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('NOSE', 'NOSE')]
        self.repeated_subsections = [('DEFINE_REGION', 'define_region2')]

    def addDEFINE_REGION(self):
        new_section = define_region2()
        self.listDEFINE_REGION.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class print28(printable):
    """Section of possible print options specific of the QMMM code."""
    def __init__(self):
        self.PGF = pgf1()
        self.POTENTIAL = potential1()
        self.MM_POTENTIAL = mm_potential1()
        self.QMMM_MATRIX = qmmm_matrix1()
        self.PROGRAM_BANNER = program_banner1()
        self.PROGRAM_RUN_INFO = program_run_info18()
        self.PERIODIC_INFO = periodic_info1()
        self.GRID_INFORMATION = grid_information2()
        self.DERIVATIVES = derivatives3()
        self.QMMM_CHARGES = qmmm_charges1()
        self.QMMM_LINK_INFO = qmmm_link_info1()
        self.QS_DERIVATIVES = qs_derivatives1()
        self.IMAGE_CHARGE_INFO = image_charge_info1()
        self.IMAGE_CHARGE_RESTART = image_charge_restart1()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PGF', 'PGF'), ('POTENTIAL', 'POTENTIAL'), ('MM_POTENTIAL', 'MM_POTENTIAL'), ('QMMM_MATRIX', 'QMMM_MATRIX'), ('PROGRAM_BANNER', 'PROGRAM_BANNER'), ('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('PERIODIC_INFO', 'PERIODIC_INFO'), ('GRID_INFORMATION', 'GRID_INFORMATION'), ('DERIVATIVES', 'DERIVATIVES'), ('QMMM_CHARGES', 'QMMM_CHARGES'), ('QMMM_LINK_INFO', 'QMMM_LINK_INFO'), ('QS_DERIVATIVES', 'QS_DERIVATIVES'), ('IMAGE_CHARGE_INFO', 'IMAGE_CHARGE_INFO'), ('IMAGE_CHARGE_RESTART', 'IMAGE_CHARGE_RESTART')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class cuda1(printable):
    """For CUDA support related input"""
    def __init__(self):
        self._MEMORY = None    # Allocates this much device memory (in kB)
        self.name = "CUDA"
        self.keywords = [('_MEMORY', 'MEMORY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class colvar_restart1(printable):
    """Specify restart position only for COLVAR restraints."""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # The restarting values for COLVAR restraints. The order is an internal order. So if you decide to modify these values by hand first think what you're doing!
        self.name = "COLVAR_RESTART"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class centroid_vel1(printable):
    """Controls the output of the centroid's velocity"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._UNIT = None    # Specify the unit of measurement for the quantity in output. All available CP2K units can be used.
        self._FORMAT = None    # Output file format for the velocity of centroid
        self.EACH = each1()
        self.name = "CENTROID_VEL"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_UNIT', 'UNIT'), ('_FORMAT', 'FORMAT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class pbe_hole_t_c_lr1(printable):
    """PBE exchange hole model in trucanted coulomb potential"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._SCALE_X = None    # scales the exchange part of the functional
        self._CUTOFF_RADIUS = None    # Defines cutoff for lower integration boundary
        self.name = "PBE_HOLE_T_C_LR"
        self.keywords = [('_SCALE_X', 'SCALE_X'), ('_CUTOFF_RADIUS', 'CUTOFF_RADIUS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class bmhft1(printable):
    """This section specifies the input parameters for BMHFT potential type.Functional form: V(r) = A * EXP(-B*r) - C/r^6 - D/r^8.Values available inside cp2k only for the Na/Cl pair."""
    def __init__(self):
        self._ATOMS = None    # Defines the atomic kind involved in the BMHFT nonbond potential
        self._MAP_ATOMS = None    # Defines the kinds for which internally is defined the BMHFT nonbond potential at the moment only Na and Cl.
        self._RCUT = None    # Defines the cutoff parameter of the BMHFT potential
        self._A = None    # Defines the A parameter of the Fumi-Tosi Potential
        self._B = None    # Defines the B parameter of the Fumi-Tosi Potential
        self._C = None    # Defines the C parameter of the Fumi-Tosi Potential
        self._D = None    # Defines the D parameter of the Fumi-Tosi Potential
        self._RMIN = None    # Defines the lower bound of the potential. If not set the range is the full range generate by the spline
        self._RMAX = None    # Defines the upper bound of the potential. If not set the range is the full range generate by the spline
        self.name = "BMHFT"
        self.keywords = [('_ATOMS', 'ATOMS'), ('_MAP_ATOMS', 'MAP_ATOMS'), ('_RCUT', 'RCUT'), ('_A', 'A'), ('_B', 'B'), ('_C', 'C'), ('_D', 'D'), ('_RMIN', 'RMIN'), ('_RMAX', 'RMAX')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class check_spline1(printable):
    """Controls the checking of the G-space term Spline Interpolation."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "CHECK_SPLINE"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class low_spin_roks1(printable):
    """Specify the details of the low spin ROKS method.In particular, one can specify various terms added to the energy of the high spin roks configuration with a energy scaling factor, and a prescription of the spin state."""
    def __init__(self):
        self._ENERGY_SCALING = None    # The scaling factors for each term added to the total energy.This list should contain one number for each term added to the total energy.
        self.list_SPIN_CONFIGURATION = []
        self._SPIN_CONFIGURATION = None
    # for each singly occupied orbital, specify if this should be an alpha (=1) or a beta (=2) orbitalThis keyword should be repeated, each repetition corresponding to an additional term.
        self.name = "LOW_SPIN_ROKS"
        self.keywords = [('_ENERGY_SCALING', 'ENERGY_SCALING')]
        self.repeated_keywords = [('_SPIN_CONFIGURATION', 'SPIN_CONFIGURATION')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def add_SPIN_CONFIGURATION(self, value):
        self.list_SPIN_CONFIGURATION.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class mode_selective1(printable):
    """All parameters needed for to run a mode selective vibrational analysis"""
    def __init__(self):
        self._FREQUENCY = None    # value close to the expected value of the frequency for to look for. If the block Davidson algorithm is applied, the nrep closest frequencies are tracked.
        self._RANGE = None    # Track modes in a given range of frequencies. No warranty that the set of frequencies is complete.
        self._ATOMS = None    # Specifies the list of atoms which should be displaced for the Initial guess
        self._EPS_MAX_VAL = None    # Convergence criterium for the davidson algorithm. Specifies the maximal value in the residuum vectors
        self._EPS_NORM = None    # Convergence criterium for the davidson algorithm. Specifies the maximal value of the norm of the residuum vectors
        self._INITIAL_GUESS = None    # The type of initial guess for the normal modes
        self._RESTART_FILE_NAME = None    # Specifies the name of the file used to create the restarted vectors
        self.INVOLVED_ATOMS = involved_atoms1()
        self.listPRINT = []
        self.PRINT = print43()
        self.name = "MODE_SELECTIVE"
        self.keywords = [('_FREQUENCY', 'FREQUENCY'), ('_RANGE', 'RANGE'), ('_ATOMS', 'ATOMS'), ('_EPS_MAX_VAL', 'EPS_MAX_VAL'), ('_EPS_NORM', 'EPS_NORM'), ('_INITIAL_GUESS', 'INITIAL_GUESS'), ('_RESTART_FILE_NAME', 'RESTART_FILE_NAME')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('INVOLVED_ATOMS', 'INVOLVED_ATOMS')]
        self.repeated_subsections = [('PRINT', 'print43')]

    def addPRINT(self):
        new_section = print43()
        self.listPRINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class mm_potential1(printable):
    """Controls the printing of the MM unidimensional potential on file"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "MM_POTENTIAL"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class atom1(printable):
    """Section handling input for atomic calculations."""
    def __init__(self):
        self._ATOMIC_NUMBER = None    # Specify the atomic number
        self._ELEMENT = None    # Specify the element to be calculated
        self._RUN_TYPE = None    # Type of run that you want to perform [ENERGY,BASIS_OPTIMIZATION,PSEUDOPOTENTIAL_OPTIMIZATION,,...]
        self._COULOMB_INTEGRALS = None    # Method to calculate Coulomb integrals
        self._EXCHANGE_INTEGRALS = None    # Method to calculate Exchange integrals
        self._CORE = None    # Specifies the core electrons for a pseudopotential
        self.list_ELECTRON_CONFIGURATION = []
        self._ELECTRON_CONFIGURATION = None
    # Specifies the electron configuration. Optional the multiplicity (m) and a core state [XX] can be declared
        self._MAX_ANGULAR_MOMENTUM = None    # Specifies the largest angular momentum calculated [0-3]
        self._CALCULATE_STATES = None    # Specifies the number of states calculated per l value
        self.PRINT = print45()
        self.AE_BASIS = ae_basis1()
        self.PP_BASIS = pp_basis1()
        self.listMETHOD = []
        self.METHOD = method1()
        self.OPTIMIZATION = optimization2()
        self.POTENTIAL = potential4()
        self.POWELL = powell1()
        self.name = "ATOM"
        self.keywords = [('_ATOMIC_NUMBER', 'ATOMIC_NUMBER'), ('_ELEMENT', 'ELEMENT'), ('_RUN_TYPE', 'RUN_TYPE'), ('_COULOMB_INTEGRALS', 'COULOMB_INTEGRALS'), ('_EXCHANGE_INTEGRALS', 'EXCHANGE_INTEGRALS'), ('_CORE', 'CORE'), ('_MAX_ANGULAR_MOMENTUM', 'MAX_ANGULAR_MOMENTUM'), ('_CALCULATE_STATES', 'CALCULATE_STATES')]
        self.repeated_keywords = [('_ELECTRON_CONFIGURATION', 'ELECTRON_CONFIGURATION')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PRINT', 'PRINT'), ('AE_BASIS', 'AE_BASIS'), ('PP_BASIS', 'PP_BASIS'), ('OPTIMIZATION', 'OPTIMIZATION'), ('POTENTIAL', 'POTENTIAL'), ('POWELL', 'POWELL')]
        self.repeated_subsections = [('METHOD', 'method1')]

    def addMETHOD(self):
        new_section = method1()
        self.listMETHOD.append(new_section)
        return new_section

    def add_ELECTRON_CONFIGURATION(self, value):
        self.list_ELECTRON_CONFIGURATION.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class hfx_ri1(printable):
    """All parameters needed in a HFX RI calculation"""
    def __init__(self):
        self._EPS_SCREENING = None    # Accuracy of geminal integral evaluation
        self._EPS_OPTIMIZATION = None    # Accuracy of iterative RI fit
        self._MAX_ITER = None    # Maximum number of iteration in RI fit
        self.PRINT = print20()
        self.name = "HFX_RI"
        self.keywords = [('_EPS_SCREENING', 'EPS_SCREENING'), ('_EPS_OPTIMIZATION', 'EPS_OPTIMIZATION'), ('_MAX_ITER', 'MAX_ITER')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PRINT', 'PRINT')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class pz811(printable):
    """Uses the PZ functional."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._PARAMETRIZATION = None    # Which one of parametrizations should be used
        self._SCALE_C = None    # scales the correlation part of the functional
        self.name = "PZ81"
        self.keywords = [('_PARAMETRIZATION', 'PARAMETRIZATION'), ('_SCALE_C', 'SCALE_C')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class free_energy1(printable):
    """Controls the calculation of free energy and free energy derivatives with different possible methods"""
    def __init__(self):
        self._METHOD = None    # Defines the method to use to compute free energy.
        self.METADYN = metadyn1()
        self.UMBRELLA_INTEGRATION = umbrella_integration1()
        self.ALCHEMICAL_CHANGE = alchemical_change1()
        self.FREE_ENERGY_INFO = free_energy_info1()
        self.name = "FREE_ENERGY"
        self.keywords = [('_METHOD', 'METHOD')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('METADYN', 'METADYN'), ('UMBRELLA_INTEGRATION', 'UMBRELLA_INTEGRATION'), ('ALCHEMICAL_CHANGE', 'ALCHEMICAL_CHANGE'), ('FREE_ENERGY_INFO', 'FREE_ENERGY_INFO')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class atom_list1(printable):
    """Defines a list of atoms for which the initial velocities are modified"""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Defines the list of atoms for which the velocities are modified. Each record consists of the atomic index, the velocity vector, and a weight to define which fraction of the total energy is assigned to the current atom.
        self.name = "ATOM_LIST"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class program_banner2(printable):
    """Controls the printing of the banner of the ATOM program"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PROGRAM_BANNER"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class replica_info1(printable):
    """Controls the printing of each replica info during a BAND run"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "REPLICA_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class compare_energies1(printable):
    """A comparison of energies between fit and reference"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "COMPARE_ENERGIES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class eip1(printable):
    """This section contains all information to run a EIP calculation."""
    def __init__(self):
        self._EIP_MODEL = None    # Selects the empirical interaction potential model
        self._EIPHYPMINMODEL = self._EIP_MODEL
        self.PRINT = print30()
        self.name = "EIP"
        self.keywords = [('_EIP_MODEL', 'EIP_MODEL'), ('_EIPHYPMINMODEL', 'EIP-MODEL')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PRINT', 'PRINT')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class helium1(printable):
    """The section that controls optional helium solvent environment (highly experimental, not for general use yet)"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._HELIUM_ONLY = None    # Simulate helium solvent only, disregard solute entirely
        self._NUM_ENV = None    # Number of independent helium environments (only for restarts, do not set explicitly)
        self._POTENTIAL_FILE_NAME = None    # Name of the Helium interaction potential file
        self._NATOMS = None    # Number of helium atoms
        self._NBEADS = None    # Number of helium path integral beads
        self._INOROT = None    # Number of MC iterations at the same time slice(s)
        self._IROT = None    # how often to reselect the time slice(s) to work on
        self._BISECTION = None    # how many time slices to change at once (+1). Must be a power of 2 currently
        self._MAX_PERM_CYCLE = None    # how large cyclic permutations to try
        self._PERIODIC = None    # Use periodic boundary conditions for helium
        self._CELL_SIZE = None    # PBC unit cell size (NOTE 1: density, number of atoms and volume are interdependent - give only two of them; NOTE 2: for small cell sizes specify NATOMS instead)
        self._CELL_SHAPE = None    # PBC unit cell shape for helium
        self._DENSITY = None    # trial density of helium for determining the helium box size
        self._PRESAMPLE = None    # Presample He coordinates before first PIMD step
        self._DROP_UNUSED_ENVS = None    # Drop He environments if N_restart > N_runtime (Warning: this will cause data loss in the restart file!)
        self.M_SAMPLING = mhypminsampling1()
        self.RDF = rdf1()
        self.RHO = rho1()
        self.COORD = coord4()
        self.PERM = perm1()
        self.FORCE = force2()
        self.RNG_STATE = rng_state1()
        self.PRINT = print12()
        self.name = "HELIUM"
        self.keywords = [('_HELIUM_ONLY', 'HELIUM_ONLY'), ('_NUM_ENV', 'NUM_ENV'), ('_POTENTIAL_FILE_NAME', 'POTENTIAL_FILE_NAME'), ('_NATOMS', 'NATOMS'), ('_NBEADS', 'NBEADS'), ('_INOROT', 'INOROT'), ('_IROT', 'IROT'), ('_BISECTION', 'BISECTION'), ('_MAX_PERM_CYCLE', 'MAX_PERM_CYCLE'), ('_PERIODIC', 'PERIODIC'), ('_CELL_SIZE', 'CELL_SIZE'), ('_CELL_SHAPE', 'CELL_SHAPE'), ('_DENSITY', 'DENSITY'), ('_PRESAMPLE', 'PRESAMPLE'), ('_DROP_UNUSED_ENVS', 'DROP_UNUSED_ENVS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('M_SAMPLING', 'M-SAMPLING'), ('RDF', 'RDF'), ('RHO', 'RHO'), ('COORD', 'COORD'), ('PERM', 'PERM'), ('FORCE', 'FORCE'), ('RNG_STATE', 'RNG_STATE'), ('PRINT', 'PRINT')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class mo_magnitude1(printable):
    """Prints the min/max eigenvalues of the overlap of the MOs without S (CT C)."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "MO_MAGNITUDE"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print27(printable):
    """Section of possible print options in FORCE_MIXING."""
    def __init__(self):
        self.SUBCELL = subcell2()
        self.NEIGHBOR_LISTS = neighbor_lists6()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('SUBCELL', 'SUBCELL'), ('NEIGHBOR_LISTS', 'NEIGHBOR_LISTS')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class replica1(printable):
    """Specify coordinates and velocities (possibly) of the replica"""
    def __init__(self):
        self._COLLECTIVE = None    # Specifies the value of the collective variables used in the projected BAND method. The order of the values is the order of the COLLECTIVE section in the constraints/restraints section
        self._COORD_FILE_NAME = None    # Name of the xyz file with coordinates (alternative to &COORD section)
        self.COORD = coord5()
        self.VELOCITY = velocity5()
        self.name = "REPLICA"
        self.keywords = [('_COLLECTIVE', 'COLLECTIVE'), ('_COORD_FILE_NAME', 'COORD_FILE_NAME')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('COORD', 'COORD'), ('VELOCITY', 'VELOCITY')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class cs11(printable):
    """Uses the CS1 functional"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self.name = "CS1"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []
        pass

    def print_input(self, level):
        return printable.print_input(self, level)


class combine_colvar1(printable):
    """Allows the possibility to combine several COLVARs into one COLVAR with a generic function."""
    def __init__(self):
        self._FUNCTION = None    # Specifies the function used to combine different COLVARs into one.
        self._VARIABLES = None    # Specifies the name of the variable that parametrises the FUNCTION defining how COLVARS should be combined. The matching follows the same order of the COLVARS definition in the input file.
        self.list_PARAMETERS = []
        self._PARAMETERS = None
    # Defines the parameters of the functional form
        self.list_VALUES = []
        self._VALUES = None
    # Defines the values of  parameter of the functional form
        self._DX = None    # Parameter used for computing the derivative of the combination of COLVARs with the Ridders method.
        self._ERROR_LIMIT = None    # Checks that the error in computing the derivative is not larger than the value set. In case prints a warning message.
        self.listCOLVAR = []
        self.COLVAR = colvar2()
        self.name = "COMBINE_COLVAR"
        self.keywords = [('_FUNCTION', 'FUNCTION'), ('_VARIABLES', 'VARIABLES'), ('_DX', 'DX'), ('_ERROR_LIMIT', 'ERROR_LIMIT')]
        self.repeated_keywords = [('_PARAMETERS', 'PARAMETERS'), ('_VALUES', 'VALUES')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('COLVAR', 'colvar2')]

    def addCOLVAR(self):
        new_section = colvar2()
        self.listCOLVAR.append(new_section)
        return new_section

    def add_PARAMETERS(self, value):
        self.list_PARAMETERS.append(value)

    def add_VALUES(self, value):
        self.list_VALUES.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class screening2(printable):
    """Sets up screening parameters if requested"""
    def __init__(self):
        self._EPS_SCHWARZ = None    # Screens the near field part of the electronic repulsion integrals using the Schwarz inequality for the given threshold.
        self._EPS_SCHWARZ_FORCES = None    # Screens the near field part of the electronic repulsion integrals using the Schwarz inequality for the given threshold. This will be approximately the accuracy of the forces,  and should normally be similar to EPS_SCF
        self._SCREEN_P_FORCES = None    # Screens the electronic repulsion integrals for the forces using the density matrix. This results in a significant speedup for large systems, but might require a somewhat tigher EPS_SCHWARZ_FORCES.
        self._SCREEN_ON_INITIAL_P = None    # Screen on an initial density matrix. For the first MD step this matrix must be provided by a Restart File.
        self._P_SCREEN_CORRECTION_FACTOR = None    # Recalculates integrals on the fly if the actual density matrix is larger by a given factor than the initial one. If the factor is set to 0.0_dp, this feature is disbled.
        self.name = "SCREENING"
        self.keywords = [('_EPS_SCHWARZ', 'EPS_SCHWARZ'), ('_EPS_SCHWARZ_FORCES', 'EPS_SCHWARZ_FORCES'), ('_SCREEN_P_FORCES', 'SCREEN_P_FORCES'), ('_SCREEN_ON_INITIAL_P', 'SCREEN_ON_INITIAL_P'), ('_P_SCREEN_CORRECTION_FACTOR', 'P_SCREEN_CORRECTION_FACTOR')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class kinetic_energy1(printable):
    """Controls the printing of the kinetic energy"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "KINETIC_ENERGY"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class screening1(printable):
    """Setup parameters for the tapering of the Coulomb/Exchange Screening in KDSO-D integral scheme,"""
    def __init__(self):
        self._RC_TAPER = None    # Atomic Cutoff Radius Cutoff for Tapering the screening term.
        self._RC_RANGE = None    # Range of cutoff switch function (tapering): 0.5*(1-TANH((r-r0)/RC_RANGE)), where r0=2*RC_TAPER-20*RC_RANGE.
        self.name = "SCREENING"
        self.keywords = [('_RC_TAPER', 'RC_TAPER'), ('_RC_RANGE', 'RC_RANGE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class rmsd1(printable):
    """Section to define a CV as function of RMSD computed with respect to given reference configurations. For 2 configurations the colvar is equal to: ss = (RMSDA-RMSDB)/(RMSDA+RMSDB), while if only 1 configuration is given, then the colvar is just the RMSD from that frame."""
    def __init__(self):
        self._SUBSET_TYPE = None    # Define the subsytem used to compute the RMSD
        self._ALIGN_FRAMES = None    # Whether the reference frames should be aligned to minimize the RMSD
        self.list_ATOMS = []
        self._ATOMS = None
    # Specify indexes of atoms building the subset.
        self.list_WEIGHTS = []
        self._WEIGHTS = None
    # Specify weights of atoms building the subset.
        self.listFRAME = []
        self.FRAME = frame1()
        self.name = "RMSD"
        self.keywords = [('_SUBSET_TYPE', 'SUBSET_TYPE'), ('_ALIGN_FRAMES', 'ALIGN_FRAMES')]
        self.repeated_keywords = [('_ATOMS', 'ATOMS'), ('_WEIGHTS', 'WEIGHTS')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('FRAME', 'frame1')]

    def addFRAME(self):
        new_section = frame1()
        self.listFRAME.append(new_section)
        return new_section

    def add_ATOMS(self, value):
        self.list_ATOMS.append(value)

    def add_WEIGHTS(self, value):
        self.list_WEIGHTS.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class cls_function_cubes1(printable):
    """Controls the printing of the relaxed orbitals"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._STRIDE = None    # The stride (X,Y,Z) used to write the cube file (larger values result in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1 number valid for all components.
        self._CUBES_LU_BOUNDS = None    # The lower and upper index of the states to be printed as cube
        self._CUBES_LU = self._CUBES_LU_BOUNDS
        self.list_CUBES_LIST = []
        self._CUBES_LIST = None
    # Indexes of the states to be printed as cube filesThis keyword can be repeated several times(useful if you have to specify many indexes).
        self._APPEND = None    # append the cube files when they already exist
        self.EACH = each1()
        self.name = "CLS_FUNCTION_CUBES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_STRIDE', 'STRIDE'), ('_CUBES_LU_BOUNDS', 'CUBES_LU_BOUNDS'), ('_CUBES_LU', 'CUBES_LU'), ('_APPEND', 'APPEND')]
        self.repeated_keywords = [('_CUBES_LIST', 'CUBES_LIST')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def add_CUBES_LIST(self, value):
        self.list_CUBES_LIST.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class periodic_efield1(printable):
    """parameters for finite periodic electric field computed using the Berry phase approach. IMPORTANT: Can only be used in combination  with OT. Can not be used in combination with RTP or EMD."""
    def __init__(self):
        self._INTENSITY = None    # Intensity of the electric field in a.u
        self._POLARISATION = None    # Polarisation vector of electric field
        self.name = "PERIODIC_EFIELD"
        self.keywords = [('_INTENSITY', 'INTENSITY'), ('_POLARISATION', 'POLARISATION')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class wnumber1(printable):
    """Controls the output of the helium winding number"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "WNUMBER"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class point1(printable):
    """Enables the possibility to use geometrical centers instead of single atoms to define colvars"""
    def __init__(self):
        self._TYPE = None    # Chooses the type of geometrical point
        self.list_ATOMS = []
        self._ATOMS = None
    # Specifies the indexes of atoms defining the geometrical center
        self.list_WEIGHTS = []
        self._WEIGHTS = None
    # Specifies the weights for a weighted geometrical center. Default is 1/natoms for every atom
        self._XYZ = None    # Specifies the xyz of the fixed point (if the case)
        self.name = "POINT"
        self.keywords = [('_TYPE', 'TYPE'), ('_XYZ', 'XYZ')]
        self.repeated_keywords = [('_ATOMS', 'ATOMS'), ('_WEIGHTS', 'WEIGHTS')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def add_ATOMS(self, value):
        self.list_ATOMS.append(value)

    def add_WEIGHTS(self, value):
        self.list_WEIGHTS.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class charges1(printable):
    """Allow to specify an array of classical charges, thus avoiding the packing and permitting the usage of different charges for same atomic types."""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Value of the charge for the individual atom. Order MUST reflect the one specified for the geometry.
        self.name = "CHARGES"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class epr1(printable):
    """The g tensor is calculated by DFPT"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._RESTART_EPR = None    # Restart the EPR calculation from a previous run (NOT WORKING)
        self.PRINT = print38()
        self.INTERPOLATOR = interpolator1()
        self.name = "EPR"
        self.keywords = [('_RESTART_EPR', 'RESTART_EPR')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PRINT', 'PRINT'), ('INTERPOLATOR', 'INTERPOLATOR')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class angles1(printable):
    """Defines new angles"""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Three integer indexes per line defining the new angle Indexes must be relative to the full system and not to the single molecules
        self.name = "ANGLES"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class center_coordinates1(printable):
    """Allows centering the coordinates of the system in the box. The centering point can be defined by the user."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._CENTER_POINT = None    # Specify the point used for centering the coordinates. Default is to center the system in cell/2.
        self.name = "CENTER_COORDINATES"
        self.keywords = [('_CENTER_POINT', 'CENTER_POINT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class involved_atoms1(printable):
    """All parameters needed for the tracking of modes dominated by the motion of selected atoms"""
    def __init__(self):
        self._RANGE = None    #  Specifies the range of wavenumbers in which the modes related to the ATOMS have to be tracked.  If not specified frequencies >400cm-1 will be used to avoid tracking of translational or rotational modes
        self._INVOLVED_ATOMS = None    # Specifies the list of atoms on which the tracked eigenvector should have the highest value similar to looking for the vibration of a set of atoms
        self.name = "INVOLVED_ATOMS"
        self.keywords = [('_RANGE', 'RANGE'), ('_INVOLVED_ATOMS', 'INVOLVED_ATOMS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class convergence_control2(printable):
    """Setup parameters to control the convergence criteria for BAND"""
    def __init__(self):
        self._MAX_DR = None    # Tolerance on the maximum value of the displacement on the BAND.
        self._MAX_FORCE = None    # Tolerance on the maximum value of Forces on the BAND.
        self._RMS_DR = None    # Tolerance on RMS displacements on the BAND.
        self._RMS_FORCE = None    # Tolerance on RMS Forces on the BAND.
        self.name = "CONVERGENCE_CONTROL"
        self.keywords = [('_MAX_DR', 'MAX_DR'), ('_MAX_FORCE', 'MAX_FORCE'), ('_RMS_DR', 'RMS_DR'), ('_RMS_FORCE', 'RMS_FORCE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class convergence_control1(printable):
    """This section specify parameters controlling the convergence of the free energy."""
    def __init__(self):
        self._COARSE_GRAINED_WIDTH = None    # Width of segments in MD steps to generate the set of coarse grained data, providing a correlation independent data set.
        self._CG_WIDTH = self._COARSE_GRAINED_WIDTH
        self._MAX_COARSE_GRAINED_WIDTH = None    # Max Width of segments in MD steps to generate the set of coarse grained data.
        self._MAX_CG_WIDTH = self._MAX_COARSE_GRAINED_WIDTH
        self._COARSE_GRAINED_POINTS = None    # Set the minimum amount of coarse grained points to collect before starting the statistical analysis
        self._CG_POINTS = self._COARSE_GRAINED_POINTS
        self._EPS_CONV = None    # Set the relative tolerance for the convergence of the collective variable averages used to compute the free energy.
        self._K_CONFIDENCE_LIMIT = None    # Set the confidence limit for the Mann-Kendall trend test.
        self._SW_CONFIDENCE_LIMIT = None    # Set the confidence limit for the Shapiro-Wilks normality test.
        self._VN_CONFIDENCE_LIMIT = None    # Set the confidence limit for the Von Neumann serial correlation test.
        self.name = "CONVERGENCE_CONTROL"
        self.keywords = [('_COARSE_GRAINED_WIDTH', 'COARSE_GRAINED_WIDTH'), ('_CG_WIDTH', 'CG_WIDTH'), ('_MAX_COARSE_GRAINED_WIDTH', 'MAX_COARSE_GRAINED_WIDTH'), ('_MAX_CG_WIDTH', 'MAX_CG_WIDTH'), ('_COARSE_GRAINED_POINTS', 'COARSE_GRAINED_POINTS'), ('_CG_POINTS', 'CG_POINTS'), ('_EPS_CONV', 'EPS_CONV'), ('_K_CONFIDENCE_LIMIT', 'K_CONFIDENCE_LIMIT'), ('_SW_CONFIDENCE_LIMIT', 'SW_CONFIDENCE_LIMIT'), ('_VN_CONFIDENCE_LIMIT', 'VN_CONFIDENCE_LIMIT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class moments1(printable):
    """Section controlling the calculation of MOMENTS. Note that the result in the periodic case might be defined modulo a certain period, determined by the lattice vectors. During MD, this can lead to jumps."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._PERIODIC = None    # Use Berry phase formula (PERIODIC=T) or simple operator (PERIODIC=F). The latter normally requires that the CELL is periodic NONE.
        self._REFERENCE = None    # Define the reference point for the calculation of the electrostatic moment.
        self._REF = self._REFERENCE
        self._REFERENCE_POINT = None    # Fixed reference point for the calculations of the electrostatic moment.
        self._REF_POINT = self._REFERENCE_POINT
        self._MAX_MOMENT = None    # Maximum moment to be calculated
        self._MAGNETIC = None    # Calculate also magnetic moments
        self.EACH = each1()
        self.name = "MOMENTS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_PERIODIC', 'PERIODIC'), ('_REFERENCE', 'REFERENCE'), ('_REF', 'REF'), ('_REFERENCE_POINT', 'REFERENCE_POINT'), ('_REF_POINT', 'REF_POINT'), ('_MAX_MOMENT', 'MAX_MOMENT'), ('_MAGNETIC', 'MAGNETIC')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class optical_conductivity1(printable):
    """Controls the printing of the optical conductivity."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "OPTICAL_CONDUCTIVITY"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class mass1(printable):
    """The masses for BAROSTAT used for restart"""
    def __init__(self):
        self._DEFAULT_KEYWORD = None    # Specify masses of the system
        self.name = "MASS"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []
        pass

    def print_input(self, level):
        return printable.print_input(self, level)


class mass3(printable):
    """Information to initialize the Ad-Langevin thermostat DOF MASS"""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Specify an initial thermostat DOF MASS for Ad-Langevin thermostat.
        self.name = "MASS"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class mapping1(printable):
    """Defines the mapping of atoms for the different force_eval with the mixed force_eval. The default is to have a mapping 1-1 between atom index (i.e. all force_eval share the same geometrical structure). The mapping is based on defining fragments and the mapping the  fragments between the several force_eval and the mixed force_eval"""
    def __init__(self):
        self.listFORCE_EVAL_MIXED = []
        self.FORCE_EVAL_MIXED = force_eval_mixed1()
        self.listFORCE_EVAL = []
        self.FORCE_EVAL = force_eval1()
        self.name = "MAPPING"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('FORCE_EVAL_MIXED', 'force_eval_mixed1'), ('FORCE_EVAL', 'force_eval1')]

    def addFORCE_EVAL_MIXED(self):
        new_section = force_eval_mixed1()
        self.listFORCE_EVAL_MIXED.append(new_section)
        return new_section

    def addFORCE_EVAL(self):
        new_section = force_eval1()
        self.listFORCE_EVAL.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class num2d_mc1(printable):
    """provides parameters for the 2D Monte Carlo procedure"""
    def __init__(self):
        self._MOVES = None    # Total number of Monte Carlo moves to use in the optimization
        self._CYCLES = None    # How many annealing cycles to use
        self._REDUCTION_STEPS = None    # How many temperature reduction steps have to be performed per cycle
        self._REDUCTION_FACTOR = None    # How to scale the temperature at each reduction step
        self._TEMPERATURE = None    # Highest temperature to be used (in units of the maximum cost of a non-zero 2D block)
        self._TOLERANCE = None    # If the found distribution is within a fraction of the theoretical optimal one, the optimization stops
        self._SWAP_PROBABILITY = None    # Probability of a col/row assignment swap
        self._OPT_TARGET = None    # The aim of the MC optimization
        self.PROGRAM_RUN_INFO = program_run_info11()
        self.name = "2D_MC"
        self.keywords = [('_MOVES', 'MOVES'), ('_CYCLES', 'CYCLES'), ('_REDUCTION_STEPS', 'REDUCTION_STEPS'), ('_REDUCTION_FACTOR', 'REDUCTION_FACTOR'), ('_TEMPERATURE', 'TEMPERATURE'), ('_TOLERANCE', 'TOLERANCE'), ('_SWAP_PROBABILITY', 'SWAP_PROBABILITY'), ('_OPT_TARGET', 'OPT_TARGET')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class ext_lagrange_fs1(printable):
    """Colvar force within an extended Lagrangian formalism.Used for RESTART."""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Specified the theta
        self.name = "EXT_LAGRANGE_FS"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class linres1(printable):
    """The linear response is used to calculate one of the  following properties: nmr, epr, raman, ..."""
    def __init__(self):
        self._EPS = None    # target accuracy for the convergence of the conjugate gradient.
        self._MAX_ITER = None    # Maximum number of conjugate gradient iteration to be performed for one optimization.
        self._RESTART_EVERY = None    # Restart the conjugate gradient after the specified number of iterations.
        self._PRECONDITIONER = None    # Type of preconditioner to be used with all minimization schemes. They differ in effectiveness, cost of construction, cost of application. Properly preconditioned minimization can be orders of magnitude faster than doing nothing.
        self._ENERGY_GAP = None    # Energy gap estimate [a.u.] for preconditioning
        self._RESTART = None    # Restart the response calculation if the restart file exists
        self._WFN_RESTART_FILE_NAME = None    # Root of the file names where to read the response functions fromwhich to restart the calculation of the linear response
        self._RESTART_FILE_NAME = self._WFN_RESTART_FILE_NAME
        self.LOCALIZE = localize1()
        self.CURRENT = current1()
        self.NMR = nmr1()
        self.SPINSPIN = spinspin1()
        self.EPR = epr1()
        self.PRINT = print39()
        self.name = "LINRES"
        self.keywords = [('_EPS', 'EPS'), ('_MAX_ITER', 'MAX_ITER'), ('_RESTART_EVERY', 'RESTART_EVERY'), ('_PRECONDITIONER', 'PRECONDITIONER'), ('_ENERGY_GAP', 'ENERGY_GAP'), ('_RESTART', 'RESTART'), ('_WFN_RESTART_FILE_NAME', 'WFN_RESTART_FILE_NAME'), ('_RESTART_FILE_NAME', 'RESTART_FILE_NAME')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('LOCALIZE', 'LOCALIZE'), ('CURRENT', 'CURRENT'), ('NMR', 'NMR'), ('SPINSPIN', 'SPINSPIN'), ('EPR', 'EPR'), ('PRINT', 'PRINT')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class curvy_steps1(printable):
    """Specifies the parameters of the linear scaling SCF routines"""
    def __init__(self):
        self._LINE_SEARCH = None    # Line serch type used in the curvy_setp optimization.
        self._N_BCH_HISTORY = None    # Number of stored matrices in the Baker-Campbell-Hausdorff series. Reduces the BCH evaluation during line search but can be memory intense.
        self._MIN_HESSIAN_SHIFT = None    # Minimal eigenvalue shift for the Hessian in the Newton iteration. Useful for small band gap systems (0.5-1.0 recommended).
        self._FILTER_FACTOR = None    # Allows to set a seperate EPS_FILTER in the newton iterations. The new EPS is EPS_FILTER*FILTER_FACTOR.
        self._FILTER_FACTOR_SCALE = None    # Allows for dynamic EPS_FILTER. Updates the filter factor every scf-newton step by FILTER_FACTOR=FILTER_FACTOR*FILTER_FACTOR_SCALE
        self._MIN_FILTER = None    # Lowest EPS_FILTER in dynamic filtering. Given as multiple of EPS_FILTER: EPS_FILTER_MIN=EPS_FILTER*MIN_FILTER
        self.name = "CURVY_STEPS"
        self.keywords = [('_LINE_SEARCH', 'LINE_SEARCH'), ('_N_BCH_HISTORY', 'N_BCH_HISTORY'), ('_MIN_HESSIAN_SHIFT', 'MIN_HESSIAN_SHIFT'), ('_FILTER_FACTOR', 'FILTER_FACTOR'), ('_FILTER_FACTOR_SCALE', 'FILTER_FACTOR_SCALE'), ('_MIN_FILTER', 'MIN_FILTER')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class scp1(printable):
    """Parameters needed to set up the SCP-DFT method"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._DISPERSION = None    # Use dispersion correction through SCP method
        self.PROGRAM_RUN_INFO = program_run_info11()
        self.name = "SCP"
        self.keywords = [('_DISPERSION', 'DISPERSION')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class force1(printable):
    """The forces for NOSE HOOVER used for restart"""
    def __init__(self):
        self._DEFAULT_KEYWORD = None    # Specify masses of the system
        self.name = "FORCE"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []
        pass

    def print_input(self, level):
        return printable.print_input(self, level)


class outer_scf1(printable):
    """parameters controlling the outer SCF loop"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._TYPE = None    # Specifies which kind of outer SCF should be employed
        self._OPTIMIZER = None    # Method used to bring the outer loop to a stationary point
        self._BISECT_TRUST_COUNT = None    # Maximum number of times the same point will be used in bisection, a small number guards against the effect of wrongly converged states.
        self._EPS_SCF = None    # The target gradient of the outer scf variables. Notice that the EPS_SCF of the inner loop also determines the value that can be reached in the outer loop, typically EPS_SCF of the outer loop must be smaller than EPS_SCF of the inner loop.
        self._DIIS_BUFFER_LENGTH = None    # Maximum number of DIIS vectors used
        self._EXTRAPOLATION_ORDER = None    # Number of past states used in the extrapolation of the variables during e.g. MD
        self._MAX_SCF = None    # The maximum number of outer loops
        self._STEP_SIZE = None    # The initial step_size used in the optimizer (currently steepest descent).Note that in cases where a sadle point is sought for (DDAPC_CONSTRAINT), this can be negative
        self.name = "OUTER_SCF"
        self.keywords = [('_TYPE', 'TYPE'), ('_OPTIMIZER', 'OPTIMIZER'), ('_BISECT_TRUST_COUNT', 'BISECT_TRUST_COUNT'), ('_EPS_SCF', 'EPS_SCF'), ('_DIIS_BUFFER_LENGTH', 'DIIS_BUFFER_LENGTH'), ('_EXTRAPOLATION_ORDER', 'EXTRAPOLATION_ORDER'), ('_MAX_SCF', 'MAX_SCF'), ('_STEP_SIZE', 'STEP_SIZE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class multiple_force_evals1(printable):
    """Describes how to handle multiple force_evals."""
    def __init__(self):
        self._FORCE_EVAL_ORDER = None    # Specify the orders of the different force_eval. When using a MIXED force_eval this does not need to be specified in this list, because it that takes into account only the real energy contributions
        self._MULTIPLE_SUBSYS = None    # Specify if force_eval have different subsys. In case they share the same subsys, it needs to be specified only in the MIXED force_eval (if using MIXED) or in the force_eval corresponding to first force_eval of the previous order (when not using MIXED).
        self.name = "MULTIPLE_FORCE_EVALS"
        self.keywords = [('_FORCE_EVAL_ORDER', 'FORCE_EVAL_ORDER'), ('_MULTIPLE_SUBSYS', 'MULTIPLE_SUBSYS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class ramp_env1(printable):
    """Parameters for an trapeziodal envelop"""
    def __init__(self):
        self._START_STEP_IN = None    # Step when the electric field starts to be applied
        self._END_STEP_IN = None    # Step when the field reaches the full strength
        self._START_STEP_OUT = None    # Step when the field starts to vanish
        self._END_STEP_OUT = None    # Step when the field disappears
        self.name = "RAMP_ENV"
        self.keywords = [('_START_STEP_IN', 'START_STEP_IN'), ('_END_STEP_IN', 'END_STEP_IN'), ('_START_STEP_OUT', 'START_STEP_OUT'), ('_END_STEP_OUT', 'END_STEP_OUT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class shell_forces1(printable):
    """controls the output of the forces on shells when shell-model is used"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._UNIT = None    # Specify the unit of measurement for the quantity in output. All available CP2K units can be used.
        self._FORMAT = None    # Specifies the format of the output file for the forces on shells.
        self.EACH = each1()
        self.name = "SHELL_FORCES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_UNIT', 'UNIT'), ('_FORMAT', 'FORMAT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class mixed1(printable):
    """This section contains all information to run with a hamiltonian defined by a mixing of force_evals"""
    def __init__(self):
        self._MIXING_TYPE = None    # The type of mixing to be employed
        self._GROUP_PARTITION = None    # gives the exact number of processors for each group. If not specified processors allocated will be equally distributed for the specified subforce_eval, trying to build a number of groups equal to the number of subforce_eval specified.
        self._NGROUPS = None    # Gives the wanted number of groups. If not specified the number of groups is set to the number of subforce_eval defined.
        self._NGROUP = self._NGROUPS
        self.LINEAR = linear1()
        self.COUPLING = coupling1()
        self.RESTRAINT = restraint2()
        self.GENERIC = generic1()
        self.listMAPPING = []
        self.MAPPING = mapping1()
        self.PRINT = print15()
        self.name = "MIXED"
        self.keywords = [('_MIXING_TYPE', 'MIXING_TYPE'), ('_GROUP_PARTITION', 'GROUP_PARTITION'), ('_NGROUPS', 'NGROUPS'), ('_NGROUP', 'NGROUP')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('LINEAR', 'LINEAR'), ('COUPLING', 'COUPLING'), ('RESTRAINT', 'RESTRAINT'), ('GENERIC', 'GENERIC'), ('PRINT', 'PRINT')]
        self.repeated_subsections = [('MAPPING', 'mapping1')]

    def addMAPPING(self):
        new_section = mapping1()
        self.listMAPPING.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class iteration_info1(printable):
    """Controls the printing of basic iteration information during the scf."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._TIME_CUMUL = None    # If the printkey is activated switches the printing of timings to cumulative (over the scf).
        self.EACH = each1()
        self.name = "ITERATION_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_TIME_CUMUL', 'TIME_CUMUL')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class cubes1(printable):
    """Controls the printing of cube files"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._STRIDE = None    # The stride (X,Y,Z) used to write the cube file (larger values result in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1 number valid for all components.
        self.EACH = each1()
        self.name = "CUBES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_STRIDE', 'STRIDE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class bond2(printable):
    """Section used to add/remove  bonds in the connectivity. Useful for systems with a complex connectivity, difficult to find out automatically."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self.list_ATOMS = []
        self._ATOMS = None
    # Specifies two atomic index united by a covalent bond
        self.name = "BOND"
        self.keywords = []
        self.repeated_keywords = [('_ATOMS', 'ATOMS')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def add_ATOMS(self, value):
        self.list_ATOMS.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class constrain_exponents1(printable):
    """specicifies contraints for the exponents to be fitted. Only a single constraint can be applied to an exponent"""
    def __init__(self):
        self._USE_EXP = None    # Defines the exponent to be constraint. The two integers indicate the set number and i'th exponent. The value -1 can be used to mark all sets/expoenents in a set.
        self._BOUNDARIES = None    # Defines the boundaries to which the optimization is restricted. First value is the lower bound, second value is the upper bound.
        self._MAX_VAR_FRACTION = None    # Defines the maximum fractionr by which the exponent is allowed to vary. e.g. 0.5 allows the exp to vary by 0.5*exp in both directions.
        self.name = "CONSTRAIN_EXPONENTS"
        self.keywords = [('_USE_EXP', 'USE_EXP'), ('_BOUNDARIES', 'BOUNDARIES'), ('_MAX_VAR_FRACTION', 'MAX_VAR_FRACTION')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class mixing1(printable):
    """Define type and parameters for mixingprocedures to be applied to the density matrix. Normally, only one type of mixing method should be accepted. The mixing procedures activated by this section are only active for diagonalization methods, i.e. not with minimization methods based on OT."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._METHOD = None    # Mixing method to be applied
        self._ALPHA = None    # Fraction of new density to be included
        self._BETA = None    # Denominator parameter in Kerker damping introduced to suppress charge sloshing: rho_mix(g) =rho_in(g) + alpha*g^2/(g^2 + beta^2)*(rho_out(g)-rho_in(g))
        self._PULAY_ALPHA = None    # Fraction of new density to be added to the Pulay expansion
        self._PULAY_BETA = None    # Fraction of residual contribution to be added to Pulay expansion
        self._NMIXING = None    # Minimal number of density mixing (should be greater than 0),before starting DIIS
        self._NBUFFER = None    # Number of previous steps stored for the actual mixing scheme
        self._NPULAY = self._NBUFFER
        self._NBROYDEN = self._NBUFFER
        self._NMULTISECANT = self._NBUFFER
        self._BROY_W0 = None    #  w0 parameter used in Broyden mixing
        self._BROY_WREF = None
        self._BROY_WMAX = None
        self._REGULARIZATION = None    # Regularization parameter to stabilize the inversion of the residual matrix {Yn^t Yn} in the multisecant mixing scheme (noise)
        self._MAX_STEP = None    # Upper bound for the magnitude of the unpredicted step size in the update by the multisecant mixing scheme
        self._R_FACTOR = None    # Control factor for the magnitude of the unpredicted step size in the update by the multisecant mixing scheme
        self._NSKIP = None    # Number of initial iteration for which the mixing is skipped
        self._NSKIP_MIXING = self._NSKIP
        self._N_SIMPLE_MIX = None    # Number of kerker damping iterations before starting other mixing procedures
        self._NSIMPLEMIX = self._N_SIMPLE_MIX
        self._KERKER_MIN = None    # Minimal Kerker damping factor: MAX(g^2/(g^2 + beta^2),KERKER_MIN)
        self._MAX_GVEC_EXP = None    # Restricts the G-space mixing to lower part of G-vector spectrum, up to a G0, by assigning the exponent of the Gaussian that can be represented by vectors smaller than G0 within a certain accuracy.
        self.name = "MIXING"
        self.keywords = [('_METHOD', 'METHOD'), ('_ALPHA', 'ALPHA'), ('_BETA', 'BETA'), ('_PULAY_ALPHA', 'PULAY_ALPHA'), ('_PULAY_BETA', 'PULAY_BETA'), ('_NMIXING', 'NMIXING'), ('_NBUFFER', 'NBUFFER'), ('_NPULAY', 'NPULAY'), ('_NBROYDEN', 'NBROYDEN'), ('_NMULTISECANT', 'NMULTISECANT'), ('_BROY_W0', 'BROY_W0'), ('_BROY_WREF', 'BROY_WREF'), ('_BROY_WMAX', 'BROY_WMAX'), ('_REGULARIZATION', 'REGULARIZATION'), ('_MAX_STEP', 'MAX_STEP'), ('_R_FACTOR', 'R_FACTOR'), ('_NSKIP', 'NSKIP'), ('_NSKIP_MIXING', 'NSKIP_MIXING'), ('_N_SIMPLE_MIX', 'N_SIMPLE_MIX'), ('_NSIMPLEMIX', 'NSIMPLEMIX'), ('_KERKER_MIN', 'KERKER_MIN'), ('_MAX_GVEC_EXP', 'MAX_GVEC_EXP')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class pdos1(printable):
    """Print out the DOS projected per kind and per angular momentum"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._COMPONENTS = None    # Print out pdos distinguishing all angular momentum components.
        self._APPEND = None    # Append the pdos obtained at different iterations to the pdos  output file.By defaut the file is overwritten
        self._NLUMO = None    # Number of virtual orbitals to be added to the MO set (-1=all)
        self._OUT_EACH_MO = None    # Output on the status of the calculation every OUT_EACH_MO states. If -1 no output
        self.EACH = each1()
        self.listLDOS = []
        self.LDOS = ldos1()
        self.listR_LDOS = []
        self.R_LDOS = r_ldos1()
        self.name = "PDOS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_COMPONENTS', 'COMPONENTS'), ('_APPEND', 'APPEND'), ('_NLUMO', 'NLUMO'), ('_OUT_EACH_MO', 'OUT_EACH_MO')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = [('LDOS', 'ldos1'), ('R_LDOS', 'r_ldos1')]

    def addLDOS(self):
        new_section = ldos1()
        self.listLDOS.append(new_section)
        return new_section

    def addR_LDOS(self):
        new_section = r_ldos1()
        self.listR_LDOS.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class optimization2(printable):
    """Section of information on optimization thresholds and algorithms."""
    def __init__(self):
        self._MAX_ITER = None    # Maximum number of iterations for optimization
        self._EPS_SCF = None    # Convergence criterion for SCF
        self._DAMPING = None    # Damping parameter for extrapolation method
        self._EPS_DIIS = None    # Starting DIIS method at convergence to EPS_DIIS
        self._N_DIIS = None    # Maximum number of DIIS vectors
        self.name = "OPTIMIZATION"
        self.keywords = [('_MAX_ITER', 'MAX_ITER'), ('_EPS_SCF', 'EPS_SCF'), ('_DAMPING', 'DAMPING'), ('_EPS_DIIS', 'EPS_DIIS'), ('_N_DIIS', 'N_DIIS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class exchange1(printable):
    """Setup parameters for the evaluation of the EXCHANGE and  core Hamiltonian terms in SE calculations."""
    def __init__(self):
        self._CUTOFF = None    # Atomic Cutoff Radius Cutoff for the evaluation of the Exchange integrals. For non-periodic calculation the default value is exactly the full cell dimension, in order to evaluate all pair interactions. Instead, for periodic calculations the default is the minimum value between 1/4 of the cell dimension and the value specified in input (either explicitly defined or the default numerical value).
        self._RC_TAPER = None    # Atomic Cutoff Radius Cutoff for Tapering Exchange integrals. If not specified it assumes the same value specified for the CUTOFF.
        self._RC_RANGE = None    # Range of cutoff switch function (tapering): 0.5*(1-TANH((r-r0)/RC_RANGE)), where r0=2.0*RC_TAPER-20.0*RC_RANGE.
        self.name = "EXCHANGE"
        self.keywords = [('_CUTOFF', 'CUTOFF'), ('_RC_TAPER', 'RC_TAPER'), ('_RC_RANGE', 'RC_RANGE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class v_resp_cube1(printable):
    """Controls the printing of the potential generated by the RESP CHARGES to a cube file. Prints the relative root-mean-square (RRMS) and root-mean-square (RMS) errors."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._STRIDE = None    # The stride (X,Y,Z) used to write the cube file (larger values result in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1 number valid for all components.
        self._APPEND = None    # append the cube files when they already exist
        self.EACH = each1()
        self.name = "V_RESP_CUBE"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_STRIDE', 'STRIDE'), ('_APPEND', 'APPEND')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class thermal_region1(printable):
    """Define regions where different initialization and control of the temperature is used."""
    def __init__(self):
        self._FORCE_RESCALING = None    # Control the rescaling ot the velocities in all the regions,  according to the temperature assigned to each reagion, when RESTART_VELOCITY in EXT_RESTART is active.
        self.listDEFINE_REGION = []
        self.DEFINE_REGION = define_region5()
        self.PRINT = print9()
        self.name = "THERMAL_REGION"
        self.keywords = [('_FORCE_RESCALING', 'FORCE_RESCALING')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PRINT', 'PRINT')]
        self.repeated_subsections = [('DEFINE_REGION', 'define_region5')]

    def addDEFINE_REGION(self):
        new_section = define_region5()
        self.listDEFINE_REGION.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class dump_pdb1(printable):
    """controls the dumping of the PDB at the starting geometry"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._CHARGE_OCCUP = None    # Write the MM charges to the OCCUP field of the PDB file
        self._CHARGE_O = self._CHARGE_OCCUP
        self._CHARGE_BETA = None    # Write the MM charges to the BETA field of the PDB file
        self._CHARGE_B = self._CHARGE_BETA
        self._CHARGE_EXTENDED = None    # Write the MM charges to the very last field of the PDB file (starting from column 81)
        self.EACH = each1()
        self.name = "DUMP_PDB"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_CHARGE_OCCUP', 'CHARGE_OCCUP'), ('_CHARGE_O', 'CHARGE_O'), ('_CHARGE_BETA', 'CHARGE_BETA'), ('_CHARGE_B', 'CHARGE_B'), ('_CHARGE_EXTENDED', 'CHARGE_EXTENDED')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class barostat1(printable):
    """Parameters of barostat."""
    def __init__(self):
        self._PRESSURE = None    # Initial pressure
        self._TIMECON = None    # Barostat time constant
        self._TEMPERATURE = None    # Barostat initial temperature. If not set, the ensemble temperature is used instead.
        self._TEMP_TOL = None    # Maximum oscillation of the Barostat temperature imposed by recaling.
        self._VIRIAL = None    # For NPT_F only: allows the screening of one or more components of the virial in order to relax the cell only along specific cartesian axis
        self.VELOCITY = velocity1()
        self.MASS = mass1()
        self.THERMOSTAT = thermostat1()
        self.PRINT = print7()
        self.name = "BAROSTAT"
        self.keywords = [('_PRESSURE', 'PRESSURE'), ('_TIMECON', 'TIMECON'), ('_TEMPERATURE', 'TEMPERATURE'), ('_TEMP_TOL', 'TEMP_TOL'), ('_VIRIAL', 'VIRIAL')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('VELOCITY', 'VELOCITY'), ('MASS', 'MASS'), ('THERMOSTAT', 'THERMOSTAT'), ('PRINT', 'PRINT')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class nmr1(printable):
    """The chemical shift is calculated by DFPT."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._INTERPOLATE_SHIFT = None    # Calculate the soft part of the chemical shift by interpolation
        self._NICS = None    # Calculate the chemical shift in a set of points   given from an external file
        self._NICS_FILE_NAME = None    # Name of the file with the NICS points coordinates
        self._RESTART_NMR = None    # Restart the NMR calculation from a previous run (NOT WORKING YET)
        self._SHIFT_GAPW_RADIUS = None    # While computing the local part of the shift (GAPW), the integration is restricted to nuclei that are within this radius.
        self.PRINT = print36()
        self.INTERPOLATOR = interpolator1()
        self.name = "NMR"
        self.keywords = [('_INTERPOLATE_SHIFT', 'INTERPOLATE_SHIFT'), ('_NICS', 'NICS'), ('_NICS_FILE_NAME', 'NICS_FILE_NAME'), ('_RESTART_NMR', 'RESTART_NMR'), ('_SHIFT_GAPW_RADIUS', 'SHIFT_GAPW_RADIUS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PRINT', 'PRINT'), ('INTERPOLATOR', 'INTERPOLATOR')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class mixed_energies1(printable):
    """Controls the output of the energies of the tworegular FORCE_EVALS in the MIXED methodprinted is step,time,Etot,E_F1,E_F2,CONS_QNT"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "MIXED_ENERGIES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class shell_trajectory1(printable):
    """Controls the output of the trajectory of shells when the shell-model is used"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._UNIT = None    # Specify the unit of measurement for the quantity in output. All available CP2K units can be used.
        self._FORMAT = None    # Specifies the format of the output file for the trajectory of shells.
        self._CHARGE_OCCUP = None    # Write the MM charges to the OCCUP field of the PDB file
        self._CHARGE_O = self._CHARGE_OCCUP
        self._CHARGE_BETA = None    # Write the MM charges to the BETA field of the PDB file
        self._CHARGE_B = self._CHARGE_BETA
        self._CHARGE_EXTENDED = None    # Write the MM charges to the very last field of the PDB file (starting from column 81)
        self.EACH = each1()
        self.name = "SHELL_TRAJECTORY"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_UNIT', 'UNIT'), ('_FORMAT', 'FORMAT'), ('_CHARGE_OCCUP', 'CHARGE_OCCUP'), ('_CHARGE_O', 'CHARGE_O'), ('_CHARGE_BETA', 'CHARGE_BETA'), ('_CHARGE_B', 'CHARGE_B'), ('_CHARGE_EXTENDED', 'CHARGE_EXTENDED')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class optx1(printable):
    """Uses the OPTX functional"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._SCALE_X = None    # scales the exchange part of the functional
        self.name = "OPTX"
        self.keywords = [('_SCALE_X', 'SCALE_X')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class pbe1(printable):
    """Uses the PBE functional"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._PARAMETRIZATION = None    # switches between the different parametrizations of the functional
        self._SCALE_X = None    # scales the exchange part of the functional
        self._SCALE_C = None    # scales the correlation part of the functional
        self.name = "PBE"
        self.keywords = [('_PARAMETRIZATION', 'PARAMETRIZATION'), ('_SCALE_X', 'SCALE_X'), ('_SCALE_C', 'SCALE_C')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class cell_opt1(printable):
    """This section sets the environment for the optimization of the simulation cell. Two possible schemes are available: (1) Zero temperature optimization;  (2) Finite temperature optimization."""
    def __init__(self):
        self._OPTIMIZER = None    # Specify which method to use to perform a geometry optimization.
        self._MINIMIZER = self._OPTIMIZER
        self._MAX_ITER = None    # Specifies the maximum number of geometry optimization steps. One step might imply several force evaluations for the CG and LBFGS optimizers.
        self._MAX_DR = None    # Convergence criterium for the maximum geometry change between the current and the last optimizer iteration.
        self._MAX_FORCE = None    # Convergence criterium for the maximum force component of the current configuration.
        self._RMS_DR = None    # Convergence criterium for the root mean square (RMS) geometry change between the current and the last optimizer iteration.
        self._RMS_FORCE = None    # Convergence criterium for the root mean square (RMS) force of the current configuration.
        self._STEP_START_VAL = None    # The starting step value for the CELL_OPT module.
        self._TYPE = None    # Specify which kind of method to use for the optimization of the simulation cell
        self._EXTERNAL_PRESSURE = None    # Specifies the external pressure (1 value or the full 9 components of the pressure tensor) applied during the cell optimization.
        self._KEEP_ANGLES = None    # Keep angles between the cell vectors constant, but allow the lenghts of the cell vectors to change independently. For example, a cubic cell might become orthorhombic, but not triclinic.
        self._KEEP_SYMMETRY = None    # Keep the requested initial cell symmetry (e.g. during a cell optimisation). See cell section for how to impose a cell symmetry.
        self._PRESSURE_TOLERANCE = None    # Specifies the Pressure tolerance (compared to the external pressure) to achieve during the cell optimization.
        self.LBFGS = lbfgs1()
        self.CG = cg1()
        self.BFGS = bfgs1()
        self.listPRINT = []
        self.PRINT = print4()
        self.name = "CELL_OPT"
        self.keywords = [('_OPTIMIZER', 'OPTIMIZER'), ('_MINIMIZER', 'MINIMIZER'), ('_MAX_ITER', 'MAX_ITER'), ('_MAX_DR', 'MAX_DR'), ('_MAX_FORCE', 'MAX_FORCE'), ('_RMS_DR', 'RMS_DR'), ('_RMS_FORCE', 'RMS_FORCE'), ('_STEP_START_VAL', 'STEP_START_VAL'), ('_TYPE', 'TYPE'), ('_EXTERNAL_PRESSURE', 'EXTERNAL_PRESSURE'), ('_KEEP_ANGLES', 'KEEP_ANGLES'), ('_KEEP_SYMMETRY', 'KEEP_SYMMETRY'), ('_PRESSURE_TOLERANCE', 'PRESSURE_TOLERANCE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('LBFGS', 'LBFGS'), ('CG', 'CG'), ('BFGS', 'BFGS')]
        self.repeated_subsections = [('PRINT', 'print4')]

    def addPRINT(self):
        new_section = print4()
        self.listPRINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class geminal1(printable):
    """Section used to specify a geminal basis set for QM calculations."""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # CP2K Basis Set Standard Format
        self.name = "GEMINAL"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class pair_potential1(printable):
    """Information on the pair potential to calculate dispersion"""
    def __init__(self):
        self._R_CUTOFF = None    # Range of potential. The cutoff will be 2 times this value
        self._TYPE = None    # Type of potential. DFTD2 and DFTD3 are the Grimme D2 and D3 methods respectively.
        self._PARAMETER_FILE_NAME = None    # Name of the parameter file, may include a path
        self._REFERENCE_FUNCTIONAL = None    # Use parameters for this specific density functional
        self._SCALING = None    # XC Functional dependent scaling parameter, if set to zero CP2K attempts to guess the xc functional that is in use and sets the associated scaling parameter.
        self._EXP_PRE = None    # Prefactor in exponential damping factor (DFT-D2 potential)
        self._EPS_CN = None    # Cutoff value for coordination number function (DFT-D3 method)
        self._D3_SCALING = None    # XC Functional dependent scaling parameters (s6,sr6,s8) for the DFT-D3 method,  if set to zero CP2K attempts to guess the xc functional from REFERENCE_FUNCTIONAL and sets the associated scaling parameter.
        self._CALCULATE_C9_TERM = None    # Calculate C9 terms in DFT-D3 model
        self._REFERENCE_C9_TERM = None    # Calculate C9 terms in DFT-D3 model using reference coordination numbers
        self._LONG_RANGE_CORRECTION = None    # Calculate a long range correction to the DFT-D3 model
        self._VERBOSE_OUTPUT = None    # Extensive output for the DFT-D2 and DFT-D3 models
        self.list_KIND_COORDINATION_NUMBERS = []
        self._KIND_COORDINATION_NUMBERS = None
    # Specifies the coordination number for a kind for the C9 term in DFT-D3.
        self.list_ATOM_COORDINATION_NUMBERS = []
        self._ATOM_COORDINATION_NUMBERS = None
    # Specifies the coordination number of a set of atoms for the C9 term in DFT-D3.
        self.list_ATOMPARM = []
        self._ATOMPARM = None
    # Specifies parameters for atom types (in atomic units). If not provided default parameters are used (DFT-D2).
        self.PRINT_DFTD = print_dftd1()
        self.name = "PAIR_POTENTIAL"
        self.keywords = [('_R_CUTOFF', 'R_CUTOFF'), ('_TYPE', 'TYPE'), ('_PARAMETER_FILE_NAME', 'PARAMETER_FILE_NAME'), ('_REFERENCE_FUNCTIONAL', 'REFERENCE_FUNCTIONAL'), ('_SCALING', 'SCALING'), ('_EXP_PRE', 'EXP_PRE'), ('_EPS_CN', 'EPS_CN'), ('_D3_SCALING', 'D3_SCALING'), ('_CALCULATE_C9_TERM', 'CALCULATE_C9_TERM'), ('_REFERENCE_C9_TERM', 'REFERENCE_C9_TERM'), ('_LONG_RANGE_CORRECTION', 'LONG_RANGE_CORRECTION'), ('_VERBOSE_OUTPUT', 'VERBOSE_OUTPUT')]
        self.repeated_keywords = [('_KIND_COORDINATION_NUMBERS', 'KIND_COORDINATION_NUMBERS'), ('_ATOM_COORDINATION_NUMBERS', 'ATOM_COORDINATION_NUMBERS'), ('_ATOMPARM', 'ATOMPARM')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PRINT_DFTD', 'PRINT_DFTD')]
        self.repeated_subsections = []

    def add_KIND_COORDINATION_NUMBERS(self, value):
        self.list_KIND_COORDINATION_NUMBERS.append(value)

    def add_ATOM_COORDINATION_NUMBERS(self, value):
        self.list_ATOM_COORDINATION_NUMBERS.append(value)

    def add_ATOMPARM(self, value):
        self.list_ATOMPARM.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class mulliken1(printable):
    """Controls the printing of the Mulliken (spin) population analysis"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._PRINT_GOP = None    # Print the gross orbital populations (GOP) in addition to the gross atomic populations (GAP) and net charges
        self._PRINT_ALL = None    # Print all information including the full net AO and overlap population matrix
        self.EACH = each1()
        self.name = "MULLIKEN"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_PRINT_GOP', 'PRINT_GOP'), ('_PRINT_ALL', 'PRINT_ALL')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class buffer_links1(printable):
    """Information about possible links for automatic covalent bond breaking for the buffer QM/MM calculation.Ignored - need to implement buffer selection by atom and walking of connectivity data."""
    def __init__(self):
        self.listLINK = []
        self.LINK = link1()
        self.name = "BUFFER_LINKS"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('LINK', 'link1')]

    def addLINK(self):
        new_section = link1()
        self.listLINK.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class compare_forces1(printable):
    """A comparison of forces between fit and reference"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "COMPARE_FORCES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class neighbor_lists3(printable):
    """Activates the printing of the neighbor lists used for the periodic SE calculations."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._UNIT = None    # Specify the unit of measurement for the quantity in output. All available CP2K units can be used.
        self.EACH = each1()
        self.name = "NEIGHBOR_LISTS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_UNIT', 'UNIT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class neighbor_lists2(printable):
    """This section specifies the input parameters for the construction of neighbor lists."""
    def __init__(self):
        self._VERLET_SKIN = None    # Defines the Verlet Skin for the generation of the neighbor lists
        self._NEIGHBOR_LISTS_FROM_SCRATCH = None    # This keyword enables the building of the neighbouring list from scratch.
        self._GEO_CHECK = None    # This keyword enables the check that two atoms are never below the minimum value used to construct the splines during the construction of the neighbouring list. Disabling this keyword avoids CP2K to abort in case two atoms are below the minimum  value of the radius used to generate the splines.
        self.name = "NEIGHBOR_LISTS"
        self.keywords = [('_VERLET_SKIN', 'VERLET_SKIN'), ('_NEIGHBOR_LISTS_FROM_SCRATCH', 'NEIGHBOR_LISTS_FROM_SCRATCH'), ('_GEO_CHECK', 'GEO_CHECK')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class neighbor_lists1(printable):
    """Controls the printing of the neighbor lists."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._UNIT = None    # Specify the unit of measurement for the quantity in output. All available CP2K units can be used.
        self._SAB_ORB_FULL = None    # Activates the printing of the full orbital orbital neighbor lists.
        self._SAB_ORB_MOLECULAR = None    # Activates the printing of the orbital orbital neighbor lists for molecular subsets.
        self.EACH = each1()
        self.name = "NEIGHBOR_LISTS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_UNIT', 'UNIT'), ('_SAB_ORB_FULL', 'SAB_ORB_FULL'), ('_SAB_ORB_MOLECULAR', 'SAB_ORB_MOLECULAR')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class gth_potential1(printable):
    """Section used to specify Potentials."""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # CP2K Pseudo Potential Standard Format (GTH, ALL or KG)
        self.name = "GTH_POTENTIAL"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class neighbor_lists7(printable):
    """Activates the printing of the neighbor lists used for generating the connectivity."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._UNIT = None    # Specify the unit of measurement for the quantity in output. All available CP2K units can be used.
        self.EACH = each1()
        self.name = "NEIGHBOR_LISTS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_UNIT', 'UNIT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class neighbor_lists6(printable):
    """Activates the printing of the neighbor lists used for the hysteretic region calculations."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._UNIT = None    # Specify the unit of measurement for the quantity in output. All available CP2K units can be used.
        self.EACH = each1()
        self.name = "NEIGHBOR_LISTS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_UNIT', 'UNIT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class neighbor_lists5(printable):
    """Activates the printing of the neighbor lists."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._UNIT = None    # Specify the unit of measurement for the quantity in output. All available CP2K units can be used.
        self.EACH = each1()
        self.name = "NEIGHBOR_LISTS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_UNIT', 'UNIT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class neighbor_lists4(printable):
    """Controls the printing of the neighbor lists"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._UNIT = None    # Specify the unit of measurement for the quantity in output. All available CP2K units can be used.
        self._SAB_ORB = None    # Activates the printing of the orbital orbital neighbor lists, i.e. the overlap neighbor lists
        self._SAB_AUX_FIT = None    # Activates the printing of the orbital orbital neighbor lists wavefunction fitting basis, i.e. the overlap neighbor lists
        self._SAB_AUX_FIT_VS_ORB = None    # Activates the printing of the orbital orbital mixed neighbor lists of wavefunction fitting basis, and the orbital basis, i.e. the overlap neighbor lists
        self._SAB_SCP = None    # Activates the printing of the vdW SCP neighbor lists
        self._SAB_VDW = None    # Activates the printing of the vdW neighbor lists (from DFT, DFTB, SE), i.e. the dispersion neighbor lists
        self._SAB_CN = None    # Activates the printing of the neighbor lists used for coordination numbers in vdW DFT-D3
        self._SAC_AE = None    # Activates the printing of the orbital nuclear attraction neighbor lists (erfc potential)
        self._SAC_PPL = None    # Activates the printing of the orbital GTH-PPL neighbor lists (local part of the Goedecker-Teter-Hutter pseudo potentials)
        self._SAP_PPNL = None    # Activates the printing of the orbital GTH-PPNL neighbor lists (non-local part of theGoedecker-Teter-Hutter pseudo potentials)
        self._SAP_OCE = None    # Activates the printing of the orbital PAW-projector neighbor lists (only GAPW)
        self._SAB_SE = None    # Activates the printing of the two-center neighbor lists for Coulomb type interactions in NDDO
        self._SAB_LRC = None    # Activates the printing of the long-range SE correction neighbor lists (only when doing long-range SE with integral scheme KDSO and KDSO-d)
        self._SAB_TBE = None    # Activates the printing of the DFTB Ewald neighbor lists
        self._SAB_CORE = None    # Activates the printing of core interaction neighbor lists
        self._SOO_LIST = None    # Activates the printing of RI orbital-orbital neighbor lists
        self._SIP_LIST = None    # Activates the printing of RI basis-projector interaction neighbor lists
        self.EACH = each1()
        self.name = "NEIGHBOR_LISTS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_UNIT', 'UNIT'), ('_SAB_ORB', 'SAB_ORB'), ('_SAB_AUX_FIT', 'SAB_AUX_FIT'), ('_SAB_AUX_FIT_VS_ORB', 'SAB_AUX_FIT_VS_ORB'), ('_SAB_SCP', 'SAB_SCP'), ('_SAB_VDW', 'SAB_VDW'), ('_SAB_CN', 'SAB_CN'), ('_SAC_AE', 'SAC_AE'), ('_SAC_PPL', 'SAC_PPL'), ('_SAP_PPNL', 'SAP_PPNL'), ('_SAP_OCE', 'SAP_OCE'), ('_SAB_SE', 'SAB_SE'), ('_SAB_LRC', 'SAB_LRC'), ('_SAB_TBE', 'SAB_TBE'), ('_SAB_CORE', 'SAB_CORE'), ('_SOO_LIST', 'SOO_LIST'), ('_SIP_LIST', 'SIP_LIST')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class torsions1(printable):
    """Defines new torsions"""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Four integer indexes per line defining the new torsion Indexes must be relative to the full system and not to the single molecules
        self.name = "TORSIONS"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class s2_restraint1(printable):
    """Use S2 in a re/constraint (OT only)"""
    def __init__(self):
        self._STRENGTH = None    # force constant of the restraint
        self._TARGET = None    # target value of the restraint
        self._FUNCTIONAL_FORM = None    # Specifies the functional form of the term added
        self.name = "S2_RESTRAINT"
        self.keywords = [('_STRENGTH', 'STRENGTH'), ('_TARGET', 'TARGET'), ('_FUNCTIONAL_FORM', 'FUNCTIONAL_FORM')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class qs_derivatives1(printable):
    """Print QM derivatives after QS calculation"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "QS_DERIVATIVES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class adiabatic_rescaling1(printable):
    """Parameters for self interation corrected hybrid functionals"""
    def __init__(self):
        self._FUNCTIONAL_TYPE = None    # Which Hybrid functional should be used. (Has to be consistent with the definitions in XC and HF).
        self._LAMBDA = None    # The point to be used along the adiabatic curve (0<lambda<1)
        self._OMEGA = None    # Long-range parameter
        self._FUNCTIONAL_MODEL = None    # Which model for the coupling constant integration should be used.
        self.name = "ADIABATIC_RESCALING"
        self.keywords = [('_FUNCTIONAL_TYPE', 'FUNCTIONAL_TYPE'), ('_LAMBDA', 'LAMBDA'), ('_OMEGA', 'OMEGA'), ('_FUNCTIONAL_MODEL', 'FUNCTIONAL_MODEL')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class program_banner1(printable):
    """Controls the printing of the banner of the MM program"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PROGRAM_BANNER"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class temp_control1(printable):
    """Setup parameters to control the temperature during a BAND MD run."""
    def __init__(self):
        self._TEMPERATURE = None    # Specify the target temperature
        self._TEMP_TOL = None    # Specify the tolerance on the temperature for rescaling
        self._TEMP_TOL_STEPS = None    # Specify the number of steps to apply a temperature control
        self.name = "TEMP_CONTROL"
        self.keywords = [('_TEMPERATURE', 'TEMPERATURE'), ('_TEMP_TOL', 'TEMP_TOL'), ('_TEMP_TOL_STEPS', 'TEMP_TOL_STEPS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class wfn_mix1(printable):
    """A section that allows manipulation of the MO coeffs, e.g. for changing a ground state into an excited state.Starting from a copy of the original MOs, changes can be madeby adding linear combinations of HOMO/LUMO of the original MOs to the result MOs"""
    def __init__(self):
        self._OVERWRITE_MOS = None    # If the keyword is active molecular orbitals in memory will be replaced by the mixed wfn. In combination with RTP or EMD no restart will be required to use the mixed wfn.
        self.listUPDATE = []
        self.UPDATE = update1()
        self.name = "WFN_MIX"
        self.keywords = [('_OVERWRITE_MOS', 'OVERWRITE_MOS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('UPDATE', 'update1')]

    def addUPDATE(self):
        new_section = update1()
        self.listUPDATE.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class parameter1(printable):
    """Information on where to find DFTB parameters"""
    def __init__(self):
        self.list_SK_FILE = []
        self._SK_FILE = None
    # Define parameter file for atom pair
        self._PARAM_FILE_PATH = None    # Specify the directory with the DFTB parameter files
        self._PARAM_FILE_NAME = None    # Specify file that contains the SK_FILE names
        self._UFF_FORCE_FIELD = None    # Name of file with UFF parameters
        self.name = "PARAMETER"
        self.keywords = [('_PARAM_FILE_PATH', 'PARAM_FILE_PATH'), ('_PARAM_FILE_NAME', 'PARAM_FILE_NAME'), ('_UFF_FORCE_FIELD', 'UFF_FORCE_FIELD')]
        self.repeated_keywords = [('_SK_FILE', 'SK_FILE')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def add_SK_FILE(self, value):
        self.list_SK_FILE.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class alchemical_change1(printable):
    """Controls the calculation of delta free energies with the alchemical change method."""
    def __init__(self):
        self._PARAMETER = None    # Defines the perturbing parameter of the alchemical change tranformation
        self._WEIGHTING_FUNCTION = None    # Specifies the weighting function (umbrella potential, part of the mixing function)
        self._EPS_CONV = None    # Set the relative tolerance for the convergence of the free energy derivative
        self._NEQUIL_STEPS = None    # Set the number of equilibration steps, skipped to compute averages
        self.name = "ALCHEMICAL_CHANGE"
        self.keywords = [('_PARAMETER', 'PARAMETER'), ('_WEIGHTING_FUNCTION', 'WEIGHTING_FUNCTION'), ('_EPS_CONV', 'EPS_CONV'), ('_NEQUIL_STEPS', 'NEQUIL_STEPS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class v_hartree_cube1(printable):
    """Controls the printing of a cube file with eletrostatic  potential generated by the total density (electrons+ions). It is  valid only for QS with GPW formalism ."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._STRIDE = None    # The stride (X,Y,Z) used to write the cube file (larger values result in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1 number valid for all components.
        self._APPEND = None    # append the cube files when they already exist
        self.EACH = each1()
        self.name = "V_HARTREE_CUBE"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_STRIDE', 'STRIDE'), ('_APPEND', 'APPEND')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class centroid_pos1(printable):
    """Controls the output of the centroid's position"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._UNIT = None    # Specify the unit of measurement for the quantity in output. All available CP2K units can be used.
        self._FORMAT = None    # Output file format for the positions of centroid
        self._CHARGE_OCCUP = None    # Write the MM charges to the OCCUP field of the PDB file
        self._CHARGE_O = self._CHARGE_OCCUP
        self._CHARGE_BETA = None    # Write the MM charges to the BETA field of the PDB file
        self._CHARGE_B = self._CHARGE_BETA
        self._CHARGE_EXTENDED = None    # Write the MM charges to the very last field of the PDB file (starting from column 81)
        self.EACH = each1()
        self.name = "CENTROID_POS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_UNIT', 'UNIT'), ('_FORMAT', 'FORMAT'), ('_CHARGE_OCCUP', 'CHARGE_OCCUP'), ('_CHARGE_O', 'CHARGE_O'), ('_CHARGE_BETA', 'CHARGE_BETA'), ('_CHARGE_B', 'CHARGE_B'), ('_CHARGE_EXTENDED', 'CHARGE_EXTENDED')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class optimize_input1(printable):
    """describes an input optimization job, in which parameters in input files get optimized."""
    def __init__(self):
        self._METHOD = None    # What kind of input optimization to perform.
        self._ACCURACY = None    # Final accuracy requested in optimization (RHOEND)
        self._STEP_SIZE = None    # Initial step size for search algorithm (RHOBEG)
        self._MAX_FUN = None    # Maximum number of function evaluations
        self._ITER_START_VAL = None    # Used for restarting, starting value of the iteration
        self._RANDOMIZE_VARIABLES = None    # Percentage randomization of the free variables applied initially
        self.listVARIABLE = []
        self.VARIABLE = variable1()
        self.listFORCE_MATCHING = []
        self.FORCE_MATCHING = force_matching1()
        self.HISTORY = history1()
        self.RESTART = restart9()
        self.name = "OPTIMIZE_INPUT"
        self.keywords = [('_METHOD', 'METHOD'), ('_ACCURACY', 'ACCURACY'), ('_STEP_SIZE', 'STEP_SIZE'), ('_MAX_FUN', 'MAX_FUN'), ('_ITER_START_VAL', 'ITER_START_VAL'), ('_RANDOMIZE_VARIABLES', 'RANDOMIZE_VARIABLES')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('HISTORY', 'HISTORY'), ('RESTART', 'RESTART')]
        self.repeated_subsections = [('VARIABLE', 'variable1'), ('FORCE_MATCHING', 'force_matching1')]

    def addVARIABLE(self):
        new_section = variable1()
        self.listVARIABLE.append(new_section)
        return new_section

    def addFORCE_MATCHING(self):
        new_section = force_matching1()
        self.listFORCE_MATCHING.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class exclude_ei_list1(printable):
    """Speficy bonds (via atom kinds) for fine tuning of 1-2 exclusion lists. If this section is not present the 1-2 exclusion is applied to all bond kinds. When this section is present the 1-2 exclusion is applied ONLY to the bonds defined herein. This section allows ONLY fine tuning of 1-2 interactions."""
    def __init__(self):
        self._BOND = None    # Specify the atom kinds involved in the bond for which 1-2 exclusion holds.
        self.name = "EXCLUDE_EI_LIST"
        self.keywords = [('_BOND', 'BOND')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class control1(printable):
    """Controls the printing of FP info at startup"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "CONTROL"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class isolated_atoms1(printable):
    """ This section specifies the  atoms that one considers isolated. Useful when present  ions in solution."""
    def __init__(self):
        self.list_LIST = []
        self._LIST = None
    # Specifies a list of atomic indexes of the isolated ion
        self.name = "ISOLATED_ATOMS"
        self.keywords = []
        self.repeated_keywords = [('_LIST', 'LIST')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def add_LIST(self, value):
        self.list_LIST.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class molecule1(printable):
    """Specify information about the connectivity of single molecules"""
    def __init__(self):
        self._NMOL = None    # number of molecules
        self._CONN_FILE_NAME = None    # Specifies the filename that contains the molecular connectivity.
        self._CONN_FILE = self._CONN_FILE_NAME
        self._CONN_FILE_FORMAT = None    # Ways to determine and generate a molecules. Default is to use GENERATE
        self._CONNECTIVITY = self._CONN_FILE_FORMAT
        self.name = "MOLECULE"
        self.keywords = [('_NMOL', 'NMOL'), ('_CONN_FILE_NAME', 'CONN_FILE_NAME'), ('_CONN_FILE', 'CONN_FILE'), ('_CONN_FILE_FORMAT', 'CONN_FILE_FORMAT'), ('_CONNECTIVITY', 'CONNECTIVITY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class bsse1(printable):
    """This section is used to set up the BSSE calculation. It also requires that for each atomic kind X a kind X_ghost is present, with the GHOST keyword specified, in addition to the other required fields."""
    def __init__(self):
        self.listFRAGMENT = []
        self.FRAGMENT = fragment3()
        self.listCONFIGURATION = []
        self.CONFIGURATION = configuration1()
        self.listFRAGMENT_ENERGIES = []
        self.FRAGMENT_ENERGIES = fragment_energies1()
        self.PRINT = print31()
        self.name = "BSSE"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PRINT', 'PRINT')]
        self.repeated_subsections = [('FRAGMENT', 'fragment3'), ('CONFIGURATION', 'configuration1'), ('FRAGMENT_ENERGIES', 'fragment_energies1')]

    def addFRAGMENT(self):
        new_section = fragment3()
        self.listFRAGMENT.append(new_section)
        return new_section

    def addCONFIGURATION(self):
        new_section = configuration1()
        self.listCONFIGURATION.append(new_section)
        return new_section

    def addFRAGMENT_ENERGIES(self):
        new_section = fragment_energies1()
        self.listFRAGMENT_ENERGIES.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class molden_vib1(printable):
    """Controls the printing for visualization in molden format"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "MOLDEN_VIB"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class restart_history1(printable):
    """Dumps unique restart files during the run keeping all of them.Most useful if recovery is needed at a later point."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "RESTART_HISTORY"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class restart_history2(printable):
    """Dumps unique MO restart files during the run keeping all of them."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._BACKUP_COPIES = None    # Specifies the maximum index of backup copies.
        self.EACH = each1()
        self.name = "RESTART_HISTORY"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_BACKUP_COPIES', 'BACKUP_COPIES')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class load_balance1(printable):
    """Parameters influencing the load balancing of the HF"""
    def __init__(self):
        self._NBINS = None    # Number of bins per process used to group atom quartets.
        self._BLOCK_SIZE = None    # Determines the blocking used for the atomic quartet loops. A proper choice can speedup the calculation. The default (-1) is automatic.
        self._RANDOMIZE = None    # This flag controls the randomization of the bin assignment to processes. For highly ordered input structures with a bad load balance, setting this flag to TRUE might improve.
        self.PRINT = print19()
        self.name = "LOAD_BALANCE"
        self.keywords = [('_NBINS', 'NBINS'), ('_BLOCK_SIZE', 'BLOCK_SIZE'), ('_RANDOMIZE', 'RANDOMIZE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PRINT', 'PRINT')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class job1(printable):
    """description of the jobs to be executed"""
    def __init__(self):
        self._DIRECTORY = None    # the directory in which the job should be executed
        self._INPUT_FILE_NAME = None    # the filename of the input file
        self._OUTPUT_FILE_NAME = None    # the filename of the output file, if not specified will use the project name in the &GLOBAL section.
        self._JOB_ID = None    # An ID used to indentify a job in DEPENDENCIES. JOB_IDs do not need to be unique, dependencies will be on all jobs with a given ID. If no JOB_ID is given, the index of the &JOB section in the input file will be used.
        self._DEPENDENCIES = None    # specifies a list of JOB_IDs on which the current job depends. The current job will not be executed before all the dependencies have finished. The keyword requires a MASTER_SLAVE farming run. Beyond the default case, some special cases might arise: 1) circular dependencies will lead to a deadlock. 2) This keyword is not compatible with CYCLE. 3) MAX_JOBS_PER_GROUP is ignored (though only a total of MAX_JOBS_PER_GROUP*NGROUPS jobs will be executed) 4) dependencies on jobs that will not be executed (due to RESTART or MAX_JOBS_PER_GROUP) are ignored. Additionally, note that, on some file systems,  output (restart) files might not be immediately available on all compute nodes,potentially resulting in unexpected failures.
        self.name = "JOB"
        self.keywords = [('_DIRECTORY', 'DIRECTORY'), ('_INPUT_FILE_NAME', 'INPUT_FILE_NAME'), ('_OUTPUT_FILE_NAME', 'OUTPUT_FILE_NAME'), ('_JOB_ID', 'JOB_ID'), ('_DEPENDENCIES', 'DEPENDENCIES')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class com1(printable):
    """Controls the output of the center of mass"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "COM"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class walkers_file_name1(printable):
    """Specify the basename for the NUMBER_OF_WALKERS files used to communicate between the walkers. Absolute path can be input as well together with the filename. One file will be created for each spawned hill."""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Specified the communication filename for each walker.
        self.name = "WALKERS_FILE_NAME"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class ext_lagrange_ss1(printable):
    """Colvar Theta within an extended Lagrangian formalism.Used for RESTART."""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Specified the theta
        self.name = "EXT_LAGRANGE_SS"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class dft_control_parameters1(printable):
    """Controls the printing of dft control parameters."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "DFT_CONTROL_PARAMETERS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class becke_roussel1(printable):
    """Becke Roussel exchange hole model. Can be usedas long range correction with a truncated coulomb potential"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._SCALE_X = None    # scales the exchange part of the functional
        self._CUTOFF_RADIUS = None    # Defines the cutoff radius for the truncation. If put to zero, the standard full range potential will be used
        self._GAMMA = None    # Parameter in the exchange hole. Usually this is put to 1.0 or 0.8
        self.name = "BECKE_ROUSSEL"
        self.keywords = [('_SCALE_X', 'SCALE_X'), ('_CUTOFF_RADIUS', 'CUTOFF_RADIUS'), ('_GAMMA', 'GAMMA')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class lr_correction1(printable):
    """Setup parameters for the evaluation of the long-range correction term in SE calculations."""
    def __init__(self):
        self._CUTOFF = None    # Atomic Cutoff Radius Cutoff for the evaluation of the long-ranbe correction integrals.
        self._RC_TAPER = None    # Atomic Cutoff Radius Cutoff for Tapering the long-range correction integrals. If not specified it assumes the same value specified for the CUTOFF.
        self._RC_RANGE = None    # Range of cutoff switch function (tapering): 0.5*(1-TANH((r-r0)/RC_RANGE)), where r0=2.0*RC_TAPER-20.0*RC_RANGE.
        self.name = "LR_CORRECTION"
        self.keywords = [('_CUTOFF', 'CUTOFF'), ('_RC_TAPER', 'RC_TAPER'), ('_RC_RANGE', 'RC_RANGE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class davidson2(printable):
    """Controls the printing of information on Davidson iterations."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "DAVIDSON"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class davidson1(printable):
    """"""
    def __init__(self):
        self._PRECONDITIONER = None    # Type of preconditioner to be used with all minimization schemes.
        self._PRECOND_SOLVER = None    # How the preconditioner is applied to the residual.
        self._ENERGY_GAP = None    # Should be an estimate for the energy gap [a.u.] (HOMO-LUMO) and is used in preconditioning, especially effective with the FULL_ALL preconditioner, in which case it should be an underestimate of the gap (0.001 doing normally fine). For the other preconditioners, making this value larger (0.2) will tame the preconditioner in case of poor initial guesses.
        self._NEW_PREC_EACH = None    # Number of SCF iterations after which a new Preconditioner is computed
        self._FIRST_PREC = None    # First SCF iteration at which a Preconditioner is employed
        self._CONV_MOS_PERCENT = None    # Minimal percent of MOS that have to converge within the Davidson loop before the SCF iteration is completed and a new Hamiltonian is computed
        self._SPARSE_MOS = None    # Use MOS as sparse matrix and avoid as much as possible multiplications with full matrices
        self.name = "DAVIDSON"
        self.keywords = [('_PRECONDITIONER', 'PRECONDITIONER'), ('_PRECOND_SOLVER', 'PRECOND_SOLVER'), ('_ENERGY_GAP', 'ENERGY_GAP'), ('_NEW_PREC_EACH', 'NEW_PREC_EACH'), ('_FIRST_PREC', 'FIRST_PREC'), ('_CONV_MOS_PERCENT', 'CONV_MOS_PERCENT'), ('_SPARSE_MOS', 'SPARSE_MOS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class method_info1(printable):
    """Controls the printing of method information"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "METHOD_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class topology_info1(printable):
    """controls the printing of information in the topology settings"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._XTL_INFO = None    # Prints information when parsing XTL files.
        self._CIF_INFO = None    # Prints information when parsing CIF files.
        self._PDB_INFO = None    # Prints information when parsing PDB files.
        self._XYZ_INFO = None    # Prints information when parsing XYZ files.
        self._PSF_INFO = None    # Prints information when parsing PSF files.
        self._AMBER_INFO = None    # Prints information when parsing ABER topology files.
        self._G96_INFO = None    # Prints information when parsing G96 files.
        self._CRD_INFO = None    # Prints information when parsing CRD files.
        self._GTOP_INFO = None    # Prints information when parsing GROMOS topology files.
        self._UTIL_INFO = None    # Prints information regarding topology utilities
        self._GENERATE_INFO = None    # Prints information regarding topology generation
        self.EACH = each1()
        self.name = "TOPOLOGY_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_XTL_INFO', 'XTL_INFO'), ('_CIF_INFO', 'CIF_INFO'), ('_PDB_INFO', 'PDB_INFO'), ('_XYZ_INFO', 'XYZ_INFO'), ('_PSF_INFO', 'PSF_INFO'), ('_AMBER_INFO', 'AMBER_INFO'), ('_G96_INFO', 'G96_INFO'), ('_CRD_INFO', 'CRD_INFO'), ('_GTOP_INFO', 'GTOP_INFO'), ('_UTIL_INFO', 'UTIL_INFO'), ('_GENERATE_INFO', 'GENERATE_INFO')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class constraint_info1(printable):
    """Prints information about iterative constraints solutions"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "CONSTRAINT_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class dbcsr1(printable):
    """Configuration options for the DBCSR library."""
    def __init__(self):
        self._SUBCOMMUNICATORS = None    # Use MPI subcommunicators for transfers that are limited to process grid rows and columns.
        self._COMBINED_TYPES = None    # Combine matrix index and data into a single MPI derived data type for communication (avoid using).
        self._USE_MPI_ALLOCATION = None    # Allow use of MPI-allocated memory for potentially faster network communication.
        self._USE_CUDA_HOST_ALLOCATION = None    # Allow use of CUDA-allocated host-pinned memory (avoid using). (not available)
        self._MM_STACK_SIZE = None    # Size of multiplication parameter stack.
        self._MM_DRIVER = None    # Select which routines to use for matrix block multiplications.
        self._N_SIZE_MNK_STACKS = None    # Number of stacks to use for distinct atomic sizes (e.g., 2 for a system of mostly waters).
        self._N_STACK_BUFFERS = None    # Number of stack buffers to use (e.g., 2 when using GPUs)
        self._USE_COMM_THREAD = None    # During multiplication, use a thread to periodically poll MPI to progress outstanding message completions.  This is beneficial on systems without a DMA-capable network adapter e.g. Cray XE6.
        self._COMM_THREAD_LOAD = None    # If a communications thread is used, specify how much multiplication workload (%) the thread should perform in addition to communication tasks
        self.name = "DBCSR"
        self.keywords = [('_SUBCOMMUNICATORS', 'SUBCOMMUNICATORS'), ('_COMBINED_TYPES', 'COMBINED_TYPES'), ('_USE_MPI_ALLOCATION', 'USE_MPI_ALLOCATION'), ('_USE_CUDA_HOST_ALLOCATION', 'USE_CUDA_HOST_ALLOCATION'), ('_MM_STACK_SIZE', 'MM_STACK_SIZE'), ('_MM_DRIVER', 'MM_DRIVER'), ('_N_SIZE_MNK_STACKS', 'N_SIZE_MNK_STACKS'), ('_N_STACK_BUFFERS', 'N_STACK_BUFFERS'), ('_USE_COMM_THREAD', 'USE_COMM_THREAD'), ('_COMM_THREAD_LOAD', 'COMM_THREAD_LOAD')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class direct_canonical1(printable):
    """Parameters influencing the direct canonical method"""
    def __init__(self):
        self._BIG_SEND = None    # Send big messages between processes (useful for >48 processors).
        self.name = "DIRECT_CANONICAL"
        self.keywords = [('_BIG_SEND', 'BIG_SEND')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class dipoles1(printable):
    """Specifies the dipoles of the particles."""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # The dipole components for each atom.
        self.name = "DIPOLES"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class multipole1(printable):
    """This section is used to set up the decoupling of QM periodic images with the use of density derived atomic point charges."""
    def __init__(self):
        self._RCUT = None    # Real space cutoff for the Ewald sum.
        self._EWALD_PRECISION = None    # Precision achieved in the Ewald sum.
        self._ANALYTICAL_GTERM = None    # Evaluates the Gterm in the Ewald Scheme analytically instead of using Splines.
        self._NGRIDS = None    # Specifies the number of grid points used for the Interpolation of the G-space term
        self.INTERPOLATOR = interpolator2()
        self.CHECK_SPLINE = check_spline1()
        self.PROGRAM_RUN_INFO = program_run_info11()
        self.name = "MULTIPOLE"
        self.keywords = [('_RCUT', 'RCUT'), ('_EWALD_PRECISION', 'EWALD_PRECISION'), ('_ANALYTICAL_GTERM', 'ANALYTICAL_GTERM'), ('_NGRIDS', 'NGRIDS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('INTERPOLATOR', 'INTERPOLATOR'), ('CHECK_SPLINE', 'CHECK_SPLINE'), ('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class csvr1(printable):
    """Parameters of the canonical sampling through velocity rescaling thermostat."""
    def __init__(self):
        self._TIMECON = None    # Time constant of the CSVR thermostat. A small time constant will result in strong thermostatting (useful for initial equilibrations) and a large time constant would be adequate to get weak thermostatting in production runs.
        self.THERMOSTAT_ENERGY = thermostat_energy1()
        self.RNG_INIT = rng_init1()
        self.name = "CSVR"
        self.keywords = [('_TIMECON', 'TIMECON')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('THERMOSTAT_ENERGY', 'THERMOSTAT_ENERGY'), ('RNG_INIT', 'RNG_INIT')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class beads1(printable):
    """Sets positions and velocities of the beads"""
    def __init__(self):
        self.COORD = coord2()
        self.VELOCITY = velocity3()
        self.name = "BEADS"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('COORD', 'COORD'), ('VELOCITY', 'VELOCITY')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class se1(printable):
    """Parameters needed to set up the Semi-empirical methods"""
    def __init__(self):
        self._ORTHOGONAL_BASIS = None    # Assume orthogonal basis set. This flag is overwritten by methods with fixed orthogonal/non-orthogonal basis set.
        self._STO_NG = None    # Provides the order of the Slater orbital expansion of Gaussian-Type Orbitals.
        self._ANALYTICAL_GRADIENTS = None    # Nuclear Gradients are computed analytically or numerically
        self._DELTA = None    # Step size in finite difference force calculation
        self._INTEGRAL_SCREENING = None    # Specifies the functional form for the
        self._PERIODIC = None    # Specifies the type of treatment for the electrostatic long-range part in semi-empirical calculations.
        self._SCP = None    # Perform a SCP-NDDO calculation
        self._FORCE_KDSOHYPMIND_EXCHANGE = None    # This keywords forces the usage of the KDSO-D integral screening for the Exchange integrals (default is to apply the screening only to the Coulomb integrals.
        self.COULOMB = coulomb1()
        self.EXCHANGE = exchange1()
        self.SCREENING = screening1()
        self.LR_CORRECTION = lr_correction1()
        self.NEIGHBOR_LISTS = neighbor_lists2()
        self.MEMORY = memory1()
        self.PRINT = print18()
        self.GA = ga1()
        self.name = "SE"
        self.keywords = [('_ORTHOGONAL_BASIS', 'ORTHOGONAL_BASIS'), ('_STO_NG', 'STO_NG'), ('_ANALYTICAL_GRADIENTS', 'ANALYTICAL_GRADIENTS'), ('_DELTA', 'DELTA'), ('_INTEGRAL_SCREENING', 'INTEGRAL_SCREENING'), ('_PERIODIC', 'PERIODIC'), ('_SCP', 'SCP'), ('_FORCE_KDSOHYPMIND_EXCHANGE', 'FORCE_KDSO-D_EXCHANGE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('COULOMB', 'COULOMB'), ('EXCHANGE', 'EXCHANGE'), ('SCREENING', 'SCREENING'), ('LR_CORRECTION', 'LR_CORRECTION'), ('NEIGHBOR_LISTS', 'NEIGHBOR_LISTS'), ('MEMORY', 'MEMORY'), ('PRINT', 'PRINT'), ('GA', 'GA')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class atomic1(printable):
    """Controls the calculation and printing of atomic properties"""
    def __init__(self):
        self._ENERGY = None    # Calculate atomic energies
        self._PRESSURE = None    # Calculate atomic pressure tensors
        self.PRINT = print41()
        self.name = "ATOMIC"
        self.keywords = [('_ENERGY', 'ENERGY'), ('_PRESSURE', 'PRESSURE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PRINT', 'PRINT')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class langevin1(printable):
    """Controls the set of parameters to run a Langevin MD"""
    def __init__(self):
        self._GAMMA = None    # Gamma parameter for the Langevin dynamics (LD)
        self._NOISY_GAMMA = None    # Imaginary Langevin Friction term for LD with noisy forces.
        self._NOISYGAMMA = self._NOISY_GAMMA
        self._SHADOW_GAMMA = None    # Shadow Langevin Friction term for LD with noisy forces in order to adjust Noisy_Gamma.
        self._SHADOWGAMMA = self._SHADOW_GAMMA
        self.name = "LANGEVIN"
        self.keywords = [('_GAMMA', 'GAMMA'), ('_NOISY_GAMMA', 'NOISY_GAMMA'), ('_NOISYGAMMA', 'NOISYGAMMA'), ('_SHADOW_GAMMA', 'SHADOW_GAMMA'), ('_SHADOWGAMMA', 'SHADOWGAMMA')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class ddapc_restraint_a1(printable):
    """Use DDAPC charges in a restraint (check code for details), section can be repeated, but only one constraint is possible at the moment."""
    def __init__(self):
        self._STRENGTH = None    # force constant of the restraint
        self._TYPE_OF_DENSITY = None    # Specifies the type of density used for the fitting
        self._TARGET = None    # target value of the restraint
        self._ATOMS = None    # Specifies the list of atoms that is summed in the restraint
        self._COEFF = None    # Defines the the coefficient of the atom in the atom list (default is one), currently DDAPC only
        self._FUNCTIONAL_FORM = None    # Specifies the functional form of the term added
        self.PROGRAM_RUN_INFO = program_run_info12()
        self.name = "DDAPC_RESTRAINT_A"
        self.keywords = [('_STRENGTH', 'STRENGTH'), ('_TYPE_OF_DENSITY', 'TYPE_OF_DENSITY'), ('_TARGET', 'TARGET'), ('_ATOMS', 'ATOMS'), ('_COEFF', 'COEFF'), ('_FUNCTIONAL_FORM', 'FUNCTIONAL_FORM')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class core_trajectory1(printable):
    """Controls the output of the trajectory of cores when the shell-model is used"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._UNIT = None    # Specify the unit of measurement for the quantity in output. All available CP2K units can be used.
        self._FORMAT = None    # Specifies the format of the output file for the trajectory of cores.
        self._CHARGE_OCCUP = None    # Write the MM charges to the OCCUP field of the PDB file
        self._CHARGE_O = self._CHARGE_OCCUP
        self._CHARGE_BETA = None    # Write the MM charges to the BETA field of the PDB file
        self._CHARGE_B = self._CHARGE_BETA
        self._CHARGE_EXTENDED = None    # Write the MM charges to the very last field of the PDB file (starting from column 81)
        self.EACH = each1()
        self.name = "CORE_TRAJECTORY"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_UNIT', 'UNIT'), ('_FORMAT', 'FORMAT'), ('_CHARGE_OCCUP', 'CHARGE_OCCUP'), ('_CHARGE_O', 'CHARGE_O'), ('_CHARGE_BETA', 'CHARGE_BETA'), ('_CHARGE_B', 'CHARGE_B'), ('_CHARGE_EXTENDED', 'CHARGE_EXTENDED')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class lagrange_multipliers1(printable):
    """Prints out the lagrange multipliers of the specified constraints during an MD."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "LAGRANGE_MULTIPLIERS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class wannier_spreads1(printable):
    """Controls the printing of the wannier functions"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "WANNIER_SPREADS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class shell_opt1(printable):
    """This section sets the environment for the optimization of the shell-core distances that might turn to be necessary along a MD run using a shell-model potential.  The optimization procedure is activated when at least one of the shell-core pairs becomes too elongated,  i.e. when the assumption of point dipole is not longer valid."""
    def __init__(self):
        self._OPTIMIZER = None    # Specify which method to use to perform a geometry optimization.
        self._MINIMIZER = self._OPTIMIZER
        self._MAX_ITER = None    # Specifies the maximum number of geometry optimization steps. One step might imply several force evaluations for the CG and LBFGS optimizers.
        self._MAX_DR = None    # Convergence criterium for the maximum geometry change between the current and the last optimizer iteration.
        self._MAX_FORCE = None    # Convergence criterium for the maximum force component of the current configuration.
        self._RMS_DR = None    # Convergence criterium for the root mean square (RMS) geometry change between the current and the last optimizer iteration.
        self._RMS_FORCE = None    # Convergence criterium for the root mean square (RMS) force of the current configuration.
        self._STEP_START_VAL = None    # The starting step value for the SHELL_OPT module.
        self.LBFGS = lbfgs1()
        self.CG = cg1()
        self.BFGS = bfgs1()
        self.listPRINT = []
        self.PRINT = print5()
        self.name = "SHELL_OPT"
        self.keywords = [('_OPTIMIZER', 'OPTIMIZER'), ('_MINIMIZER', 'MINIMIZER'), ('_MAX_ITER', 'MAX_ITER'), ('_MAX_DR', 'MAX_DR'), ('_MAX_FORCE', 'MAX_FORCE'), ('_RMS_DR', 'RMS_DR'), ('_RMS_FORCE', 'RMS_FORCE'), ('_STEP_START_VAL', 'STEP_START_VAL')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('LBFGS', 'LBFGS'), ('CG', 'CG'), ('BFGS', 'BFGS')]
        self.repeated_subsections = [('PRINT', 'print5')]

    def addPRINT(self):
        new_section = print5()
        self.listPRINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class g4x61(printable):
    """This section is used to set 4x6 (4 atoms and 6 distances) constraints."""
    def __init__(self):
        self._MOLECULE = None    # Specifies the molecule number on which constraint will be applied. MOLECULE and MOLNAME keyword exclude themself mutually.
        self._MOL = self._MOLECULE
        self._MOLNAME = None    # Specifies the name of the molecule on which the constraint will be applied.
        self._SEGNAME = self._MOLNAME
        self._INTERMOLECULAR = None    # Specify if the constraint/restraint is intermolecular.
        self._ATOMS = None    # Atoms' index on which apply the constraint
        self._DISTANCES = None    # The constrained distances' values.
        self._EXCLUDE_QM = None    # Does not apply the constraint to the QM region within a QM/MM calculation
        self._EXCLUDE_MM = None    # Does not apply the constraint to the MM region within a QM/MM calculation
        self.RESTRAINT = restraint1()
        self.name = "G4X6"
        self.keywords = [('_MOLECULE', 'MOLECULE'), ('_MOL', 'MOL'), ('_MOLNAME', 'MOLNAME'), ('_SEGNAME', 'SEGNAME'), ('_INTERMOLECULAR', 'INTERMOLECULAR'), ('_ATOMS', 'ATOMS'), ('_DISTANCES', 'DISTANCES'), ('_EXCLUDE_QM', 'EXCLUDE_QM'), ('_EXCLUDE_MM', 'EXCLUDE_MM')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('RESTRAINT', 'RESTRAINT')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class temp_kind1(printable):
    """Controls the output of the temperature computed separately for each kind"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "TEMP_KIND"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class ae_basis1(printable):
    """Section of basis set information for all-electron calculations."""
    def __init__(self):
        self._BASIS_TYPE = None    # Basis set type
        self._NUM_GTO = None    # Number of Gaussian type functions for s, p, d, ...
        self._NUM_SLATER = None    # Number of Slater type functions for s, p, d, ...
        self._START_INDEX = None    # Starting index for Geometrical Basis sets
        self._S_EXPONENTS = None    # Exponents for s functions
        self._P_EXPONENTS = None    # Exponents for p functions
        self._D_EXPONENTS = None    # Exponents for d functions
        self._F_EXPONENTS = None    # Exponents for f functions
        self._S_QUANTUM_NUMBERS = None    # Main quantum numbers for s functions
        self._P_QUANTUM_NUMBERS = None    # Main quantum numbers for p functions
        self._D_QUANTUM_NUMBERS = None    # Main quantum numbers for d functions
        self._F_QUANTUM_NUMBERS = None    # Main quantum numbers for f functions
        self._GEOMETRICAL_FACTOR = None    # Geometrical basis: factor C in a*C^k
        self._GEO_START_VALUE = None    # Geometrical basis: starting value a in a*C^k
        self._BASIS_SET_FILE_NAME = None    # Name of the basis set file, may include a path
        self._BASIS_SET = None    # The contracted Gaussian basis set
        self._ORBITAL_BASIS_SET = self._BASIS_SET
        self._ORB_BASIS = self._BASIS_SET
        self._QUADRATURE = None    # Algorithm to construct the atomic radial grids
        self._GRID_POINTS = None    # Number of radial grid points
        self._EPS_EIGENVALUE = None    # Cutoff of overlap matrix eigenvalues included into basis
        self.BASIS = basis1()
        self.name = "AE_BASIS"
        self.keywords = [('_BASIS_TYPE', 'BASIS_TYPE'), ('_NUM_GTO', 'NUM_GTO'), ('_NUM_SLATER', 'NUM_SLATER'), ('_START_INDEX', 'START_INDEX'), ('_S_EXPONENTS', 'S_EXPONENTS'), ('_P_EXPONENTS', 'P_EXPONENTS'), ('_D_EXPONENTS', 'D_EXPONENTS'), ('_F_EXPONENTS', 'F_EXPONENTS'), ('_S_QUANTUM_NUMBERS', 'S_QUANTUM_NUMBERS'), ('_P_QUANTUM_NUMBERS', 'P_QUANTUM_NUMBERS'), ('_D_QUANTUM_NUMBERS', 'D_QUANTUM_NUMBERS'), ('_F_QUANTUM_NUMBERS', 'F_QUANTUM_NUMBERS'), ('_GEOMETRICAL_FACTOR', 'GEOMETRICAL_FACTOR'), ('_GEO_START_VALUE', 'GEO_START_VALUE'), ('_BASIS_SET_FILE_NAME', 'BASIS_SET_FILE_NAME'), ('_BASIS_SET', 'BASIS_SET'), ('_ORBITAL_BASIS_SET', 'ORBITAL_BASIS_SET'), ('_ORB_BASIS', 'ORB_BASIS'), ('_QUADRATURE', 'QUADRATURE'), ('_GRID_POINTS', 'GRID_POINTS'), ('_EPS_EIGENVALUE', 'EPS_EIGENVALUE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('BASIS', 'BASIS')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class ao_matrices1(printable):
    """Controls the printing of the ao (i.e. contracted gaussian) matrices (debug)."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._CORE_HAMILTONIAN = None    # If the printkey is activated controls the printing of the hamiltonian matrix
        self._DENSITY = None    # If the printkey is activated controls the printing of the density (P) matrix
        self._KINETIC_ENERGY = None    # If the printkey is activated controls the printing of the kinetic energy matrix
        self._KOHN_SHAM_MATRIX = None    # If the printkey is activated controls the printing of the kohn-sham matrix
        self._MATRIX_VXC = None    # If the printkey is activated compute and print the matrix of the exchange and correlation potential.Only the GGA part for GPW is printed
        self._ORTHO = None    # If the printkey is activated controls the printing of the orthogonalization matrix
        self._OVERLAP = None    # If the printkey is activated controls the printing of the overlap matrix
        self._FERMI_CONTACT = None    # If the printkey is activated controls the printing of the Fermi contact matrix
        self._PSO = None    # If the printkey is activated controls the printing of the paramagnetic spin-orbit matrices
        self._EFG = None    # If the printkey is activated controls the printing of the electric field gradient matrices
        self._POTENTIAL_ENERGY = None    # If the printkey is activated controls the printing of the potential energy matrix
        self._OCE_HARD = None    # If the printkey is activated controls the printing of the OCE HARD matrix
        self._OCE_SOFT = None    # If the printkey is activated controls the printing of the OCE SOFT matrix
        self._W_MATRIX = None    # If the printkey is activated controls the printing of the w matrix
        self._W_MATRIX_AUX_FIT = None    # If the printkey is activated controls the printing of the w matrix
        self._DERIVATIVES = None    # If the printkey is activated controls the printing of derivatives (for the matrixes that support this)
        self.EACH = each1()
        self.name = "AO_MATRICES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_CORE_HAMILTONIAN', 'CORE_HAMILTONIAN'), ('_DENSITY', 'DENSITY'), ('_KINETIC_ENERGY', 'KINETIC_ENERGY'), ('_KOHN_SHAM_MATRIX', 'KOHN_SHAM_MATRIX'), ('_MATRIX_VXC', 'MATRIX_VXC'), ('_ORTHO', 'ORTHO'), ('_OVERLAP', 'OVERLAP'), ('_FERMI_CONTACT', 'FERMI_CONTACT'), ('_PSO', 'PSO'), ('_EFG', 'EFG'), ('_POTENTIAL_ENERGY', 'POTENTIAL_ENERGY'), ('_OCE_HARD', 'OCE_HARD'), ('_OCE_SOFT', 'OCE_SOFT'), ('_W_MATRIX', 'W_MATRIX'), ('_W_MATRIX_AUX_FIT', 'W_MATRIX_AUX_FIT'), ('_DERIVATIVES', 'DERIVATIVES')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print39(printable):
    """printing of information during the linear response calculation"""
    def __init__(self):
        self.PROGRAM_RUN_INFO = program_run_info20()
        self.RESTART = restart7()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('RESTART', 'RESTART')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print38(printable):
    """print results of epr calculation"""
    def __init__(self):
        self.NABLAVKS_CUBES = nablavks_cubes1()
        self.G_TENSOR = g_tensor1()
        self.RESPONSE_FUNCTION_CUBES = response_function_cubes2()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('NABLAVKS_CUBES', 'NABLAVKS_CUBES'), ('G_TENSOR', 'G_TENSOR'), ('RESPONSE_FUNCTION_CUBES', 'RESPONSE_FUNCTION_CUBES')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class velocity3(printable):
    """The velocities for BEADS used for restart"""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Specify velocities of the system
        self.name = "VELOCITY"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class print33(printable):
    """Controls the printing of the colvar specifications"""
    def __init__(self):
        self.PROGRAM_RUN_INFO = program_run_info19()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print32(printable):
    """Section of possible print options in GENERATE code."""
    def __init__(self):
        self.NEIGHBOR_LISTS = neighbor_lists7()
        self.SUBCELL = subcell4()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('NEIGHBOR_LISTS', 'NEIGHBOR_LISTS'), ('SUBCELL', 'SUBCELL')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print31(printable):
    """Section of possible print options in BSSE code."""
    def __init__(self):
        self.PROGRAM_RUN_INFO = program_run_info18()
        self.RESTART = restart6()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('RESTART', 'RESTART')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print30(printable):
    """Section of possible print options in EIP code."""
    def __init__(self):
        self.ENERGIES = energies1()
        self.ENERGIES_VAR = energies_var1()
        self.FORCES = forces3()
        self.COORD_AVG = coord_avg1()
        self.COORD_VAR = coord_var1()
        self.COUNT = count1()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('ENERGIES', 'ENERGIES'), ('ENERGIES_VAR', 'ENERGIES_VAR'), ('FORCES', 'FORCES'), ('COORD_AVG', 'COORD_AVG'), ('COORD_VAR', 'COORD_VAR'), ('COUNT', 'COUNT')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class wannier_centers1(printable):
    """Controls the printing of the wannier functions"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._UNIT = None    # Specify the unit of measurement for the quantity in output. All available CP2K units can be used.
        self._IONSPLUSCENTERS = None    # prints out the wannier centers together with the particles
        self._FORMAT = None    # Specifies the format of the output file when IONS+CENTERS is enabled.
        self._CHARGE_OCCUP = None    # Write the MM charges to the OCCUP field of the PDB file
        self._CHARGE_O = self._CHARGE_OCCUP
        self._CHARGE_BETA = None    # Write the MM charges to the BETA field of the PDB file
        self._CHARGE_B = self._CHARGE_BETA
        self._CHARGE_EXTENDED = None    # Write the MM charges to the very last field of the PDB file (starting from column 81)
        self.EACH = each1()
        self.name = "WANNIER_CENTERS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_UNIT', 'UNIT'), ('_IONSPLUSCENTERS', 'IONS+CENTERS'), ('_FORMAT', 'FORMAT'), ('_CHARGE_OCCUP', 'CHARGE_OCCUP'), ('_CHARGE_O', 'CHARGE_O'), ('_CHARGE_BETA', 'CHARGE_BETA'), ('_CHARGE_B', 'CHARGE_B'), ('_CHARGE_EXTENDED', 'CHARGE_EXTENDED')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print36(printable):
    """print results of nmr calculation"""
    def __init__(self):
        self.RESPONSE_FUNCTION_CUBES = response_function_cubes2()
        self.CHI_TENSOR = chi_tensor1()
        self.SHIELDING_TENSOR = shielding_tensor1()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('RESPONSE_FUNCTION_CUBES', 'RESPONSE_FUNCTION_CUBES'), ('CHI_TENSOR', 'CHI_TENSOR'), ('SHIELDING_TENSOR', 'SHIELDING_TENSOR')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print35(printable):
    """print results of induced current density calculation"""
    def __init__(self):
        self.CURRENT_CUBES = current_cubes1()
        self.RESPONSE_FUNCTION_CUBES = response_function_cubes1()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('CURRENT_CUBES', 'CURRENT_CUBES'), ('RESPONSE_FUNCTION_CUBES', 'RESPONSE_FUNCTION_CUBES')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print34(printable):
    """Controls printings related to the subsys"""
    def __init__(self):
        self.ATOMIC_COORDINATES = atomic_coordinates1()
        self.STRUCTURE_DATA = structure_data1()
        self.INTERATOMIC_DISTANCES = interatomic_distances1()
        self.TOPOLOGY_INFO = topology_info1()
        self.CELL = cell4()
        self.KINDS = kinds1()
        self.SYMMETRY = symmetry1()
        self.MOLECULES = molecules1()
        self.RADII = radii1()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('ATOMIC_COORDINATES', 'ATOMIC_COORDINATES'), ('STRUCTURE_DATA', 'STRUCTURE_DATA'), ('INTERATOMIC_DISTANCES', 'INTERATOMIC_DISTANCES'), ('TOPOLOGY_INFO', 'TOPOLOGY_INFO'), ('CELL', 'CELL'), ('KINDS', 'KINDS'), ('SYMMETRY', 'SYMMETRY'), ('MOLECULES', 'MOLECULES'), ('RADII', 'RADII')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class siepmann1(printable):
    """This section specifies the input parameters for the Siepmann-Sprik potential type. Consist of 4 terms: T1+T2+T3+T4. The terms T1=A/rij^alpha and T2=-C/rij^6 have to be given via the GENPOT section. The terms T3+T4 are obtained from the SIEPMANN section."""
    def __init__(self):
        self._ATOMS = None    # Defines the atomic kind involved in the nonbond potential
        self._B = None    # Defines the B parameter of Siepmann potential
        self._D = None    # Defines the D parameter of Siepmann potential
        self._E = None    # Defines the E parameter of Siepmann potential
        self._F = None    # Defines the F parameter of Siepmann potential
        self._BETA = None    # Defines the beta parameter of Siepmann potential
        self._RCUT = None    # Defines the cutoff parameter of Siepmann potential
        self.name = "SIEPMANN"
        self.keywords = [('_ATOMS', 'ATOMS'), ('_B', 'B'), ('_D', 'D'), ('_E', 'E'), ('_F', 'F'), ('_BETA', 'BETA'), ('_RCUT', 'RCUT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class subcell2(printable):
    """Activates the printing of the subcells used for thegeneration of neighbor lists."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._UNIT = None    # Specify the unit of measurement for the quantity in output. All available CP2K units can be used.
        self.EACH = each1()
        self.name = "SUBCELL"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_UNIT', 'UNIT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class wannier_states1(printable):
    """Controls printing of molecular states"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._CUBE_EVAL_RANGE = None    # only write cubes if the eigenvalues of the corresponding molecular states lie in the given interval. Default is all states.
        self.list_MARK_STATES = []
        self._MARK_STATES = None
    # Can be used to mark given molecular states. Sets a mark to both, occupied and unoccupied states. Occupied states are counted beginning with HOMO=1, unoccupied states are counted beginning with LUMO=1, This is only meaningful in combination with WFN_MIX. First integer specifies the molecule, second integer specifies the state.
        self.EACH = each1()
        self.CUBES = cubes1()
        self.name = "WANNIER_STATES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_CUBE_EVAL_RANGE', 'CUBE_EVAL_RANGE')]
        self.repeated_keywords = [('_MARK_STATES', 'MARK_STATES')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH'), ('CUBES', 'CUBES')]
        self.repeated_subsections = []

    def add_MARK_STATES(self, value):
        self.list_MARK_STATES.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class subcell1(printable):
    """Activates the printing of the subcells used for thegeneration of neighbor lists for periodic SE."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "SUBCELL"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class colvar2(printable):
    """This section specifies the nature of the collective variables."""
    def __init__(self):
        self.DISTANCE = distance1()
        self.ANGLE = angle2()
        self.TORSION = torsion3()
        self.COORDINATION = coordination1()
        self.POPULATION = population1()
        self.GYRATION_RADIUS = gyration_radius1()
        self.DISTANCE_POINT_PLANE = distance_point_plane1()
        self.ANGLE_PLANE_PLANE = angle_plane_plane1()
        self.BOND_ROTATION = bond_rotation1()
        self.DISTANCE_FUNCTION = distance_function1()
        self.QPARM = qparm1()
        self.HYDRONIUM = hydronium1()
        self.RMSD = rmsd1()
        self.XYZ_DIAG = xyz_diag1()
        self.XYZ_OUTERDIAG = xyz_outerdiag1()
        self.U = u1()
        self.WC = wc1()
        self.HBP = hbp1()
        self.RING_PUCKERING = ring_puckering1()
        self.CONDITIONED_DISTANCE = conditioned_distance1()
        self.listPRINT = []
        self.PRINT = print33()
        self.COLVAR_FUNC_INFO = colvar_func_info1()
        self.name = "COLVAR"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('DISTANCE', 'DISTANCE'), ('ANGLE', 'ANGLE'), ('TORSION', 'TORSION'), ('COORDINATION', 'COORDINATION'), ('POPULATION', 'POPULATION'), ('GYRATION_RADIUS', 'GYRATION_RADIUS'), ('DISTANCE_POINT_PLANE', 'DISTANCE_POINT_PLANE'), ('ANGLE_PLANE_PLANE', 'ANGLE_PLANE_PLANE'), ('BOND_ROTATION', 'BOND_ROTATION'), ('DISTANCE_FUNCTION', 'DISTANCE_FUNCTION'), ('QPARM', 'QPARM'), ('HYDRONIUM', 'HYDRONIUM'), ('RMSD', 'RMSD'), ('XYZ_DIAG', 'XYZ_DIAG'), ('XYZ_OUTERDIAG', 'XYZ_OUTERDIAG'), ('U', 'U'), ('WC', 'WC'), ('HBP', 'HBP'), ('RING_PUCKERING', 'RING_PUCKERING'), ('CONDITIONED_DISTANCE', 'CONDITIONED_DISTANCE'), ('COLVAR_FUNC_INFO', 'COLVAR_FUNC_INFO')]
        self.repeated_subsections = [('PRINT', 'print33')]

    def addPRINT(self):
        new_section = print33()
        self.listPRINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class ga1(printable):
    """Sets up memory parameters for the storage of the integrals"""
    def __init__(self):
        self._NCELLS = None    # Defines the number of linked cells for the neighbor list. Default value is number of processors
        self.name = "GA"
        self.keywords = [('_NCELLS', 'NCELLS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class each1(printable):
    """This section specifies how often this proprety is printed.Each keyword inside this section is mapping to a specific iteration level and the value of each of these keywords is matched with the iteration level during the calculation. How to handle the last iteration is treated separately in ADD_LAST (this mean that each iteration level (MD, GEO_OPT, etc..), though equal to 0, might print the last iteration). If an iteration level is specified that is not present in the flow of the calculation it is just ignored."""
    def __init__(self):
        self._JUST_ENERGY = None    # Iteration level for an ENERGY/ENERGY_FORCE calculation.
        self._POWELL_OPT = None    # Iteration level for POWELL based optimization steps.
        self._QS_SCF = None    # Iteration level for the SCF Steps.
        self._XAS_SCF = None    # Iteration level for the X-Ray Absorption Spectroscopy (XAS) SCF Steps.
        self._MD = None    # Iteration level for the MD steps.
        self._METADYNAMICS = None    # Iteration level for the METADYNAMICS steps (number of hills added).
        self._GEO_OPT = None    # Iteration level for the Geometry optimization steps.
        self._ROT_OPT = None    # Iteration level for the Rotational optimization steps in the Dimer Calculation.
        self._CELL_OPT = None    # Iteration level for the Cell optimization steps.
        self._BAND = None    # Iteration level for the Band Calculation Steps
        self._EP_LIN_SOLVER = None    # Iteration level for the Energy Perturbation (EP) linear solver
        self._SPLINE_FIND_COEFFS = None    # Iteration level for the solution of the coefficients of the splines
        self._REPLICA_EVAL = None    # Iteration level for the evaluation of the Replica Environment
        self._BSSE = None    # Iteration level for the Basis Set Superposition Error (BSSE) Calculation
        self._SHELL_OPT = None    # Iteration level for the Shell-Core distances optimization steps
        self.name = "EACH"
        self.keywords = [('_JUST_ENERGY', 'JUST_ENERGY'), ('_POWELL_OPT', 'POWELL_OPT'), ('_QS_SCF', 'QS_SCF'), ('_XAS_SCF', 'XAS_SCF'), ('_MD', 'MD'), ('_METADYNAMICS', 'METADYNAMICS'), ('_GEO_OPT', 'GEO_OPT'), ('_ROT_OPT', 'ROT_OPT'), ('_CELL_OPT', 'CELL_OPT'), ('_BAND', 'BAND'), ('_EP_LIN_SOLVER', 'EP_LIN_SOLVER'), ('_SPLINE_FIND_COEFFS', 'SPLINE_FIND_COEFFS'), ('_REPLICA_EVAL', 'REPLICA_EVAL'), ('_BSSE', 'BSSE'), ('_SHELL_OPT', 'SHELL_OPT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class distance_from_path1(printable):
    """Section defining the distance from a one dimensional reaction path in an Q-dimensional space of colvars. Constraining this colvar, allows to sample the space equidistant to the reaction path, both in the Q-dimensional colvar and 3N-Q remaining coordinates. For the details of the function see cited literature."""
    def __init__(self):
        self._DISTANCES_RMSD = None
        self._RMSD = None
        self._SUBSET_TYPE = None    # Define the subsytem used to compute the RMSD
        self._ALIGN_FRAMES = None    # Whether the reference frames should be aligned to minimize the RMSD
        self.list_ATOMS = []
        self._ATOMS = None
    # Specify indexes of atoms building the subset.
        self.list_FUNCTION = []
        self._FUNCTION = None
    # Specifies the ith element of the vector valued function that defines the reaction path. This keyword needs to repeat exactly Q times, and the order must match the order of the colvars. The VARIABLE (e.g. T) which parametrises the curve can be used as the target of a constraint.
        self._VARIABLE = None    # Specifies the name of the variable that parametrises the FUNCTION defining the reaction path.
        self._LAMBDA = None    # Specifies the exponent of the Gaussian used in the integral representation of the colvar.The shape of the space orthogonal to the reaction path is defined by this choice. In the limit of large values, it is given by the plane orthogonal to the path.In practice, modest values are required for stable numerical integration.
        self._STEP_SIZE = None    # Step size in the numerical integration, a few thousand points are common, and the proper number also depends on LAMBDA.
        self._RANGE = None    # The range of VARIABLE used for the parametrisation.
        self.listCOLVAR = []
        self.COLVAR = colvar2()
        self.listFRAME = []
        self.FRAME = frame2()
        self.MAP = map1()
        self.name = "DISTANCE_FROM_PATH"
        self.keywords = [('_DISTANCES_RMSD', 'DISTANCES_RMSD'), ('_RMSD', 'RMSD'), ('_SUBSET_TYPE', 'SUBSET_TYPE'), ('_ALIGN_FRAMES', 'ALIGN_FRAMES'), ('_VARIABLE', 'VARIABLE'), ('_LAMBDA', 'LAMBDA'), ('_STEP_SIZE', 'STEP_SIZE'), ('_RANGE', 'RANGE')]
        self.repeated_keywords = [('_ATOMS', 'ATOMS'), ('_FUNCTION', 'FUNCTION')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('MAP', 'MAP')]
        self.repeated_subsections = [('COLVAR', 'colvar2'), ('FRAME', 'frame2')]

    def addCOLVAR(self):
        new_section = colvar2()
        self.listCOLVAR.append(new_section)
        return new_section

    def addFRAME(self):
        new_section = frame2()
        self.listFRAME.append(new_section)
        return new_section

    def add_ATOMS(self, value):
        self.list_ATOMS.append(value)

    def add_FUNCTION(self, value):
        self.list_FUNCTION.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class qs1(printable):
    """parameters needed to set up the Quickstep framework"""
    def __init__(self):
        self._EPS_DEFAULT = None    # Try setting all EPS_xxx to values leading to an energy correct up to EPS_DEFAULT
        self._EPS_CORE_CHARGE = None    # Precision for mapping the core charges.Overrides EPS_DEFAULT/100.0 value
        self._EPS_GVG_RSPACE = None    # Sets precision of the realspace KS matrix element integration. Overrides SQRT(EPS_DEFAULT) value
        self._EPS_GVG = self._EPS_GVG_RSPACE
        self._EPS_PGF_ORB = None    # Sets precision of the overlap matrix elements. Overrides SQRT(EPS_DEFAULT) value
        self._EPS_KG_ORB = None    # Sets precision used in coloring the subsets. Overrides SQRT(EPS_DEFAULT) value
        self._EPS_3C_REDUCE = None    # GAPW: Factor to reduce the precision in the construction of the 3 center lists for the calculation of the OCE coefficients.
        self._EPS_PPL = None    # Adjusts the precision for the local part of the pseudo potential.
        self._EPS_PPNL = None    # Sets precision of the non-local part of the pseudo potential. Overrides sqrt(EPS_DEFAULT) value
        self._EPS_CPC = None    # Sets precision of the GAPW projection. Overrides EPS_DEFAULT value
        self._EPS_RHO = None    # Sets precision of the density mapping on the grids.Overrides EPS_DEFAULT value
        self._EPS_RHO_RSPACE = None    # Sets precision of the density mapping in rspace.Overrides EPS_DEFAULT value..Overrides EPS_RHO value
        self._EPS_RHO_GSPACE = None    # Sets precision of the density mapping in gspace.Overrides EPS_DEFAULT value..Overrides EPS_RHO value
        self._EPS_FILTER_MATRIX = None    # Sets the threshold for filtering matrix elements.
        self._EPSFIT = None    # GAPW and LRIPAW: precision to give the extention of a hard gaussian
        self._EPS_FIT = self._EPSFIT
        self._EPSISO = None    # GAPW : precision to determine an isolated projector
        self._EPS_ISO = self._EPSISO
        self._EPSSVD = None    # GAPW : tolerance used in the singular value decomposition of the projector matrix
        self._EPS_SVD = self._EPSSVD
        self._EPSRHO0 = None    # GAPW : precision to determine the range of V(rho0-rho0soft)
        self._EPSVRHO0 = self._EPSRHO0
        self._EPS_VRHO0 = self._EPSRHO0
        self._ALPHA0_HARD = None    # GAPW and LRIPAW : Exponent for hard compensation charge
        self._ALPHA0_H = self._ALPHA0_HARD
        self._ALPHA0 = self._ALPHA0_HARD
        self._FORCE_PAW = None    # Use the GAPW scheme also for atoms with soft basis sets, i.e.  the local densities are computed even if hard and soft should be equal. If this keyword is not set to true, those atoms with soft basis sets are treated by a GPW scheme, i.e. the corresponding density contribution goes on the global grid and is expanded in PW.  This option nullifies the effect of the GPW_TYPE in the atomic KIND
        self._MAX_RAD_LOCAL = None    # GAPW : maximum radius of gaussian functions included in the generation of projectors
        self._SCP = None    # Introduce additional self-consistent polarization through additional response basis functions (read in through AUX_BASIS.
        self._LS_SCF = None    # Perform a linear scaling SCF
        self._KG_METHOD = None    # Use a Kim-Gordon-like scheme.
        self._MAP_CONSISTENT = None    # Compute the exact derivative (Hks) of the energy with respect to the density matrix. This is slightly more expensive than using an approximate computation, but consistent mapping can improve the stability of the SCF procedure, especially for a tight EPS_SCF and a less tight EPS_DEFAULT.
        self._CHECK_BCSR_CODE = None    # Check the BCSR code on actual data, once per QS run.
        self._BCSR_CODE = None    # Selects BCSR pathway.
        self._LMAXN1 = None    # GAPW : max L number for espansion of the atomic densities in spherical gaussians
        self._LMAXRHO1 = self._LMAXN1
        self._LMAXN0 = None    # GAPW : max L number for the expansion compensation densities in spherical gaussians
        self._LMAXRHO0 = self._LMAXN0
        self._LADDN0 = None    # GAPW : integer added to the max L of the basis set, used to determine the maximum value of L for the compensation charge density.
        self._QUADRATURE = None    # GAPW and LRIPAW: algorithm to construct the atomic radial grids
        self._PW_GRID = None    # What kind of PW_GRID should be employed
        self._PW_GRID_LAYOUT = None    # Force a particular real-space layout for the plane waves grids. Numbers <=0 mean that this dimension is free, incorrect layouts will be ignored. The default (/-1,-1/) causes CP2K to select a good value, i.e. plane distributed for large grids, more general distribution for small grids.
        self._PW_GRID_BLOCKED = None    # Can be used to set the distribution in g-space for the pw grids and their FFT.
        self._EXTRAPOLATION = None    # Extrapolation strategy for the wavefunction during e.g. MD.PS and ASPC are recommended, see also EXTRAPOLATION_ORDER.
        self._INTERPOLATION = self._EXTRAPOLATION
        self._WF_INTERPOLATION = self._EXTRAPOLATION
        self._EXTRAPOLATION_ORDER = None    # Order for the PS or ASPC extrapolation (typically 2-4). Higher order might bring more accuracy, but comes, for large systems, also at some cost. In some cases, a high order extrapolation is not stable, and the order needs to be reduced.
        self._METHOD = None    # Specifies the electronic structure method that should be employed
        self._CORE_PPL = None    # Specifies the method used to calculate the local pseudopotential contribution.
        self.DISTRIBUTION = distribution1()
        self.DFTB = dftb1()
        self.SCPTB = scptb1()
        self.SE = se1()
        self.MULLIKEN_RESTRAINT = mulliken_restraint1()
        self.listDDAPC_RESTRAINT = []
        self.DDAPC_RESTRAINT = ddapc_restraint1()
        self.BECKE_RESTRAINT = becke_restraint1()
        self.S2_RESTRAINT = s2_restraint1()
        self.HARRIS = harris1()
        self.name = "QS"
        self.keywords = [('_EPS_DEFAULT', 'EPS_DEFAULT'), ('_EPS_CORE_CHARGE', 'EPS_CORE_CHARGE'), ('_EPS_GVG_RSPACE', 'EPS_GVG_RSPACE'), ('_EPS_GVG', 'EPS_GVG'), ('_EPS_PGF_ORB', 'EPS_PGF_ORB'), ('_EPS_KG_ORB', 'EPS_KG_ORB'), ('_EPS_3C_REDUCE', 'EPS_3C_REDUCE'), ('_EPS_PPL', 'EPS_PPL'), ('_EPS_PPNL', 'EPS_PPNL'), ('_EPS_CPC', 'EPS_CPC'), ('_EPS_RHO', 'EPS_RHO'), ('_EPS_RHO_RSPACE', 'EPS_RHO_RSPACE'), ('_EPS_RHO_GSPACE', 'EPS_RHO_GSPACE'), ('_EPS_FILTER_MATRIX', 'EPS_FILTER_MATRIX'), ('_EPSFIT', 'EPSFIT'), ('_EPS_FIT', 'EPS_FIT'), ('_EPSISO', 'EPSISO'), ('_EPS_ISO', 'EPS_ISO'), ('_EPSSVD', 'EPSSVD'), ('_EPS_SVD', 'EPS_SVD'), ('_EPSRHO0', 'EPSRHO0'), ('_EPSVRHO0', 'EPSVRHO0'), ('_EPS_VRHO0', 'EPS_VRHO0'), ('_ALPHA0_HARD', 'ALPHA0_HARD'), ('_ALPHA0_H', 'ALPHA0_H'), ('_ALPHA0', 'ALPHA0'), ('_FORCE_PAW', 'FORCE_PAW'), ('_MAX_RAD_LOCAL', 'MAX_RAD_LOCAL'), ('_SCP', 'SCP'), ('_LS_SCF', 'LS_SCF'), ('_KG_METHOD', 'KG_METHOD'), ('_MAP_CONSISTENT', 'MAP_CONSISTENT'), ('_CHECK_BCSR_CODE', 'CHECK_BCSR_CODE'), ('_BCSR_CODE', 'BCSR_CODE'), ('_LMAXN1', 'LMAXN1'), ('_LMAXRHO1', 'LMAXRHO1'), ('_LMAXN0', 'LMAXN0'), ('_LMAXRHO0', 'LMAXRHO0'), ('_LADDN0', 'LADDN0'), ('_QUADRATURE', 'QUADRATURE'), ('_PW_GRID', 'PW_GRID'), ('_PW_GRID_LAYOUT', 'PW_GRID_LAYOUT'), ('_PW_GRID_BLOCKED', 'PW_GRID_BLOCKED'), ('_EXTRAPOLATION', 'EXTRAPOLATION'), ('_INTERPOLATION', 'INTERPOLATION'), ('_WF_INTERPOLATION', 'WF_INTERPOLATION'), ('_EXTRAPOLATION_ORDER', 'EXTRAPOLATION_ORDER'), ('_METHOD', 'METHOD'), ('_CORE_PPL', 'CORE_PPL')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('DISTRIBUTION', 'DISTRIBUTION'), ('DFTB', 'DFTB'), ('SCPTB', 'SCPTB'), ('SE', 'SE'), ('MULLIKEN_RESTRAINT', 'MULLIKEN_RESTRAINT'), ('BECKE_RESTRAINT', 'BECKE_RESTRAINT'), ('S2_RESTRAINT', 'S2_RESTRAINT'), ('HARRIS', 'HARRIS')]
        self.repeated_subsections = [('DDAPC_RESTRAINT', 'ddapc_restraint1')]

    def addDDAPC_RESTRAINT(self):
        new_section = ddapc_restraint1()
        self.listDDAPC_RESTRAINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class ewald1(printable):
    """Ewald parameters controlling electrostatic only for CLASSICAL MM."""
    def __init__(self):
        self._EWALD_TYPE = None    # The type of ewald you want to perform. NONE standard real-space coulomb potential is computed together with the non-bonded contributions. EWALD is the standard non-fft based ewald. SPME is the smooth particle mesh using beta-Euler splines (recommended). PME is the particle mesh using fft interpolation.
        self._EWALD_ACCURACY = None    # Expected accuracy in the Ewald sum. This number affects only the calculation of the cutoff for the real-space term of the ewald summation (EWALD|PME|SPME) as well as the construction of the neighbor lists (if the cutoff for non-bonded terms is smaller than the value employed to compute the EWALD real-space term). This keyword has no effect on the reciprocal space term (which can be tuned independently).
        self._RCUT = None    # Explicitly provide the real-space cutoff of the ewald summation (EWALD|PME|SPME). If present, overwrites the estimate of EWALD_ACCURACY and may affect the construction of the neighbor lists for non-bonded terms (in FIST), if the value specified is larger than the cutoff for non-bonded interactions.
        self._ALPHA = None    # alpha parameter associated with Ewald (EWALD|PME|SPME). Recommended for small systems is is alpha = 3.5 / r_cut. Tuning alpha, r_cut and gmax is needed to obtain O(N**1.5) scaling for ewald.
        self._GMAX = None    # number of grid points (SPME and EWALD). If a single number is specified,the same number of points is used for all three directions on the grid.If three numbers are given, each direction can have a different number of points.The number of points needs to be FFTable (which depends on the library used) and odd for EWALD.The optimal number depends e.g. on alpha and the size of the cell. 1 point per Angstrom is common.
        self._NS_MAX = None    # number of grid points on small mesh (PME only), should be odd.
        self._O_SPLINE = None    # order of the beta-Euler spline (SPME only)
        self._EPSILON = None    # tolerance of gaussians for fft interpolation (PME only)
        self.listRS_GRID = []
        self.RS_GRID = rs_grid1()
        self.MULTIPOLES = multipoles1()
        self.PRINT = print21()
        self.name = "EWALD"
        self.keywords = [('_EWALD_TYPE', 'EWALD_TYPE'), ('_EWALD_ACCURACY', 'EWALD_ACCURACY'), ('_RCUT', 'RCUT'), ('_ALPHA', 'ALPHA'), ('_GMAX', 'GMAX'), ('_NS_MAX', 'NS_MAX'), ('_O_SPLINE', 'O_SPLINE'), ('_EPSILON', 'EPSILON')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('MULTIPOLES', 'MULTIPOLES'), ('PRINT', 'PRINT')]
        self.repeated_subsections = [('RS_GRID', 'rs_grid1')]

    def addRS_GRID(self):
        new_section = rs_grid1()
        self.listRS_GRID.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class run_info1(printable):
    """Prints various informations on the progress of the ep calculation"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._LIN_SOLV = None    # print the linear solver progress
        self.EACH = each1()
        self.name = "RUN_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_LIN_SOLV', 'LIN_SOLV')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class nonbonded141(printable):
    """This section specifies the input parameters for 1-4 NON-BONDED interactions."""
    def __init__(self):
        self.listLENNARD_JONES = []
        self.LENNARD_JONES = lennardhypminjones1()
        self.listWILLIAMS = []
        self.WILLIAMS = williams1()
        self.listGOODWIN = []
        self.GOODWIN = goodwin1()
        self.listGENPOT = []
        self.GENPOT = genpot1()
        self.name = "NONBONDED14"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('LENNARD_JONES', 'lennardhypminjones1'), ('WILLIAMS', 'williams1'), ('GOODWIN', 'goodwin1'), ('GENPOT', 'genpot1')]

    def addLENNARD_JONES(self):
        new_section = lennardhypminjones1()
        self.listLENNARD_JONES.append(new_section)
        return new_section

    def addWILLIAMS(self):
        new_section = williams1()
        self.listWILLIAMS.append(new_section)
        return new_section

    def addGOODWIN(self):
        new_section = goodwin1()
        self.listGOODWIN.append(new_section)
        return new_section

    def addGENPOT(self):
        new_section = genpot1()
        self.listGENPOT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class hbonds1(printable):
    """This section is used to set bonds constraints involving Hydrogen atoms"""
    def __init__(self):
        self._ATOM_TYPE = None    # Defines the atoms' type forming a bond with an hydrogen. If not specified  the default bond value of the first molecule is used as constraint target
        self._MOLECULE = None    # Specifies the indexes of the molecule kind (in input file order)on which the constraint will be applied. MOLECULE and MOLNAME keyword exclude themself mutually.
        self._MOLNAME = None    # Specifies the names of the molecule on which the constraint will be applied.
        self._SEGNAME = self._MOLNAME
        self._EXCLUDE_QM = None    # Does not shake HBONDS in the QM region within a QM/MM calculation
        self._EXCLUDE_MM = None    # Does not shake HBONDS in the MM region within a QM/MM calculation
        self._TARGETS = None    # The constrained distances' values  for the types defines in ATOM_TYPE.
        self.RESTRAINT = restraint1()
        self.name = "HBONDS"
        self.keywords = [('_ATOM_TYPE', 'ATOM_TYPE'), ('_MOLECULE', 'MOLECULE'), ('_MOLNAME', 'MOLNAME'), ('_SEGNAME', 'SEGNAME'), ('_EXCLUDE_QM', 'EXCLUDE_QM'), ('_EXCLUDE_MM', 'EXCLUDE_MM'), ('_TARGETS', 'TARGETS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('RESTRAINT', 'RESTRAINT')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class ot1(printable):
    """Sets the various options for the orbital transformation (OT) method. Default settings already provide an efficient, yet robust method. Most systems benefit from using the FULL_ALL preconditioner combined with a small value (0.001) of ENERGY_GAP.Well-behaved systems might benefit from using a DIIS minimizer."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ALGORITHM = None    # Algorithm to be used for OT
        self._IRAC_DEGREE = None    # The refinement polynomial degree (2, 3 or 4).
        self._MAX_IRAC = None    # Maximum allowed refinement iteration.
        self._MIXED_PRECISION = None    # Uses a mixed precision algorithm.With a well behaved basis set (i.e. condition number less than 1/eps_sp)it provides double precision accuracy results and up to a 2 fold speedup for building and applying the preconditioner.
        self._ORTHO_IRAC = None    # The orthogonality method.
        self._EPS_IRAC_FILTER_MATRIX = None    # Sets the threshold for filtering the matrices.
        self._EPS_IRAC = None    # Targeted accuracy during the refinement iteration.
        self._EPS_IRAC_QUICK_EXIT = None    # Only one extra refinement iteration is done when the norm is below this value.
        self._EPS_IRAC_SWITCH = None    # The algorithm switches to the polynomial refinement when the norm is below this value.
        self._ON_THE_FLY_LOC = None    # On the fly localization of the molecular orbitals. Can only be used with OT/IRAC.
        self._MINIMIZER = None    # Minimizer to be used with the OT method
        self._SAFE_DIIS = None    # Reject DIIS steps if they point away from the minimum, do SD in that case.
        self._SAFER_DIIS = self._SAFE_DIIS
        self._N_HISTORY_VEC = None    # Number of history vectors to be used with DIIS or BROYDEN
        self._NDIIS = self._N_HISTORY_VEC
        self._N_DIIS = self._N_HISTORY_VEC
        self._N_BROYDEN = self._N_HISTORY_VEC
        self._BROYDEN_BETA = None    # Underrelaxation for the broyden mixer
        self._BROYDEN_GAMMA = None    # Backtracking parameter
        self._BROYDEN_SIGMA = None    # Curvature of energy functional.
        self._BROYDEN_ETA = None    # Dampening of estimated energy curvature.
        self._BROYDEN_OMEGA = None    # Growth limit of curvature.
        self._BROYDEN_SIGMA_DECREASE = None    # Reduction of curvature on bad approximation.
        self._BROYDEN_SIGMA_MIN = None    # Minimum adaptive curvature.
        self._BROYDEN_FORGET_HISTORY = None    # Forget history on bad approximation
        self._BROYDEN_ADAPTIVE_SIGMA = None    # Enable adaptive curvature estimation
        self._BROYDEN_ENABLE_FLIP = None    # Ensure positive definite update
        self._LINESEARCH = None    # 1D line search algorithm to be used with the OT minimizer, in increasing order of robustness and cost. MINIMIZER CG combined with LINESEARCH GOLD should always find an electronic minimum.  Whereas the 2PNT minimizer is almost always OK, 3PNT might be needed for systems in which successive OT CG steps do not decrease the total energy.
        self._LINE_SEARCH = self._LINESEARCH
        self._STEPSIZE = None    # Initial stepsize used for the line search, sometimes this parameter can be reduced to stablize DIIS or to improve the CG behavior in the first few steps
        self._GOLD_TARGET = None    # Target relative uncertainty in the location of the minimum for LINESEARCH GOLD
        self._PRECONDITIONER = None    # Type of preconditioner to be used with all minimization schemes. They differ in effectiveness, cost of construction, cost of application. Properly preconditioned minimization can be orders of magnitude faster than doing nothing.
        self._PRECOND_SOLVER = None    # How the preconditioner is applied to the residual.
        self._ENERGY_GAP = None    # Should be an estimate for the energy gap [a.u.] (HOMO-LUMO) and is used in preconditioning, especially effective with the FULL_ALL preconditioner, in which case it should be an underestimate of the gap (0.001 doing normally fine). For the other preconditioners, making this value larger (0.2) will tame the preconditioner in case of poor initial guesses.
        self._EPS_TAYLOR = None    # Target accuracy of the taylor expansion for the matrix functions, should normally be kept as is.
        self._EPSTAYLOR = self._EPS_TAYLOR
        self._MAX_TAYLOR = None    # Maximum order of the Taylor expansion before diagonalisation is prefered, for large parallel runs a slightly higher order could sometimes result in a small speedup.
        self._ROTATION = None    # Introduce additional variables so that rotations of the occupied subspace are allowed as well, only needed for cases where the energy is not invariant under  a rotation of the occupied subspace such as non-singlet restricted calculations  or fractional occupations.
        self._SCP_DFT = None    # Introduce additional self-consistent polarization through additional response basis functions (read in through AUX_BASIS.)
        self._SCP_NDDO = None    # Introduce additional self-consistent polarization through response basis set = orbital basis set for NDDO.)
        self._ENERGIES = None    # Optimize orbital energies for use in Fermi-Dirac smearing (requires ROTATION and FD smearing to be active).
        self._OCCUPATION_PRECONDITIONER = None    # Preconditioner with the occupation numbers (FD smearing)
        self._NONDIAG_ENERGY = None    # Add a non-diagonal energy penalty (FD smearing)
        self._NONDIAG_ENERGY_STRENGTH = None    # The prefactor for the non-diagonal energy penalty (FD smearing)
        self.name = "OT"
        self.keywords = [('_ALGORITHM', 'ALGORITHM'), ('_IRAC_DEGREE', 'IRAC_DEGREE'), ('_MAX_IRAC', 'MAX_IRAC'), ('_MIXED_PRECISION', 'MIXED_PRECISION'), ('_ORTHO_IRAC', 'ORTHO_IRAC'), ('_EPS_IRAC_FILTER_MATRIX', 'EPS_IRAC_FILTER_MATRIX'), ('_EPS_IRAC', 'EPS_IRAC'), ('_EPS_IRAC_QUICK_EXIT', 'EPS_IRAC_QUICK_EXIT'), ('_EPS_IRAC_SWITCH', 'EPS_IRAC_SWITCH'), ('_ON_THE_FLY_LOC', 'ON_THE_FLY_LOC'), ('_MINIMIZER', 'MINIMIZER'), ('_SAFE_DIIS', 'SAFE_DIIS'), ('_SAFER_DIIS', 'SAFER_DIIS'), ('_N_HISTORY_VEC', 'N_HISTORY_VEC'), ('_NDIIS', 'NDIIS'), ('_N_DIIS', 'N_DIIS'), ('_N_BROYDEN', 'N_BROYDEN'), ('_BROYDEN_BETA', 'BROYDEN_BETA'), ('_BROYDEN_GAMMA', 'BROYDEN_GAMMA'), ('_BROYDEN_SIGMA', 'BROYDEN_SIGMA'), ('_BROYDEN_ETA', 'BROYDEN_ETA'), ('_BROYDEN_OMEGA', 'BROYDEN_OMEGA'), ('_BROYDEN_SIGMA_DECREASE', 'BROYDEN_SIGMA_DECREASE'), ('_BROYDEN_SIGMA_MIN', 'BROYDEN_SIGMA_MIN'), ('_BROYDEN_FORGET_HISTORY', 'BROYDEN_FORGET_HISTORY'), ('_BROYDEN_ADAPTIVE_SIGMA', 'BROYDEN_ADAPTIVE_SIGMA'), ('_BROYDEN_ENABLE_FLIP', 'BROYDEN_ENABLE_FLIP'), ('_LINESEARCH', 'LINESEARCH'), ('_LINE_SEARCH', 'LINE_SEARCH'), ('_STEPSIZE', 'STEPSIZE'), ('_GOLD_TARGET', 'GOLD_TARGET'), ('_PRECONDITIONER', 'PRECONDITIONER'), ('_PRECOND_SOLVER', 'PRECOND_SOLVER'), ('_ENERGY_GAP', 'ENERGY_GAP'), ('_EPS_TAYLOR', 'EPS_TAYLOR'), ('_EPSTAYLOR', 'EPSTAYLOR'), ('_MAX_TAYLOR', 'MAX_TAYLOR'), ('_ROTATION', 'ROTATION'), ('_SCP_DFT', 'SCP_DFT'), ('_SCP_NDDO', 'SCP_NDDO'), ('_ENERGIES', 'ENERGIES'), ('_OCCUPATION_PRECONDITIONER', 'OCCUPATION_PRECONDITIONER'), ('_NONDIAG_ENERGY', 'NONDIAG_ENERGY'), ('_NONDIAG_ENERGY_STRENGTH', 'NONDIAG_ENERGY_STRENGTH')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class force_mixing1(printable):
    """This section enables and defines parameters for force-mixing based QM/MM, which actually does two conventional QM/MM calculations, on a small  and a large QM region, and combines the MM forces from one and QM  forces from the other to create a complete set of forces.  Energy is  not conserved (although the QM/MM energy from the large QM region calculation is reported)  so a proper thermostat (i.e. massive, and able to handle dissipation, such as  Adaptive Langevin (AD_LANGEVIN)) must be used. For some propagation algorithms  (NVT and REFTRAJ MD ensembles) algorithm is adaptive,  including molecules hysteretically based on their instantaneous distance from the core region.  Information on core/QM/buffer labels can be written in PDB file using  MOTION&PRINT&FORCE_MIXING_LABELS.  Will fail if calculation requires a  meaningfull stress, or an energy that is consistent with the forces.  For GEO_OPT this means  only MOTION&GEO_OPT&TYPE CG, MOTION&GEO_OPT&CG&LINE_SEARCH&TYPE 2PNT, and  MOTION&GEO_OPT&CG&LINE_SEARCH&2PNT&LINMIN_GRAD_ONLY T"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._MOMENTUM_CONSERVATION_TYPE = None    # How to apply force to get momentum conservation
        self._MOMENTUM_CONSERVATION_REGION = None    # Region to apply correction force to for momentum conservation
        self._R_CORE = None    # Specify the inner and outer radii of core QM region.  All molecules with any atoms within this distance (hysteretically) of any atoms  specified as QM in enclosing QM/MM section  will be core QM atoms in the force-mixing calculation.
        self._R_QM = None    # Specify the inner and outer radii of QM dynamics region.  All molecules with atoms within this distance (hysteretically) of any atoms in  core will follow QM dynamics in the force-mixing calculation.
        self._QM_EXTENDED_SEED_IS_ONLY_CORE_LIST = None    # Makes the extended QM zone be defined hysterestically  by distance from QM core list (i.e. atoms specified explicitly by  user) instead of from full QM core region (specified by user + hysteretic  selection + unbreakable bonds)
        self._R_BUF = None    # Specify the inner and outer radii of buffer region.  All atoms within this distance (hysteretically) of any QM atoms  will be buffer atoms in the force-mixing calculation.
        self.list_QM_KIND_ELEMENT_MAPPING = []
        self._QM_KIND_ELEMENT_MAPPING = None
    # Mapping from elements to QM_KINDs for adaptively included atoms.
        self._MAX_N_QM = None    # Maximum number of QM atoms, for detection of runaway adaptive selection.
        self._ADAPTIVE_EXCLUDE_MOLECULES = None    # List of molecule names to exclude from adaptive regions (e.g. big things like proteins)
        self._EXTENDED_DELTA_CHARGE = None    # Additional net charge in extended region relative to core (core charge is  specified in DFT section, as usual for a convetional QM/MM calculation)
        self.listQM_NON_ADAPTIVE = []
        self.QM_NON_ADAPTIVE = qm_non_adaptive1()
        self.listBUFFER_NON_ADAPTIVE = []
        self.BUFFER_NON_ADAPTIVE = buffer_non_adaptive1()
        self.listBUFFER_LINKS = []
        self.BUFFER_LINKS = buffer_links1()
        self.RESTART_INFO = restart_info1()
        self.PRINT = print27()
        self.name = "FORCE_MIXING"
        self.keywords = [('_MOMENTUM_CONSERVATION_TYPE', 'MOMENTUM_CONSERVATION_TYPE'), ('_MOMENTUM_CONSERVATION_REGION', 'MOMENTUM_CONSERVATION_REGION'), ('_R_CORE', 'R_CORE'), ('_R_QM', 'R_QM'), ('_QM_EXTENDED_SEED_IS_ONLY_CORE_LIST', 'QM_EXTENDED_SEED_IS_ONLY_CORE_LIST'), ('_R_BUF', 'R_BUF'), ('_MAX_N_QM', 'MAX_N_QM'), ('_ADAPTIVE_EXCLUDE_MOLECULES', 'ADAPTIVE_EXCLUDE_MOLECULES'), ('_EXTENDED_DELTA_CHARGE', 'EXTENDED_DELTA_CHARGE')]
        self.repeated_keywords = [('_QM_KIND_ELEMENT_MAPPING', 'QM_KIND_ELEMENT_MAPPING')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('RESTART_INFO', 'RESTART_INFO'), ('PRINT', 'PRINT')]
        self.repeated_subsections = [('QM_NON_ADAPTIVE', 'qm_non_adaptive1'), ('BUFFER_NON_ADAPTIVE', 'buffer_non_adaptive1'), ('BUFFER_LINKS', 'buffer_links1')]

    def addQM_NON_ADAPTIVE(self):
        new_section = qm_non_adaptive1()
        self.listQM_NON_ADAPTIVE.append(new_section)
        return new_section

    def addBUFFER_NON_ADAPTIVE(self):
        new_section = buffer_non_adaptive1()
        self.listBUFFER_NON_ADAPTIVE.append(new_section)
        return new_section

    def addBUFFER_LINKS(self):
        new_section = buffer_links1()
        self.listBUFFER_LINKS.append(new_section)
        return new_section

    def add_QM_KIND_ELEMENT_MAPPING(self, value):
        self.list_QM_KIND_ELEMENT_MAPPING.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class qm_non_adaptive1(printable):
    """List of atoms always in QM region, non-adaptively"""
    def __init__(self):
        self.listQM_KIND = []
        self.QM_KIND = qm_kind1()
        self.name = "QM_NON_ADAPTIVE"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('QM_KIND', 'qm_kind1')]

    def addQM_KIND(self):
        new_section = qm_kind1()
        self.listQM_KIND.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class mc1(printable):
    """This section sets parameters to set up a MonteCarlo calculation."""
    def __init__(self):
        self._NSTEP = None    # Specifies the number of MC cycles.
        self._IPRINT = None    # Prints coordinate/cell/etc information every IPRINT steps.
        self._NMOVES = None    # Specifies the number of classical moves between energy evaluations.
        self._NSWAPMOVES = None    # How many insertions to try per swap move.
        self._LBIAS = None    # Dictates if we presample moves with a different potential.
        self._LSTOP = None    # Makes nstep in terms of steps, instead of cycles.
        self._LDISCRETE = None    # Changes the volume of the box in discrete steps, one side at a time.
        self._RESTART = None    # Read initial configuration from restart file.
        self._IUPVOLUME = None    # Every iupvolume steps update maximum volume displacement.
        self._IUPTRANS = None    # Every iuptrans steps update maximum translation.
        self._NVIRIAL = None    # Use this many random orientations to compute the second virial coefficient (ENSEMBLE=VIRIAL)
        self._ENSEMBLE = None    # Specify the type of simulation
        self._RESTART_FILE_NAME = None    # Name of the restart file for MC information.
        self._MOVES_FILE_NAME = None    # The file to print the move statistics to.
        self._MOLECULES_FILE_NAME = None    # The file to print the number of molecules to.
        self._COORDINATE_FILE_NAME = None    # The file to print the current coordinates to.
        self._ENERGY_FILE_NAME = None    # The file to print current energies to.
        self._DATA_FILE_NAME = None    # The file to print current configurational info to.
        self._CELL_FILE_NAME = None    # The file to print current cell length info to.
        self._MAX_DISP_FILE_NAME = None    # The file to print current maximum displacement info to.
        self._BOX2_FILE_NAME = None    # For GEMC, the name of the input file for the other box.
        self._PRESSURE = None    # The pressure for NpT simulations, in bar.
        self._TEMPERATURE = None    # The temperature of the simulation, in Kelvin.
        self._PMSWAP = None    # The probability of attempting a swap move.
        self._PMSWAP_MOL = None    # The probability of attempting a molecule swap of a given molecule type.
        self._PMHMC = None    # The probability of attempting a hybrid MC move.
        self._PMHMC_BOX = None    # The probability of attempting a HMC move on this box.
        self._PMVOLUME = None    # The probability of attempting a volume move.
        self._PMVOL_BOX = None    # The probability of attempting a volume move on this box (GEMC_NpT).
        self._PMROT_MOL = None    # The probability of attempting a molecule rotation of a given molecule type.
        self._PMTRAION = None    # The probability of attempting a conformational change.
        self._PMTRAION_MOL = None    # The probability of attempting a conformational change of a given molecule type.
        self._PMTRANS = None    # The probability of attempting a molecule translation.
        self._PMTRANS_MOL = None    # The probability of attempting a molecule translation of a given molecule type.
        self._RMVOLUME = None    # Maximum volume displacement, in angstrom**3.
        self._AVBMC_ATOM = None    # The target atom for an AVBMC swap move for each molecule type.
        self._RMBOND = None    # Maximum bond length displacement, in angstroms, for each molecule type.
        self._RMANGLE = None    # Maximum bond angle displacement, in degrees, for each molecule type.
        self._RMDIHEDRAL = None    # Maximum dihedral angle distplacement, in degrees, for each molecule type.
        self._RMROT = None    # Maximum rotational displacement, in degrees, for each molecule type.
        self._RMTRANS = None    # Maximum translational displacement, in angstroms, for each molecule type.
        self._VIRIAL_TEMPS = None    # The temperatures you wish to compute the virial coefficient for.  Only used if ensemble=VIRIAL.
        self._AVBMC_RMIN = None    # The inner radius for an AVBMC swap move, in angstroms for every molecule type.
        self._AVBMC_RMAX = None    # The outer radius for an AVBMC swap move, in angstroms, for every molecule type.
        self._PMAVBMC = None    # The probability of attempting an AVBMC swap move.
        self._PMAVBMC_MOL = None    # The probability of attempting an AVBMC swap move on each molecule type.
        self._PBIAS = None    # The probability of swapping to an inner region in an AVBMC swap move for each molecule type.
        self._DISCRETE_STEP = None    # The size of the discrete volume move step, in angstroms.
        self._ETA = None    # The free energy bias (in Kelvin) for swapping a molecule of each type into this box.
        self._RANDOMTOSKIP = None    # Number of random numbers from the acceptance/rejection stream to skip
        self.name = "MC"
        self.keywords = [('_NSTEP', 'NSTEP'), ('_IPRINT', 'IPRINT'), ('_NMOVES', 'NMOVES'), ('_NSWAPMOVES', 'NSWAPMOVES'), ('_LBIAS', 'LBIAS'), ('_LSTOP', 'LSTOP'), ('_LDISCRETE', 'LDISCRETE'), ('_RESTART', 'RESTART'), ('_IUPVOLUME', 'IUPVOLUME'), ('_IUPTRANS', 'IUPTRANS'), ('_NVIRIAL', 'NVIRIAL'), ('_ENSEMBLE', 'ENSEMBLE'), ('_RESTART_FILE_NAME', 'RESTART_FILE_NAME'), ('_MOVES_FILE_NAME', 'MOVES_FILE_NAME'), ('_MOLECULES_FILE_NAME', 'MOLECULES_FILE_NAME'), ('_COORDINATE_FILE_NAME', 'COORDINATE_FILE_NAME'), ('_ENERGY_FILE_NAME', 'ENERGY_FILE_NAME'), ('_DATA_FILE_NAME', 'DATA_FILE_NAME'), ('_CELL_FILE_NAME', 'CELL_FILE_NAME'), ('_MAX_DISP_FILE_NAME', 'MAX_DISP_FILE_NAME'), ('_BOX2_FILE_NAME', 'BOX2_FILE_NAME'), ('_PRESSURE', 'PRESSURE'), ('_TEMPERATURE', 'TEMPERATURE'), ('_PMSWAP', 'PMSWAP'), ('_PMSWAP_MOL', 'PMSWAP_MOL'), ('_PMHMC', 'PMHMC'), ('_PMHMC_BOX', 'PMHMC_BOX'), ('_PMVOLUME', 'PMVOLUME'), ('_PMVOL_BOX', 'PMVOL_BOX'), ('_PMROT_MOL', 'PMROT_MOL'), ('_PMTRAION', 'PMTRAION'), ('_PMTRAION_MOL', 'PMTRAION_MOL'), ('_PMTRANS', 'PMTRANS'), ('_PMTRANS_MOL', 'PMTRANS_MOL'), ('_RMVOLUME', 'RMVOLUME'), ('_AVBMC_ATOM', 'AVBMC_ATOM'), ('_RMBOND', 'RMBOND'), ('_RMANGLE', 'RMANGLE'), ('_RMDIHEDRAL', 'RMDIHEDRAL'), ('_RMROT', 'RMROT'), ('_RMTRANS', 'RMTRANS'), ('_VIRIAL_TEMPS', 'VIRIAL_TEMPS'), ('_AVBMC_RMIN', 'AVBMC_RMIN'), ('_AVBMC_RMAX', 'AVBMC_RMAX'), ('_PMAVBMC', 'PMAVBMC'), ('_PMAVBMC_MOL', 'PMAVBMC_MOL'), ('_PBIAS', 'PBIAS'), ('_DISCRETE_STEP', 'DISCRETE_STEP'), ('_ETA', 'ETA'), ('_RANDOMTOSKIP', 'RANDOMTOSKIP')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class centroid_gyr1(printable):
    """Controls the output of the centroid's radii of gyration"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._UNIT = None    # Specify the unit of measurement for the quantity in output. All available CP2K units can be used.
        self.EACH = each1()
        self.name = "CENTROID_GYR"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_UNIT', 'UNIT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class vwn1(printable):
    """Uses the VWN functional"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._SCALE_C = None    # scales the correlation part of the functional
        self._FUNCTIONAL_TYPE = None    # Which version of the VWN functional should be used
        self.name = "VWN"
        self.keywords = [('_SCALE_C', 'SCALE_C'), ('_FUNCTIONAL_TYPE', 'FUNCTIONAL_TYPE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class coord6(printable):
    """The coordinates for simple systems (like the QM ones) xyz format by default. More complex systems should be given with an external pdb file."""
    def __init__(self):
        self._UNIT = None    # Specify the unit of measurement for the coordinates in inputAll available CP2K units can be used.
        self._SCALED = None    # Specify if the coordinateds in input are scaled.
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # ATOM_KIND  X  Y  Z  <MOLNAME>. MOLNAME is optional. If not provided the molecule name is internally created. All other fields after MOLNAME are simply ignored.
        self.name = "COORD"
        self.keywords = [('_UNIT', 'UNIT'), ('_SCALED', 'SCALED')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class nonperiodic_sys1(printable):
    """Specifies the parameter for sampling the RESP fitting points for non-periodic systems, i.e. systems that do not involve surfaces. This section can be used with periodic and nonperiodic Poisson solvers, it only affects the sampling of grid points. All grid points in the shell defined by rmin and rmax are accepted for fitting."""
    def __init__(self):
        self._X_LOW = None    # Specifies the lower boundary of the box along X used to sample the potential.
        self._X_HI = None    # Specifies the upper boundary of the box along X used to sample the potential.
        self._Y_LOW = None    # Specifies the lower boundary of the box along Y used to sample the potential.
        self._Y_HI = None    # Specifies the upper boundary of the box along Y used to sample the potential.
        self._Z_LOW = None    # Specifies the lower boundary of the box along Z used to sample the potential.
        self._Z_HI = None    # Specifies the upper boundary of the box along Z used to sample the potential.
        self._RMAX = None    # Specifies the maximum distance a fit point is away from an atom. Valid for all atomic kinds for which no RMAX_KIND are specified.
        self._RMIN = None    # Specifies the minimum distance a fit point is away from an atom. Valid for all atomic kinds for which no RMIN_KIND are specified.
        self.list_RMAX_KIND = []
        self._RMAX_KIND = None
    # Specifies the maximum distance a fit point is away from an atom of a given kind
        self.list_RMIN_KIND = []
        self._RMIN_KIND = None
    # Specifies the minimum distance a fit point is away from an atom of a given kind
        self.name = "NONPERIODIC_SYS"
        self.keywords = [('_X_LOW', 'X_LOW'), ('_X_HI', 'X_HI'), ('_Y_LOW', 'Y_LOW'), ('_Y_HI', 'Y_HI'), ('_Z_LOW', 'Z_LOW'), ('_Z_HI', 'Z_HI'), ('_RMAX', 'RMAX'), ('_RMIN', 'RMIN')]
        self.repeated_keywords = [('_RMAX_KIND', 'RMAX_KIND'), ('_RMIN_KIND', 'RMIN_KIND')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def add_RMAX_KIND(self, value):
        self.list_RMAX_KIND.append(value)

    def add_RMIN_KIND(self, value):
        self.list_RMIN_KIND.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class rho0_information1(printable):
    """If the printkey is activated controls if information on rho0 is printed."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._UNIT = None    # Specify the unit of measurement for the quantity in output. All available CP2K units can be used.
        self.EACH = each1()
        self.name = "RHO0_INFORMATION"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_UNIT', 'UNIT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class beta1(printable):
    """beta spin"""
    def __init__(self):
        self._NEL = None    # Orbital ccupation change per angular momentum quantum number.Applied to spin beta and active only in unrestricted calculations.
        self._L = None    # Angular momentum quantum number of theorbitals of beta spin whose occupation is changed.Active only for unrestricted calculations
        self._N = None    # Principal quantum number of theorbitals of beta spin whose occupation is changed. Default is the first not occupied.Active only for unrestricted calculations
        self.name = "BETA"
        self.keywords = [('_NEL', 'NEL'), ('_L', 'L'), ('_N', 'N')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class bond_rotation1(printable):
    """Section to define the rotation of a bond/line with respect toanother bond/line"""
    def __init__(self):
        self._P1_BOND1 = None    # Specifies the index of atom/point defining the first pointof the first bond/line.
        self._P2_BOND1 = None    # Specifies the index of atom/point defining the second pointof the first bond/line.
        self._P1_BOND2 = None    # Specifies the index of atom/point defining the first pointof the second bond/line.
        self._P2_BOND2 = None    # Specifies the index of atom/point defining the second pointof the second bond/line.
        self.listPOINT = []
        self.POINT = point1()
        self.name = "BOND_ROTATION"
        self.keywords = [('_P1_BOND1', 'P1_BOND1'), ('_P2_BOND1', 'P2_BOND1'), ('_P1_BOND2', 'P1_BOND2'), ('_P2_BOND2', 'P2_BOND2')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('POINT', 'point1')]

    def addPOINT(self):
        new_section = point1()
        self.listPOINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class derived_basis_sets1(printable):
    """This section can be used to create subsets of a basis  which will be fitted at the same time. This is especially useful if connected bsis sets e.g. TZVP, DZVP, SZV should be fitted."""
    def __init__(self):
        self._REFERENCE_SET = None    # Specifies the reference basis ID which is used as template to create the new set. The original basis has ID 0. All follwing sets are counted in order as specified in the Input. The decriptors always assume the structure of the input basis set.
        self.list_REMOVE_CONTRACTION = []
        self._REMOVE_CONTRACTION = None
    # Can be used to remove a contraction from the reference basis set. The contraction is speciefied by set number, angular momentum and number of contraction. The decriptors always assume the structure of the input basis set.
        self.list_REMOVE_SET = []
        self._REMOVE_SET = None
    # Can be used to remove a set from the reference basis set.
        self.name = "DERIVED_BASIS_SETS"
        self.keywords = [('_REFERENCE_SET', 'REFERENCE_SET')]
        self.repeated_keywords = [('_REMOVE_CONTRACTION', 'REMOVE_CONTRACTION'), ('_REMOVE_SET', 'REMOVE_SET')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def add_REMOVE_CONTRACTION(self, value):
        self.list_REMOVE_CONTRACTION.append(value)

    def add_REMOVE_SET(self, value):
        self.list_REMOVE_SET.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class coupling1(printable):
    """Coupling between two force_eval: E=(E1+E2 - sqrt((E1-E2)**2+4*H12**2))/2"""
    def __init__(self):
        self._COUPLING_PARAMETER = None    # Coupling parameter H12 used in the coupling
        self.name = "COUPLING"
        self.keywords = [('_COUPLING_PARAMETER', 'COUPLING_PARAMETER')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class xc_potential1(printable):
    """The xc potential to use (CAREFUL: xc potential here refers to potentials that are not derived from an xc functional, but rather are modelled directly. Therefore there is no consistent xc energy available. To still get an energy expression, see ENERGY below"""
    def __init__(self):
        self._ENERGY = None    # How to determine the total energy.
        self.listSAOP = []
        self.SAOP = saop1()
        self.name = "XC_POTENTIAL"
        self.keywords = [('_ENERGY', 'ENERGY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('SAOP', 'saop1')]

    def addSAOP(self):
        new_section = saop1()
        self.listSAOP.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class xyz_outerdiag1(printable):
    """Section to define the cross term (XA-XA(0))*(XB-XB(0))+(XA-XA(0))*(YB-YB(0)) or part of its components as a collective variable. The final term is given by the product  of the components of A with the components of B."""
    def __init__(self):
        self._ATOMS = None    # Specifies the index of the atoms/points A and B.
        self._POINTS = self._ATOMS
        self._COMPONENT_A = None    # Define the component of the position vector which will be used as a colvar for atom A.
        self._COMPONENT_B = None    # Define the component of the position vector which will be used as a colvar for atom B.
        self._PBC = None    # Whether periodic boundary conditions should be applied on the atomic position before computing the colvar or not.
        self.listPOINT = []
        self.POINT = point1()
        self.name = "XYZ_OUTERDIAG"
        self.keywords = [('_ATOMS', 'ATOMS'), ('_POINTS', 'POINTS'), ('_COMPONENT_A', 'COMPONENT_A'), ('_COMPONENT_B', 'COMPONENT_B'), ('_PBC', 'PBC')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('POINT', 'point1')]

    def addPOINT(self):
        new_section = point1()
        self.listPOINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class force_eval_mixed1(printable):
    """Defines the fragments for the mixed force_eval (reference)"""
    def __init__(self):
        self.listFRAGMENT = []
        self.FRAGMENT = fragment1()
        self.name = "FORCE_EVAL_MIXED"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('FRAGMENT', 'fragment1')]

    def addFRAGMENT(self):
        new_section = fragment1()
        self.listFRAGMENT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class qmmm1(printable):
    """Input for QM/MM calculations."""
    def __init__(self):
        self._E_COUPL = None    # Specifies the type of the QM - MM electrostatic coupling.
        self._QMMM_COUPLING = self._E_COUPL
        self._ECOUPL = self._E_COUPL
        self._MM_POTENTIAL_FILE_NAME = None    # Name of the file containing the potential expansion in gaussians. See the USE_GEEP_LIB keyword.
        self._USE_GEEP_LIB = None    #  This keyword enables the use of the internal GEEP library to generate the gaussian expansion of the MM potential. Using this keyword there's no need to provide the MM_POTENTIAL_FILENAME. It expects a number from 2 to 15 (the number of gaussian funtions to be used in the expansion.
        self._NOCOMPATIBILITY = None    # This keyword disables the compatibility of QM/MM potential between CPMD and CP2K implementations. The compatibility is achieved using an MM potential of the form: Erf[x/rc]/x + (1/rc -2/(pi^1/2*rc))*Exp[-(x/rc)^2] .This keyword has effect only selecting GAUSS E_COUPLING type.
        self._EPS_MM_RSPACE = None    # Set the threshold for the collocation of the GEEP gaussian functions.this keyword affects only the GAUSS E_COUPLING.
        self._SPHERICAL_CUTOFF = None    # Set the spherical cutoff for the QMMM electrostatic interaction. This acts like a charge multiplicative factor dependent on cutoff. For MM atoms farther than the SPHERICAL_CUTOFF(1) their charge is zero. The switch is performed with a smooth function: 0.5*(1-TANH((r-[SPH_CUT(1)-20*SPH_CUT(2)])/(SPH_CUT(2)))). Two values are required: the first one is the distance cutoff. The second one controls the stiffness of the smoothing.
        self._PARALLEL_SCHEME = None    # Chooses the parallel_scheme for the long range Potential
        self._NOCENTER = None    # This keyword disables the automatic centering of the qm system every MD step.It centers the system only for the first step. Default .FALSE. (i.e. the QM system is centered every step)
        self._NOCENTER0 = None    # This keyword disables the automatic centering of the qm system every MD step  even for the first step. Default .FALSE. (i.e. the QM system is centered every step)
        self._TYP_CENTER = None    # This keyword specifies how the QM system is centered with respect to the QM box during MD.
        self._INITIAL_TRANSLATION_VECTOR = None    # This keyword specify the initial translation vector to be applied to the system.
        self._DELTA_CHARGE = None    # Additional net charge relative to that specified in DFT section.  Used automatically by force mixing
        self.FORCE_MIXING = force_mixing1()
        self.listQM_KIND = []
        self.QM_KIND = qm_kind1()
        self.listMM_KIND = []
        self.MM_KIND = mm_kind1()
        self.CELL = cell3()
        self.PERIODIC = periodic2()
        self.listLINK = []
        self.LINK = link1()
        self.INTERPOLATOR = interpolator3()
        self.listFORCEFIELD = []
        self.FORCEFIELD = forcefield2()
        self.WALLS = walls1()
        self.IMAGE_CHARGE = image_charge1()
        self.PRINT = print28()
        self.name = "QMMM"
        self.keywords = [('_E_COUPL', 'E_COUPL'), ('_QMMM_COUPLING', 'QMMM_COUPLING'), ('_ECOUPL', 'ECOUPL'), ('_MM_POTENTIAL_FILE_NAME', 'MM_POTENTIAL_FILE_NAME'), ('_USE_GEEP_LIB', 'USE_GEEP_LIB'), ('_NOCOMPATIBILITY', 'NOCOMPATIBILITY'), ('_EPS_MM_RSPACE', 'EPS_MM_RSPACE'), ('_SPHERICAL_CUTOFF', 'SPHERICAL_CUTOFF'), ('_PARALLEL_SCHEME', 'PARALLEL_SCHEME'), ('_NOCENTER', 'NOCENTER'), ('_NOCENTER0', 'NOCENTER0'), ('_TYP_CENTER', 'TYP_CENTER'), ('_INITIAL_TRANSLATION_VECTOR', 'INITIAL_TRANSLATION_VECTOR'), ('_DELTA_CHARGE', 'DELTA_CHARGE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('FORCE_MIXING', 'FORCE_MIXING'), ('CELL', 'CELL'), ('PERIODIC', 'PERIODIC'), ('INTERPOLATOR', 'INTERPOLATOR'), ('WALLS', 'WALLS'), ('IMAGE_CHARGE', 'IMAGE_CHARGE'), ('PRINT', 'PRINT')]
        self.repeated_subsections = [('QM_KIND', 'qm_kind1'), ('MM_KIND', 'mm_kind1'), ('LINK', 'link1'), ('FORCEFIELD', 'forcefield2')]

    def addQM_KIND(self):
        new_section = qm_kind1()
        self.listQM_KIND.append(new_section)
        return new_section

    def addMM_KIND(self):
        new_section = mm_kind1()
        self.listMM_KIND.append(new_section)
        return new_section

    def addLINK(self):
        new_section = link1()
        self.listLINK.append(new_section)
        return new_section

    def addFORCEFIELD(self):
        new_section = forcefield2()
        self.listFORCEFIELD.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class xyz_diag1(printable):
    """Section to define the distance of an atom from its starting position (X-X(0)^2+Y-Y(0)^2+Z-Z(0)^2) or part of its components as a collective variable."""
    def __init__(self):
        self._ATOM = None    # Specifies the index of the atom/point.
        self._POINT = self._ATOM
        self._COMPONENT = None    # Define the component of the position vector which will be used as a colvar.
        self._PBC = None    # Whether periodic boundary conditions should be applied on the atomic position before computing the colvar or not.
        self.listPOINT = []
        self.POINT = point1()
        self.name = "XYZ_DIAG"
        self.keywords = [('_ATOM', 'ATOM'), ('_POINT', 'POINT'), ('_COMPONENT', 'COMPONENT'), ('_PBC', 'PBC')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('POINT', 'point1')]

    def addPOINT(self):
        new_section = point1()
        self.listPOINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class becke971(printable):
    """Uses the Becke 97 exchange correlation functional"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._SCALE_X = None    # scales the exchange part of the functional, if -1 the default for the given parametrization is used
        self._SCALE_C = None    # scales the correlation part of the functional
        self._PARAMETRIZATION = None    # switches between the B97 and Grimme parametrization
        self.name = "BECKE97"
        self.keywords = [('_SCALE_X', 'SCALE_X'), ('_SCALE_C', 'SCALE_C'), ('_PARAMETRIZATION', 'PARAMETRIZATION')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class global1(printable):
    """Section with general information regarding which kind of simulation to perform an parameters for the whole PROGRAM"""
    def __init__(self):
        self._BLACS_GRID = None    # how to distribute the processors on the 2d grid needed by BLACS (and thus SCALAPACK)
        self._BLACS_REPEATABLE = None    # Use a topology for BLACS collectives that is guaranteed to be repeatable on homegeneous architectures
        self._PREFERRED_FFT_LIBRARY = None    # Specifies the FFT library which should be preferred. If it is not available, use FFTW3 if this is linked in, if FFTW3 is not available use FFTSG. Improved performance with FFTW3 can be obtained specifying a proper value for FFTW_PLAN_TYPE. Contrary to earlier CP2K versions, all libraries will result in the same grids, i.e. the subset of grids which all FFT libraries can transform. See EXTENDED_FFT_LENGTHS if larger FFTs or grids that more precisely match a given cutoff are needed, or older results need to be reproduced. FFTW3 is often (close to) optimal, and well tested with CP2K.
        self._FFTW_WISDOM_FILE_NAME = None    # The name of the file that contains wisdom (pre-planned FFTs) for use with FFTW3. Using wisdom can significantly speed up the FFTs (see the FFTW homepage for details). Note that wisdom is not transferable between different computer (architectures). Wisdom can be generated using the fftw-wisdom tool that is part of the fftw installation. cp2k/tools/cp2k-wisdom is a script that contains some additional info, and can help to generate a useful default for /etc/fftw/wisdom or particular values for a given simulation.
        self._FFTW_PLAN_TYPE = None    # FFTW can have improved performance if it is allowed to plan with explicit measurements which strategy is best for a given FFT. While a plan based on measurements is generally faster, differences in machine load will lead to different plans for the same input file, and thus numerics for the FFTs will be slightly different from run to run.PATIENT planning is recommended for long ab initio MD runs.
        self._EXTENDED_FFT_LENGTHS = None    # Use fft library specific values for the allows number of points in FFTs. The default is to use the internal FFT lengths. For external fft libraries this may create an error at the external library level, because the length provided by cp2k is not supported by the external library. In this case switch on this keyword to obtain, with certain fft libraries, lengths matching the external fft library lengths, or larger allowed grids, or grids that more precisely match a given cutoff. IMPORTANT NOTE: in this case, the actual grids used in CP2K depends on the FFT library. A change of FFT library must therefore be considered equivalent to a change of basis, which implies a change of total energy.
        self._FFT_POOL_SCRATCH_LIMIT = None    # Limits the memory usage of the FFT scratch pool, potentially reducing efficiency a bit
        self._ALLTOALL_SGL = None    # All-to-all communication (FFT) should use single precision
        self._PRINT_LEVEL = None    # How much output is written out.
        self._IOLEVEL = self._PRINT_LEVEL
        self._PROGRAM_NAME = None    # Which program should be run
        self._PROGRAM = self._PROGRAM_NAME
        self._PROJECT_NAME = None    # Name of the project (used to build the name of the trajectory, and other files generated by the program)
        self._PROJECT = self._PROJECT_NAME
        self._OUTPUT_FILE_NAME = None    # Name of the output file. Relevant only if automatically started (through farming for example). If empty uses the project name as basis for it.
        self._RUN_TYPE = None    # Type of run that you want to perform Geometry optimization, md, montecarlo,...
        self._WALLTIME = None    # Maximum execution time for this run. Time in seconds.
        self._WALLTI = self._WALLTIME
        self._ECHO_INPUT = None    # If the input should be echoed to the output with all the defaults made explicit
        self._ECHO_ALL_HOSTS = None    # Echo a list of hostname and pid for all MPI processes.
        self._TRACE = None    # If a debug trace of the execution of the program should be written
        self._TRACE_MASTER = None    # For parallel TRACEd runs: only the master node writes output.
        self._TRACE_MAX = None    # Limit the total number a given subroutine is printed in the trace. Accounting is not influenced.
        self._TRACE_ROUTINES = None    # A list of routines to trace. If left empty all routines are traced. Accounting is not influenced.
        self._FLUSH_SHOULD_FLUSH = None    # Flush output regularly, enabling this option might degrade performance significantly on certain machines.
        self._CALLGRAPH = None    # At the end of the run write a callgraph to file, which contains detailed timing informations. This callgraph can be viewed e.g. with the open-source program kcachegrind.
        self._CALLGRAPH_FILE_NAME = None    # Name of the callgraph file, which is writte a the end of the run. If not specified the project name will be used as filename.
        self._SEED = None    # Initial seed for the global (pseudo)random number generator to create a stream of normally Gaussian distributed random numbers.
        self._SAVE_MEM = None    # Some sections of the input structure are deallocated when not needed, and reallocated only when used. This reduces the required maximum memory
        self._ENABLE_UNSUPPORTED_FEATURES = None    # This keywords enables the usage of unsupported features in a release version. It affects ONLY release versions of CP2K (no effects on development versions).
        self.TIMINGS = timings1()
        self.REFERENCES = references1()
        self.PROGRAM_RUN_INFO = program_run_info1()
        self.PRINT = print1()
        self.CUDA = cuda1()
        self.MACHINE_ARCH = machine_arch1()
        self.DBCSR = dbcsr1()
        self.name = "GLOBAL"
        self.keywords = [('_BLACS_GRID', 'BLACS_GRID'), ('_BLACS_REPEATABLE', 'BLACS_REPEATABLE'), ('_PREFERRED_FFT_LIBRARY', 'PREFERRED_FFT_LIBRARY'), ('_FFTW_WISDOM_FILE_NAME', 'FFTW_WISDOM_FILE_NAME'), ('_FFTW_PLAN_TYPE', 'FFTW_PLAN_TYPE'), ('_EXTENDED_FFT_LENGTHS', 'EXTENDED_FFT_LENGTHS'), ('_FFT_POOL_SCRATCH_LIMIT', 'FFT_POOL_SCRATCH_LIMIT'), ('_ALLTOALL_SGL', 'ALLTOALL_SGL'), ('_PRINT_LEVEL', 'PRINT_LEVEL'), ('_IOLEVEL', 'IOLEVEL'), ('_PROGRAM_NAME', 'PROGRAM_NAME'), ('_PROGRAM', 'PROGRAM'), ('_PROJECT_NAME', 'PROJECT_NAME'), ('_PROJECT', 'PROJECT'), ('_OUTPUT_FILE_NAME', 'OUTPUT_FILE_NAME'), ('_RUN_TYPE', 'RUN_TYPE'), ('_WALLTIME', 'WALLTIME'), ('_WALLTI', 'WALLTI'), ('_ECHO_INPUT', 'ECHO_INPUT'), ('_ECHO_ALL_HOSTS', 'ECHO_ALL_HOSTS'), ('_TRACE', 'TRACE'), ('_TRACE_MASTER', 'TRACE_MASTER'), ('_TRACE_MAX', 'TRACE_MAX'), ('_TRACE_ROUTINES', 'TRACE_ROUTINES'), ('_FLUSH_SHOULD_FLUSH', 'FLUSH_SHOULD_FLUSH'), ('_CALLGRAPH', 'CALLGRAPH'), ('_CALLGRAPH_FILE_NAME', 'CALLGRAPH_FILE_NAME'), ('_SEED', 'SEED'), ('_SAVE_MEM', 'SAVE_MEM'), ('_ENABLE_UNSUPPORTED_FEATURES', 'ENABLE_UNSUPPORTED_FEATURES')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('TIMINGS', 'TIMINGS'), ('REFERENCES', 'REFERENCES'), ('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('PRINT', 'PRINT'), ('CUDA', 'CUDA'), ('MACHINE_ARCH', 'MACHINE_ARCH'), ('DBCSR', 'DBCSR')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class hf_info1(printable):
    """Controls the printing basic info about hf method"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "HF_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class velocities1(printable):
    """Controls the output of the velocities"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._UNIT = None    # Specify the unit of measurement for the quantity in output. All available CP2K units can be used.
        self._FORMAT = None    # Specifies the format of the output file for the velocities.
        self.EACH = each1()
        self.name = "VELOCITIES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_UNIT', 'UNIT'), ('_FORMAT', 'FORMAT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class k_matrix1(printable):
    """Controls the printing of the indirect spin-spin matrix"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.list_ATOMS_LIST = []
        self._ATOMS_LIST = None
    # list of atoms for which the indirect spin-spin is printed into a file
        self.EACH = each1()
        self.name = "K_MATRIX"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = [('_ATOMS_LIST', 'ATOMS_LIST')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def add_ATOMS_LIST(self, value):
        self.list_ATOMS_LIST.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class scf_info1(printable):
    """Controls the printing of SCF information"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "SCF_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class distance_function1(printable):
    """Section to define functions between two distances as collective variables. The function is defined as d1+coeff*d2"""
    def __init__(self):
        self._ATOMS = None    # Specifies the indexes of atoms/points for the two bonds d1=(1-2) d2=(3-4).
        self._POINTS = self._ATOMS
        self._COEFFICIENT = None    # Specifies the coefficient in the function for the constraint. -1.0 has to be used for distance difference, 1.0 for distance addition
        self._PBC = None    # Whether periodic boundary conditions should be applied on the atomic position before computing the colvar or not.
        self.listPOINT = []
        self.POINT = point1()
        self.name = "DISTANCE_FUNCTION"
        self.keywords = [('_ATOMS', 'ATOMS'), ('_POINTS', 'POINTS'), ('_COEFFICIENT', 'COEFFICIENT'), ('_PBC', 'PBC')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('POINT', 'point1')]

    def addPOINT(self):
        new_section = point1()
        self.listPOINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class restart3(printable):
    """Controls the dumping of the MO restart file during scf.By default keeps a short history of three restarts.See also RESTART_HISTORY"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._BACKUP_COPIES = None    # Specifies the maximum index of backup copies.
        self.EACH = each1()
        self.name = "RESTART"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_BACKUP_COPIES', 'BACKUP_COPIES')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class restart2(printable):
    """Controls the dumping of the restart file during runs. By default keeps a short history of three restarts. See also RESTART_HISTORY"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._BACKUP_COPIES = None    # Specifies the maximum number of backup copies.
        self._SPLIT_RESTART_FILE = None    # If specified selected input sections, which are growing with the number of atoms in the system, are written to another restart file in binary format instead of the default restart file in human readable ASCII format. This split of the restart file may provide significant memory savings and an accelerated I/O for systems with a very large number of atoms
        self.EACH = each1()
        self.name = "RESTART"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_BACKUP_COPIES', 'BACKUP_COPIES'), ('_SPLIT_RESTART_FILE', 'SPLIT_RESTART_FILE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class restart1(printable):
    """Controls the printing of Hessian Restart file"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "RESTART"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class improper2(printable):
    """Section used to add/remove improper in the connectivity. Useful for systems with a complex connectivity, difficult to find out automatically."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self.list_ATOMS = []
        self._ATOMS = None
    # Specifies two atomic index united by a covalent bond
        self.name = "IMPROPER"
        self.keywords = []
        self.repeated_keywords = [('_ATOMS', 'ATOMS')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def add_ATOMS(self, value):
        self.list_ATOMS.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class rng_init1(printable):
    """Information to initialize the parallel random number generator streams"""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Specify an initial RNG stream
        self.name = "RNG_INIT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class restart6(printable):
    """Controls the dumping of the restart file during BSSE runs.By default the restart is updated after each configuration calculation is  completed."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "RESTART"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class restart5(printable):
    """Controls the dumping of the MO restart file during rtp.By default keeps a short history of three restarts.See also RESTART_HISTORY"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._BACKUP_COPIES = None    # Specifies the maximum index of backup copies.
        self.EACH = each1()
        self.name = "RESTART"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_BACKUP_COPIES', 'BACKUP_COPIES')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class mass2(printable):
    """The masses for NOSE HOOVER used for restart"""
    def __init__(self):
        self._DEFAULT_KEYWORD = None    # Specify masses of the system
        self.name = "MASS"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []
        pass

    def print_input(self, level):
        return printable.print_input(self, level)


class restart9(printable):
    """writes an input file that can be used to restart"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._BACKUP_COPIES = None    # Specifies the maximum index of backup copies.
        self.EACH = each1()
        self.name = "RESTART"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_BACKUP_COPIES', 'BACKUP_COPIES')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class restart8(printable):
    """controls the printing of the restart for FARMING."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "RESTART"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class rotational_info1(printable):
    """Controls the printing basic info during the cleaning of the rotational degrees of freedom."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._COORDINATES = None    # Prints atomic coordinates after rotation
        self.EACH = each1()
        self.name = "ROTATIONAL_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_COORDINATES', 'COORDINATES')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class rotational_info2(printable):
    """Controls the printing basic info during the calculation of the translational/rotational degrees of freedom."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._COORDINATES = None    # Prints atomic coordinates in the standard orientation. Coordinates are not affected during the calculation.
        self.EACH = each1()
        self.name = "ROTATIONAL_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_COORDINATES', 'COORDINATES')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class pw_transfer1(printable):
    """Benchmark and test the pw_transfer routines."""
    def __init__(self):
        self._GRID = None    # Specify the number of grid points (not all grid points are allowed)
        self._N_LOOP = None    # Number of pw_transfers (backward&forward) being timed
        self._PW_GRID = None    # What kind of PW_GRID should be employed
        self._PW_GRID_LAYOUT_ALL = None    # loop overal all PW_GRID_LAYOUTs that are compatible with a given number of CPUs
        self._DEBUG = None    # Do the FFT in debug mode in all cases
        self._PW_GRID_LAYOUT = None    # Expert use only, leave the default...Can be used to set the distribution for ray-distributed FFT.
        self._PW_GRID_BLOCKED = None    # Expert use only, leave the default...Can be used to set the distribution in g-space for the pw grids and their FFT.
        self.name = "PW_TRANSFER"
        self.keywords = [('_GRID', 'GRID'), ('_N_LOOP', 'N_LOOP'), ('_PW_GRID', 'PW_GRID'), ('_PW_GRID_LAYOUT_ALL', 'PW_GRID_LAYOUT_ALL'), ('_DEBUG', 'DEBUG'), ('_PW_GRID_LAYOUT', 'PW_GRID_LAYOUT'), ('_PW_GRID_BLOCKED', 'PW_GRID_BLOCKED')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class potential4(printable):
    """Section of information on potential."""
    def __init__(self):
        self._CONFINEMENT = None    # Definition of confinement potential
        self._PSEUDO_TYPE = None    # Pseudopotential type
        self._POTENTIAL_FILE_NAME = None    # Name of the pseudo potential file, may include a path
        self._POTENTIAL_NAME = None    # The name of the pseudopotential for the defined kind.
        self._POT_NAME = self._POTENTIAL_NAME
        self.GTH_POTENTIAL = gth_potential1()
        self.name = "POTENTIAL"
        self.keywords = [('_CONFINEMENT', 'CONFINEMENT'), ('_PSEUDO_TYPE', 'PSEUDO_TYPE'), ('_POTENTIAL_FILE_NAME', 'POTENTIAL_FILE_NAME'), ('_POTENTIAL_NAME', 'POTENTIAL_NAME'), ('_POT_NAME', 'POT_NAME')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('GTH_POTENTIAL', 'GTH_POTENTIAL')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class potential1(printable):
    """Controls the printing of the QMMM  potential"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._STRIDE = None    # The stride (X,Y,Z) used to write the cube file (larger values result in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1 number valid for all components.
        self.EACH = each1()
        self.name = "POTENTIAL"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_STRIDE', 'STRIDE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class potential2(printable):
    """Section used to specify Potentials."""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # CP2K Pseudo Potential Standard Format (GTH, ALL or KG)
        self.name = "POTENTIAL"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class potential3(printable):
    """Controls the printing of the potentials"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "POTENTIAL"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class forcefield2(printable):
    """Specify information on the QM/MM forcefield"""
    def __init__(self):
        self._MULTIPLE_POTENTIAL = None    # Enables the possibility to define NONBONDED and NONBONDED14 as a sum of different kinds of potential. Useful for piecewise defined potentials.
        self.listNONBONDED = []
        self.NONBONDED = nonbonded2()
        self.NONBONDED14 = nonbonded141()
        self.name = "FORCEFIELD"
        self.keywords = [('_MULTIPLE_POTENTIAL', 'MULTIPLE_POTENTIAL')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('NONBONDED14', 'NONBONDED14')]
        self.repeated_subsections = [('NONBONDED', 'nonbonded2')]

    def addNONBONDED(self):
        new_section = nonbonded2()
        self.listNONBONDED.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class spawned_hills_scale1(printable):
    """The scales of the spawned hills during metadynamics.Used for RESTART. When a scale is zero in one or more directions, the Gaussian hill is assumed to be infinitely wide in those directions. The latter can be used to combine spawned hills from multiple 1D metadynamics runs in one multidimensional metadynamics run."""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Specify the spawned hills
        self.name = "SPAWNED_HILLS_SCALE"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class optimize_geminals1(printable):
    """Optimize the parameters of the geminal basis set"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.POWELL = powell1()
        self.name = "OPTIMIZE_GEMINALS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH'), ('POWELL', 'POWELL')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class ext_lagrange_ss01(printable):
    """Colvar position within an extended Lagrangian formalism.Used for RESTART."""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Specified the positions
        self.name = "EXT_LAGRANGE_SS0"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class kg_method1(printable):
    """Specifies the parameters for a Kim-Gordon-like partitioning into molecular subunits"""
    def __init__(self):
        self._COLORING_METHOD = None    # Which algorithm to use for coloring.
        self.PRINT = print17()
        self.name = "KG_METHOD"
        self.keywords = [('_COLORING_METHOD', 'COLORING_METHOD')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PRINT', 'PRINT')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class bs1(printable):
    """Define the required atomic orbital occupation assigned in initialization of the density matrix, by adding or subtracting electrons from specific angular momentum channels. It works only with GUESS ATOMIC."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self.ALPHA = alpha1()
        self.BETA = beta1()
        self.name = "BS"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('ALPHA', 'ALPHA'), ('BETA', 'BETA')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class charge2(printable):
    """This section specifies the charge of the MM atoms"""
    def __init__(self):
        self._ATOM = None    # Defines the atomic kind of the charge.
        self._CHARGE = None    # Defines the charge of the MM atom in electron charge unit.
        self.name = "CHARGE"
        self.keywords = [('_ATOM', 'ATOM'), ('_CHARGE', 'CHARGE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class charge1(printable):
    """Controls the printing of the approximated charge in the RI calculation"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "CHARGE"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class conditioned_distance1(printable):
    """Section to define the conditioned distance as a collective variable."""
    def __init__(self):
        self.list_ATOMS_DISTANCE = []
        self._ATOMS_DISTANCE = None
    # Specify indexes of atoms/points from which the distance is computed.
        self.list_ATOMS_FROM = []
        self._ATOMS_FROM = None
    # Specify indexes of atoms/points building the coordination variable.
        self._POINTS_FROM = self._ATOMS_FROM
        self.list_POINTS_FROM = self.list_ATOMS_FROM
        self.list_ATOMS_TO = []
        self._ATOMS_TO = None
    # Specify indexes of atoms/points building the coordination variable.
        self._POINTS_TO = self._ATOMS_TO
        self.list_POINTS_TO = self.list_ATOMS_TO
        self.list_KINDS_FROM = []
        self._KINDS_FROM = None
    # Specify alternatively kinds of atoms building the coordination variable.
        self.list_KINDS_TO = []
        self._KINDS_TO = None
    # Specify alternatively kinds of atoms building the coordination variable.
        self._R0 = None    # Specify the R0 parameter in the coordination function.
        self._R_0 = self._R0
        self._NN = None    # Sets the value of the numerator of the exponential factorin the coordination FUNCTION.
        self._EXPON_NUMERATOR = self._NN
        self._ND = None    # Sets the value of the denominator of the exponential factorin the coordination FUNCTION.
        self._EXPON_DENOMINATOR = self._ND
        self._LAMBDA = None    # Specify the lambda parameter at the exponent of the conditioned distance function.
        self.listPOINT = []
        self.POINT = point1()
        self.name = "CONDITIONED_DISTANCE"
        self.keywords = [('_R0', 'R0'), ('_R_0', 'R_0'), ('_NN', 'NN'), ('_EXPON_NUMERATOR', 'EXPON_NUMERATOR'), ('_ND', 'ND'), ('_EXPON_DENOMINATOR', 'EXPON_DENOMINATOR'), ('_LAMBDA', 'LAMBDA')]
        self.repeated_keywords = [('_ATOMS_DISTANCE', 'ATOMS_DISTANCE'), ('_ATOMS_FROM', 'ATOMS_FROM'), ('_POINTS_FROM', 'POINTS_FROM'), ('_ATOMS_TO', 'ATOMS_TO'), ('_POINTS_TO', 'POINTS_TO'), ('_KINDS_FROM', 'KINDS_FROM'), ('_KINDS_TO', 'KINDS_TO')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('POINT', 'point1')]

    def addPOINT(self):
        new_section = point1()
        self.listPOINT.append(new_section)
        return new_section

    def add_ATOMS_DISTANCE(self, value):
        self.list_ATOMS_DISTANCE.append(value)

    def add_ATOMS_FROM(self, value):
        self.list_ATOMS_FROM.append(value)

    def add_POINTS_FROM(self, value):
        self.list_POINTS_FROM.append(value)

    def add_ATOMS_TO(self, value):
        self.list_ATOMS_TO.append(value)

    def add_POINTS_TO(self, value):
        self.list_POINTS_TO.append(value)

    def add_KINDS_FROM(self, value):
        self.list_KINDS_FROM.append(value)

    def add_KINDS_TO(self, value):
        self.list_KINDS_TO.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class p86c1(printable):
    """Uses the P86C functional"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._SCALE_C = None    # scales the correlation part of the functional
        self.name = "P86C"
        self.keywords = [('_SCALE_C', 'SCALE_C')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class pade1(printable):
    """Uses the PADE functional"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self.name = "PADE"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []
        pass

    def print_input(self, level):
        return printable.print_input(self, level)


class thermostat_info1(printable):
    """Controls output information of the corresponding thermostat."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "THERMOSTAT_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class accepts1(printable):
    """Controls the output of the helium acceptance data"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "ACCEPTS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class ms_restart1(printable):
    """Controls the printing of the Mode Selective Restart file."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "MS_RESTART"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class lda_hole_t_c_lr1(printable):
    """LDA exchange hole model in truncated coulomb potential"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._SCALE_X = None    # scales the exchange part of the functional
        self._CUTOFF_RADIUS = None    # Defines cutoff for lower integration boundary
        self.name = "LDA_HOLE_T_C_LR"
        self.keywords = [('_SCALE_X', 'SCALE_X'), ('_CUTOFF_RADIUS', 'CUTOFF_RADIUS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class cube_data1(printable):
    """Density data used for restarts"""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Cubefile data
        self.name = "CUBE_DATA"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class powell1(printable):
    """Section defines basic parameters for Powell optimization"""
    def __init__(self):
        self._ACCURACY = None    # Final accuracy requested in optimization (RHOEND)
        self._STEP_SIZE = None    # Initial step size for search algorithm (RHOBEG)
        self._MAX_FUN = None    # Maximum number of function evaluations
        self._WEIGHT_POT_VIRTUAL = None    # Weight for virtual states in pseudopotential optimization
        self._WEIGHT_POT_SEMICORE = None    # Weight for semi core states in pseudopotential optimization
        self._WEIGHT_POT_VALENCE = None    # Weight for valence states in pseudopotential optimization
        self._WEIGHT_POT_NODE = None    # Weight for node mismatch in pseudopotential optimization
        self._WEIGHT_ELECTRON_CONFIGURATION = None    # Weight for different electronic states in optimization
        self._WEIGHT_METHOD = None    # Weight for different methods in optimization
        self._TARGET_POT_VIRTUAL = None    # Target accuracy for virtual state eigenvalues in pseudopotential optimization
        self._TARGET_POT_VALENCE = None    # Target accuracy for valence state eigenvalues in pseudopotential optimization
        self._TARGET_POT_SEMICORE = None    # Target accuracy for semicore state eigenvalues in pseudopotential optimization
        self._WEIGHT_PSIR0 = None    # Weight for the wavefunctions at r=0 (only occupied states)
        self._RCOV_MULTIPLICATION = None    # Multiply Rcov integration limit for charge conservation
        self.name = "POWELL"
        self.keywords = [('_ACCURACY', 'ACCURACY'), ('_STEP_SIZE', 'STEP_SIZE'), ('_MAX_FUN', 'MAX_FUN'), ('_WEIGHT_POT_VIRTUAL', 'WEIGHT_POT_VIRTUAL'), ('_WEIGHT_POT_SEMICORE', 'WEIGHT_POT_SEMICORE'), ('_WEIGHT_POT_VALENCE', 'WEIGHT_POT_VALENCE'), ('_WEIGHT_POT_NODE', 'WEIGHT_POT_NODE'), ('_WEIGHT_ELECTRON_CONFIGURATION', 'WEIGHT_ELECTRON_CONFIGURATION'), ('_WEIGHT_METHOD', 'WEIGHT_METHOD'), ('_TARGET_POT_VIRTUAL', 'TARGET_POT_VIRTUAL'), ('_TARGET_POT_VALENCE', 'TARGET_POT_VALENCE'), ('_TARGET_POT_SEMICORE', 'TARGET_POT_SEMICORE'), ('_WEIGHT_PSIR0', 'WEIGHT_PSIR0'), ('_RCOV_MULTIPLICATION', 'RCOV_MULTIPLICATION')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class dft_plus_u1(printable):
    """Define the parameters for a DFT+U run"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._L = None    # Angular momentum quantum number of theorbitals to which the correction is applied
        self._U_MINUS_J = None    # Effective parameter U(eff) = U - J
        self._U_RAMPING = None    # Increase the effective U parameter stepwise using the specified increment until the target value given by U_MINUS_J is reached.
        self._EPS_U_RAMPING = None    # Threshold value (SCF convergence) for incrementing the effective U value when U ramping is active.
        self._INIT_U_RAMPING_EACH_SCF = None    # Set the initial U ramping value to zero before each wavefunction optimisation. The default is to apply U ramping only for the initial wavefunction optimisation.
        self.ENFORCE_OCCUPATION = enforce_occupation1()
        self.name = "DFT_PLUS_U"
        self.keywords = [('_L', 'L'), ('_U_MINUS_J', 'U_MINUS_J'), ('_U_RAMPING', 'U_RAMPING'), ('_EPS_U_RAMPING', 'EPS_U_RAMPING'), ('_INIT_U_RAMPING_EACH_SCF', 'INIT_U_RAMPING_EACH_SCF')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('ENFORCE_OCCUPATION', 'ENFORCE_OCCUPATION')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print_specific_e_density_cube1(printable):
    """Controls the printing of cube files with the electronic density (states) contributing to the density of states within the specific energy range (MIN_ENERGY<= E <=MAX_ENERGY). MIN_ENERGY and MAX_ENERGY need to be specified explicitly."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._STRIDE = None    # The stride (X,Y,Z) used to write the cube file (larger values result in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1 number valid for all components.
        self._MIN_ENERGY = None    # Lower bounds of the energy ranges of interest.
        self._MAX_ENERGY = None    # Upper bounds of the energy ranges of interest.
        self.EACH = each1()
        self.name = "PRINT_SPECIFIC_E_DENSITY_CUBE"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_STRIDE', 'STRIDE'), ('_MIN_ENERGY', 'MIN_ENERGY'), ('_MAX_ENERGY', 'MAX_ENERGY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class resp_charges_to_file1(printable):
    """Controls the printing of the RESP charges to a file."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "RESP_CHARGES_TO_FILE"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class mo_cubes1(printable):
    """Controls the printing of cubes of the molecular orbitals."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._STRIDE = None    # The stride (X,Y,Z) used to write the cube file (larger values result in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1 number valid for all components.
        self._WRITE_CUBE = None    # If the MO cube file should be written. If false, the eigenvalues are still computed. Can also be useful in combination with STM calculations
        self._NLUMO = None    # If the printkey is activated controls the number of lumosthat are printed and dumped as a cube (-1=all)
        self._NHOMO = None    # If the printkey is activated controls the number of homos that dumped as a cube (-1=all), eigenvalues are always all dumped
        self._APPEND = None    # append the cube files when they already exist
        self.EACH = each1()
        self.name = "MO_CUBES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_STRIDE', 'STRIDE'), ('_WRITE_CUBE', 'WRITE_CUBE'), ('_NLUMO', 'NLUMO'), ('_NHOMO', 'NHOMO'), ('_APPEND', 'APPEND')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class exclude_vdw_list1(printable):
    """Speficy bonds (via atom kinds) for fine tuning of 1-2 exclusion lists. If this section is not present the 1-2 exclusion is applied to all bond kinds. When this section is present the 1-2 exclusion is applied ONLY to the bonds defined herein. This section allows ONLY fine tuning of 1-2 interactions."""
    def __init__(self):
        self._BOND = None    # Specify the atom kinds involved in the bond for which 1-2 exclusion holds.
        self.name = "EXCLUDE_VDW_LIST"
        self.keywords = [('_BOND', 'BOND')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class hbp1(printable):
    """Section to define the hbond wannier centre as a collective variables."""
    def __init__(self):
        self._RCUT = None    # Parameter used for computing the cutoff radius for searching the wannier centres around an atom
        self._SHIFT = None    # Parameter used for shifting each term in the sum
        self._NPOINTS = None    # The number of points in the path
        self.list_ATOMS = []
        self._ATOMS = None
    # Specifies the indexes of atoms/points defining the bond (Od, H, Oa).
        self._POINTS = self._ATOMS
        self.list_POINTS = self.list_ATOMS
        self.listPOINT = []
        self.POINT = point1()
        self.name = "HBP"
        self.keywords = [('_RCUT', 'RCUT'), ('_SHIFT', 'SHIFT'), ('_NPOINTS', 'NPOINTS')]
        self.repeated_keywords = [('_ATOMS', 'ATOMS'), ('_POINTS', 'POINTS')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('POINT', 'point1')]

    def addPOINT(self):
        new_section = point1()
        self.listPOINT.append(new_section)
        return new_section

    def add_ATOMS(self, value):
        self.list_ATOMS.append(value)

    def add_POINTS(self, value):
        self.list_POINTS.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class current1(printable):
    """The induced current density is calculated by DFPT."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._GAUGE = None    # The gauge used to compute the induced current within GAPW.
        self._GAUGE_ATOM_RADIUS = None    # Build the gauge=atom using only the atoms within this radius.
        self._USE_OLD_GAUGE_ATOM = None    # Use the old way to compute the gauge.
        self._ORBITAL_CENTER = None    # The orbital center.
        self._COMMON_CENTER = None    # The common center
        self._NBOX = None    # How many boxes along each directions
        self._CHI_PBC = None    # Calculate the succeptibility correction to the shift with PBC
        self.list_SELECTED_STATES_ON_ATOM_LIST = []
        self._SELECTED_STATES_ON_ATOM_LIST = None
    # Indexes of the atoms for selecting the states to be used for the response calculations.
        self._SELECTED_STATES_ATOM_RADIUS = None    # Select all the states included in the given radius arround each atoms in SELECTED_STATES_ON_ATOM_LIST.
        self._RESTART_CURRENT = None    # Restart the induced current density calculation from a previous run (not working yet).
        self.PRINT = print35()
        self.INTERPOLATOR = interpolator1()
        self.name = "CURRENT"
        self.keywords = [('_GAUGE', 'GAUGE'), ('_GAUGE_ATOM_RADIUS', 'GAUGE_ATOM_RADIUS'), ('_USE_OLD_GAUGE_ATOM', 'USE_OLD_GAUGE_ATOM'), ('_ORBITAL_CENTER', 'ORBITAL_CENTER'), ('_COMMON_CENTER', 'COMMON_CENTER'), ('_NBOX', 'NBOX'), ('_CHI_PBC', 'CHI_PBC'), ('_SELECTED_STATES_ATOM_RADIUS', 'SELECTED_STATES_ATOM_RADIUS'), ('_RESTART_CURRENT', 'RESTART_CURRENT')]
        self.repeated_keywords = [('_SELECTED_STATES_ON_ATOM_LIST', 'SELECTED_STATES_ON_ATOM_LIST')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PRINT', 'PRINT'), ('INTERPOLATOR', 'INTERPOLATOR')]
        self.repeated_subsections = []

    def add_SELECTED_STATES_ON_ATOM_LIST(self, value):
        self.list_SELECTED_STATES_ON_ATOM_LIST.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class dftb1(printable):
    """Parameters needed to set up the DFTB methods"""
    def __init__(self):
        self._SELF_CONSISTENT = None    # Use self_consistent method
        self._ORTHOGONAL_BASIS = None    # Assume orthogonal basis set
        self._DO_EWALD = None    # Use Ewald type method instead of direct sum for Coulomb interaction
        self._DISPERSION = None    # Use dispersion correction
        self._HB_SR_GAMMA = None    # Uses a modified version for the GAMMA within the SCC-DFTB scheme, specifically tuned for hydrogen bonds.
        self._EPS_DISP = None    # Define accuracy of dispersion interaction
        self.PARAMETER = parameter1()
        self.name = "DFTB"
        self.keywords = [('_SELF_CONSISTENT', 'SELF_CONSISTENT'), ('_ORTHOGONAL_BASIS', 'ORTHOGONAL_BASIS'), ('_DO_EWALD', 'DO_EWALD'), ('_DISPERSION', 'DISPERSION'), ('_HB_SR_GAMMA', 'HB_SR_GAMMA'), ('_EPS_DISP', 'EPS_DISP')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PARAMETER', 'PARAMETER')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class scf1(printable):
    """parameters needed perform an scf run"""
    def __init__(self):
        self._MAX_ITER_LUMO = None    # The maximum number of iteration for the lumo computation
        self._MAX_ITER_LUMOS = self._MAX_ITER_LUMO
        self._EPS_LUMO = None    # target accuracy of the computation of the lumo energy
        self._EPS_LUMOS = self._EPS_LUMO
        self._MAX_SCF = None    # Maximum number of SCF iteration to be performed for one optimization
        self._MAX_SCF_HISTORY = None    # Maximum number of SCF iterations after the history pipeline is filled
        self._MAX_SCF_HIST = self._MAX_SCF_HISTORY
        self._MAX_DIIS = None    # Maximum number of DIIS vectors to be used
        self._MAX_DIIS_BUFFER_SIZE = self._MAX_DIIS
        self._LEVEL_SHIFT = None    # Use level shifting to improve convergence
        self._LSHIFT = self._LEVEL_SHIFT
        self._EPS_SCF = None    # target accuracy for the scf convergence
        self._EPS_SCF_HISTORY = None    # target accuracy for the scf convergence after the history pipeline is filled
        self._EPS_SCF_HIST = self._EPS_SCF_HISTORY
        self._CHOLESKY = None    # If the cholesky method should be used for computing the inverse of S, and in this case calling which Lapack routines
        self._EPS_EIGVAL = None    # Throw away linear combinations of basis functions with a small eigenvalue in S
        self._EPS_DIIS = None    # Threshold on the convergence to start using DIAG/DIIS
        self._SCF_GUESS = None    # Change the initial guess for the wavefunction.
        self._NROW_BLOCK = None    # sets the number of rows in a scalapack block
        self._NCOL_BLOCK = None    # Sets the number of columns in a scalapack block
        self._ADDED_MOS = None    # Number of additional MOS added for each spin
        self._ROKS_SCHEME = None    # Selects the ROKS scheme when ROKS is applied.
        self._ROKS_F = None    # Allows to define the parameter f for the general ROKS scheme.
        self._F_ROKS = self._ROKS_F
        self._ROKS_PARAMETERS = None    # Allows to define all parameters for the high-spin ROKS scheme explicitly. The full set of 6 parameters has to be specified in the order acc, bcc, aoo, boo, avv, bvv
        self._ROKS_PARAMETER = self._ROKS_PARAMETERS
        self.OT = ot1()
        self.DIAGONALIZATION = diagonalization1()
        self.OUTER_SCF = outer_scf1()
        self.SMEAR = smear1()
        self.MIXING = mixing1()
        self.PRINT = print16()
        self.name = "SCF"
        self.keywords = [('_MAX_ITER_LUMO', 'MAX_ITER_LUMO'), ('_MAX_ITER_LUMOS', 'MAX_ITER_LUMOS'), ('_EPS_LUMO', 'EPS_LUMO'), ('_EPS_LUMOS', 'EPS_LUMOS'), ('_MAX_SCF', 'MAX_SCF'), ('_MAX_SCF_HISTORY', 'MAX_SCF_HISTORY'), ('_MAX_SCF_HIST', 'MAX_SCF_HIST'), ('_MAX_DIIS', 'MAX_DIIS'), ('_MAX_DIIS_BUFFER_SIZE', 'MAX_DIIS_BUFFER_SIZE'), ('_LEVEL_SHIFT', 'LEVEL_SHIFT'), ('_LSHIFT', 'LSHIFT'), ('_EPS_SCF', 'EPS_SCF'), ('_EPS_SCF_HISTORY', 'EPS_SCF_HISTORY'), ('_EPS_SCF_HIST', 'EPS_SCF_HIST'), ('_CHOLESKY', 'CHOLESKY'), ('_EPS_EIGVAL', 'EPS_EIGVAL'), ('_EPS_DIIS', 'EPS_DIIS'), ('_SCF_GUESS', 'SCF_GUESS'), ('_NROW_BLOCK', 'NROW_BLOCK'), ('_NCOL_BLOCK', 'NCOL_BLOCK'), ('_ADDED_MOS', 'ADDED_MOS'), ('_ROKS_SCHEME', 'ROKS_SCHEME'), ('_ROKS_F', 'ROKS_F'), ('_F_ROKS', 'F_ROKS'), ('_ROKS_PARAMETERS', 'ROKS_PARAMETERS'), ('_ROKS_PARAMETER', 'ROKS_PARAMETER')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('OT', 'OT'), ('DIAGONALIZATION', 'DIAGONALIZATION'), ('OUTER_SCF', 'OUTER_SCF'), ('SMEAR', 'SMEAR'), ('MIXING', 'MIXING'), ('PRINT', 'PRINT')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class program_run_info21(printable):
    """Controls the printing of basic information generated by force_eval"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PROGRAM_RUN_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class program_run_info20(printable):
    """Controls the printing of basic iteration information during the LINRES calculation"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PROGRAM_RUN_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class program_run_info23(printable):
    """Controls the printing basic info about the vibrational method"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PROGRAM_RUN_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class program_run_info22(printable):
    """controls the printing of FARMING specific output"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PROGRAM_RUN_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class molecular_dipoles1(printable):
    """Section controlling the calculation of MOLECULAR_DIPOLES. Note that the result in the periodic case might be defined modulo a certain period, determined by the lattice vectors. During MD, this can lead to jumps."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._PERIODIC = None    # Use Berry phase formula (PERIODIC=T) or simple operator (PERIODIC=F). The latter normally requires that the CELL is periodic NONE.
        self._REFERENCE = None    # Define the reference point for the calculation of the electrostatic moment.
        self._REF = self._REFERENCE
        self._REFERENCE_POINT = None    # Fixed reference point for the calculations of the electrostatic moment.
        self._REF_POINT = self._REFERENCE_POINT
        self.EACH = each1()
        self.name = "MOLECULAR_DIPOLES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_PERIODIC', 'PERIODIC'), ('_REFERENCE', 'REFERENCE'), ('_REF', 'REF'), ('_REFERENCE_POINT', 'REFERENCE_POINT'), ('_REF_POINT', 'REF_POINT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class test1(printable):
    """Tests to perform on the supported libraries."""
    def __init__(self):
        self._MEMORY = None    # Set the maximum amount of memory allocated for a given test (in bytes)
        self._COPY = None    # Tests the performance to copy two vectors.The results of these tests allow to determine the size of the cache of the CPU. This can be used to optimize the performance of theFFTSG library. Tests are repeated the given number of times.
        self._MATMUL = None    # Tests the performance of different kinds of matrix matrix multiply kernels for the F95 INTRINSIC matmul. Matrices up to 2**N+1 will be tested.
        self._DGEMM = None    # Tests the performance of different kinds of matrix matrix multiply kernels for the BLAS INTRINSIC DGEMM. Matrices up to 2**N+1 will be tested.
        self._FFT = None    # Tests the performance of all available FFT libraries for 3D FFTs Tests are repeated the given number of times.
        self._ERI = None    # Tests the performance and correctness of ERI libraries
        self._CLEBSCH_GORDON = None    # Tests the Clebsch-Gordon Coefficients. Tests are repeated the given number of times.
        self._CLEBSCH = self._CLEBSCH_GORDON
        self._MPI = None    # Tests mpi, quickly adapted benchmark code,will ONLY work on an even number of CPUs. comm is the relevant, initialized communicator. This test will produce messages of the size 8*10**requested_size, where requested_size is the value given to this keyword
        self._RANDOM_NUMBER_GENERATOR = None    #  Tests the parallel random number generator (RNG)
        self._RNG = self._RANDOM_NUMBER_GENERATOR
        self.GRID_INFORMATION = grid_information1()
        self.PROGRAM_RUN_INFO = program_run_info2()
        self.RS_PW_TRANSFER = rs_pw_transfer1()
        self.listEIGENSOLVER = []
        self.EIGENSOLVER = eigensolver1()
        self.listPW_TRANSFER = []
        self.PW_TRANSFER = pw_transfer1()
        self.listCP_FM_GEMM = []
        self.CP_FM_GEMM = cp_fm_gemm1()
        self.listCP_DBCSR = []
        self.CP_DBCSR = cp_dbcsr1()
        self.name = "TEST"
        self.keywords = [('_MEMORY', 'MEMORY'), ('_COPY', 'COPY'), ('_MATMUL', 'MATMUL'), ('_DGEMM', 'DGEMM'), ('_FFT', 'FFT'), ('_ERI', 'ERI'), ('_CLEBSCH_GORDON', 'CLEBSCH_GORDON'), ('_CLEBSCH', 'CLEBSCH'), ('_MPI', 'MPI'), ('_RANDOM_NUMBER_GENERATOR', 'RANDOM_NUMBER_GENERATOR'), ('_RNG', 'RNG')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('GRID_INFORMATION', 'GRID_INFORMATION'), ('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('RS_PW_TRANSFER', 'RS_PW_TRANSFER')]
        self.repeated_subsections = [('EIGENSOLVER', 'eigensolver1'), ('PW_TRANSFER', 'pw_transfer1'), ('CP_FM_GEMM', 'cp_fm_gemm1'), ('CP_DBCSR', 'cp_dbcsr1')]

    def addEIGENSOLVER(self):
        new_section = eigensolver1()
        self.listEIGENSOLVER.append(new_section)
        return new_section

    def addPW_TRANSFER(self):
        new_section = pw_transfer1()
        self.listPW_TRANSFER.append(new_section)
        return new_section

    def addCP_FM_GEMM(self):
        new_section = cp_fm_gemm1()
        self.listCP_FM_GEMM.append(new_section)
        return new_section

    def addCP_DBCSR(self):
        new_section = cp_dbcsr1()
        self.listCP_DBCSR.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class optimization1(printable):
    """sets the parameters for optimizition, output frequency and restarts"""
    def __init__(self):
        self._ACCURACY = None    # Final accuracy requested in optimization (RHOEND)
        self._STEP_SIZE = None    # Initial step size for search algorithm (RHOBEG)
        self._MAX_FUN = None    # Maximum number of function evaluations
        self.name = "OPTIMIZATION"
        self.keywords = [('_ACCURACY', 'ACCURACY'), ('_STEP_SIZE', 'STEP_SIZE'), ('_MAX_FUN', 'MAX_FUN')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class distribution2d1(printable):
    """Controls the printing of the distribution of matrix blocks,..."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "DISTRIBUTION2D"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class mixed2(printable):
    """This section allows to use any function of the energy subsystems  in a mixed_env calculation as a collective variable."""
    def __init__(self):
        self._ENERGY_FUNCTION = None    # Specifies the functional form of the collective variable in mathematical notation.
        self._VARIABLES = None    # Defines the variables of the functional form. To allow an efficient mapping the order of the energy variables will be considered identical to the order of the force_eval in the force_eval_order list.
        self.list_PARAMETERS = []
        self._PARAMETERS = None
    # Defines the parameters of the functional form
        self.list_VALUES = []
        self._VALUES = None
    # Defines the values of parameter of the functional form
        self.list_UNITS = []
        self._UNITS = None
    # Optionally, allows to define valid CP2K unit strings for each parameter value. It is assumed that the corresponding parameter value is specified in this unit.
        self._DX = None    # Parameter used for computing the derivative with the Ridders method.
        self._ERROR_LIMIT = None    # Checks that the error in computing the derivative is not larger than the value set. In case prints a warning message.
        self.name = "MIXED"
        self.keywords = [('_ENERGY_FUNCTION', 'ENERGY_FUNCTION'), ('_VARIABLES', 'VARIABLES'), ('_DX', 'DX'), ('_ERROR_LIMIT', 'ERROR_LIMIT')]
        self.repeated_keywords = [('_PARAMETERS', 'PARAMETERS'), ('_VALUES', 'VALUES'), ('_UNITS', 'UNITS')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def add_PARAMETERS(self, value):
        self.list_PARAMETERS.append(value)

    def add_VALUES(self, value):
        self.list_VALUES.append(value)

    def add_UNITS(self, value):
        self.list_UNITS.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class dimer1(printable):
    """Specifies parameters for Dimer Method"""
    def __init__(self):
        self._DR = None    # This keyword sets the value for the DR parameter.
        self._INTERPOLATE_GRADIENT = None    # This keyword controls the interpolation of the gradient whenever possible during the optimization of the Dimer. The use of this keywords saves 1 evaluation  of energy/forces.
        self._ANGLE_TOLERANCE = None    # This keyword sets the value of the tolerance angle for the line search  performed to optimize the orientation of the dimer.
        self.ROT_OPT = rot_opt1()
        self.DIMER_VECTOR = dimer_vector1()
        self.name = "DIMER"
        self.keywords = [('_DR', 'DR'), ('_INTERPOLATE_GRADIENT', 'INTERPOLATE_GRADIENT'), ('_ANGLE_TOLERANCE', 'ANGLE_TOLERANCE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('ROT_OPT', 'ROT_OPT'), ('DIMER_VECTOR', 'DIMER_VECTOR')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class buffer_non_adaptive1(printable):
    """List of atoms always in buffer region, non-adaptively, and any needed LINK sections"""
    def __init__(self):
        self.listQM_KIND = []
        self.QM_KIND = qm_kind1()
        self.listLINK = []
        self.LINK = link1()
        self.name = "BUFFER_NON_ADAPTIVE"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('QM_KIND', 'qm_kind1'), ('LINK', 'link1')]

    def addQM_KIND(self):
        new_section = qm_kind1()
        self.listQM_KIND.append(new_section)
        return new_section

    def addLINK(self):
        new_section = link1()
        self.listLINK.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class density_fitting1(printable):
    """Setup parameters for density fitting (Bloechl charges or density derived  atomic point charges (DDAPC) charges)"""
    def __init__(self):
        self._NUM_GAUSS = None    # Specifies the numbers of gaussian used to fit the QM density for each atomic site.
        self._PFACTOR = None    # Specifies the progression factor for the gaussian exponent for each atomic site.
        self._MIN_RADIUS = None    # Specifies the smallest radius of the gaussian used in the fit. All other radius are obtained with the progression factor.
        self._RADII = None    # Specifies all the radius of the gaussian used in the fit for each atomic site. The use of this keyword disables all other keywords of this section.
        self._GCUT = None    # Cutoff for charge fit in G-space.
        self.PROGRAM_RUN_INFO = program_run_info15()
        self.name = "DENSITY_FITTING"
        self.keywords = [('_NUM_GAUSS', 'NUM_GAUSS'), ('_PFACTOR', 'PFACTOR'), ('_MIN_RADIUS', 'MIN_RADIUS'), ('_RADII', 'RADII'), ('_GCUT', 'GCUT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class mo1(printable):
    """Controls the printing of the molecular orbitals.Note that this is only functional with diagonalization based methods, in particular not with OT (see MO_CUBES)"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._CARTESIAN = None    # If the printkey is activated controls the printing of the mo in the cartesian basis
        self._EIGENVALUES = None    # If the printkey is activated controls the printing of the eigenvalues of the mos
        self._EIGVALS = self._EIGENVALUES
        self._EIGENVECTORS = None    # If the printkey is activated controls the printing of the eigenvectors of the mos
        self._EIGVECS = self._EIGENVECTORS
        self._OCCUPATION_NUMBERS = None    # If the printkey is activated controls the printing of the occupation numbers of the mos
        self._OCCNUMS = self._OCCUPATION_NUMBERS
        self._NDIGITS = None    # Specify the number of digits used to print the MO eigenvalues and occupation numbers
        self._MO_INDEX_RANGE = None    # Allows to print only a subset of the MO eigenvectors or eigenvalues. The indices of the first and the last MO have to be specified
        self._MO_RANGE = self._MO_INDEX_RANGE
        self._RANGE = self._MO_INDEX_RANGE
        self.EACH = each1()
        self.name = "MO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_CARTESIAN', 'CARTESIAN'), ('_EIGENVALUES', 'EIGENVALUES'), ('_EIGVALS', 'EIGVALS'), ('_EIGENVECTORS', 'EIGENVECTORS'), ('_EIGVECS', 'EIGVECS'), ('_OCCUPATION_NUMBERS', 'OCCUPATION_NUMBERS'), ('_OCCNUMS', 'OCCNUMS'), ('_NDIGITS', 'NDIGITS'), ('_MO_INDEX_RANGE', 'MO_INDEX_RANGE'), ('_MO_RANGE', 'MO_RANGE'), ('_RANGE', 'RANGE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class band1(printable):
    """The section that controls a BAND run"""
    def __init__(self):
        self._NPROC_REP = None    # Specify the number of processors to be used per replica environment (for parallel runs)
        self._PROC_DIST_TYPE = None    # Specify the topology of the mapping of processors into replicas.
        self._BAND_TYPE = None    # Specifies the type of BAND calculation
        self._NUMBER_OF_REPLICA = None    # Specify the number of Replica to use in the BAND
        self._USE_COLVARS = None    # Uses a version of the band scheme projected in a subspace of colvars.
        self._POT_TYPE = None    # Specifies the type of potential used in the BAND calculation
        self._ROTATE_FRAMES = None    # Compute at each BAND step the RMSD and rotate the frames in order to minimize it.
        self._ALIGN_FRAMES = None    # Enables the alignment of the frames at the beginning of a BAND calculation. This keyword does not affect the rotation of the replicas during a BAND calculation.
        self._K_SPRING = None    # Specify the value of the spring constant
        self._K = self._K_SPRING
        self.CONVERGENCE_CONTROL = convergence_control2()
        self.CI_NEB = ci_neb1()
        self.STRING_METHOD = string_method1()
        self.listOPTIMIZE_BAND = []
        self.OPTIMIZE_BAND = optimize_band1()
        self.listREPLICA = []
        self.REPLICA = replica1()
        self.PROGRAM_RUN_INFO = program_run_info8()
        self.CONVERGENCE_INFO = convergence_info1()
        self.REPLICA_INFO = replica_info1()
        self.ENERGY = energy6()
        self.BANNER = banner1()
        self.name = "BAND"
        self.keywords = [('_NPROC_REP', 'NPROC_REP'), ('_PROC_DIST_TYPE', 'PROC_DIST_TYPE'), ('_BAND_TYPE', 'BAND_TYPE'), ('_NUMBER_OF_REPLICA', 'NUMBER_OF_REPLICA'), ('_USE_COLVARS', 'USE_COLVARS'), ('_POT_TYPE', 'POT_TYPE'), ('_ROTATE_FRAMES', 'ROTATE_FRAMES'), ('_ALIGN_FRAMES', 'ALIGN_FRAMES'), ('_K_SPRING', 'K_SPRING'), ('_K', 'K')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('CONVERGENCE_CONTROL', 'CONVERGENCE_CONTROL'), ('CI_NEB', 'CI_NEB'), ('STRING_METHOD', 'STRING_METHOD'), ('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('CONVERGENCE_INFO', 'CONVERGENCE_INFO'), ('REPLICA_INFO', 'REPLICA_INFO'), ('ENERGY', 'ENERGY'), ('BANNER', 'BANNER')]
        self.repeated_subsections = [('OPTIMIZE_BAND', 'optimize_band1'), ('REPLICA', 'replica1')]

    def addOPTIMIZE_BAND(self):
        new_section = optimize_band1()
        self.listOPTIMIZE_BAND.append(new_section)
        return new_section

    def addREPLICA(self):
        new_section = replica1()
        self.listREPLICA.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class ddapc_restraint_b1(printable):
    """Use DDAPC charges in a restraint (check code for details), section can be repeated, but only one constraint is possible at the moment."""
    def __init__(self):
        self._STRENGTH = None    # force constant of the restraint
        self._TYPE_OF_DENSITY = None    # Specifies the type of density used for the fitting
        self._TARGET = None    # target value of the restraint
        self._ATOMS = None    # Specifies the list of atoms that is summed in the restraint
        self._COEFF = None    # Defines the the coefficient of the atom in the atom list (default is one), currently DDAPC only
        self._FUNCTIONAL_FORM = None    # Specifies the functional form of the term added
        self.PROGRAM_RUN_INFO = program_run_info12()
        self.name = "DDAPC_RESTRAINT_B"
        self.keywords = [('_STRENGTH', 'STRENGTH'), ('_TYPE_OF_DENSITY', 'TYPE_OF_DENSITY'), ('_TARGET', 'TARGET'), ('_ATOMS', 'ATOMS'), ('_COEFF', 'COEFF'), ('_FUNCTIONAL_FORM', 'FUNCTIONAL_FORM')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class trajectory1(printable):
    """Controls the output of the trajectory"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._UNIT = None    # Specify the unit of measurement for the quantity in output. All available CP2K units can be used.
        self._FORMAT = None    # Specifies the format of the output file for the trajectory.
        self._CHARGE_OCCUP = None    # Write the MM charges to the OCCUP field of the PDB file
        self._CHARGE_O = self._CHARGE_OCCUP
        self._CHARGE_BETA = None    # Write the MM charges to the BETA field of the PDB file
        self._CHARGE_B = self._CHARGE_BETA
        self._CHARGE_EXTENDED = None    # Write the MM charges to the very last field of the PDB file (starting from column 81)
        self.EACH = each1()
        self.name = "TRAJECTORY"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_UNIT', 'UNIT'), ('_FORMAT', 'FORMAT'), ('_CHARGE_OCCUP', 'CHARGE_OCCUP'), ('_CHARGE_O', 'CHARGE_O'), ('_CHARGE_BETA', 'CHARGE_BETA'), ('_CHARGE_B', 'CHARGE_B'), ('_CHARGE_EXTENDED', 'CHARGE_EXTENDED')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class respa1(printable):
    """Multiple timestep integration based on RESPA (implemented for NVE only). RESPA exploits multiple force_eval. In this case the order of the force_eval maps  the order of the respa shells from the slowest to the fastest force evaluation. If force_evals share the same subsys, it's enough then to specify the  subsys in the force_eval corresponding at the first index in the multiple_force_eval list"""
    def __init__(self):
        self._FREQUENCY = None    # The number of reference MD steps between two RESPA corrections.
        self.name = "RESPA"
        self.keywords = [('_FREQUENCY', 'FREQUENCY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class xalpha1(printable):
    """Uses the XALPHA (SLATER) functional."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._XA = None    # Value of the xa parameter (this does not change the exponent, just the mixing)
        self._SCALE_X = None    # scales the exchange part of the functional
        self.name = "XALPHA"
        self.keywords = [('_XA', 'XA'), ('_SCALE_X', 'SCALE_X')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class thermostat_energy1(printable):
    """Information to initialize the CSVR thermostat energy."""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Specify an initial thermostat energy  for CSVR thermostat.
        self.name = "THERMOSTAT_ENERGY"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class scrf1(printable):
    """Adds an implicit solvation model to the DFT calculation. Know also as Self Consistent Reaction Field."""
    def __init__(self):
        self._EPS_OUT = None    # Value of the dielectric constant outside the sphere
        self._LMAX = None    # Maximum value of L used in the multipole expansion
        self.SPHERE = sphere1()
        self.PROGRAM_RUN_INFO = program_run_info12()
        self.name = "SCRF"
        self.keywords = [('_EPS_OUT', 'EPS_OUT'), ('_LMAX', 'LMAX')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('SPHERE', 'SPHERE'), ('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class force_eval1(printable):
    """Defines the fragments and the mapping for each force_eval (an integer index (ID) needs to be provided as parameter)"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._DEFINE_FRAGMENTS = None    # Specify the fragments definition of the force_eval through the fragments of the force_eval_mixed. This avoids the pedantic definition of the fragments for the force_eval, assuming the order of the fragments for the specified force_eval is the same as the sequence  of integers provided. Easier to USE should be preferred to the specification of the single fragments.
        self.listFRAGMENT = []
        self.FRAGMENT = fragment2()
        self.name = "FORCE_EVAL"
        self.keywords = [('_DEFINE_FRAGMENTS', 'DEFINE_FRAGMENTS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('FRAGMENT', 'fragment2')]

    def addFRAGMENT(self):
        new_section = fragment2()
        self.listFRAGMENT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class force_eval2(printable):
    """parameters needed to calculate energy and forces and describe the system you want to analyze."""
    def __init__(self):
        self._METHOD = None    # Which method should be used to compute forces
        self._STRESS_TENSOR = None    # Controls the calculation of the stress tensor. The combinations defined below are not implemented for all methods.
        self.listEXTERNAL_POTENTIAL = []
        self.EXTERNAL_POTENTIAL = external_potential1()
        self.RESCALE_FORCES = rescale_forces1()
        self.MIXED = mixed1()
        self.DFT = dft1()
        self.MM = mm1()
        self.QMMM = qmmm1()
        self.EP = ep1()
        self.EIP = eip1()
        self.BSSE = bsse1()
        self.SUBSYS = subsys1()
        self.PROPERTIES = properties1()
        self.PRINT = print42()
        self.name = "FORCE_EVAL"
        self.keywords = [('_METHOD', 'METHOD'), ('_STRESS_TENSOR', 'STRESS_TENSOR')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('RESCALE_FORCES', 'RESCALE_FORCES'), ('MIXED', 'MIXED'), ('DFT', 'DFT'), ('MM', 'MM'), ('QMMM', 'QMMM'), ('EP', 'EP'), ('EIP', 'EIP'), ('BSSE', 'BSSE'), ('SUBSYS', 'SUBSYS'), ('PROPERTIES', 'PROPERTIES'), ('PRINT', 'PRINT')]
        self.repeated_subsections = [('EXTERNAL_POTENTIAL', 'external_potential1')]

    def addEXTERNAL_POTENTIAL(self):
        new_section = external_potential1()
        self.listEXTERNAL_POTENTIAL.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class becke88_lr_adiabatic1(printable):
    """Uses the Becke 88 longrange exchange functional in an adiabatic fashion"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._SCALE_X = None    # scales the exchange part of the functional
        self._OMEGA = None    # Potential parameter in erf(omega*r)/r
        self._LAMBDA = None    # Defines the parameter of the adiabatic curve
        self.name = "BECKE88_LR_ADIABATIC"
        self.keywords = [('_SCALE_X', 'SCALE_X'), ('_OMEGA', 'OMEGA'), ('_LAMBDA', 'LAMBDA')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class wannier_cubes1(printable):
    """Controls the printing of the wannier functions"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._STRIDE = None    # The stride (X,Y,Z) used to write the cube file (larger values result in smaller cube files). You can provide 3 numbers (for X,Y,Z) or 1 number valid for all components.
        self._CUBES_LU_BOUNDS = None    # The lower and upper index of the states to be printed as cube
        self._CUBES_LU = self._CUBES_LU_BOUNDS
        self.list_CUBES_LIST = []
        self._CUBES_LIST = None
    # Indexes of the states to be printed as cube filesThis keyword can be repeated several times(useful if you have to specify many indexes).
        self._APPEND = None    # append the cube files when they already exist
        self.EACH = each1()
        self.name = "WANNIER_CUBES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_STRIDE', 'STRIDE'), ('_CUBES_LU_BOUNDS', 'CUBES_LU_BOUNDS'), ('_CUBES_LU', 'CUBES_LU'), ('_APPEND', 'APPEND')]
        self.repeated_keywords = [('_CUBES_LIST', 'CUBES_LIST')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def add_CUBES_LIST(self, value):
        self.list_CUBES_LIST.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class coord7(printable):
    """The positions for RMSD used for restart"""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Specify positions of the system
        self.name = "COORD"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class add_mm_charge1(printable):
    """Specify information to add a classical charge before the QM/MM energies and forces evaluation"""
    def __init__(self):
        self._ATOM_INDEX_1 = None    # Specifies the index of the first atom defining the direction along which the atom will be added
        self._MM1 = self._ATOM_INDEX_1
        self._ATOM_INDEX_2 = None    # Specifies the index of the second atom defining the direction along which  the atom will be added
        self._MM2 = self._ATOM_INDEX_2
        self._ALPHA = None    # Specifies the scaling factor that defines the movement along the defined direction
        self._RADIUS = None    # Specifies the radius used for the QM/MM electrostatic coupling for the added source
        self._CORR_RADIUS = None    # Specifies the correction radius used for the QM/MM electrostatic coupling for the added source
        self._CHARGE = None    # Specifies the charge for the added source of QM/MM potential
        self.name = "ADD_MM_CHARGE"
        self.keywords = [('_ATOM_INDEX_1', 'ATOM_INDEX_1'), ('_MM1', 'MM1'), ('_ATOM_INDEX_2', 'ATOM_INDEX_2'), ('_MM2', 'MM2'), ('_ALPHA', 'ALPHA'), ('_RADIUS', 'RADIUS'), ('_CORR_RADIUS', 'CORR_RADIUS'), ('_CHARGE', 'CHARGE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class coord5(printable):
    """The positions for BAND used for restart"""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Specify positions of the system
        self.name = "COORD"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class coord4(printable):
    """The positions for HELIUM used for restart"""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Specify positions of the system
        self.name = "COORD"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class coord3(printable):
    """The positions for NOSE used for restart"""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Specify positions of the system
        self.name = "COORD"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class coord2(printable):
    """The positions for BEADS used for restart"""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Specify positions of the system
        self.name = "COORD"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class coord1(printable):
    """The positions for NOSE HOOVER used for restart"""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Specify positions of the system
        self.name = "COORD"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class subcell3(printable):
    """Activates the printing of the subcells used for thegeneration of neighbor lists."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "SUBCELL"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class spl_coeffs1(printable):
    """outputs a cube with the coefficents calculated for the spline interpolation"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "SPL_COEFFS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class distance1(printable):
    """Section to define the distance as a collective variables."""
    def __init__(self):
        self._ATOMS = None    # Specifies the indexes of atoms/points defining the distance.
        self._POINTS = self._ATOMS
        self._AXIS = None    # Define the axes along which the colvar should be evaluated
        self.listPOINT = []
        self.POINT = point1()
        self.name = "DISTANCE"
        self.keywords = [('_ATOMS', 'ATOMS'), ('_POINTS', 'POINTS'), ('_AXIS', 'AXIS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('POINT', 'point1')]

    def addPOINT(self):
        new_section = point1()
        self.listPOINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class diagonalization1(printable):
    """Set up type and parameters for Kohn-Sham matrix diagonalization."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ALGORITHM = None    # Algorithm to be used for diagonalization
        self._JACOBI_THRESHOLD = None    # Controls the accuracy of the pseudo-diagonalization method using Jacobi rotations
        self._EPS_JACOBI = None    # Below this threshold value for the SCF convergence the pseudo-diagonalization method using Jacobi rotations is activated. This method is much faster than a real diagonalization and it is even speeding up while achieving full convergence.However, it needs a pre-converged wavefunction obtained by at least one real diagonalization which is further optimized while keeping the original eigenvalue spectrum. The MO eigenvalues are NOT updated. The method might be useful to speed up calculations for large systems e.g. using a semi-empirical method.
        self._EPS_ADAPT = None    # Required accuracy in iterative diagonalization as compared to current SCF convergence
        self._MAX_ITER = None    # Maximum number of iterations in iterative diagonalization
        self._EPS_ITER = None    # Required accuracy in iterative diagonalization
        self.OT = ot1()
        self.KRYLOV = krylov1()
        self.DIAG_SUB_SCF = diag_sub_scf1()
        self.DAVIDSON = davidson1()
        self.name = "DIAGONALIZATION"
        self.keywords = [('_ALGORITHM', 'ALGORITHM'), ('_JACOBI_THRESHOLD', 'JACOBI_THRESHOLD'), ('_EPS_JACOBI', 'EPS_JACOBI'), ('_EPS_ADAPT', 'EPS_ADAPT'), ('_MAX_ITER', 'MAX_ITER'), ('_EPS_ITER', 'EPS_ITER')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('OT', 'OT'), ('KRYLOV', 'KRYLOV'), ('DIAG_SUB_SCF', 'DIAG_SUB_SCF'), ('DAVIDSON', 'DAVIDSON')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class force_mixing_labels1(printable):
    """Controls the output of the force mixing (FORCE_EVAL&QMMM&FORCE_MIXING) labels"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._FORMAT = None    # Specifies the format of the output file for the force mixing labels.
        self.EACH = each1()
        self.name = "FORCE_MIXING_LABELS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_FORMAT', 'FORMAT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class total_dipole1(printable):
    """Section controlling the calculation of TOTAL_DIPOLE. Note that the result in the periodic case might be defined modulo a certain period, determined by the lattice vectors. During MD, this can lead to jumps."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._PERIODIC = None    # Use Berry phase formula (PERIODIC=T) or simple operator (PERIODIC=F). The latter normally requires that the CELL is periodic NONE.
        self._REFERENCE = None    # Define the reference point for the calculation of the electrostatic moment.
        self._REF = self._REFERENCE
        self._REFERENCE_POINT = None    # Fixed reference point for the calculations of the electrostatic moment.
        self._REF_POINT = self._REFERENCE_POINT
        self.EACH = each1()
        self.name = "TOTAL_DIPOLE"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_PERIODIC', 'PERIODIC'), ('_REFERENCE', 'REFERENCE'), ('_REF', 'REF'), ('_REFERENCE_POINT', 'REFERENCE_POINT'), ('_REF_POINT', 'REF_POINT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class forcefield1(printable):
    """Section specifying information regarding how to set up properly a force_field for the classical calculations."""
    def __init__(self):
        self._PARMTYPE = None    # Define the kind of torsion potential
        self._PARM_FILE_NAME = None    # Specifies the filename that contains the parameters of the FF.
        self._VDW_SCALE14 = None    # Scaling factor for the VDW 1-4
        self._EI_SCALE14 = None    # Scaling factor for the electrostatics 1-4
        self._SHIFT_CUTOFF = None    # Add a constant energy shift to the real-space non-bonding interactions (both Van der Waals and electrostatic) such that the energy at the cutoff radius is zero. This makes the non-bonding interactions continuous at the cutoff.
        self._DO_NONBONDED = None    # Controls the computation of all the real-sapce (short-range) nonbonded interactions. This also includes the real-space corrections for excluded or scaled 1-2, 1-3 and 1-4 interactions. When set to F, the neighborlists are not created and all interactions that depend on them are not computed.
        self._IGNORE_MISSING_CRITICAL_PARAMS = None    # Do not abort when critical force-field parameters are missing. CP2K will run as if the terms containing the missing parameters are zero.
        self._MULTIPLE_POTENTIAL = None    # Enables the possibility to define NONBONDED and NONBONDED14 as a sum of different kinds of potential. Useful for piecewise defined potentials.
        self._ZBL_SCATTERING = None    # A short range repulsive potential is added, to simulatecollisions and scattering.
        self.listSPLINE = []
        self.SPLINE = spline1()
        self.NONBONDED = nonbonded1()
        self.NONBONDED14 = nonbonded141()
        self.listCHARGE = []
        self.CHARGE = charge2()
        self.CHARGES = charges1()
        self.listSHELL = []
        self.SHELL = shell2()
        self.listBOND = []
        self.BOND = bond1()
        self.listBEND = []
        self.BEND = bend1()
        self.listTORSION = []
        self.TORSION = torsion1()
        self.listIMPROPER = []
        self.IMPROPER = improper1()
        self.listOPBEND = []
        self.OPBEND = opbend1()
        self.listDIPOLE = []
        self.DIPOLE = dipole2()
        self.listQUADRUPOLE = []
        self.QUADRUPOLE = quadrupole1()
        self.name = "FORCEFIELD"
        self.keywords = [('_PARMTYPE', 'PARMTYPE'), ('_PARM_FILE_NAME', 'PARM_FILE_NAME'), ('_VDW_SCALE14', 'VDW_SCALE14'), ('_EI_SCALE14', 'EI_SCALE14'), ('_SHIFT_CUTOFF', 'SHIFT_CUTOFF'), ('_DO_NONBONDED', 'DO_NONBONDED'), ('_IGNORE_MISSING_CRITICAL_PARAMS', 'IGNORE_MISSING_CRITICAL_PARAMS'), ('_MULTIPLE_POTENTIAL', 'MULTIPLE_POTENTIAL'), ('_ZBL_SCATTERING', 'ZBL_SCATTERING')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('NONBONDED', 'NONBONDED'), ('NONBONDED14', 'NONBONDED14'), ('CHARGES', 'CHARGES')]
        self.repeated_subsections = [('SPLINE', 'spline1'), ('CHARGE', 'charge2'), ('SHELL', 'shell2'), ('BOND', 'bond1'), ('BEND', 'bend1'), ('TORSION', 'torsion1'), ('IMPROPER', 'improper1'), ('OPBEND', 'opbend1'), ('DIPOLE', 'dipole2'), ('QUADRUPOLE', 'quadrupole1')]

    def addSPLINE(self):
        new_section = spline1()
        self.listSPLINE.append(new_section)
        return new_section

    def addCHARGE(self):
        new_section = charge2()
        self.listCHARGE.append(new_section)
        return new_section

    def addSHELL(self):
        new_section = shell2()
        self.listSHELL.append(new_section)
        return new_section

    def addBOND(self):
        new_section = bond1()
        self.listBOND.append(new_section)
        return new_section

    def addBEND(self):
        new_section = bend1()
        self.listBEND.append(new_section)
        return new_section

    def addTORSION(self):
        new_section = torsion1()
        self.listTORSION.append(new_section)
        return new_section

    def addIMPROPER(self):
        new_section = improper1()
        self.listIMPROPER.append(new_section)
        return new_section

    def addOPBEND(self):
        new_section = opbend1()
        self.listOPBEND.append(new_section)
        return new_section

    def addDIPOLE(self):
        new_section = dipole2()
        self.listDIPOLE.append(new_section)
        return new_section

    def addQUADRUPOLE(self):
        new_section = quadrupole1()
        self.listQUADRUPOLE.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class spinspin1(printable):
    """Compute indirect spin-spin coupling constants."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._RESTART_SPINSPIN = None    # Restart the spin-spin calculation from a previous run (NOT WORKING YET)
        self.list_ISSC_ON_ATOM_LIST = []
        self._ISSC_ON_ATOM_LIST = None
    # Atoms for which the issc is computed.
        self._DO_FC = None    # Compute the Fermi contact contribution
        self._DO_SD = None    # Compute the spin-dipolar contribution
        self._DO_PSO = None    # Compute the paramagnetic spin-orbit contribution
        self._DO_DSO = None    # Compute the diamagnetic spin-orbit contribution (NOT YET IMPLEMENTED)
        self.PRINT = print37()
        self.INTERPOLATOR = interpolator1()
        self.name = "SPINSPIN"
        self.keywords = [('_RESTART_SPINSPIN', 'RESTART_SPINSPIN'), ('_DO_FC', 'DO_FC'), ('_DO_SD', 'DO_SD'), ('_DO_PSO', 'DO_PSO'), ('_DO_DSO', 'DO_DSO')]
        self.repeated_keywords = [('_ISSC_ON_ATOM_LIST', 'ISSC_ON_ATOM_LIST')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PRINT', 'PRINT'), ('INTERPOLATOR', 'INTERPOLATOR')]
        self.repeated_subsections = []

    def add_ISSC_ON_ATOM_LIST(self, value):
        self.list_ISSC_ON_ATOM_LIST.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class define_region4(printable):
    """This section provides the possibility to define arbitrary region  for the MSD calculation."""
    def __init__(self):
        self.list_LIST = []
        self._LIST = None
    # Specifies a list of atoms to thermostat.
        self.list_MOLNAME = []
        self._MOLNAME = None
    # Specifies the name of the molecules to thermostat
        self._SEGNAME = self._MOLNAME
        self.list_SEGNAME = self.list_MOLNAME
        self._MM_SUBSYS = None    # In a QM/MM run all  MM atoms are specified as a whole ensemble to be thermostated
        self._PROTEIN = self._MM_SUBSYS
        self._QM_SUBSYS = None    # In a QM/MM run all QM atoms are specified as a whole ensemble to be thermostated
        self.name = "DEFINE_REGION"
        self.keywords = [('_MM_SUBSYS', 'MM_SUBSYS'), ('_PROTEIN', 'PROTEIN'), ('_QM_SUBSYS', 'QM_SUBSYS')]
        self.repeated_keywords = [('_LIST', 'LIST'), ('_MOLNAME', 'MOLNAME'), ('_SEGNAME', 'SEGNAME')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def add_LIST(self, value):
        self.list_LIST.append(value)

    def add_MOLNAME(self, value):
        self.list_MOLNAME.append(value)

    def add_SEGNAME(self, value):
        self.list_SEGNAME.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class define_region5(printable):
    """This section provides the possibility to define arbitrary region"""
    def __init__(self):
        self.list_LIST = []
        self._LIST = None
    # Specifies a list of atoms belonging to the region.
        self._TEMPERATURE = None    # The temperature in K used to  initialize the velocities of the atoms in this region
        self._TEMP_TOL = None    # Maximum accepted  temperature deviation  from the expected value for this region.If  temp_tol=0 no rescaling is performed
        self.name = "DEFINE_REGION"
        self.keywords = [('_TEMPERATURE', 'TEMPERATURE'), ('_TEMP_TOL', 'TEMP_TOL')]
        self.repeated_keywords = [('_LIST', 'LIST')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def add_LIST(self, value):
        self.list_LIST.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class define_region2(printable):
    """This section provides the possibility to define arbitrary region  for the fast thermostat."""
    def __init__(self):
        self.list_LIST = []
        self._LIST = None
    # Specifies a list of atoms to thermostat.
        self.list_MOLNAME = []
        self._MOLNAME = None
    # Specifies the name of the molecules to thermostat
        self._SEGNAME = self._MOLNAME
        self.list_SEGNAME = self.list_MOLNAME
        self._MM_SUBSYS = None    # In a QM/MM run all  MM atoms are specified as a whole ensemble to be thermostated
        self._PROTEIN = self._MM_SUBSYS
        self._QM_SUBSYS = None    # In a QM/MM run all QM atoms are specified as a whole ensemble to be thermostated
        self.name = "DEFINE_REGION"
        self.keywords = [('_MM_SUBSYS', 'MM_SUBSYS'), ('_PROTEIN', 'PROTEIN'), ('_QM_SUBSYS', 'QM_SUBSYS')]
        self.repeated_keywords = [('_LIST', 'LIST'), ('_MOLNAME', 'MOLNAME'), ('_SEGNAME', 'SEGNAME')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def add_LIST(self, value):
        self.list_LIST.append(value)

    def add_MOLNAME(self, value):
        self.list_MOLNAME.append(value)

    def add_SEGNAME(self, value):
        self.list_SEGNAME.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class define_region3(printable):
    """This section provides the possibility to define arbitrary region  for the slow thermostat."""
    def __init__(self):
        self.list_LIST = []
        self._LIST = None
    # Specifies a list of atoms to thermostat.
        self.list_MOLNAME = []
        self._MOLNAME = None
    # Specifies the name of the molecules to thermostat
        self._SEGNAME = self._MOLNAME
        self.list_SEGNAME = self.list_MOLNAME
        self._MM_SUBSYS = None    # In a QM/MM run all  MM atoms are specified as a whole ensemble to be thermostated
        self._PROTEIN = self._MM_SUBSYS
        self._QM_SUBSYS = None    # In a QM/MM run all QM atoms are specified as a whole ensemble to be thermostated
        self.name = "DEFINE_REGION"
        self.keywords = [('_MM_SUBSYS', 'MM_SUBSYS'), ('_PROTEIN', 'PROTEIN'), ('_QM_SUBSYS', 'QM_SUBSYS')]
        self.repeated_keywords = [('_LIST', 'LIST'), ('_MOLNAME', 'MOLNAME'), ('_SEGNAME', 'SEGNAME')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def add_LIST(self, value):
        self.list_LIST.append(value)

    def add_MOLNAME(self, value):
        self.list_MOLNAME.append(value)

    def add_SEGNAME(self, value):
        self.list_SEGNAME.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class define_region1(printable):
    """This section provides the possibility to define arbitrary region  for the thermostat."""
    def __init__(self):
        self.list_LIST = []
        self._LIST = None
    # Specifies a list of atoms to thermostat.
        self.list_MOLNAME = []
        self._MOLNAME = None
    # Specifies the name of the molecules to thermostat
        self._SEGNAME = self._MOLNAME
        self.list_SEGNAME = self.list_MOLNAME
        self._MM_SUBSYS = None    # In a QM/MM run all  MM atoms are specified as a whole ensemble to be thermostated
        self._PROTEIN = self._MM_SUBSYS
        self._QM_SUBSYS = None    # In a QM/MM run all QM atoms are specified as a whole ensemble to be thermostated
        self.name = "DEFINE_REGION"
        self.keywords = [('_MM_SUBSYS', 'MM_SUBSYS'), ('_PROTEIN', 'PROTEIN'), ('_QM_SUBSYS', 'QM_SUBSYS')]
        self.repeated_keywords = [('_LIST', 'LIST'), ('_MOLNAME', 'MOLNAME'), ('_SEGNAME', 'SEGNAME')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def add_LIST(self, value):
        self.list_LIST.append(value)

    def add_MOLNAME(self, value):
        self.list_MOLNAME.append(value)

    def add_SEGNAME(self, value):
        self.list_SEGNAME.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class subcell4(printable):
    """Activates the printing of the subcells used for thegeneration of neighbor lists for connectivity."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "SUBCELL"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class atomic_coordinates1(printable):
    """controls the output of the atomic coordinates when setting up theforce environment. For printing coordinates during MD or GEO refer to the keyword trajectory."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._UNIT = None    # Specify the unit of measurement for the quantity in output. All available CP2K units can be used.
        self.EACH = each1()
        self.name = "ATOMIC_COORDINATES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_UNIT', 'UNIT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class energies1(printable):
    """Controls the printing of the EIP energies."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "ENERGIES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class ke_libxc1(printable):
    """To be used for KG runs. Uses kinetic energy functionals from LIBXC, see also http://www.tddft.org/programs/octopus/wiki/index.php/Libxc"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._FUNCTIONAL = None    # names of the functionals, see also http://www.tddft.org/programs/octopus/wiki/index.php/Libxc:manual .The precise list of available functionals depends on the version of libxc interfaced (currently 2.0.1).
        self._SCALE = None    # scaling factors of the functionals
        self._PARAMETERS = None    # parameters of the functionals
        self.name = "KE_LIBXC"
        self.keywords = [('_FUNCTIONAL', 'FUNCTIONAL'), ('_SCALE', 'SCALE'), ('_PARAMETERS', 'PARAMETERS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class convergence_info1(printable):
    """Controls the printing of the convergence criteria during a BAND run"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "CONVERGENCE_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class dos1(printable):
    """Controls the printing of the Density of States (DOS)."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._N_GRIDPOINTS = None    # Number of points in the computed DOS
        self.EACH = each1()
        self.name = "DOS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_N_GRIDPOINTS', 'N_GRIDPOINTS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class forces_inst1(printable):
    """Controls the output of the instantaneous helium forces on the solute"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "FORCES_INST"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class lyp1(printable):
    """Uses the LYP functional"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._SCALE_C = None    # scales the correlation part of the functional
        self.name = "LYP"
        self.keywords = [('_SCALE_C', 'SCALE_C')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print37(printable):
    """print results of the indirect spin-spin calculation"""
    def __init__(self):
        self.K_MATRIX = k_matrix1()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('K_MATRIX', 'K_MATRIX')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class energies_var1(printable):
    """Controls the printing of the variance of the EIP energies."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "ENERGIES_VAR"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class ldos1(printable):
    """Controls the printing of local PDOS, projected on subsets of atoms given through lists"""
    def __init__(self):
        self._COMPONENTS = None    # Print out pdos distinguishing all angular momentum components.
        self.list_LIST = []
        self._LIST = None
    # Specifies a list of indexes of atoms where to project the DOS
        self.name = "LDOS"
        self.keywords = [('_COMPONENTS', 'COMPONENTS')]
        self.repeated_keywords = [('_LIST', 'LIST')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def add_LIST(self, value):
        self.list_LIST.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class ad_langevin1(printable):
    """Parameters of the adaptive-Langevin thermostat."""
    def __init__(self):
        self._TIMECON_NH = None    # Time constant of the Nose-Hoover part of the AD_LANGEVIN thermostat. A small time constant will result in strong thermostatting (useful for initial equilibrations) and a large time constant would be adequate to get weak thermostatting in production runs.
        self._TIMECON_LANGEVIN = None    # Time constant of the Langevin part of the AD_LANGEVIN thermostat. A small time constant will result in strong thermostatting (useful for initial equilibrations) and a large time constant would be adequate to get weak thermostatting in production runs.
        self.CHI = chi1()
        self.MASS = mass3()
        self.name = "AD_LANGEVIN"
        self.keywords = [('_TIMECON_NH', 'TIMECON_NH'), ('_TIMECON_LANGEVIN', 'TIMECON_LANGEVIN')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('CHI', 'CHI'), ('MASS', 'MASS')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class angle1(printable):
    """Section used to add/remove angles in the connectivity. Useful for systems with a complex connectivity, difficult to find out automatically."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self.list_ATOMS = []
        self._ATOMS = None
    # Specifies two atomic index united by a covalent bond
        self.name = "ANGLE"
        self.keywords = []
        self.repeated_keywords = [('_ATOMS', 'ATOMS')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def add_ATOMS(self, value):
        self.list_ATOMS.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class ff_parameter_file1(printable):
    """Controls the printing of Force Field parameter file"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "FF_PARAMETER_FILE"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class constraint2(printable):
    """specifies a linear constraint on the fitted charges.This can be used to give equal values to equivalent atoms.sum over atom_list c_i * q_i = t"""
    def __init__(self):
        self._TARGET = None    # the target value for the constraint
        self._EQUAL_CHARGES = None    # All atoms in ATOM_LIST are constrained to have the same charges. When using this keyword, TARGET and ATOM_COEF do not need to be set and will be ignored. Instead of using this keyword, the constraint section could be repeated.
        self.list_ATOM_LIST = []
        self._ATOM_LIST = None
    # Defines the list of atoms involved in this constraint
        self._ATOM_COEF = None    # Defines the coefficient of the atom in this linear constraint
        self.name = "CONSTRAINT"
        self.keywords = [('_TARGET', 'TARGET'), ('_EQUAL_CHARGES', 'EQUAL_CHARGES'), ('_ATOM_COEF', 'ATOM_COEF')]
        self.repeated_keywords = [('_ATOM_LIST', 'ATOM_LIST')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def add_ATOM_LIST(self, value):
        self.list_ATOM_LIST.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class temp_shell_kind1(printable):
    """Controls the output of the temperature of the shell-core motion computed separately for each kind"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "TEMP_SHELL_KIND"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class coord_fit_points1(printable):
    """Controls the printing of the coordinates of the grid points used for periodic RESP fitting. This section is intended to be only used for testing (you can get large files)."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "COORD_FIT_POINTS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class angle2(printable):
    """Section to define the angle as a collective variables."""
    def __init__(self):
        self._ATOMS = None    # Specifies the indexes of atoms/points defining the angle.
        self._POINTS = self._ATOMS
        self.listPOINT = []
        self.POINT = point1()
        self.name = "ANGLE"
        self.keywords = [('_ATOMS', 'ATOMS'), ('_POINTS', 'POINTS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('POINT', 'point1')]

    def addPOINT(self):
        new_section = point1()
        self.listPOINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class ep_matrixes1(printable):
    """Prints various matrixes of an ep calculation"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._PSI0 = None    # print the value of the psi0 matrix
        self._PSI0_BLOCKS = None    # print the value of the blocs of the psi0 matrix
        self._PSI1 = None    # print the value of the psi1 matrix
        self._MO_S_INV = None    # print the value of the inverse of the mo overlap matrix
        self.EACH = each1()
        self.name = "EP_MATRIXES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_PSI0', 'PSI0'), ('_PSI0_BLOCKS', 'PSI0_BLOCKS'), ('_PSI1', 'PSI1'), ('_MO_S_INV', 'MO_S_INV')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class loc_restart1(printable):
    """Controls the printing of restart file for localized MOS"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "LOC_RESTART"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class translation_vector1(printable):
    """Dumps the translation vector applied along an MD (if any). Useful for postprocessing of QMMM trajectories in which the QM fragment is continuously centered in the QM box"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "TRANSLATION_VECTOR"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class reftraj1(printable):
    """Loads an external trajectory file and performs analysis on the loaded snapshots."""
    def __init__(self):
        self._TRAJ_FILE_NAME = None    # Specify the filename where the trajectory is stored.
        self._CELL_FILE_NAME = None    # Specify the filename where the cell is stored (for trajectories generated within variable cell ensembles).
        self._VARIABLE_VOLUME = None    # Enables the possibility to read a CELL file with information on the CELL size during the MD.
        self._FIRST_SNAPSHOT = None    # Index of the snapshot stored in the trajectory file from which to start a REFTRAJ run
        self._LAST_SNAPSHOT = None    # Index of the last snapshot stored in the trajectory file that is read along a REFTRAJ run
        self._STRIDE = None    #  Stride in number of snapshot for the  reftraj analysis
        self._EVAL_ENERGY_FORCES = None    # Evaluate energy and forces for each retrieved snapshot during a REFTRAJ run
        self.MSD = msd1()
        self.PRINT = print8()
        self.name = "REFTRAJ"
        self.keywords = [('_TRAJ_FILE_NAME', 'TRAJ_FILE_NAME'), ('_CELL_FILE_NAME', 'CELL_FILE_NAME'), ('_VARIABLE_VOLUME', 'VARIABLE_VOLUME'), ('_FIRST_SNAPSHOT', 'FIRST_SNAPSHOT'), ('_LAST_SNAPSHOT', 'LAST_SNAPSHOT'), ('_STRIDE', 'STRIDE'), ('_EVAL_ENERGY_FORCES', 'EVAL_ENERGY_FORCES')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('MSD', 'MSD'), ('PRINT', 'PRINT')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class cg1(printable):
    """Provides parameters to tune the conjugate gradient optimization"""
    def __init__(self):
        self._MAX_STEEP_STEPS = None    # Maximum number of steepest descent steps before starting the conjugate gradients optimization.
        self._RESTART_LIMIT = None    # Cosine of the angle between two consecutive searching directions. If the angle during a CG optimization is less than the one corresponding to  to the RESTART_LIMIT the CG is reset and one step of steepest descent is  performed.
        self._FLETCHER_REEVES = None    # Uses FLETCHER-REEVES instead of POLAK-RIBIERE when using Conjugate Gradients
        self.LINE_SEARCH = line_search1()
        self.name = "CG"
        self.keywords = [('_MAX_STEEP_STEPS', 'MAX_STEEP_STEPS'), ('_RESTART_LIMIT', 'RESTART_LIMIT'), ('_FLETCHER_REEVES', 'FLETCHER_REEVES')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('LINE_SEARCH', 'LINE_SEARCH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class stress1(printable):
    """Controls the output of the stress tensor"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "STRESS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class genpot1(printable):
    """This section specifies the input parameters for a generic potential type.A functional form is specified. Mathematical Operators recognized are +, -, *, /, ** or alternatively ^, whereas symbols for brackets must be (). The function parser recognizes the (single argument) Fortran 90 intrinsic functions abs, exp, log10, log, sqrt, sinh, cosh, tanh, sin, cos, tan, asin, acos, atan. Parsing for INTRINSIC functions is CASE INsensitive."""
    def __init__(self):
        self._ATOMS = None    # Defines the atomic kind involved in the generic potential
        self._FUNCTION = None    # Specifies the functional form in mathematical notation.
        self._VARIABLES = None    # Defines the variable of the functional form.
        self.list_PARAMETERS = []
        self._PARAMETERS = None
    # Defines the parameters of the functional form
        self.list_VALUES = []
        self._VALUES = None
    # Defines the values of parameter of the functional form
        self.list_UNITS = []
        self._UNITS = None
    # Optionally, allows to define valid CP2K unit strings for each parameter value. It is assumed that the corresponding parameter value is specified in this unit.
        self._RCUT = None    # Defines the cutoff parameter of the generic potential
        self._RMIN = None    # Defines the lower bound of the potential. If not set the range is the full range generate by the spline
        self._RMAX = None    # Defines the upper bound of the potential. If not set the range is the full range generate by the spline
        self.name = "GENPOT"
        self.keywords = [('_ATOMS', 'ATOMS'), ('_FUNCTION', 'FUNCTION'), ('_VARIABLES', 'VARIABLES'), ('_RCUT', 'RCUT'), ('_RMIN', 'RMIN'), ('_RMAX', 'RMAX')]
        self.repeated_keywords = [('_PARAMETERS', 'PARAMETERS'), ('_VALUES', 'VALUES'), ('_UNITS', 'UNITS')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def add_PARAMETERS(self, value):
        self.list_PARAMETERS.append(value)

    def add_VALUES(self, value):
        self.list_VALUES.append(value)

    def add_UNITS(self, value):
        self.list_UNITS.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class wavelet1(printable):
    """Sets up parameters of  wavelet based poisson solver.This solver allows for non-periodic (PERIODIC NONE) boundary conditions and slab-boundary conditions (but only PERIODIC XZ).It does not require very large unit cells, only that the density goes to zero on the faces of the cell.The use of PREFERRED_FFT_LIBRARY FFTSG is required"""
    def __init__(self):
        self._SCF_TYPE = None    # Type of scaling function used in the wavelet approach, the total energy depends on this choice,and the convergence with respect to cutoff depends on the selected scaling functions.Possible values are 8,14,16,20,24,30,40,50,60,100
        self.name = "WAVELET"
        self.keywords = [('_SCF_TYPE', 'SCF_TYPE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class krylov1(printable):
    """"""
    def __init__(self):
        self._NKRYLOV = None    # Dimension of the Krylov space used for the Lanczos refinement
        self._NBLOCK = None    # Size of the block of vectors refined simultaneously by the Lanczos procedure
        self._EPS_KRYLOV = None    # Convergence criterion for the MOs
        self._EPS_STD_DIAG = None    # Level of convergence to be reached before starting the Lanczos procedure. Above this threshold a standard diagonalization method is used.  If negative Lanczos is started at the first iteration
        self._CHECK_MOS_CONV = None    # This requires to check the convergence of MOS also when standard diagonalization steps are performed, if the block krylov approach is active.
        self.name = "KRYLOV"
        self.keywords = [('_NKRYLOV', 'NKRYLOV'), ('_NBLOCK', 'NBLOCK'), ('_EPS_KRYLOV', 'EPS_KRYLOV'), ('_EPS_STD_DIAG', 'EPS_STD_DIAG'), ('_CHECK_MOS_CONV', 'CHECK_MOS_CONV')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class diis1(printable):
    """Activate the DIIS based optimization procedure for BAND"""
    def __init__(self):
        self._MAX_SD_STEPS = None    # Specify the maximum number of SD steps to perform before switching on DIIS (the minimum number will always be equal to N_DIIS).
        self._MAX_STEPS = None    # Specify the maximum number of optimization steps
        self._N_DIIS = None    # Number of history vectors to be used with DIIS
        self._NDIIS = self._N_DIIS
        self._STEPSIZE = None    # Initial stepsize used for the line search, sometimes this parametercan be reduced to stablize DIIS
        self._MAX_STEPSIZE = None    # Maximum stepsize used for the line search, sometimes this parametercan be reduced to stablize the LS for particularly difficult initial geometries
        self._NP_LS = None    # Number of points used in the line search SD.
        self._NO_LS = None    # Does not perform LS during SD. Useful in combination with a proper STEPSIZE for particularly out of equilibrium starting geometries.
        self._CHECK_DIIS = None    # Performes a series of checks on the DIIS solution in order to accept the DIIS step. If set to .FALSE. the only check performed is that the angle between the DIIS solution and the reference vector is less than Pi/2. Can be useful if many DIIS steps are rejected.
        self.DIIS_INFO = diis_info1()
        self.name = "DIIS"
        self.keywords = [('_MAX_SD_STEPS', 'MAX_SD_STEPS'), ('_MAX_STEPS', 'MAX_STEPS'), ('_N_DIIS', 'N_DIIS'), ('_NDIIS', 'NDIIS'), ('_STEPSIZE', 'STEPSIZE'), ('_MAX_STEPSIZE', 'MAX_STEPSIZE'), ('_NP_LS', 'NP_LS'), ('_NO_LS', 'NO_LS'), ('_CHECK_DIIS', 'CHECK_DIIS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('DIIS_INFO', 'DIIS_INFO')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class basis_molopt_quantities1(printable):
    """Print the two quantities needed in the basis molopt generation: total energy and condition number of the overlap matrix (S matrix)"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "BASIS_MOLOPT_QUANTITIES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class total_densities1(printable):
    """Controls the printing of total densities."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "TOTAL_DENSITIES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class timings1(printable):
    """Controls the printing of the timing report at the end of CP2K execution"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._THRESHOLD = None    # Specify % of CPUTIME above which the contribution will be inserted in the final timing report
        self._SORT_BY_SELF_TIME = None    # Sort the final timing report by the average self (exclusive) time instead of the total (inclusive) time of a routine
        self.EACH = each1()
        self.name = "TIMINGS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_THRESHOLD', 'THRESHOLD'), ('_SORT_BY_SELF_TIME', 'SORT_BY_SELF_TIME')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class dft1(printable):
    """parameter needed by dft programs"""
    def __init__(self):
        self.list_BASIS_SET_FILE_NAME = []
        self._BASIS_SET_FILE_NAME = None
    # Name of the basis set file, may include a path
        self._POTENTIAL_FILE_NAME = None    # Name of the pseudo potential file, may include a path
        self._GEMINAL_FILE_NAME = None    # Name of the geminal basis set file, may include a path
        self._WFN_RESTART_FILE_NAME = None    # Name of the wavefunction restart file, may include a path. If no file is specified, the default is to open the file as generated by the wfn restart print key.
        self._RESTART_FILE_NAME = self._WFN_RESTART_FILE_NAME
        self._UKS = None    # Requests a spin-polarized calculation using alpha and beta orbitals, i.e. no spin restriction is applied
        self._UNRESTRICTED_KOHN_SHAM = self._UKS
        self._LSD = self._UKS
        self._SPIN_POLARIZED = self._UKS
        self._ROKS = None    # Requests a restricted open Kohn-Sham calculation
        self._RESTRICTED_OPEN_KOHN_SHAM = self._ROKS
        self._MULTIPLICITY = None    # Two times the total spin plus one. Specify 3 for a triplet, 4 for a quartet, and so on. Default is 1 (singlet) for an even number and 2 (doublet) for an odd number of electrons.
        self._MULTIP = self._MULTIPLICITY
        self._CHARGE = None    # The total charge of the system
        self._EXCITATIONS = None    # If excitations should be calculated
        self._PLUS_U_METHOD = None    # Method employed for the calculation of the DFT+U contribution
        self._RELAX_MULTIPLICITY = None    # Do not enforce the occupation of alpha and beta MOs due to the initially defined multiplicity, but rather follow an Aufbau principle. A threshold value greater than zero activates this option. Larger threshold values increase the probability for a spin flip. This option is only valid for unrestricted (i.e. spin polarised) Kohn-Sham (UKS) calculations.
        self._RELAX_MULTIP = self._RELAX_MULTIPLICITY
        self._SUBCELLS = None    # Read the grid size for subcell generation in the construction of neighbor lists.
        self.SCF = scf1()
        self.LS_SCF = ls_scf1()
        self.KG_METHOD = kg_method1()
        self.SCP = scp1()
        self.AUXILIARY_DENSITY_MATRIX_METHOD = auxiliary_density_matrix_method1()
        self.QS = qs1()
        self.TDDFPT = tddfpt1()
        self.MGRID = mgrid1()
        self.XC = xc1()
        self.RELATIVISTIC = relativistic1()
        self.SIC = sic1()
        self.LOW_SPIN_ROKS = low_spin_roks1()
        self.listEFIELD = []
        self.EFIELD = efield1()
        self.listPERIODIC_EFIELD = []
        self.PERIODIC_EFIELD = periodic_efield1()
        self.EXTERNAL_POTENTIAL = external_potential2()
        self.POISSON = poisson1()
        self.SCRF = scrf1()
        self.DENSITY_FITTING = density_fitting1()
        self.XAS = xas1()
        self.LOCALIZE = localize1()
        self.REAL_TIME_PROPAGATION = real_time_propagation1()
        self.PRINT = print25()
        self.name = "DFT"
        self.keywords = [('_POTENTIAL_FILE_NAME', 'POTENTIAL_FILE_NAME'), ('_GEMINAL_FILE_NAME', 'GEMINAL_FILE_NAME'), ('_WFN_RESTART_FILE_NAME', 'WFN_RESTART_FILE_NAME'), ('_RESTART_FILE_NAME', 'RESTART_FILE_NAME'), ('_UKS', 'UKS'), ('_UNRESTRICTED_KOHN_SHAM', 'UNRESTRICTED_KOHN_SHAM'), ('_LSD', 'LSD'), ('_SPIN_POLARIZED', 'SPIN_POLARIZED'), ('_ROKS', 'ROKS'), ('_RESTRICTED_OPEN_KOHN_SHAM', 'RESTRICTED_OPEN_KOHN_SHAM'), ('_MULTIPLICITY', 'MULTIPLICITY'), ('_MULTIP', 'MULTIP'), ('_CHARGE', 'CHARGE'), ('_EXCITATIONS', 'EXCITATIONS'), ('_PLUS_U_METHOD', 'PLUS_U_METHOD'), ('_RELAX_MULTIPLICITY', 'RELAX_MULTIPLICITY'), ('_RELAX_MULTIP', 'RELAX_MULTIP'), ('_SUBCELLS', 'SUBCELLS')]
        self.repeated_keywords = [('_BASIS_SET_FILE_NAME', 'BASIS_SET_FILE_NAME')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('SCF', 'SCF'), ('LS_SCF', 'LS_SCF'), ('KG_METHOD', 'KG_METHOD'), ('SCP', 'SCP'), ('AUXILIARY_DENSITY_MATRIX_METHOD', 'AUXILIARY_DENSITY_MATRIX_METHOD'), ('QS', 'QS'), ('TDDFPT', 'TDDFPT'), ('MGRID', 'MGRID'), ('XC', 'XC'), ('RELATIVISTIC', 'RELATIVISTIC'), ('SIC', 'SIC'), ('LOW_SPIN_ROKS', 'LOW_SPIN_ROKS'), ('EXTERNAL_POTENTIAL', 'EXTERNAL_POTENTIAL'), ('POISSON', 'POISSON'), ('SCRF', 'SCRF'), ('DENSITY_FITTING', 'DENSITY_FITTING'), ('XAS', 'XAS'), ('LOCALIZE', 'LOCALIZE'), ('REAL_TIME_PROPAGATION', 'REAL_TIME_PROPAGATION'), ('PRINT', 'PRINT')]
        self.repeated_subsections = [('EFIELD', 'efield1'), ('PERIODIC_EFIELD', 'periodic_efield1')]

    def addEFIELD(self):
        new_section = efield1()
        self.listEFIELD.append(new_section)
        return new_section

    def addPERIODIC_EFIELD(self):
        new_section = periodic_efield1()
        self.listPERIODIC_EFIELD.append(new_section)
        return new_section

    def add_BASIS_SET_FILE_NAME(self, value):
        self.list_BASIS_SET_FILE_NAME.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class method1(printable):
    """Section of information on method to use."""
    def __init__(self):
        self._METHOD_TYPE = None    # Type of electronic structure method to be used
        self._RELATIVISTIC = None    # Type of scalar relativistic method to be used
        self.XC = xc1()
        self.name = "METHOD"
        self.keywords = [('_METHOD_TYPE', 'METHOD_TYPE'), ('_RELATIVISTIC', 'RELATIVISTIC')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('XC', 'XC')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class qm_kind1(printable):
    """Information about the qm kind in the qm/mm scheme"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self.list_MM_INDEX = []
        self._MM_INDEX = None
    # The indexes of the mm atoms that have this kind. This keyword can be repeated several times (useful if you have to specify many indexes).
        self.name = "QM_KIND"
        self.keywords = []
        self.repeated_keywords = [('_MM_INDEX', 'MM_INDEX')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def add_MM_INDEX(self, value):
        self.list_MM_INDEX.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class thermostat2(printable):
    """Specify thermostat type and parameters controlling the thermostat."""
    def __init__(self):
        self._TYPE = None    # Specify the thermostat used for the constant temperature ensembles.
        self._REGION = None    # Determines the region each thermostat is attached to.
        self.listDEFINE_REGION = []
        self.DEFINE_REGION = define_region1()
        self.NOSE = nose1()
        self.CSVR = csvr1()
        self.GLE = gle1()
        self.AD_LANGEVIN = ad_langevin1()
        self.PRINT = print6()
        self.name = "THERMOSTAT"
        self.keywords = [('_TYPE', 'TYPE'), ('_REGION', 'REGION')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('NOSE', 'NOSE'), ('CSVR', 'CSVR'), ('GLE', 'GLE'), ('AD_LANGEVIN', 'AD_LANGEVIN'), ('PRINT', 'PRINT')]
        self.repeated_subsections = [('DEFINE_REGION', 'define_region1')]

    def addDEFINE_REGION(self):
        new_section = define_region1()
        self.listDEFINE_REGION.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class thermostat1(printable):
    """Specify thermostat type and parameters controlling the thermostat."""
    def __init__(self):
        self._TYPE = None    # Specify the thermostat used for the constant temperature ensembles.
        self.NOSE = nose1()
        self.CSVR = csvr1()
        self.GLE = gle1()
        self.AD_LANGEVIN = ad_langevin1()
        self.PRINT = print6()
        self.name = "THERMOSTAT"
        self.keywords = [('_TYPE', 'TYPE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('NOSE', 'NOSE'), ('CSVR', 'CSVR'), ('GLE', 'GLE'), ('AD_LANGEVIN', 'AD_LANGEVIN'), ('PRINT', 'PRINT')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class lyp_adiabatic1(printable):
    """Uses the LYP correlation functional in an adiabatic fashion"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._LAMBDA = None    # Defines the parameter of the adiabatic curve.
        self.name = "LYP_ADIABATIC"
        self.keywords = [('_LAMBDA', 'LAMBDA')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class chi_tensor1(printable):
    """Controls the printing of susceptibility"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "CHI_TENSOR"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class mo_orthonormality1(printable):
    """Controls the printing relative to the orthonormality of MOs (CT S C)."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "MO_ORTHONORMALITY"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class interpolator2(printable):
    """controls the interpolation for the G-space term"""
    def __init__(self):
        self._AINT_PRECOND = None    # the approximate inverse to use to get the starting point for the linear solver of the spline3 methods
        self._PRECOND = None    # The preconditioner used for the linear solver of the spline3 methods
        self._EPS_X = None    # accuracy on the solution for spline3 the interpolators
        self._EPS_R = None    # accuracy on the residual for spline3 the interpolators
        self._MAX_ITER = None    # the maximum number of iterations
        self._MAXITER = self._MAX_ITER
        self.CONV_INFO = conv_info1()
        self.name = "INTERPOLATOR"
        self.keywords = [('_AINT_PRECOND', 'AINT_PRECOND'), ('_PRECOND', 'PRECOND'), ('_EPS_X', 'EPS_X'), ('_EPS_R', 'EPS_R'), ('_MAX_ITER', 'MAX_ITER'), ('_MAXITER', 'MAXITER')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('CONV_INFO', 'CONV_INFO')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class interpolator3(printable):
    """kind of interpolation used between the multigrids"""
    def __init__(self):
        self._KIND = None    # the interpolator to use
        self._SAFE_COMPUTATION = None    # if a non unrolled calculation is to be performed in parallel
        self._AINT_PRECOND = None    # the approximate inverse to use to get the starting point for the linear solver of the spline3 methods
        self._PRECOND = None    # The preconditioner used for the linear solver of the spline3 methods
        self._EPS_X = None    # accuracy on the solution for spline3 the interpolators
        self._EPS_R = None    # accuracy on the residual for spline3 the interpolators
        self._MAX_ITER = None    # the maximum number of iterations
        self._MAXITER = self._MAX_ITER
        self.CONV_INFO = conv_info1()
        self.SPL_COEFFS = spl_coeffs1()
        self.name = "INTERPOLATOR"
        self.keywords = [('_KIND', 'KIND'), ('_SAFE_COMPUTATION', 'SAFE_COMPUTATION'), ('_AINT_PRECOND', 'AINT_PRECOND'), ('_PRECOND', 'PRECOND'), ('_EPS_X', 'EPS_X'), ('_EPS_R', 'EPS_R'), ('_MAX_ITER', 'MAX_ITER'), ('_MAXITER', 'MAXITER')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('CONV_INFO', 'CONV_INFO'), ('SPL_COEFFS', 'SPL_COEFFS')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class rdf1(printable):
    """Radial distribution function generation settings"""
    def __init__(self):
        self._MAXR = None    # Maximum RDF range, defaults to unit cell size
        self._NBIN = None    # Number of bins
        self.name = "RDF"
        self.keywords = [('_MAXR', 'MAXR'), ('_NBIN', 'NBIN')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class rdf2(printable):
    """Controls the output of the helium radial distribution function"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "RDF"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class basis1(printable):
    """Section used to specify a general basis set for QM calculations."""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # CP2K Basis Set Standard Format
        self.name = "BASIS"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class thermostat_slow1(printable):
    """Specify thermostat type and parameters controlling the thermostat."""
    def __init__(self):
        self._TYPE = None    # Specify the thermostat used for the constant temperature ensembles.
        self._REGION = None    # Determines the defined region for slow thermostat
        self.listDEFINE_REGION = []
        self.DEFINE_REGION = define_region3()
        self.NOSE = nose1()
        self.name = "THERMOSTAT_SLOW"
        self.keywords = [('_TYPE', 'TYPE'), ('_REGION', 'REGION')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('NOSE', 'NOSE')]
        self.repeated_subsections = [('DEFINE_REGION', 'define_region3')]

    def addDEFINE_REGION(self):
        new_section = define_region3()
        self.listDEFINE_REGION.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class tddfpt1(printable):
    """parameters needed to set up the Time Dependent Density Functional PT"""
    def __init__(self):
        self._MAX_KV = None    #  maximal number of Krylov space vectors
        self._MAX_VECTORS = self._MAX_KV
        self._RESTARTS = None    #  maximal number subspace search restarts
        self._N_RESTARTS = self._RESTARTS
        self._NEV = None    #  number of excitations to calculate
        self._N_EV = self._NEV
        self._EV = self._NEV
        self._NLUMO = None    #  number of additional unoccupied orbitals
        self._NREORTHO = None    #  number of reorthogonalization steps
        self._N_REORTHO = self._NREORTHO
        self._REORTHO = self._NREORTHO
        self._REORTHOGONALITAZIONS = self._NREORTHO
        self._KERNEL = None    # compute the kernel (debug purpose only)
        self._DO_KERNEL = self._KERNEL
        self._LSD_SINGLETS = None    # compute singlets using lsd vxc kernel
        self._INVERT_S = None    # use the inverse of the overlap matrix
        self._INVERT_OVERLAP = self._INVERT_S
        self._PRECONDITIONER = None    # use the preconditioner (only for Davidson)
        self._PRECOND = self._PRECONDITIONER
        self._RES_ETYPE = None    # (singlets/triplets) for restricted calculation
        self._RESTRICTED_EXCITATIONS_TYPE = self._RES_ETYPE
        self._RES_E_TYPE = self._RES_ETYPE
        self._DIAG_METHOD = None    # Diagonalization method used in tddfpt
        self._DIAGONALIZATION_METHOD = self._DIAG_METHOD
        self._METHOD = self._DIAG_METHOD
        self._OE_CORR = None    # Which type of orbital eigenvalue correction to use\n(to yield better HOMO-LUMO energies)
        self._ORBITAL_EIGENVALUES_CORRECTION = self._OE_CORR
        self._CONVERGENCE = None    # The convergence of the eigenvalues
        self._CONV = self._CONVERGENCE
        self.XC = xc1()
        self.SIC = sic1()
        self.name = "TDDFPT"
        self.keywords = [('_MAX_KV', 'MAX_KV'), ('_MAX_VECTORS', 'MAX_VECTORS'), ('_RESTARTS', 'RESTARTS'), ('_N_RESTARTS', 'N_RESTARTS'), ('_NEV', 'NEV'), ('_N_EV', 'N_EV'), ('_EV', 'EV'), ('_NLUMO', 'NLUMO'), ('_NREORTHO', 'NREORTHO'), ('_N_REORTHO', 'N_REORTHO'), ('_REORTHO', 'REORTHO'), ('_REORTHOGONALITAZIONS', 'REORTHOGONALITAZIONS'), ('_KERNEL', 'KERNEL'), ('_DO_KERNEL', 'DO_KERNEL'), ('_LSD_SINGLETS', 'LSD_SINGLETS'), ('_INVERT_S', 'INVERT_S'), ('_INVERT_OVERLAP', 'INVERT_OVERLAP'), ('_PRECONDITIONER', 'PRECONDITIONER'), ('_PRECOND', 'PRECOND'), ('_RES_ETYPE', 'RES_ETYPE'), ('_RESTRICTED_EXCITATIONS_TYPE', 'RESTRICTED_EXCITATIONS_TYPE'), ('_RES_E_TYPE', 'RES_E_TYPE'), ('_DIAG_METHOD', 'DIAG_METHOD'), ('_DIAGONALIZATION_METHOD', 'DIAGONALIZATION_METHOD'), ('_METHOD', 'METHOD'), ('_OE_CORR', 'OE_CORR'), ('_ORBITAL_EIGENVALUES_CORRECTION', 'ORBITAL_EIGENVALUES_CORRECTION'), ('_CONVERGENCE', 'CONVERGENCE'), ('_CONV', 'CONV')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('XC', 'XC'), ('SIC', 'SIC')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class dipole3(printable):
    """Section controlling the calculation of DIPOLE. Note that the result in the periodic case might be defined modulo a certain period, determined by the lattice vectors. During MD, this can lead to jumps."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._PERIODIC = None    # Use Berry phase formula (PERIODIC=T) or simple operator (PERIODIC=F). The latter normally requires that the CELL is periodic NONE.
        self._REFERENCE = None    # Define the reference point for the calculation of the electrostatic moment.
        self._REF = self._REFERENCE
        self._REFERENCE_POINT = None    # Fixed reference point for the calculations of the electrostatic moment.
        self._REF_POINT = self._REFERENCE_POINT
        self.EACH = each1()
        self.name = "DIPOLE"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_PERIODIC', 'PERIODIC'), ('_REFERENCE', 'REFERENCE'), ('_REF', 'REF'), ('_REFERENCE_POINT', 'REFERENCE_POINT'), ('_REF_POINT', 'REF_POINT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class dipole1(printable):
    """Controls the printing of dipole information. Requires the DIPOLE calculation be active for all subforce_eval."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "DIPOLE"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class fragment1(printable):
    """Fragment definition"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Starting and ending atomic index defining one fragment must be provided
        self.name = "FRAGMENT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class transition_state1(printable):
    """Specifies parameters to perform a transition state search"""
    def __init__(self):
        self._METHOD = None    # Specify which kind of method to use for locating transition states
        self.DIMER = dimer1()
        self.name = "TRANSITION_STATE"
        self.keywords = [('_METHOD', 'METHOD')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('DIMER', 'DIMER')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class fragment3(printable):
    """Specify the atom number belonging to this fragment."""
    def __init__(self):
        self._LIST = None    # Specifies a list of atoms.
        self.name = "FRAGMENT"
        self.keywords = [('_LIST', 'LIST')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class fragment2(printable):
    """Fragment definition"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._MAP = None    # Provides the index of the fragment of the MIXED force_eval mapped on the locally defined fragment.
        self._DEFAULT_KEYWORD = None    # Starting and ending atomic index defining one fragment must be provided
        self.name = "FRAGMENT"
        self.keywords = [('_MAP', 'MAP')]
        self.repeated_keywords = []
        self.default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class gaussian_env1(printable):
    """parameters for a gaussian envelop"""
    def __init__(self):
        self._T0 = None    # Center of the gaussian envelop (maximum of the gaussian)
        self._SIGMA = None    # Width of the gaussian
        self.name = "GAUSSIAN_ENV"
        self.keywords = [('_T0', 'T0'), ('_SIGMA', 'SIGMA')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class mm_kind1(printable):
    """Information about the mm kind in the qm/mm scheme"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._RADIUS = None    # Specifies the radius of the atomic kinds
        self._CORR_RADIUS = None    # Specifies the correction radius of the atomic kinds The correction radius is connected to the use of the compatibility keyword.
        self.name = "MM_KIND"
        self.keywords = [('_RADIUS', 'RADIUS'), ('_CORR_RADIUS', 'CORR_RADIUS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class mm1(printable):
    """This section contains all information to run a MM calculation."""
    def __init__(self):
        self.FORCEFIELD = forcefield1()
        self.NEIGHBOR_LISTS = neighbor_lists2()
        self.POISSON = poisson1()
        self.PRINT = print26()
        self.name = "MM"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('FORCEFIELD', 'FORCEFIELD'), ('NEIGHBOR_LISTS', 'NEIGHBOR_LISTS'), ('POISSON', 'POISSON'), ('PRINT', 'PRINT')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class image_charge_restart1(printable):
    """Controls the printing of the restart file for the image matrix when using the iterative scheme"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "IMAGE_CHARGE_RESTART"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class lanczos1(printable):
    """Controls the printing of information on Lanczos refinement iterations."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "LANCZOS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class molecular_states1(printable):
    """Controls printing of molecular states"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._CUBE_EVAL_RANGE = None    # only write cubes if the eigenvalues of the corresponding molecular states lie in the given interval. Default is all states.
        self.list_MARK_STATES = []
        self._MARK_STATES = None
    # Can be used to mark given molecular states. Sets a mark to both, occupied and unoccupied states. Occupied states are counted beginning with HOMO=1, unoccupied states are counted beginning with LUMO=1, This is only meaningful in combination with WFN_MIX. First integer specifies the molecule, second integer specifies the state.
        self.EACH = each1()
        self.CUBES = cubes1()
        self.name = "MOLECULAR_STATES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_CUBE_EVAL_RANGE', 'CUBE_EVAL_RANGE')]
        self.repeated_keywords = [('_MARK_STATES', 'MARK_STATES')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH'), ('CUBES', 'CUBES')]
        self.repeated_subsections = []

    def add_MARK_STATES(self, value):
        self.list_MARK_STATES.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class line_search1(printable):
    """Provides parameters to tune the line search during the conjugate gradient optimization"""
    def __init__(self):
        self._TYPE = None    # 1D line search algorithm to be used with the CG optimizer, in increasing order of robustness and cost.
        self._2PNT = num2pnt1()
        self.GOLD = gold1()
        self.name = "LINE_SEARCH"
        self.keywords = [('_TYPE', 'TYPE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('_2PNT', '2PNT'), ('GOLD', 'GOLD')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class forces4(printable):
    """Controls the printing of the forces after each force evaluation"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._NDIGITS = None    # Specifies the number of digits used for the printing of the forces
        self.EACH = each1()
        self.name = "FORCES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_NDIGITS', 'NDIGITS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class forces3(printable):
    """Controls the printing of the EIP forces."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "FORCES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class diag_sub_scf1(printable):
    """Activation of self-consistenf subspace refinement by diagonalization of H by adjusting the occupation but keeping the MOS unchanged."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._MAX_ITER = None    # Maximum number of iterations for the SCF inner loop
        self._EPS_ENE = None    # Required energy accuracy for convergence of subspace diagonalization
        self._EPS_ADAPT_SCF = None    # Required density matrix accuracy as compared to current SCF convergence
        self._EPS_SKIP_SUB_DIAG = None    # Level of convergence to be reached before starting the internal loop of subspace rotations. Above this threshold only the outer diagonalization method is used.  If negative the subspace rotation is started at the first iteration
        self.MIXING = mixing1()
        self.name = "DIAG_SUB_SCF"
        self.keywords = [('_MAX_ITER', 'MAX_ITER'), ('_EPS_ENE', 'EPS_ENE'), ('_EPS_ADAPT_SCF', 'EPS_ADAPT_SCF'), ('_EPS_SKIP_SUB_DIAG', 'EPS_SKIP_SUB_DIAG')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('MIXING', 'MIXING')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class diag_sub_scf2(printable):
    """Controls the printing of information on subspace diagonalization internal loop."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "DIAG_SUB_SCF"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class cell1(printable):
    """Controls the printing of the cell eveytime a calculation using a new cell is started."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._UNIT = None    # Specify the unit of measurement for the quantity in output. All available CP2K units can be used.
        self.EACH = each1()
        self.name = "CELL"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_UNIT', 'UNIT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class flexible_partitioning1(printable):
    """This section sets up flexible_partitioning"""
    def __init__(self):
        self._CENTRAL_ATOM = None    # Specifies the central atom.
        self._INNER_ATOMS = None    # Specifies the list of atoms that should remain close to the central atom.
        self._OUTER_ATOMS = None    # Specifies the list of atoms that should remain far from the central atom.
        self._INNER_RADIUS = None    # radius of the inner wall
        self._OUTER_RADIUS = None    # radius of the outer wall
        self._STRENGTH = None    # Sets the force constant of the repulsive harmonic potential
        self._BIAS = None    # If a bias potential counter-acting the weight term should be applied (recommended).
        self._TEMPERATURE = None    # Sets the temperature parameter that is used in the baising potential.It is recommended to use the actual simulation temperature
        self._SMOOTH_WIDTH = None    # Sets the width of the smooth counting function.
        self.WEIGHTS = weights1()
        self.CONTROL = control1()
        self.name = "FLEXIBLE_PARTITIONING"
        self.keywords = [('_CENTRAL_ATOM', 'CENTRAL_ATOM'), ('_INNER_ATOMS', 'INNER_ATOMS'), ('_OUTER_ATOMS', 'OUTER_ATOMS'), ('_INNER_RADIUS', 'INNER_RADIUS'), ('_OUTER_RADIUS', 'OUTER_RADIUS'), ('_STRENGTH', 'STRENGTH'), ('_BIAS', 'BIAS'), ('_TEMPERATURE', 'TEMPERATURE'), ('_SMOOTH_WIDTH', 'SMOOTH_WIDTH')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('WEIGHTS', 'WEIGHTS'), ('CONTROL', 'CONTROL')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class cell3(printable):
    """Input parameters needed to set up the CELL."""
    def __init__(self):
        self._A = None    # Specify the Cartesian components for the cell vector A. This defines the first column of the h matrix.
        self._B = None    # Specify the Cartesian components for the cell vector B. This defines the second column of the h matrix.
        self._C = None    # Specify the Cartesian components for the cell vector C. This defines the third column of the h matrix.
        self._ABC = None    # Specify the lengths of the cell vectors A, B, and C, which defines the diagonal elements of h matrix for an orthorhombic cell. For non-orthorhombic cells it is possible either to specify the angles ALPHA, BETA, GAMMA via ALPHA_BETA_GAMMA keyword or alternatively use the keywords A, B, and C. The convention is that A lies along the X-axis, B is in the XY plane.
        self._ALPHA_BETA_GAMMA = None    # Specify the angles between the vectors A, B and C when using the ABC keyword. The convention is that A lies along the X-axis, B is in the XY plane. ALPHA is the angle between B and C, BETA is the angle between A and C and GAMMA the angle between A and B.
        self._ANGLES = self._ALPHA_BETA_GAMMA
        self._CELL_FILE_NAME = None    # Possibility to read the cell from an external file
        self._CELL_FILE_FORMAT = None    # Specify the format of the cell file (if used)
        self._PERIODIC = None    # Specify the directions for which periodic boundary conditions (PBC) will be applied. Important notice: This applies to the generation of the pair lists as well as to the application of the PBCs to positions. See the POISSON section to specify the periodicity used for the electrostatics. Typically the settings should be the same.
        self._MULTIPLE_UNIT_CELL = None    # Specifies the numbers of repetition in space (X, Y, Z) of the defined cell, assuming it as a unit cell. This keyword affects only the CELL specification. The same keyword in SUBSYS%TOPOLOGY%MULTIPLE_UNIT_CELL should be modified in order to affect the coordinates specification.
        self._SYMMETRY = None    # Imposes an initial cell symmetry.
        self.CELL_REF = cell_ref1()
        self.name = "CELL"
        self.keywords = [('_A', 'A'), ('_B', 'B'), ('_C', 'C'), ('_ABC', 'ABC'), ('_ALPHA_BETA_GAMMA', 'ALPHA_BETA_GAMMA'), ('_ANGLES', 'ANGLES'), ('_CELL_FILE_NAME', 'CELL_FILE_NAME'), ('_CELL_FILE_FORMAT', 'CELL_FILE_FORMAT'), ('_PERIODIC', 'PERIODIC'), ('_MULTIPLE_UNIT_CELL', 'MULTIPLE_UNIT_CELL'), ('_SYMMETRY', 'SYMMETRY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('CELL_REF', 'CELL_REF')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class cell2(printable):
    """Controls the output of the simulation cell.For later analysis of the trajectory it is recommendable that thefrequency of printing is the same as the one used for the trajectory file"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "CELL"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class vel_control1(printable):
    """Setup parameters to control the velocity during a BAND MD run."""
    def __init__(self):
        self._ANNEALING = None    # Specify the annealing coefficient
        self._PROJ_VELOCITY_VERLET = None    # Uses a Projected Velocity Verlet instead of a normal Velocity Verlet. Every time the cosine between velocities and forces is < 0 velocities are zeroed.
        self._SD_LIKE = None    # Zeros velocity at each MD step emulating a steepest descent like(SD_LIKE) approach
        self.name = "VEL_CONTROL"
        self.keywords = [('_ANNEALING', 'ANNEALING'), ('_PROJ_VELOCITY_VERLET', 'PROJ_VELOCITY_VERLET'), ('_SD_LIKE', 'SD_LIKE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class cell4(printable):
    """controls the output of the cell parameters"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._UNIT = None    # Specify the unit of measurement for the quantity in output. All available CP2K units can be used.
        self.EACH = each1()
        self.name = "CELL"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_UNIT', 'UNIT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class real_time_propagation1(printable):
    """Parameters needed to set up the real time propagation for the electron dynamics"""
    def __init__(self):
        self._MAX_ITER = None    # Maximal number of iterations for the self consistent propagator loop.
        self._EPS_ITER = None    # Convergence criterium for the self consistent propagator loop.
        self._ASPC_ORDER = None    # Speciefies how many steps will be used for extrapolation. One will be always used which is means X(t+dt)=X(t)
        self._EXTRAPOLATION = None    # Controls which quantity is extrapolated
        self._MAT_EXP = None    # Which method should be used to calculate the exponential in the propagator. For Ehrenfest MD only the Taylor method works, for real time propagation diagonalization works as well.
        self._SC_CHECK_START = None    # Speciefies how many iteration steps will be done without a check for self consistency. Can save some time in big calculations.
        self._EXP_ACCURACY = None    # Accuracy for the taylor and pade approximation. This is only an upper bound bound since the norm used for the guess is an upper bound for the needed one.
        self._PROPAGATOR = None    # Which propagator should be used for the orbitals
        self._INITIAL_WFN = None    # Controls the initial WFN used for propagation.
        self._APPLY_DELTA_PULSE = None    # Applies a delta kick to the initial wfn (only RTP for now - the EMD  case is not yet implemented).
        self._PERIODIC = None    # Apply a delta-kick that is compatible with periodic boundary conditions for any value of DELTA_PULSE_SCALE. Uses perturbation theory for the preparation of the initial wfn. Note that the pulse is only applied when INITIAL_WFN is set to SCF_WFN, and not for restarts (RT_RESTART).
        self._DELTA_PULSE_DIRECTION = None    # Direction of the applied electric field. The k vector is given as 2*Pi*[i,j,k]*inv(h_mat), which for PERIODIC .FALSE. yields exp(ikr) periodic with the unit cell, only if DELTA_PULSE_SCALE is set to unity. For an orthorhombic cell [1,0,0] yields [2*Pi/L_x,0,0]. For small cells, this results in a very large kick.
        self._DELTA_PULSE_SCALE = None    # Scale the k vector, which for PERIODIC .FALSE. results in exp(ikr) no longer being periodic with the unit cell. The norm of k is the strength of the applied electric field in atomic units.
        self._HFX_BALANCE_IN_CORE = None    # If HFX is used, this keyword forces a redistribution/recalculation of the integrals, balanced with respect to the in core steps.
        self.PRINT = print24()
        self.name = "REAL_TIME_PROPAGATION"
        self.keywords = [('_MAX_ITER', 'MAX_ITER'), ('_EPS_ITER', 'EPS_ITER'), ('_ASPC_ORDER', 'ASPC_ORDER'), ('_EXTRAPOLATION', 'EXTRAPOLATION'), ('_MAT_EXP', 'MAT_EXP'), ('_SC_CHECK_START', 'SC_CHECK_START'), ('_EXP_ACCURACY', 'EXP_ACCURACY'), ('_PROPAGATOR', 'PROPAGATOR'), ('_INITIAL_WFN', 'INITIAL_WFN'), ('_APPLY_DELTA_PULSE', 'APPLY_DELTA_PULSE'), ('_PERIODIC', 'PERIODIC'), ('_DELTA_PULSE_DIRECTION', 'DELTA_PULSE_DIRECTION'), ('_DELTA_PULSE_SCALE', 'DELTA_PULSE_SCALE'), ('_HFX_BALANCE_IN_CORE', 'HFX_BALANCE_IN_CORE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PRINT', 'PRINT')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class string_method1(printable):
    """Controls parameters for String Method type calculation only."""
    def __init__(self):
        self._SPLINE_ORDER = None    # Specify the oder of the spline used in the String Method.
        self._SMOOTHING = None    # Smoothing parameter for the reparametrization of the frames.
        self.name = "STRING_METHOD"
        self.keywords = [('_SPLINE_ORDER', 'SPLINE_ORDER'), ('_SMOOTHING', 'SMOOTHING')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print29(printable):
    """Section of possible print options for an EP calculation."""
    def __init__(self):
        self.ENERGY = energy7()
        self.RUN_INFO = run_info1()
        self.EP_MATRIXES = ep_matrixes1()
        self.EP_RHO_CUBE = ep_rho_cube1()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('ENERGY', 'ENERGY'), ('RUN_INFO', 'RUN_INFO'), ('EP_MATRIXES', 'EP_MATRIXES'), ('EP_RHO_CUBE', 'EP_RHO_CUBE')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class periodic_sys1(printable):
    """Specifies the parameter for sampling the RESP fitting points for periodic systems, i.e. systems that involve surfaces. This section can only be used with periodic  Poisson solver and cell. To see, which grid points were used, switch on COORD_FIT_POINTS in the PRINT section."""
    def __init__(self):
        self.list_ATOM_LIST = []
        self._ATOM_LIST = None
    # Specifies the list of indexes of atoms used to define the region for the RESP fitting. The list should contain indexes of atoms of the first surface layer.
        self._RANGE = None    # Range where the fitting points are sampled. A range of 3 to 5 Angstroms means that the fitting points are sampled in the region of 3 to 5 Angstroms above the surface which is defined by atom indexes given in ATOM_LIST.
        self._LENGTH = None    # Length of the sampling box, i.e. a box of this length and the height specified by RANGE is defined above each surface atom given in ATOM_LIST. The grid points in the boxes are accepted as fitting point. Should be in the range of the nearest neighbour distance (a bit larger to be on the safe side). Allows for a refined sampling of grid points in case of corrugated surfaces.
        self._SURF_DIRECTION = None    # Specifies what above the surface means. Defines the direction.
        self.name = "PERIODIC_SYS"
        self.keywords = [('_RANGE', 'RANGE'), ('_LENGTH', 'LENGTH'), ('_SURF_DIRECTION', 'SURF_DIRECTION')]
        self.repeated_keywords = [('_ATOM_LIST', 'ATOM_LIST')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def add_ATOM_LIST(self, value):
        self.list_ATOM_LIST.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class plane1(printable):
    """This section defines the plane. When using this colvar, two plane section must be defined!"""
    def __init__(self):
        self._DEF_TYPE = None    # Specify how the plane is defined: either by 3 atoms or by a fixed normal vector. At least one plane must be defined through atoms.
        self._ATOMS = None    # Specifies the indexes of 3 atoms/points defining the plane.
        self._NORMAL_VECTOR = None    # Alternatively to 3 atoms/points one can define one of the two, planes by defining its NORMAL vector.
        self.name = "PLANE"
        self.keywords = [('_DEF_TYPE', 'DEF_TYPE'), ('_ATOMS', 'ATOMS'), ('_NORMAL_VECTOR', 'NORMAL_VECTOR')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print20(printable):
    """Print results of a HFX RI calculation"""
    def __init__(self):
        self.PROGRAM_RUN_INFO = program_run_info13()
        self.GEMINAL_BASIS = geminal_basis1()
        self.CHARGE = charge1()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('GEMINAL_BASIS', 'GEMINAL_BASIS'), ('CHARGE', 'CHARGE')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print21(printable):
    """Controls printing of Ewald properties"""
    def __init__(self):
        self.PROGRAM_RUN_INFO = program_run_info14()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print22(printable):
    """Collects all printing options related to the Wannier centers and properties computed with Wannier centers."""
    def __init__(self):
        self.PROGRAM_RUN_INFO = program_run_info12()
        self.WANNIER_CUBES = wannier_cubes1()
        self.WANNIER_CENTERS = wannier_centers1()
        self.WANNIER_SPREADS = wannier_spreads1()
        self.LOC_RESTART = loc_restart1()
        self.TOTAL_DIPOLE = total_dipole1()
        self.MOLECULAR_DIPOLES = molecular_dipoles1()
        self.MOLECULAR_STATES = molecular_states1()
        self.WANNIER_STATES = wannier_states1()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('WANNIER_CUBES', 'WANNIER_CUBES'), ('WANNIER_CENTERS', 'WANNIER_CENTERS'), ('WANNIER_SPREADS', 'WANNIER_SPREADS'), ('LOC_RESTART', 'LOC_RESTART'), ('TOTAL_DIPOLE', 'TOTAL_DIPOLE'), ('MOLECULAR_DIPOLES', 'MOLECULAR_DIPOLES'), ('MOLECULAR_STATES', 'MOLECULAR_STATES'), ('WANNIER_STATES', 'WANNIER_STATES')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print23(printable):
    """printing of information during the core-level spectroscopy simulation"""
    def __init__(self):
        self.WANNIER_CUBES = wannier_cubes1()
        self.WANNIER_CENTERS = wannier_centers1()
        self.WANNIER_SPREADS = wannier_spreads1()
        self.LOC_RESTART = loc_restart1()
        self.ITERATION_INFO = iteration_info2()
        self.PROGRAM_RUN_INFO = program_run_info16()
        self.XES_SPECTRUM = xes_spectrum1()
        self.XAS_SPECTRUM = xas_spectrum1()
        self.RESTART = restart4()
        self.CLS_FUNCTION_CUBES = cls_function_cubes1()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('WANNIER_CUBES', 'WANNIER_CUBES'), ('WANNIER_CENTERS', 'WANNIER_CENTERS'), ('WANNIER_SPREADS', 'WANNIER_SPREADS'), ('LOC_RESTART', 'LOC_RESTART'), ('ITERATION_INFO', 'ITERATION_INFO'), ('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('XES_SPECTRUM', 'XES_SPECTRUM'), ('XAS_SPECTRUM', 'XAS_SPECTRUM'), ('RESTART', 'RESTART'), ('CLS_FUNCTION_CUBES', 'CLS_FUNCTION_CUBES')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print24(printable):
    """Section of possible print options for an RTP runs"""
    def __init__(self):
        self.PROGRAM_RUN_INFO = program_run_info17()
        self.RESTART = restart5()
        self.RESTART_HISTORY = restart_history2()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('RESTART', 'RESTART'), ('RESTART_HISTORY', 'RESTART_HISTORY')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print25(printable):
    """Section of possible print options in DFT code."""
    def __init__(self):
        self.PROGRAM_BANNER = program_banner1()
        self.KINETIC_ENERGY = kinetic_energy1()
        self.DERIVATIVES = derivatives1()
        self.NEIGHBOR_LISTS = neighbor_lists4()
        self.SUBCELL = subcell2()
        self.AO_MATRICES = ao_matrices1()
        self.MO = mo1()
        self.MO_CUBES = mo_cubes1()
        self.STM = stm1()
        self.WFN_MIX = wfn_mix1()
        self.GAPW = gapw1()
        self.DFT_CONTROL_PARAMETERS = dft_control_parameters1()
        self.OPTICAL_CONDUCTIVITY = optical_conductivity1()
        self.E_DENSITY_CUBE = e_density_cube1()
        self.TOT_DENSITY_CUBE = tot_density_cube1()
        self.V_HARTREE_CUBE = v_hartree_cube1()
        self.EFIELD_CUBE = efield_cube1()
        self.ELF_CUBE = elf_cube1()
        self.PDOS = pdos1()
        self.LOCALIZATION = localization1()
        self.MOMENTS = moments1()
        self.MULLIKEN = mulliken1()
        self.LOWDIN = lowdin1()
        self.XRAY_DIFFRACTION_SPECTRUM = xray_diffraction_spectrum1()
        self.ELECTRIC_FIELD_GRADIENT = electric_field_gradient1()
        self.BASIS_MOLOPT_QUANTITIES = basis_molopt_quantities1()
        self.HYPERFINE_COUPLING_TENSOR = hyperfine_coupling_tensor1()
        self.OPTIMIZE_GEMINALS = optimize_geminals1()
        self.PLUS_U = plus_u1()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PROGRAM_BANNER', 'PROGRAM_BANNER'), ('KINETIC_ENERGY', 'KINETIC_ENERGY'), ('DERIVATIVES', 'DERIVATIVES'), ('NEIGHBOR_LISTS', 'NEIGHBOR_LISTS'), ('SUBCELL', 'SUBCELL'), ('AO_MATRICES', 'AO_MATRICES'), ('MO', 'MO'), ('MO_CUBES', 'MO_CUBES'), ('STM', 'STM'), ('WFN_MIX', 'WFN_MIX'), ('GAPW', 'GAPW'), ('DFT_CONTROL_PARAMETERS', 'DFT_CONTROL_PARAMETERS'), ('OPTICAL_CONDUCTIVITY', 'OPTICAL_CONDUCTIVITY'), ('E_DENSITY_CUBE', 'E_DENSITY_CUBE'), ('TOT_DENSITY_CUBE', 'TOT_DENSITY_CUBE'), ('V_HARTREE_CUBE', 'V_HARTREE_CUBE'), ('EFIELD_CUBE', 'EFIELD_CUBE'), ('ELF_CUBE', 'ELF_CUBE'), ('PDOS', 'PDOS'), ('LOCALIZATION', 'LOCALIZATION'), ('MOMENTS', 'MOMENTS'), ('MULLIKEN', 'MULLIKEN'), ('LOWDIN', 'LOWDIN'), ('XRAY_DIFFRACTION_SPECTRUM', 'XRAY_DIFFRACTION_SPECTRUM'), ('ELECTRIC_FIELD_GRADIENT', 'ELECTRIC_FIELD_GRADIENT'), ('BASIS_MOLOPT_QUANTITIES', 'BASIS_MOLOPT_QUANTITIES'), ('HYPERFINE_COUPLING_TENSOR', 'HYPERFINE_COUPLING_TENSOR'), ('OPTIMIZE_GEMINALS', 'OPTIMIZE_GEMINALS'), ('PLUS_U', 'PLUS_U')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print26(printable):
    """Section of possible print options in MM code."""
    def __init__(self):
        self.DERIVATIVES = derivatives2()
        self.EWALD_INFO = ewald_info2()
        self.DIPOLE = dipole3()
        self.NEIGHBOR_LISTS = neighbor_lists5()
        self.ITER_INFO = iter_info1()
        self.SUBCELL = subcell3()
        self.PROGRAM_BANNER = program_banner1()
        self.PROGRAM_RUN_INFO = program_run_info18()
        self.FF_PARAMETER_FILE = ff_parameter_file1()
        self.FF_INFO = ff_info1()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('DERIVATIVES', 'DERIVATIVES'), ('EWALD_INFO', 'EWALD_INFO'), ('DIPOLE', 'DIPOLE'), ('NEIGHBOR_LISTS', 'NEIGHBOR_LISTS'), ('ITER_INFO', 'ITER_INFO'), ('SUBCELL', 'SUBCELL'), ('PROGRAM_BANNER', 'PROGRAM_BANNER'), ('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('FF_PARAMETER_FILE', 'FF_PARAMETER_FILE'), ('FF_INFO', 'FF_INFO')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class linear1(printable):
    """Linear combination between two force_eval:  F= lambda F1 + (1-lambda) F2"""
    def __init__(self):
        self._LAMBDA = None    # Specify the mixing parameter lambda in the formula:
        self.name = "LINEAR"
        self.keywords = [('_LAMBDA', 'LAMBDA')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class wc1(printable):
    """Section to define the hbond wannier centre as a collective variables."""
    def __init__(self):
        self._RCUT = None    # Parameter used for computing the cutoff radius for searching the wannier centres around an atom
        self.list_ATOMS = []
        self._ATOMS = None
    # Specifies the indexes of atoms/points defining the bond (Od, H, Oa).
        self._POINTS = self._ATOMS
        self.list_POINTS = self.list_ATOMS
        self.listPOINT = []
        self.POINT = point1()
        self.name = "WC"
        self.keywords = [('_RCUT', 'RCUT')]
        self.repeated_keywords = [('_ATOMS', 'ATOMS'), ('_POINTS', 'POINTS')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('POINT', 'point1')]

    def addPOINT(self):
        new_section = point1()
        self.listPOINT.append(new_section)
        return new_section

    def add_ATOMS(self, value):
        self.list_ATOMS.append(value)

    def add_POINTS(self, value):
        self.list_POINTS.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class num2pnt1(printable):
    """Provides parameters to tune the line search for the two point based line search."""
    def __init__(self):
        self._MAX_ALLOWED_STEP = None    # Max allowed value for the line search step.
        self._LINMIN_GRAD_ONLY = None    # Use only the gradient, not the energy for line minimizations (e.g. in conjugate gradients).
        self.name = "2PNT"
        self.keywords = [('_MAX_ALLOWED_STEP', 'MAX_ALLOWED_STEP'), ('_LINMIN_GRAD_ONLY', 'LINMIN_GRAD_ONLY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class non_local1(printable):
    """Information on the non local dispersion functional"""
    def __init__(self):
        self._TYPE = None    # Type of functional (the corresponding kernel data file should be selected).
        self._VERBOSE_OUTPUT = None    # Extensive output for non local functionals
        self._KERNEL_FILE_NAME = None    # Name of the kernel data file, may include a path.vdW_kernel_table.dat is for DRSLL and LMKLL andrVV10_kernel_table.dat is for rVV10.
        self._CUTOFF = None    # The cutoff of the FFT grid used in the calculation of the nonlocal vdW functional [Ry].
        self._PARAMETERS = None    # Parameters b and C of the rVV10 functional
        self.name = "NON_LOCAL"
        self.keywords = [('_TYPE', 'TYPE'), ('_VERBOSE_OUTPUT', 'VERBOSE_OUTPUT'), ('_KERNEL_FILE_NAME', 'KERNEL_FILE_NAME'), ('_CUTOFF', 'CUTOFF'), ('_PARAMETERS', 'PARAMETERS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class frame2(printable):
    """Specify coordinates of the frame"""
    def __init__(self):
        self._COORD_FILE_NAME = None    # Name of the xyz file with coordinates (alternative to &COORD section)
        self.COORD = coord7()
        self.name = "FRAME"
        self.keywords = [('_COORD_FILE_NAME', 'COORD_FILE_NAME')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('COORD', 'COORD')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class frame1(printable):
    """Specify coordinates of the frame (number of frames can be either 1 or 2)"""
    def __init__(self):
        self._COORD_FILE_NAME = None    # Name of the xyz file with coordinates (alternative to &COORD section)
        self.COORD = coord7()
        self.name = "FRAME"
        self.keywords = [('_COORD_FILE_NAME', 'COORD_FILE_NAME')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('COORD', 'COORD')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class cascade1(printable):
    """Defines the parameters for the setup of a cascade simulation."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ENERGY = None    # Total energy transferred to the system during the cascade event.
        self.ATOM_LIST = atom_list1()
        self.name = "CASCADE"
        self.keywords = [('_ENERGY', 'ENERGY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('ATOM_LIST', 'ATOM_LIST')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class periodic_info1(printable):
    """Controls the printing of information regarding the periodic boundary condition."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PERIODIC_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class training_files1(printable):
    """specicifies the location in which the files necessary for fitting procedure are located. Each Training set needs a reptition of this section."""
    def __init__(self):
        self._DIRECTORY = None    # the directory in which the files are placed
        self._INPUT_FILE_NAME = None    # the filename of the input file used to run the original calcuation
        self.name = "TRAINING_FILES"
        self.keywords = [('_DIRECTORY', 'DIRECTORY'), ('_INPUT_FILE_NAME', 'INPUT_FILE_NAME')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class shell1(printable):
    """Parameters of shell model in adiabatic dynamics."""
    def __init__(self):
        self._TEMPERATURE = None    # Temperature in K used to control the internal velocities of the core-shell motion
        self._TEMP_TOL = None    # Maximum accepted temperature deviation from the expected value, for the internal core-shell motion.If 0, no rescaling is performed
        self._NOSE_PARTICLE = None    # If nvt or npt, the core and shell velocities are controlled by the same thermostat used for the particle. This might favour heat exchange and additional rescaling of the internal core-shell velocity is needed (TEMP_TOL)
        self._DISPLACEMENT_SHELL_TOL = None    # This keyword sets a maximum variation of the shell core distance in each Cartesian direction.The maximum internal core-shell velocity is evaluated and if it is too large to remainwithin the assigned limit, the time step is rescaled accordingly,and the first half step of the velocity verlet is repeated.
        self.THERMOSTAT = thermostat2()
        self.name = "SHELL"
        self.keywords = [('_TEMPERATURE', 'TEMPERATURE'), ('_TEMP_TOL', 'TEMP_TOL'), ('_NOSE_PARTICLE', 'NOSE_PARTICLE'), ('_DISPLACEMENT_SHELL_TOL', 'DISPLACEMENT_SHELL_TOL')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('THERMOSTAT', 'THERMOSTAT')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class shell2(printable):
    """This section specifies the parameters for shell-model potentials"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._CORE_CHARGE = None    # Partial charge assigned to the core (electron charge units)
        self._CORE = self._CORE_CHARGE
        self._SHELL_CHARGE = None    # Partial charge assigned to the shell (electron charge units)
        self._SHELL = self._SHELL_CHARGE
        self._MASS_FRACTION = None    # Fraction of the mass of the atom to be assigned to the shell
        self._MASS = self._MASS_FRACTION
        self._K2_SPRING = None    # Force constant k2 of the spring potential 1/2*k2*r^2 + 1/24*k4*r^4 binding a core-shell pair when a core-shell potential is employed.
        self._K2 = self._K2_SPRING
        self._SPRING = self._K2_SPRING
        self._K4_SPRING = None    # Force constant k4 of the spring potential 1/2*k2*r^2 + 1/24*k4*r^4 binding a core-shell pair when a core-shell potential is employed. By default a harmonic spring potential is used, i.e. k4 is zero.
        self._K4 = self._K4_SPRING
        self._MAX_DISTANCE = None    # Assign a maximum elongation of the spring, if negative no limit is imposed
        self._SHELL_CUTOFF = None    # Define a screening function to exclude some neighbors  of the shell when electrostatic interaction are considered, if negative no screening is operated
        self.name = "SHELL"
        self.keywords = [('_CORE_CHARGE', 'CORE_CHARGE'), ('_CORE', 'CORE'), ('_SHELL_CHARGE', 'SHELL_CHARGE'), ('_SHELL', 'SHELL'), ('_MASS_FRACTION', 'MASS_FRACTION'), ('_MASS', 'MASS'), ('_K2_SPRING', 'K2_SPRING'), ('_K2', 'K2'), ('_SPRING', 'SPRING'), ('_K4_SPRING', 'K4_SPRING'), ('_K4', 'K4'), ('_MAX_DISTANCE', 'MAX_DISTANCE'), ('_SHELL_CUTOFF', 'SHELL_CUTOFF')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class ring_puckering1(printable):
    """Section to define general ring puckering collective variables."""
    def __init__(self):
        self._ATOMS = None    # Specifies the indexes of atoms/points defining the ring.At least 4 Atoms are needed.
        self._POINTS = self._ATOMS
        self._COORDINATE = None    # Indicate the coordinate to be used. Follow the Cremer-Pople definition for a N ring.0 is the total puckering variable Q,2..[N/2] are puckering coordinates.-2..-[N/2-1] are puckering angles.
        self.listPOINT = []
        self.POINT = point1()
        self.name = "RING_PUCKERING"
        self.keywords = [('_ATOMS', 'ATOMS'), ('_POINTS', 'POINTS'), ('_COORDINATE', 'COORDINATE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('POINT', 'point1')]

    def addPOINT(self):
        new_section = point1()
        self.listPOINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class virtual_site1(printable):
    """This section is used to set a virtual interaction-site constraint."""
    def __init__(self):
        self._MOLECULE = None    # Specifies the molecule number on which constraint will be applied. MOLECULE and MOLNAME keyword exclude themself mutually.
        self._MOL = self._MOLECULE
        self._MOLNAME = None    # Specifies the name of the molecule on which the constraint will be applied.
        self._SEGNAME = self._MOLNAME
        self._INTERMOLECULAR = None    # Specify if the constraint/restraint is intermolecular.
        self._ATOMS = None    # Atoms' index on which apply the constraint (v i j k), first is virtual site
        self._PARAMETERS = None    # The constrained paramters' values to construct virtual site.r_v=a*r_ij+b*r_kj
        self._EXCLUDE_QM = None    # Does not apply the constraint to the QM region within a QM/MM calculation
        self._EXCLUDE_MM = None    # Does not apply the constraint to the MM region within a QM/MM calculation
        self.RESTRAINT = restraint1()
        self.name = "VIRTUAL_SITE"
        self.keywords = [('_MOLECULE', 'MOLECULE'), ('_MOL', 'MOL'), ('_MOLNAME', 'MOLNAME'), ('_SEGNAME', 'SEGNAME'), ('_INTERMOLECULAR', 'INTERMOLECULAR'), ('_ATOMS', 'ATOMS'), ('_PARAMETERS', 'PARAMETERS'), ('_EXCLUDE_QM', 'EXCLUDE_QM'), ('_EXCLUDE_MM', 'EXCLUDE_MM')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('RESTRAINT', 'RESTRAINT')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class wfc_gpw1(printable):
    """Parameters for the GPW approach in Wavefunction-based Correlation methods"""
    def __init__(self):
        self._EPS_GRID = None    # Determines a threshold for the GPW based integration
        self._EPS_FILTER = None    # Determines a threshold for the DBCSR based multiply (usually 10 times smaller than EPS_GRID).
        self._CUTOFF = None    # The cutoff of the finest grid level in the MP2 gpw integration.
        self._REL_CUTOFF = None    # Determines the grid at which a Gaussian is mapped.
        self._RELATIVE_CUTOFF = self._REL_CUTOFF
        self._PRINT_LEVEL = None    # How much output is written by the individual groups.
        self._IOLEVEL = self._PRINT_LEVEL
        self.name = "WFC_GPW"
        self.keywords = [('_EPS_GRID', 'EPS_GRID'), ('_EPS_FILTER', 'EPS_FILTER'), ('_CUTOFF', 'CUTOFF'), ('_REL_CUTOFF', 'REL_CUTOFF'), ('_RELATIVE_CUTOFF', 'RELATIVE_CUTOFF'), ('_PRINT_LEVEL', 'PRINT_LEVEL'), ('_IOLEVEL', 'IOLEVEL')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class total_numbers1(printable):
    """Controls the printing of the total number of atoms, kinds,..."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "TOTAL_NUMBERS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class constant_env1(printable):
    """parameters for a constant envelop"""
    def __init__(self):
        self._START_STEP = None    # First step the field is applied
        self._END_STEP = None    # Last step the field is applied
        self.name = "CONSTANT_ENV"
        self.keywords = [('_START_STEP', 'START_STEP'), ('_END_STEP', 'END_STEP')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class plus_u1(printable):
    """Controls the printing for the DFT+U methods"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PLUS_U"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class colvar1(printable):
    """Controls the printing of COLVAR summary information during metadynamics. When an extended Lagrangian use used, the files contain (in order): colvar value of the extended Lagrangian,  instantaneous colvar value, force due to the harmonic term of the extended  Lagrangian and the force due to the previously spawned hills, the force due to the walls, the velocities in the extended  Lagrangian, the potential of the harmonic term of the Lagrangian, the potential energy of the hills, the potential energy of the walls and the temperature of the extended Lagrangian. When the extended Lagrangian is not used, all related fields are omitted."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "COLVAR"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class gv091(printable):
    """Combination of three different exchange hole models"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._SCALE_X = None    # scales the exchange part of the functional
        self._CUTOFF_RADIUS = None    # Defines cutoff for lower integration boundary
        self._GAMMA = None    # Parameter for Becke Roussel hole
        self.name = "GV09"
        self.keywords = [('_SCALE_X', 'SCALE_X'), ('_CUTOFF_RADIUS', 'CUTOFF_RADIUS'), ('_GAMMA', 'GAMMA')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class colvar3(printable):
    """This section specifies the nature of the collective variables."""
    def __init__(self):
        self.DISTANCE = distance1()
        self.ANGLE = angle2()
        self.TORSION = torsion3()
        self.COORDINATION = coordination1()
        self.POPULATION = population1()
        self.GYRATION_RADIUS = gyration_radius1()
        self.DISTANCE_POINT_PLANE = distance_point_plane1()
        self.ANGLE_PLANE_PLANE = angle_plane_plane1()
        self.BOND_ROTATION = bond_rotation1()
        self.DISTANCE_FUNCTION = distance_function1()
        self.QPARM = qparm1()
        self.HYDRONIUM = hydronium1()
        self.RMSD = rmsd1()
        self.XYZ_DIAG = xyz_diag1()
        self.XYZ_OUTERDIAG = xyz_outerdiag1()
        self.U = u1()
        self.WC = wc1()
        self.HBP = hbp1()
        self.RING_PUCKERING = ring_puckering1()
        self.CONDITIONED_DISTANCE = conditioned_distance1()
        self.REACTION_PATH = reaction_path1()
        self.DISTANCE_FROM_PATH = distance_from_path1()
        self.COMBINE_COLVAR = combine_colvar1()
        self.listPRINT = []
        self.PRINT = print33()
        self.COLVAR_FUNC_INFO = colvar_func_info1()
        self.name = "COLVAR"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('DISTANCE', 'DISTANCE'), ('ANGLE', 'ANGLE'), ('TORSION', 'TORSION'), ('COORDINATION', 'COORDINATION'), ('POPULATION', 'POPULATION'), ('GYRATION_RADIUS', 'GYRATION_RADIUS'), ('DISTANCE_POINT_PLANE', 'DISTANCE_POINT_PLANE'), ('ANGLE_PLANE_PLANE', 'ANGLE_PLANE_PLANE'), ('BOND_ROTATION', 'BOND_ROTATION'), ('DISTANCE_FUNCTION', 'DISTANCE_FUNCTION'), ('QPARM', 'QPARM'), ('HYDRONIUM', 'HYDRONIUM'), ('RMSD', 'RMSD'), ('XYZ_DIAG', 'XYZ_DIAG'), ('XYZ_OUTERDIAG', 'XYZ_OUTERDIAG'), ('U', 'U'), ('WC', 'WC'), ('HBP', 'HBP'), ('RING_PUCKERING', 'RING_PUCKERING'), ('CONDITIONED_DISTANCE', 'CONDITIONED_DISTANCE'), ('REACTION_PATH', 'REACTION_PATH'), ('DISTANCE_FROM_PATH', 'DISTANCE_FROM_PATH'), ('COMBINE_COLVAR', 'COMBINE_COLVAR'), ('COLVAR_FUNC_INFO', 'COLVAR_FUNC_INFO')]
        self.repeated_subsections = [('PRINT', 'print33')]

    def addPRINT(self):
        new_section = print33()
        self.listPRINT.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class shell_velocities1(printable):
    """Controls the output of the velocities of shells when the shell model is used"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._UNIT = None    # Specify the unit of measurement for the quantity in output. All available CP2K units can be used.
        self._FORMAT = None    # Specifies the format of the output file for the velocities of shells.
        self.EACH = each1()
        self.name = "SHELL_VELOCITIES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_UNIT', 'UNIT'), ('_FORMAT', 'FORMAT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class ub1(printable):
    """Specifies the Urey-Bradley potential between the external atoms defining the angle"""
    def __init__(self):
        self._KIND = None    # Define the kind of Urey-Bradleypotential.
        self._K = None    # Defines the force constant of the potential. For QUARTIC potentials three numbers are expected.
        self._CS = None    # Defines the cubic stretch term.
        self._R0 = None    # Defines the equilibrium distance.
        self.name = "UB"
        self.keywords = [('_KIND', 'KIND'), ('_K', 'K'), ('_CS', 'CS'), ('_R0', 'R0')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class kind1(printable):
    """The description of the kind of the atoms (mostly for QM)"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._AUX_BASIS_SET = None    # The auxliliary basis set (GTO type)
        self._AUXILIARY_BASIS_SET = self._AUX_BASIS_SET
        self._AUX_BASIS = self._AUX_BASIS_SET
        self._RI_AUX_BASIS_SET = None    # The RI auxliliary basis set used in WF_CORRELATION (GTO type)
        self._RI_MP2_BASIS_SET = self._RI_AUX_BASIS_SET
        self._RI_RPA_BASIS_SET = self._RI_AUX_BASIS_SET
        self._RI_AUX_BASIS = self._RI_AUX_BASIS_SET
        self._AUX_BASIS_NORMALIZATION = None    # The normalization of the auxliliary basis set
        self._AUXILIARY_BASIS_NORMALIZATION = self._AUX_BASIS_NORMALIZATION
        self._AUX_BASIS_NORM = self._AUX_BASIS_NORMALIZATION
        self._LRI_BASIS_SET = None    # The local resolution of identity basis set (GTO type)
        self._LRI_BASIS = self._LRI_BASIS_SET
        self._AUX_FIT_BASIS_SET = None    # The auxliliary basis set (GTO type) for auxiliary density matrix method
        self._AUXILIARY_FIT_BASIS_SET = self._AUX_FIT_BASIS_SET
        self._AUX_FIT_BASIS = self._AUX_FIT_BASIS_SET
        self._AUX_BASIS_FIT_NORMALIZATION = None    # The normalization of the basis set for auxiliary density matrix method
        self._AUXILIARY_BASIS_FIT_NORMALIZATION = self._AUX_BASIS_FIT_NORMALIZATION
        self._AUX_BASIS_FIT_NORM = self._AUX_BASIS_FIT_NORMALIZATION
        self._BASIS_SET = None    # The primary Gaussian basis set (NONE implies no basis used, meaningful with GHOST)
        self._ORBITAL_BASIS_SET = self._BASIS_SET
        self._ORB_BASIS = self._BASIS_SET
        self._GEMINAL_BASIS_SET = None    # The Geminal Gaussian basis set to be used in HF exchange fitting
        self._ELEC_CONF = None    # Specifies the electronic configration used in construction the atomic initial guess (see the pseudo potential file for the default values.
        self._BASIS_NORMALIZATION = None    # The normalization of the auxliliary basis set
        self._ORBITAL_BASIS_NORMALIZATION = self._BASIS_NORMALIZATION
        self._ORB_BASIS_NORM = self._BASIS_NORMALIZATION
        self._CORE_CORRECTION = None    # Corrects the effective nuclear charge
        self._ELEMENT = None    # The element of the actual kind (if not given it is inferred from the kind name)
        self._ELEMENT_SYMBOL = self._ELEMENT
        self._MASS = None    # The mass of the atom (if negative or non present it is inferred from the element symbol)
        self._ATOMIC_MASS = self._MASS
        self._ATOMIC_WEIGHT = self._MASS
        self._WEIGHT = self._MASS
        self._POTENTIAL = None    # The name of the pseudopotential for the defined kind.
        self._POT = self._POTENTIAL
        self._HARD_EXP_RADIUS = None    # The region where the hard density is supposed to be confined(GAPW)(in Bohr, default is 1.2 for H and 1.512 otherwise)
        self._MAX_RAD_LOCAL = None    # Max radius for the basis functions used to generate the local projectors in GAPW [Bohr]
        self._RHO0_EXP_RADIUS = None    # the radius which defines the atomic region where the hard compensation density is confined.should be less than HARD_EXP_RADIUS (GAPW)(Bohr, default equals HARD_EXP_RADIUS)
        self._LEBEDEV_GRID = None    # The number of points for the angular part of the local grid (GAPW)
        self._RADIAL_GRID = None    # The number of points for the radial part of the local grid (GAPW)
        self._ALPHA_SCP = None    # The polarizability for scalar-isotropic polarization using SCP with FIST as the driver
        self._I_SCP = None    # The dispersion parameter for scalar-isotropic polarization using SCP with FIST as the driver
        self._MM_RADIUS = None    # Defines the radius of the electrostatic multipole of the atom in Fist. This radius applies to the charge, the dipole and the quadrupole. When zero, the atom is treated as a point multipole, otherwise it is treated as a Gaussian charge distribution with the given radius: p(x,y,z)*N*exp(-(x**2+y**2+z**2)/(2*MM_RADIUS**2)), where N is a normalization constant. In the core-shell model, only the shell is treated as a Gaussian and the core is always a point charge.
        self._SE_P_ORBITALS_ON_H = None    # Forces the usage of p-orbitals on H for SEMI-EMPIRICAL calculations.  This keyword applies only when the KIND is specifying an Hydrogen element. In all  other cases is simply ignored.
        self._GPW_TYPE = None    # Force one type to be treated by the GPW scheme, whatever are its primitives, even if the GAPW method is used
        self._GHOST = None    # This keyword makes all atoms of this kind ghost atoms, i.e. without pseudo or nuclear charge.Useful to just have the basis set at that position (BSSE calculations),or to have a non-interacting particle with BASIS_SET NONE
        self._NO_OPTIMIZE = None    # Skip optimization of this type (used in specific basis set or potential optimization schemes
        self.BASIS = basis1()
        self.GEMINAL = geminal1()
        self.POTENTIAL = potential2()
        self.DFT_PLUS_U = dft_plus_u1()
        self.BS = bs1()
        self.name = "KIND"
        self.keywords = [('_AUX_BASIS_SET', 'AUX_BASIS_SET'), ('_AUXILIARY_BASIS_SET', 'AUXILIARY_BASIS_SET'), ('_AUX_BASIS', 'AUX_BASIS'), ('_RI_AUX_BASIS_SET', 'RI_AUX_BASIS_SET'), ('_RI_MP2_BASIS_SET', 'RI_MP2_BASIS_SET'), ('_RI_RPA_BASIS_SET', 'RI_RPA_BASIS_SET'), ('_RI_AUX_BASIS', 'RI_AUX_BASIS'), ('_AUX_BASIS_NORMALIZATION', 'AUX_BASIS_NORMALIZATION'), ('_AUXILIARY_BASIS_NORMALIZATION', 'AUXILIARY_BASIS_NORMALIZATION'), ('_AUX_BASIS_NORM', 'AUX_BASIS_NORM'), ('_LRI_BASIS_SET', 'LRI_BASIS_SET'), ('_LRI_BASIS', 'LRI_BASIS'), ('_AUX_FIT_BASIS_SET', 'AUX_FIT_BASIS_SET'), ('_AUXILIARY_FIT_BASIS_SET', 'AUXILIARY_FIT_BASIS_SET'), ('_AUX_FIT_BASIS', 'AUX_FIT_BASIS'), ('_AUX_BASIS_FIT_NORMALIZATION', 'AUX_BASIS_FIT_NORMALIZATION'), ('_AUXILIARY_BASIS_FIT_NORMALIZATION', 'AUXILIARY_BASIS_FIT_NORMALIZATION'), ('_AUX_BASIS_FIT_NORM', 'AUX_BASIS_FIT_NORM'), ('_BASIS_SET', 'BASIS_SET'), ('_ORBITAL_BASIS_SET', 'ORBITAL_BASIS_SET'), ('_ORB_BASIS', 'ORB_BASIS'), ('_GEMINAL_BASIS_SET', 'GEMINAL_BASIS_SET'), ('_ELEC_CONF', 'ELEC_CONF'), ('_BASIS_NORMALIZATION', 'BASIS_NORMALIZATION'), ('_ORBITAL_BASIS_NORMALIZATION', 'ORBITAL_BASIS_NORMALIZATION'), ('_ORB_BASIS_NORM', 'ORB_BASIS_NORM'), ('_CORE_CORRECTION', 'CORE_CORRECTION'), ('_ELEMENT', 'ELEMENT'), ('_ELEMENT_SYMBOL', 'ELEMENT_SYMBOL'), ('_MASS', 'MASS'), ('_ATOMIC_MASS', 'ATOMIC_MASS'), ('_ATOMIC_WEIGHT', 'ATOMIC_WEIGHT'), ('_WEIGHT', 'WEIGHT'), ('_POTENTIAL', 'POTENTIAL'), ('_POT', 'POT'), ('_HARD_EXP_RADIUS', 'HARD_EXP_RADIUS'), ('_MAX_RAD_LOCAL', 'MAX_RAD_LOCAL'), ('_RHO0_EXP_RADIUS', 'RHO0_EXP_RADIUS'), ('_LEBEDEV_GRID', 'LEBEDEV_GRID'), ('_RADIAL_GRID', 'RADIAL_GRID'), ('_ALPHA_SCP', 'ALPHA_SCP'), ('_I_SCP', 'I_SCP'), ('_MM_RADIUS', 'MM_RADIUS'), ('_SE_P_ORBITALS_ON_H', 'SE_P_ORBITALS_ON_H'), ('_GPW_TYPE', 'GPW_TYPE'), ('_GHOST', 'GHOST'), ('_NO_OPTIMIZE', 'NO_OPTIMIZE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('BASIS', 'BASIS'), ('GEMINAL', 'GEMINAL'), ('POTENTIAL', 'POTENTIAL'), ('DFT_PLUS_U', 'DFT_PLUS_U'), ('BS', 'BS')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class generate1(printable):
    """Setup of keywords controlling the generation of the connectivity"""
    def __init__(self):
        self._REORDER = None    # Reorder a list of atomic coordinates into order so it can be packed correctly.
        self._CREATE_MOLECULES = None    # Create molecules names and definition. Can be used to override the  molecules specifications of a possible input connectivity or to create molecules specifications for file types as XYZ, missing of molecules definitions.
        self._BONDPARM = None    # Used in conjunction with BONDPARM_FACTOR to help determine wheather there is bonding between two atoms based on a distance criteria. Can use covalent radii information or VDW radii information
        self._BONDPARM_FACTOR = None    # Used in conjunction with BONDPARM to help determine wheather there is bonding between two atoms based on a distance criteria.
        self._BONDLENGTH_MAX = None    # Maximum distance to generate neighbor lists to build connectivity
        self._BONDLENGTH_MIN = None    # Minimum distance to generate neighbor lists to build connectivity
        self.listBOND = []
        self.BOND = bond2()
        self.listANGLE = []
        self.ANGLE = angle1()
        self.listTORSION = []
        self.TORSION = torsion2()
        self.listIMPROPER = []
        self.IMPROPER = improper2()
        self.ISOLATED_ATOMS = isolated_atoms1()
        self.NEIGHBOR_LISTS = neighbor_lists2()
        self.PRINT = print32()
        self.name = "GENERATE"
        self.keywords = [('_REORDER', 'REORDER'), ('_CREATE_MOLECULES', 'CREATE_MOLECULES'), ('_BONDPARM', 'BONDPARM'), ('_BONDPARM_FACTOR', 'BONDPARM_FACTOR'), ('_BONDLENGTH_MAX', 'BONDLENGTH_MAX'), ('_BONDLENGTH_MIN', 'BONDLENGTH_MIN')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('ISOLATED_ATOMS', 'ISOLATED_ATOMS'), ('NEIGHBOR_LISTS', 'NEIGHBOR_LISTS'), ('PRINT', 'PRINT')]
        self.repeated_subsections = [('BOND', 'bond2'), ('ANGLE', 'angle1'), ('TORSION', 'torsion2'), ('IMPROPER', 'improper2')]

    def addBOND(self):
        new_section = bond2()
        self.listBOND.append(new_section)
        return new_section

    def addANGLE(self):
        new_section = angle1()
        self.listANGLE.append(new_section)
        return new_section

    def addTORSION(self):
        new_section = torsion2()
        self.listTORSION.append(new_section)
        return new_section

    def addIMPROPER(self):
        new_section = improper2()
        self.listIMPROPER.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class periodic1(printable):
    """Sets up periodic boundary condition parameters if requested"""
    def __init__(self):
        self._NUMBER_OF_SHELLS = None    # Number of shells taken into account for periodicity. By default, cp2k tries to automatically evaluate this number. This algorithm might be to conservative, resulting in some overhead. You can try to adjust this number in order to make a calculation cheaper.
        self.name = "PERIODIC"
        self.keywords = [('_NUMBER_OF_SHELLS', 'NUMBER_OF_SHELLS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class periodic2(printable):
    """Specify parameters for QM/MM periodic boundary conditions calculations"""
    def __init__(self):
        self._GMAX = None    # Specifies the maximum value of G in the reciprocal space over which perform the Ewald sum.
        self._REPLICA = None    # Specifies the number of replica to take into consideration for the real part of the calculation. Default is letting the qmmm module decide how many replica you really need.
        self._NGRIDS = None    # Specifies the number of grid points used for the Interpolation of the G-space term
        self.MULTIPOLE = multipole1()
        self.INTERPOLATOR = interpolator2()
        self.CHECK_SPLINE = check_spline1()
        self.name = "PERIODIC"
        self.keywords = [('_GMAX', 'GMAX'), ('_REPLICA', 'REPLICA'), ('_NGRIDS', 'NGRIDS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('MULTIPOLE', 'MULTIPOLE'), ('INTERPOLATOR', 'INTERPOLATOR'), ('CHECK_SPLINE', 'CHECK_SPLINE')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class core_velocities1(printable):
    """controls the output of the velocities of cores when the shell model is used"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._UNIT = None    # Specify the unit of measurement for the quantity in output. All available CP2K units can be used.
        self._FORMAT = None    # Specifies the format of the output file for the velocities of cores.
        self.EACH = each1()
        self.name = "CORE_VELOCITIES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_UNIT', 'UNIT'), ('_FORMAT', 'FORMAT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class g3x31(printable):
    """This section is used to set 3x3 (3 atoms and 3 distances) constraints."""
    def __init__(self):
        self._MOLECULE = None    # Specifies the molecule kind number on which constraint will be applied. MOLECULE and MOLNAME keyword exclude themself mutually.
        self._MOL = self._MOLECULE
        self._MOLNAME = None    # Specifies the name of the molecule on which the constraint will be applied.
        self._SEGNAME = self._MOLNAME
        self._INTERMOLECULAR = None    # Specify if the constraint/restraint is intermolecular.
        self._ATOMS = None    # Atoms' index on which apply the constraint
        self._DISTANCES = None    # The constrained distances' values.
        self._EXCLUDE_QM = None    # Does not apply the constraint to the QM region within a QM/MM calculation
        self._EXCLUDE_MM = None    # Does not apply the constraint to the MM region within a QM/MM calculation
        self.RESTRAINT = restraint1()
        self.name = "G3X3"
        self.keywords = [('_MOLECULE', 'MOLECULE'), ('_MOL', 'MOL'), ('_MOLNAME', 'MOLNAME'), ('_SEGNAME', 'SEGNAME'), ('_INTERMOLECULAR', 'INTERMOLECULAR'), ('_ATOMS', 'ATOMS'), ('_DISTANCES', 'DISTANCES'), ('_EXCLUDE_QM', 'EXCLUDE_QM'), ('_EXCLUDE_MM', 'EXCLUDE_MM')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('RESTRAINT', 'RESTRAINT')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class mulliken_restraint1(printable):
    """Use mulliken charges in a restraint (check code for details)"""
    def __init__(self):
        self._STRENGTH = None    # force constant of the restraint
        self._TARGET = None    # target value of the restraint
        self._ATOMS = None    # Specifies the list of atoms that is summed in the restraint
        self.name = "MULLIKEN_RESTRAINT"
        self.keywords = [('_STRENGTH', 'STRENGTH'), ('_TARGET', 'TARGET'), ('_ATOMS', 'ATOMS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class hydronium1(printable):
    """Section to define the formation of a hydronium as a collective variable."""
    def __init__(self):
        self.list_OXYGENS = []
        self._OXYGENS = None
    # Specify indexes of atoms building the coordination variable.
        self.list_HYDROGENS = []
        self._HYDROGENS = None
    # Specify indexes of atoms building the coordination variable.
        self._ROO = None    # Specify the ROO parameter in the coordination function.
        self._R_OO = self._ROO
        self._PNO = None    # Sets the value of the numerator of the exponential factorin the coordination FUNCTION.
        self._EXPON_NUMERATORA = self._PNO
        self._QNO = None    # Sets the value of the denominator of the exponential factorin the coordination FUNCTION.
        self._EXPON_DENOMINATORA = self._QNO
        self._ROH = None    # Specify the ROH parameter in the coordination function.
        self._R_OH = self._ROH
        self._PNH = None    # Sets the value of the numerator of the exponential factorin the coordination FUNCTION.
        self._EXPON_NUMERATORB = self._PNH
        self._QNH = None    # Sets the value of the denominator of the exponential factorin the coordination FUNCTION.
        self._EXPON_DENOMINATORB = self._QNH
        self._NH = None    # Specify the NH parameter in the hydronium function.
        self._NHTEST = self._NH
        self._P = None    # Sets the value of the numerator of the exponential factorin the coordination FUNCTION.
        self._EXPON_NUMERATOR = self._P
        self._Q = None    # Sets the value of the denominator of the exponential factorin the coordination FUNCTION.
        self._EXPON_DENOMINATOR = self._Q
        self._LAMBDA = None    # Specify the LAMBDA parameter in the hydronium function.
        self._LAMBDA = None    # Specify the LAMBDA parameter in the hydronium function.
        self.listPOINT = []
        self.POINT = point1()
        self.name = "HYDRONIUM"
        self.keywords = [('_ROO', 'ROO'), ('_R_OO', 'R_OO'), ('_PNO', 'PNO'), ('_EXPON_NUMERATORA', 'EXPON_NUMERATORA'), ('_QNO', 'QNO'), ('_EXPON_DENOMINATORA', 'EXPON_DENOMINATORA'), ('_ROH', 'ROH'), ('_R_OH', 'R_OH'), ('_PNH', 'PNH'), ('_EXPON_NUMERATORB', 'EXPON_NUMERATORB'), ('_QNH', 'QNH'), ('_EXPON_DENOMINATORB', 'EXPON_DENOMINATORB'), ('_NH', 'NH'), ('_NHTEST', 'NHTEST'), ('_P', 'P'), ('_EXPON_NUMERATOR', 'EXPON_NUMERATOR'), ('_Q', 'Q'), ('_EXPON_DENOMINATOR', 'EXPON_DENOMINATOR'), ('_LAMBDA', 'LAMBDA'), ('_LAMBDA', 'LAMBDA')]
        self.repeated_keywords = [('_OXYGENS', 'OXYGENS'), ('_HYDROGENS', 'HYDROGENS')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('POINT', 'point1')]

    def addPOINT(self):
        new_section = point1()
        self.listPOINT.append(new_section)
        return new_section

    def add_OXYGENS(self, value):
        self.list_OXYGENS.append(value)

    def add_HYDROGENS(self, value):
        self.list_HYDROGENS.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class block_density_matrix_method1(printable):
    """Parameters needed to set wavefunction fitting"""
    def __init__(self):
        self._BASIS_PROJECTION = None    # Defines usage of auxiliary basis set
        self._PURIFICATION = None    # Method that shall be used for Purification
        self.listBLOCK = []
        self.BLOCK = block1()
        self.name = "BLOCK_DENSITY_MATRIX_METHOD"
        self.keywords = [('_BASIS_PROJECTION', 'BASIS_PROJECTION'), ('_PURIFICATION', 'PURIFICATION')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('BLOCK', 'block1')]

    def addBLOCK(self):
        new_section = block1()
        self.listBLOCK.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class displaced_atom1(printable):
    """Controls the output of index and dislacement of atoms that moved away from the initial position of more than agiven distance (see msd%disp_tol)"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "DISPLACED_ATOM"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class print4(printable):
    """Controls the printing properties during a geometry optimization run"""
    def __init__(self):
        self.PROGRAM_RUN_INFO = program_run_info4()
        self.CELL = cell1()
        self.name = "PRINT"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PROGRAM_RUN_INFO', 'PROGRAM_RUN_INFO'), ('CELL', 'CELL')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class qmmm_charges1(printable):
    """Print all charges generating the QM/MM potential"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "QMMM_CHARGES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class buckmorse1(printable):
    """This section specifies the input parameters for Buckingham plus Morse potential type  Functional Form: V(r) = F0*(B1+B2)*EXP([A1+A2-r]/[B1+B2])-C/r^6+D*{EXP[-2*beta*(r-R0)]-2*EXP[-beta*(r-R0)]}."""
    def __init__(self):
        self._ATOMS = None    # Defines the atomic kind involved in the nonbond potential
        self._F0 = None    # Defines the f0 parameter of Buckingham+Morse potential
        self._A1 = None    # Defines the A1 parameter of Buckingham+Morse potential
        self._A2 = None    # Defines the A2 parameter of Buckingham+Morse potential
        self._B1 = None    # Defines the B1 parameter of Buckingham+Morse potential
        self._B2 = None    # Defines the B2 parameter of Buckingham+Morse potential
        self._C = None    # Defines the C parameter of Buckingham+Morse  potential
        self._D = None    # Defines the amplitude for the Morse part
        self._R0 = None    # Defines the equilibrium distance for the Morse part
        self._BETA = None    # Defines the width for the Morse part
        self._RCUT = None    # Defines the cutoff parameter of the Buckingham potential
        self._RMIN = None    # Defines the lower bound of the potential. If not set the range is the full range generate by the spline
        self._RMAX = None    # Defines the upper bound of the potential. If not set the range is the full range generate by the spline
        self.name = "BUCKMORSE"
        self.keywords = [('_ATOMS', 'ATOMS'), ('_F0', 'F0'), ('_A1', 'A1'), ('_A2', 'A2'), ('_B1', 'B1'), ('_B2', 'B2'), ('_C', 'C'), ('_D', 'D'), ('_R0', 'R0'), ('_BETA', 'BETA'), ('_RCUT', 'RCUT'), ('_RMIN', 'RMIN'), ('_RMAX', 'RMAX')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class umbrella_integration1(printable):
    """Controls the calculation of free energy derivatives with the umbrella integration method."""
    def __init__(self):
        self.listCONVERGENCE_CONTROL = []
        self.CONVERGENCE_CONTROL = convergence_control1()
        self.listUVAR = []
        self.UVAR = uvar1()
        self.name = "UMBRELLA_INTEGRATION"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = [('CONVERGENCE_CONTROL', 'convergence_control1'), ('UVAR', 'uvar1')]

    def addCONVERGENCE_CONTROL(self):
        new_section = convergence_control1()
        self.listCONVERGENCE_CONTROL.append(new_section)
        return new_section

    def addUVAR(self):
        new_section = uvar1()
        self.listUVAR.append(new_section)
        return new_section

    def print_input(self, level):
        return printable.print_input(self, level)


class bmhftd1(printable):
    """This section specifies the input parameters for BMHFTD potential type.Functional form: V(r) = A*exp(-B*r) - f_6*(r)C/r^6 - f_8(r)*D/r^8.where f_order(r)=1-exp(-BD * r) * \sum_{k=0}^order (BD * r)^k / k! .(Tang-Toennies damping function)No values available inside cp2k."""
    def __init__(self):
        self._ATOMS = None    # Defines the atomic kind involved in the BMHFTD nonbond potential
        self._MAP_ATOMS = None    # Defines the kinds for which internally is defined the BMHFTD nonbond potential at the moment no species included.
        self._RCUT = None    # Defines the cutoff parameter of the BMHFTD potential
        self._A = None    # Defines the A parameter of the dispersion-damped Fumi-Tosi Potential
        self._B = None    # Defines the B parameter of the dispersion-damped Fumi-Tosi Potential
        self._C = None    # Defines the C parameter of the dispersion-damped Fumi-Tosi Potential
        self._D = None    # Defines the D parameter of the dispersion-damped Fumi-Tosi Potential
        self._BD = None    # Defines the BD parameter of the dispersion-damped Fumi-Tosi Potential
        self._ORDER = None    # Defines the order for this damping.
        self._RMIN = None    # Defines the lower bound of the potential. If not set the range is the full range generate by the spline
        self._RMAX = None    # Defines the upper bound of the potential. If not set the range is the full range generate by the spline
        self.name = "BMHFTD"
        self.keywords = [('_ATOMS', 'ATOMS'), ('_MAP_ATOMS', 'MAP_ATOMS'), ('_RCUT', 'RCUT'), ('_A', 'A'), ('_B', 'B'), ('_C', 'C'), ('_D', 'D'), ('_BD', 'BD'), ('_ORDER', 'ORDER'), ('_RMIN', 'RMIN'), ('_RMAX', 'RMAX')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class relativistic1(printable):
    """parameters needed and setup for relativistic calculations"""
    def __init__(self):
        self._METHOD = None    # type of relativistic correction used
        self._DKH_ORDER = None    # The order of the DKH transformation
        self._TRANSFORMATION = None    # type of DKH transformation, full: use full matrix transformation, molecule: use transformation blocked by molecule, atom: use atomic blocks
        self._Z_CUTOFF = None    # The minimal atomic number considered for atom transformation
        self._POTENTIAL = None    # External potential used in DKH transformation, full 1/r or erfc(r)/r
        self.name = "RELATIVISTIC"
        self.keywords = [('_METHOD', 'METHOD'), ('_DKH_ORDER', 'DKH_ORDER'), ('_TRANSFORMATION', 'TRANSFORMATION'), ('_Z_CUTOFF', 'Z_CUTOFF'), ('_POTENTIAL', 'POTENTIAL')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class ep1(printable):
    """parameter needed by an ep calculation"""
    def __init__(self):
        self._EPS_LIN_SOLV = None    # Requested convergence of the linear solver (for psi1)
        self._ROTATE = None    # If rotations from a unique set of coefficients should be used or if single molecule optimizations generate it
        self._START_COEFFS = None    # Starting coefficients for roatation based ep
        self._E0_ONLY = None    # If only e0 should be calculated
        self._COMP_INPUT = None    # Path to the input to be used for the component of the main system
        self._AT_PER_MOL = None    # Number of atoms in each molecule (at the moment only uniform system cam be handled)
        self.PRINT = print29()
        self.name = "EP"
        self.keywords = [('_EPS_LIN_SOLV', 'EPS_LIN_SOLV'), ('_ROTATE', 'ROTATE'), ('_START_COEFFS', 'START_COEFFS'), ('_E0_ONLY', 'E0_ONLY'), ('_COMP_INPUT', 'COMP_INPUT'), ('_AT_PER_MOL', 'AT_PER_MOL')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('PRINT', 'PRINT')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class banner1(printable):
    """Controls the printing of the BAND banner"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "BANNER"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class banner2(printable):
    """Controls the printing of the vibrational analysis banner"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "BANNER"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class ext_restart1(printable):
    """Section for external restart, specifies an external input file where to take positions,..."""
    def __init__(self):
        self._RESTART_FILE_NAME = None    # Specifies the name of restart file (or any other input file) to be read. Only fields relevant to a restart will be used (unless switched off with the keywords in this section)
        self._EXTERNAL_FILE = self._RESTART_FILE_NAME
        self._BINARY_RESTART_FILE_NAME = None    # Specifies the name of an additional restart file from which selected input sections are read in binary format (see SPLIT_RESTART_FILE).
        self._BINARY_RESTART_FILE = self._BINARY_RESTART_FILE_NAME
        self._RESTART_DEFAULT = None    # This keyword controls the default value for all possible  restartable keywords, unless explicitly defined. For example setting this keyword to .FALSE. does not restart any quantity. If, at the  same time, one keyword is set to .TRUE. only that quantity will be restarted.
        self._RESTART_COUNTERS = None    # Restarts the counters in MD schemes
        self._RESTART_POS = None    # Takes the positions from the external file
        self._RESTART_VEL = None    # Takes the velocities from the external file
        self._RESTART_RANDOMG = None    # Restarts the random number generator from the external file
        self._RESTART_SHELL_POS = None    # Takes the positions of the shells from the external file (only if shell-model)
        self._RESTART_CORE_POS = None    # Takes the positions of the cores from the external file (only if shell-model)
        self._RESTART_OPTIMIZE_INPUT_VARIABLES = None    # Restart with the optimize input variables
        self._RESTART_SHELL_VELOCITY = None    # Takes the velocities of the shells from the external file (only if shell-model)
        self._RESTART_CORE_VELOCITY = None    # Takes the velocities of the shells from the external file (only if shell-model)
        self._RESTART_BAROSTAT = None    # Restarts the barostat from the external file
        self._RESTART_BAROSTAT_THERMOSTAT = None    # Restarts the barostat thermostat from the external file
        self._RESTART_SHELL_THERMOSTAT = None    # Restarts the shell thermostat from the external file
        self._RESTART_THERMOSTAT = None    # Restarts the nose thermostats of the particles from the EXTERNAL file
        self._RESTART_CELL = None    # Restarts the cell (and cell_ref) from the EXTERNAL file
        self._RESTART_METADYNAMICS = None    # Restarts hills from a previous metadynamics run from the EXTERNAL file
        self._RESTART_WALKERS = None    # Restarts walkers informations from a previous metadynamics run from the EXTERNAL file
        self._RESTART_BAND = None    # Restarts positions and velocities of the Band.
        self._RESTART_QMMM = None    # Restarts the following specific QMMM info: translation vectors.
        self._RESTART_CONSTRAINT = None    # Restarts constraint section. It's necessary when doing restraint calculation to have a perfect energy conservation. For constraints only it's use is optional.
        self._RESTART_BSSE = None    # Restarts information for BSSE calculations.
        self._RESTART_DIMER = None    # Restarts information for DIMER geometry optimizations.
        self._RESTART_AVERAGES = None    # Restarts information for AVERAGES.
        self._RESTART_RTP = None    # Restarts information for REAL TIME PROPAGATION and EHRENFEST DYNAMICS.
        self.list_CUSTOM_PATH = []
        self._CUSTOM_PATH = None
    # Restarts the given path from the EXTERNAL file. Allows a major flexibility for restarts.
        self._RESTART_PINT_POS = None    # Restart bead positions from PINT%BEADS%COORD.
        self._RESTART_PINT_VEL = None    # Restart bead velocities from PINT%BEADS%VELOCITY.
        self._RESTART_PINT_NOSE = None    # Restart Nose thermostat for beads from PINT%NOSE.
        self._RESTART_PINT_GLE = None    # Restart GLE thermostat for beads from PINT%GLE.
        self._RESTART_HELIUM_POS = None    # Restart helium positions from PINT%HELIUM%COORD.
        self._RESTART_HELIUM_PERMUTATION = None    # Restart helium permutation state from PINT%HELIUM%PERM.
        self._RESTART_HELIUM_FORCE = None    # Restart helium forces exerted on the solute from PINT%HELIUM%FORCE.
        self._RESTART_HELIUM_RNG = None    # Restarts helium random number generators from PINT%HELIUM%RNG_STATE.
        self._RESTART_HELIUM_DENSITIES = None    # Restarts helium density distributions from PINT%HELIUM%RHO.
        self.name = "EXT_RESTART"
        self.keywords = [('_RESTART_FILE_NAME', 'RESTART_FILE_NAME'), ('_EXTERNAL_FILE', 'EXTERNAL_FILE'), ('_BINARY_RESTART_FILE_NAME', 'BINARY_RESTART_FILE_NAME'), ('_BINARY_RESTART_FILE', 'BINARY_RESTART_FILE'), ('_RESTART_DEFAULT', 'RESTART_DEFAULT'), ('_RESTART_COUNTERS', 'RESTART_COUNTERS'), ('_RESTART_POS', 'RESTART_POS'), ('_RESTART_VEL', 'RESTART_VEL'), ('_RESTART_RANDOMG', 'RESTART_RANDOMG'), ('_RESTART_SHELL_POS', 'RESTART_SHELL_POS'), ('_RESTART_CORE_POS', 'RESTART_CORE_POS'), ('_RESTART_OPTIMIZE_INPUT_VARIABLES', 'RESTART_OPTIMIZE_INPUT_VARIABLES'), ('_RESTART_SHELL_VELOCITY', 'RESTART_SHELL_VELOCITY'), ('_RESTART_CORE_VELOCITY', 'RESTART_CORE_VELOCITY'), ('_RESTART_BAROSTAT', 'RESTART_BAROSTAT'), ('_RESTART_BAROSTAT_THERMOSTAT', 'RESTART_BAROSTAT_THERMOSTAT'), ('_RESTART_SHELL_THERMOSTAT', 'RESTART_SHELL_THERMOSTAT'), ('_RESTART_THERMOSTAT', 'RESTART_THERMOSTAT'), ('_RESTART_CELL', 'RESTART_CELL'), ('_RESTART_METADYNAMICS', 'RESTART_METADYNAMICS'), ('_RESTART_WALKERS', 'RESTART_WALKERS'), ('_RESTART_BAND', 'RESTART_BAND'), ('_RESTART_QMMM', 'RESTART_QMMM'), ('_RESTART_CONSTRAINT', 'RESTART_CONSTRAINT'), ('_RESTART_BSSE', 'RESTART_BSSE'), ('_RESTART_DIMER', 'RESTART_DIMER'), ('_RESTART_AVERAGES', 'RESTART_AVERAGES'), ('_RESTART_RTP', 'RESTART_RTP'), ('_RESTART_PINT_POS', 'RESTART_PINT_POS'), ('_RESTART_PINT_VEL', 'RESTART_PINT_VEL'), ('_RESTART_PINT_NOSE', 'RESTART_PINT_NOSE'), ('_RESTART_PINT_GLE', 'RESTART_PINT_GLE'), ('_RESTART_HELIUM_POS', 'RESTART_HELIUM_POS'), ('_RESTART_HELIUM_PERMUTATION', 'RESTART_HELIUM_PERMUTATION'), ('_RESTART_HELIUM_FORCE', 'RESTART_HELIUM_FORCE'), ('_RESTART_HELIUM_RNG', 'RESTART_HELIUM_RNG'), ('_RESTART_HELIUM_DENSITIES', 'RESTART_HELIUM_DENSITIES')]
        self.repeated_keywords = [('_CUSTOM_PATH', 'CUSTOM_PATH')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def add_CUSTOM_PATH(self, value):
        self.list_CUSTOM_PATH.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class core_coord1(printable):
    """The core coordinates for the shell-model potentials xyz format with an additional column for the index of the corresponding particle"""
    def __init__(self):
        self._UNIT = None    # Specify the unit of measurement for the coordinates in inputAll available CP2K units can be used.
        self._SCALED = None    # Specify if the coordinateds in input are scaled.
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # The core coordinates in xyz format.
        self.name = "CORE_COORD"
        self.keywords = [('_UNIT', 'UNIT'), ('_SCALED', 'SCALED')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class upf_file1(printable):
    """Write GTH pseudopotential in UPF format"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "UPF_FILE"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class machine_arch1(printable):
    """Configuration options for the machine architecture."""
    def __init__(self):
        self._PRINT_RESUME = None    # Print the compute node architecture number of components.
        self._PRINT_FULL = None    # Print full machine architecture
        self._PRINT_BRANCH = None    # Print machine architecture component organization.
        self._PRINT_THREAD = None    # Print the threads binding in the machine.
        self._PRINT_THREAD_CUR = None    # Print the current threads binding in the machine.
        self._PRINT_PROC = None    # Print the process binding in the machine.
        self._SCHED_THREAD = None    # Enable thread scheduling on the compute node.
        self._SCHED_MPI = None    # Enable process scheduling on the compute node.
        self._MEM_POL = None    # Enable memory binding on the compute node.
        self._PROCESS = None    # Core ID for each MPI process of a compute node. It will be used to place the MPI process.
        self._THREAD = None    # Core ID for each thread of a compute node. It will be used to place the thread.
        self._MEMORY = None    # The memory banks ID for each MPI process. It will beuse to set memory bank of the MPI process
        self._MPI_REORDERING = None    # Apply a global MPI reordering for the run
        self.name = "MACHINE_ARCH"
        self.keywords = [('_PRINT_RESUME', 'PRINT_RESUME'), ('_PRINT_FULL', 'PRINT_FULL'), ('_PRINT_BRANCH', 'PRINT_BRANCH'), ('_PRINT_THREAD', 'PRINT_THREAD'), ('_PRINT_THREAD_CUR', 'PRINT_THREAD_CUR'), ('_PRINT_PROC', 'PRINT_PROC'), ('_SCHED_THREAD', 'SCHED_THREAD'), ('_SCHED_MPI', 'SCHED_MPI'), ('_MEM_POL', 'MEM_POL'), ('_PROCESS', 'PROCESS'), ('_THREAD', 'THREAD'), ('_MEMORY', 'MEMORY'), ('_MPI_REORDERING', 'MPI_REORDERING')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class force2(printable):
    """Forces exerted by the helium on the solute system (used for restarts)"""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Number of real values should be 3 * <num_solute_atoms> * <num_solute_beads>
        self.name = "FORCE"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class restart_info1(printable):
    """This section provides information about old force-mixing indices and labels, for restarts."""
    def __init__(self):
        self.list_INDICES = []
        self._INDICES = None
    # Indices of atoms in previous step QM regions.
        self.list_LABELS = []
        self._LABELS = None
    # Labels of atoms in previous step QM regions.
        self.name = "RESTART_INFO"
        self.keywords = []
        self.repeated_keywords = [('_INDICES', 'INDICES'), ('_LABELS', 'LABELS')]
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def add_INDICES(self, value):
        self.list_INDICES.append(value)

    def add_LABELS(self, value):
        self.list_LABELS.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class fragment_energies1(printable):
    """This section contains the energies of the fragments already computed. It is useful as a summary and specifically for restarting BSSE runs."""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # The energy computed for each fragment
        self.name = "FRAGMENT_ENERGIES"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class variable1(printable):
    """Defines initial values for variables and their labels"""
    def __init__(self):
        self._VALUE = None    # Initial value of the variable
        self._FIXED = None    # Is this variable fixed or should it be optimized.
        self._LABEL = None    # The label used in the input file, i.e. ${LABEL} will be replaced by the VALUE specified.
        self.name = "VARIABLE"
        self.keywords = [('_VALUE', 'VALUE'), ('_FIXED', 'FIXED'), ('_LABEL', 'LABEL')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class move_mm_charge1(printable):
    """Specify information to move a classical charge before the QM/MM energies and forces evaluation"""
    def __init__(self):
        self._ATOM_INDEX_1 = None    # Specifies the index of the MM atom involved in the QM/MM link to be moved
        self._MM1 = self._ATOM_INDEX_1
        self._ATOM_INDEX_2 = None    # Specifies the index of the second atom defining the direction along which  the atom will be moved
        self._MM2 = self._ATOM_INDEX_2
        self._ALPHA = None    # Specifies the scaling factor that defines the movement along the defined direction
        self._RADIUS = None    # Specifies the radius used for the QM/MM electrostatic coupling after movement
        self._CORR_RADIUS = None    # Specifies the correction radius used for the QM/MM electrostatic coupling after movement
        self.name = "MOVE_MM_CHARGE"
        self.keywords = [('_ATOM_INDEX_1', 'ATOM_INDEX_1'), ('_MM1', 'MM1'), ('_ATOM_INDEX_2', 'ATOM_INDEX_2'), ('_MM2', 'MM2'), ('_ALPHA', 'ALPHA'), ('_RADIUS', 'RADIUS'), ('_CORR_RADIUS', 'CORR_RADIUS')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class restart_averages1(printable):
    """Stores information for restarting averages."""
    def __init__(self):
        self._ITIMES_START = None    # TIME STEP starting the evaluation of averages
        self._AVECPU = None    # CPU average
        self._AVEHUGONIOT = None    # HUGONIOT average
        self._AVETEMP_BARO = None    # BAROSTAT TEMPERATURE average
        self._AVEPOT = None    # POTENTIAL ENERGY average
        self._AVEKIN = None    # KINETIC ENERGY average
        self._AVETEMP = None    # TEMPERATURE average
        self._AVEKIN_QM = None    # QM KINETIC ENERGY average in QMMM runs
        self._AVETEMP_QM = None    # QM TEMPERATURE average in QMMM runs
        self._AVEVOL = None    # VOLUME average
        self._AVECELL_A = None    # CELL VECTOR A average
        self._AVECELL_B = None    # CELL VECTOR B average
        self._AVECELL_C = None    # CELL VECTOR C average
        self._AVEALPHA = None    # ALPHA cell angle average
        self._AVEBETA = None    # BETA cell angle average
        self._AVEGAMMA = None    # GAMMA cell angle average
        self._AVE_ECONS = None    # CONSTANT ENERGY average
        self._AVE_PRESS = None    # PRESSURE average
        self._AVE_PXX = None    # P_{XX} average
        self._AVE_PV_VIR = None    # PV VIRIAL average
        self._AVE_PV_TOT = None    # PV TOTAL average
        self._AVE_PV_KIN = None    # PV KINETIC average
        self._AVE_PV_CNSTR = None    # PV CONSTRAINTS average
        self._AVE_PV_XC = None    # PV XC average
        self._AVE_PV_FOCK_4C = None    # PV XC average
        self._AVE_COLVARS = None    # COLVARS averages
        self._AVE_MMATRIX = None    # METRIC TENSOR averages
        self.name = "RESTART_AVERAGES"
        self.keywords = [('_ITIMES_START', 'ITIMES_START'), ('_AVECPU', 'AVECPU'), ('_AVEHUGONIOT', 'AVEHUGONIOT'), ('_AVETEMP_BARO', 'AVETEMP_BARO'), ('_AVEPOT', 'AVEPOT'), ('_AVEKIN', 'AVEKIN'), ('_AVETEMP', 'AVETEMP'), ('_AVEKIN_QM', 'AVEKIN_QM'), ('_AVETEMP_QM', 'AVETEMP_QM'), ('_AVEVOL', 'AVEVOL'), ('_AVECELL_A', 'AVECELL_A'), ('_AVECELL_B', 'AVECELL_B'), ('_AVECELL_C', 'AVECELL_C'), ('_AVEALPHA', 'AVEALPHA'), ('_AVEBETA', 'AVEBETA'), ('_AVEGAMMA', 'AVEGAMMA'), ('_AVE_ECONS', 'AVE_ECONS'), ('_AVE_PRESS', 'AVE_PRESS'), ('_AVE_PXX', 'AVE_PXX'), ('_AVE_PV_VIR', 'AVE_PV_VIR'), ('_AVE_PV_TOT', 'AVE_PV_TOT'), ('_AVE_PV_KIN', 'AVE_PV_KIN'), ('_AVE_PV_CNSTR', 'AVE_PV_CNSTR'), ('_AVE_PV_XC', 'AVE_PV_XC'), ('_AVE_PV_FOCK_4C', 'AVE_PV_FOCK_4C'), ('_AVE_COLVARS', 'AVE_COLVARS'), ('_AVE_MMATRIX', 'AVE_MMATRIX')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class ext_lagrange_vvp1(printable):
    """Colvar velocities within an extended Lagrangian formalism.Used for RESTART."""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # Specified the velocities
        self.name = "EXT_LAGRANGE_VVP"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class distribution2(printable):
    """Controls the printing of the distribution of molecules, atoms, ..."""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "DISTRIBUTION"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class distribution1(printable):
    """can be used used to tune the parallel distribution of the data"""
    def __init__(self):
        self._COST_MODEL = None    # The cost model that needs to be minimized
        self._2D_MOLECULAR_DISTRIBUTION = None    # Distribute the atoms so that atoms belonging to a given molecule are on the same CPU for the 2D distribution. This might give rise to a worse distribution but reduces memory needs of finding the optimal distribution.
        self._SKIP_OPTIMIZATION = None    # Do not optimize the distribution, go for something very simple. Might be useful if the optimization, which scales quadratically in system size, is too expensive.
        self._BASIC_OPTIMIZATION = None    # Creates a distribution based on a few heuristics using only minimal memory and CPU time.
        self._BASIC_SPATIAL_OPTIMIZATION = None    # Creates a distribution with spatial info, using only minimal memory and CPU time.
        self._SYMMETRIC = None    # Take the symmetry of the distribution_2d into account.
        self._2D_MC = num2d_mc1()
        self.name = "DISTRIBUTION"
        self.keywords = [('_COST_MODEL', 'COST_MODEL'), ('_2D_MOLECULAR_DISTRIBUTION', '2D_MOLECULAR_DISTRIBUTION'), ('_SKIP_OPTIMIZATION', 'SKIP_OPTIMIZATION'), ('_BASIC_OPTIMIZATION', 'BASIC_OPTIMIZATION'), ('_BASIC_SPATIAL_OPTIMIZATION', 'BASIC_SPATIAL_OPTIMIZATION'), ('_SYMMETRIC', 'SYMMETRIC')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('_2D_MC', '2D_MC')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class msst1(printable):
    """Parameters for Multi-Scale Shock Technique (MSST) which simulate the effect of a steady planar shock on a unit cell. Reed et. al. Physical Review Letters 90, 235503 (2003)."""
    def __init__(self):
        self._PRESSURE = None    # Initial pressure
        self._ENERGY = None    # Initial energy
        self._VOLUME = None    # Initial volume
        self._CMASS = None    # Effective cell mass
        self._VSHOCK = None    # Velocity shock
        self._V_SHOCK = self._VSHOCK
        self._GAMMA = None    # Damping coefficient for cell volume
        self.name = "MSST"
        self.keywords = [('_PRESSURE', 'PRESSURE'), ('_ENERGY', 'ENERGY'), ('_VOLUME', 'VOLUME'), ('_CMASS', 'CMASS'), ('_VSHOCK', 'VSHOCK'), ('_V_SHOCK', 'V_SHOCK'), ('_GAMMA', 'GAMMA')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class electric_field_gradient1(printable):
    """Calculate and print the electric field gradientsat atomic positions"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._INTERPOLATION = None    # Use interpolation method from real space grid
        self._GSPACE_SMOOTHING = None    # Use a G-space smoothing function
        self._DEBUG = None    # Print additional debug output
        self.EACH = each1()
        self.INTERPOLATOR = interpolator2()
        self.name = "ELECTRIC_FIELD_GRADIENT"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_INTERPOLATION', 'INTERPOLATION'), ('_GSPACE_SMOOTHING', 'GSPACE_SMOOTHING'), ('_DEBUG', 'DEBUG')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH'), ('INTERPOLATOR', 'INTERPOLATOR')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class rescale_forces1(printable):
    """Section controlling the rescaling of forces. Useful when starting from quite bad geometries with unphysically large forces."""
    def __init__(self):
        self._MAX_FORCE = None    # Specify the Maximum Values of the force. If the force of one atom exceed this value it's rescaled to the MAX_FORCE value.
        self.name = "RESCALE_FORCES"
        self.keywords = [('_MAX_FORCE', 'MAX_FORCE')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class u1(printable):
    """Section to define the energy as a generalized collective variable."""
    def __init__(self):
        self.MIXED = mixed2()
        self.name = "U"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('MIXED', 'MIXED')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class orbitals1(printable):
    """Controls the printing of the optimized orbitals information"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "ORBITALS"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class interatomic_distances1(printable):
    """controls the output of the interatomic distances when setting up theforce environment"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._UNIT = None    # Specify the unit of measurement for the quantity in output. All available CP2K units can be used.
        self.EACH = each1()
        self.name = "INTERATOMIC_DISTANCES"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_UNIT', 'UNIT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class sic1(printable):
    """parameters for the self interaction correction"""
    def __init__(self):
        self._SIC_SCALING_A = None    # Scaling of the coulomb term in sic [experimental]
        self._SIC_SCALING_B = None    # Scaling of the xc term in sic [experimental]
        self._SIC_METHOD = None    # Method used to remove the self interaction
        self._ORBITAL_SET = None    # Type of orbitals treated with the SIC
        self.name = "SIC"
        self.keywords = [('_SIC_SCALING_A', 'SIC_SCALING_A'), ('_SIC_SCALING_B', 'SIC_SCALING_B'), ('_SIC_METHOD', 'SIC_METHOD'), ('_ORBITAL_SET', 'ORBITAL_SET')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class shell_coord1(printable):
    """The shell coordinates for the shell-model potentials xyz format with an additional column for the index of the corresponding particle"""
    def __init__(self):
        self._UNIT = None    # Specify the unit of measurement for the coordinates in inputAll available CP2K units can be used.
        self._SCALED = None    # Specify if the coordinateds in input are scaled.
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # The shell coordinates in xyz format.
        self.name = "SHELL_COORD"
        self.keywords = [('_UNIT', 'UNIT'), ('_SCALED', 'SCALED')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)


class smear1(printable):
    """Define the smearing of the MO occupation numbers"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._METHOD = None    # Smearing method to be applied
        self._LIST = None    # A list of fractional occupations to use. Must match the number of states and sum up to the correct number of electrons
        self._ELECTRONIC_TEMPERATURE = None    # Electronic temperature in the case of Fermi-Dirac smearing
        self._ELEC_TEMP = self._ELECTRONIC_TEMPERATURE
        self._TELEC = self._ELECTRONIC_TEMPERATURE
        self._EPS_FERMI_DIRAC = None    # Accuracy checks on occupation numbers use this as a tolerance
        self._WINDOW_SIZE = None    # Size of the energy window centred at the Fermi level
        self._FIXED_MAGNETIC_MOMENT = None    # Imposed difference between the numbers of electrons of spin up and spin down: m = n(up) - n(down). A negative value (default) allows for a change of the magnetic moment. -1 specifically keeps an integer number of spin up and spin down electrons.
        self.name = "SMEAR"
        self.keywords = [('_METHOD', 'METHOD'), ('_LIST', 'LIST'), ('_ELECTRONIC_TEMPERATURE', 'ELECTRONIC_TEMPERATURE'), ('_ELEC_TEMP', 'ELEC_TEMP'), ('_TELEC', 'TELEC'), ('_EPS_FERMI_DIRAC', 'EPS_FERMI_DIRAC'), ('_WINDOW_SIZE', 'WINDOW_SIZE'), ('_FIXED_MAGNETIC_MOMENT', 'FIXED_MAGNETIC_MOMENT')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = []
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class ff_info1(printable):
    """Controls the printing of information in the forcefield settings"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self._SPLINE_INFO = None    # if the printkey is active prints information regarding the splines used in the nonbonded interactions
        self._SPLINE_DATA = None    # if the printkey is active prints on separated files the splined function together with the reference one. Useful to check the spline behavior.
        self.EACH = each1()
        self.name = "FF_INFO"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY'), ('_SPLINE_INFO', 'SPLINE_INFO'), ('_SPLINE_DATA', 'SPLINE_DATA')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class pgf1(printable):
    """Controls the printing of the gaussian expansion basis set of the electrostatic potential"""
    def __init__(self):
        self._SECTION_PARAMETERS = None
        self._ADD_LAST = None    # If the last iteration should be added, and if it should be marked symbolically (with l) or with the iteration number.Not every iteration level is able to identify the last iteration early enough to be able to output. When this keyword is activated all iteration levels are checked for the last iteration step.
        self._COMMON_ITERATION_LEVELS = None    # How many iterations levels should be written in the same file (no extra information about the actual iteration level is written to the file)
        self._FILENAME = None    #  controls part of the filename for output.  use __STD_OUT__ (exactly as written here) for the screen or standard logger.  use filename to obtain projectname-filename.  use ./filename to get filename. A middle name (if present), iteration numbers and extension are always added to the filename. if you want to avoid it use =filename, in this case the filename is always exactly as typed. Please note that this can lead to clashes of filenames.
        self._LOG_PRINT_KEY = None    # This keywords enables the logger for the print_key (a message is printed on screen everytime data, controlled by this print_key, are written)
        self.EACH = each1()
        self.name = "PGF"
        self.keywords = [('_ADD_LAST', 'ADD_LAST'), ('_COMMON_ITERATION_LEVELS', 'COMMON_ITERATION_LEVELS'), ('_FILENAME', 'FILENAME'), ('_LOG_PRINT_KEY', 'LOG_PRINT_KEY')]
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = []
        self.subsections = [('EACH', 'EACH')]
        self.repeated_subsections = []

    def print_input(self, level):
        return printable.print_input(self, level)


class shell_velocity1(printable):
    """The velocities of shells for shell-model potentials, in xyz format"""
    def __init__(self):
        self.list_DEFAULT_KEYWORD = []
        self._DEFAULT_KEYWORD = None    # The shell velocities in xyz format. The same order as the shell coordinate is assumed.
        self.name = "SHELL_VELOCITY"
        self.keywords = []
        self.repeated_keywords = []
        self.default_keywords = []
        self.repeated_default_keywords = [('_DEFAULT_KEYWORD', 'DEFAULT_KEYWORD')]
        self.subsections = []
        self.repeated_subsections = []
        pass

    def add_DEFAULT_KEYWORD(self, value):
        self.list_DEFAULT_KEYWORD.append(value)

    def print_input(self, level):
        return printable.print_input(self, level)
